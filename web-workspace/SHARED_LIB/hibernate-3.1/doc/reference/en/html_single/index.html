<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HIBERNATE - Relational Persistence for Idiomatic Java</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>HIBERNATE - Relational Persistence for Idiomatic Java</h1></div><div><h2 class="subtitle">Hibernate Reference Documentation</h2></div><div><p class="releaseinfo">3.1</p></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="chapter"><a href="#tutorial">1. Introduction to Hibernate</a></span></dt><dd><dl><dt><span class="sect1"><a href="#tutorial-intro">1.1. Preface</a></span></dt><dt><span class="sect1"><a href="#tutorial-firstapp">1.2. Part 1 - The first Hibernate Application</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-firstapp-firstclass">1.2.1. The first class</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-mapping">1.2.2. The mapping file</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-configuration">1.2.3. Hibernate configuration</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-ant">1.2.4. Building with Ant</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-helpers">1.2.5. Startup and helpers</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-workingpersistence">1.2.6. Loading and storing objects</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-associations">1.3. Part 2 - Mapping associations</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-associations-mappinguser">1.3.1. Mapping the Person class</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-unidirset">1.3.2. A unidirectional Set-based association</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-working">1.3.3. Working the association</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-valuecollections">1.3.4. Collection of values</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-bidirectional">1.3.5. Bi-directional associations</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-usingbidir">1.3.6. Working bi-directional links</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-webapp">1.4. Part 3 - The EventManager web application</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-webapp-servlet">1.4.1. Writing the basic servlet</a></span></dt><dt><span class="sect2"><a href="#tutorial-webapp-processing">1.4.2. Processing and rendering</a></span></dt><dt><span class="sect2"><a href="#tutorial-webapp-deploy">1.4.3. Deploying and testing</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-summary">1.5. Summary</a></span></dt></dl></dd><dt><span class="chapter"><a href="#architecture">2. Architecture</a></span></dt><dd><dl><dt><span class="sect1"><a href="#architecture-overview">2.1. Overview</a></span></dt><dt><span class="sect1"><a href="#architecture-states">2.2. Instance states</a></span></dt><dt><span class="sect1"><a href="#architecture-jmx">2.3. JMX Integration</a></span></dt><dt><span class="sect1"><a href="#architecture-jca">2.4. JCA Support</a></span></dt><dt><span class="sect1"><a href="#architecture-current-session">2.5. Contextual Sessions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#session-configuration">3. Configuration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#configuration-programmatic">3.1. Programmatic configuration</a></span></dt><dt><span class="sect1"><a href="#configuration-sessionfactory">3.2. Obtaining a SessionFactory</a></span></dt><dt><span class="sect1"><a href="#configuration-hibernatejdbc">3.3. JDBC connections</a></span></dt><dt><span class="sect1"><a href="#configuration-optional">3.4. Optional configuration properties</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuration-optional-dialects">3.4.1. SQL Dialects</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-outerjoin">3.4.2. Outer Join Fetching</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-binarystreams">3.4.3. Binary Streams</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-cacheprovider">3.4.4. Second-level and query cache</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-querysubstitution">3.4.5. Query Language Substitution</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-statistics">3.4.6. Hibernate statistics</a></span></dt></dl></dd><dt><span class="sect1"><a href="#configuration-logging">3.5. Logging</a></span></dt><dt><span class="sect1"><a href="#configuration-namingstrategy">3.6. Implementing a NamingStrategy</a></span></dt><dt><span class="sect1"><a href="#configuration-xmlconfig">3.7. XML configuration file</a></span></dt><dt><span class="sect1"><a href="#configuration-j2ee">3.8. J2EE Application Server integration</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuration-optional-transactionstrategy">3.8.1. Transaction strategy configuration</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-jndi">3.8.2. JNDI-bound SessionFactory</a></span></dt><dt><span class="sect2"><a href="#configuration-j2ee-currentsession">3.8.3. Current Session context management with JTA</a></span></dt><dt><span class="sect2"><a href="#configuration-j2ee-jmx">3.8.4. JMX deployment</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#persistent-classes">4. Persistent Classes</a></span></dt><dd><dl><dt><span class="sect1"><a href="#persistent-classes-pojo">4.1. A simple POJO example</a></span></dt><dd><dl><dt><span class="sect2"><a href="#persistent-classes-pojo-constructor">4.1.1. Implement a no-argument constructor</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-identifier">4.1.2. Provide an identifier property (optional)</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-final">4.1.3. Prefer non-final classes (optional)</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-accessors">4.1.4. Declare accessors and mutators for persistent fields (optional)</a></span></dt></dl></dd><dt><span class="sect1"><a href="#persistent-classes-inheritance">4.2. Implementing inheritance</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-equalshashcode">4.3. Implementing equals() and hashCode()</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-dynamicmodels">4.4. Dynamic models</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-tuplizers">4.5. Tuplizers</a></span></dt></dl></dd><dt><span class="chapter"><a href="#mapping">5. Basic O/R Mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#mapping-declaration">5.1. Mapping declaration</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-declaration-doctype">5.1.1. Doctype</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-mapping">5.1.2. hibernate-mapping</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-class">5.1.3. class</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id">5.1.4. id</a></span></dt><dd><dl><dt><span class="sect3"><a href="#mapping-declaration-id-generator">5.1.4.1. Generator</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-hilo">5.1.4.2. Hi/lo algorithm</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-uuid">5.1.4.3. UUID algorithm</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-sequences">5.1.4.4. Identity columns and sequences</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-assigned">5.1.4.5. Assigned identifiers</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-select">5.1.4.6. Primary keys assigned by triggers</a></span></dt></dl></dd><dt><span class="sect2"><a href="#mapping-declaration-compositeid">5.1.5. composite-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-discriminator">5.1.6. discriminator</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-version">5.1.7. version (optional)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-timestamp">5.1.8. timestamp (optional)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-property">5.1.9. property</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-manytoone">5.1.10. many-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-onetoone">5.1.11. one-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-naturalid">5.1.12. natural-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-component">5.1.13. component, dynamic-component</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-properties">5.1.14. properties</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-subclass">5.1.15. subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-joinedsubclass">5.1.16. joined-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-unionsubclass">5.1.17. union-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-join">5.1.18. join</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-key">5.1.19. key</a></span></dt><dt><span class="sect2"><a href="#mapping-column">5.1.20. column and formula elements</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-import">5.1.21. import</a></span></dt><dt><span class="sect2"><a href="#mapping-types-anymapping">5.1.22. any</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-types">5.2. Hibernate Types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-types-entitiesvalues">5.2.1. Entities and values</a></span></dt><dt><span class="sect2"><a href="#mapping-types-basictypes">5.2.2. Basic value types</a></span></dt><dt><span class="sect2"><a href="#mapping-types-custom">5.2.3. Custom value types</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-entityname">5.3. Mapping a class more than once</a></span></dt><dt><span class="sect1"><a href="#mapping-quotedidentifiers">5.4. SQL quoted identifiers</a></span></dt><dt><span class="sect1"><a href="#mapping-alternatives">5.5. Metadata alternatives</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-xdoclet">5.5.1. Using XDoclet markup</a></span></dt><dt><span class="sect2"><a href="#mapping-annotations">5.5.2. Using JDK 5.0 Annotations</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-generated">5.6. Generated Properties</a></span></dt><dt><span class="sect1"><a href="#mapping-database-object">5.7. Auxiliary Database Objects</a></span></dt></dl></dd><dt><span class="chapter"><a href="#collections">6. Collection Mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#collections-persistent">6.1. Persistent collections</a></span></dt><dt><span class="sect1"><a href="#collections-mapping">6.2. Collection mappings</a></span></dt><dd><dl><dt><span class="sect2"><a href="#collections-foreignkeys">6.2.1. Collection foreign keys</a></span></dt><dt><span class="sect2"><a href="#collections-elements">6.2.2. Collection elements</a></span></dt><dt><span class="sect2"><a href="#collections-indexed">6.2.3. Indexed collections</a></span></dt><dt><span class="sect2"><a href="#collections-ofvalues">6.2.4. Collections of values and many-to-many associations</a></span></dt><dt><span class="sect2"><a href="#collections-onetomany">6.2.5. One-to-many associations</a></span></dt></dl></dd><dt><span class="sect1"><a href="#collections-advancedmappings">6.3. Advanced collection mappings</a></span></dt><dd><dl><dt><span class="sect2"><a href="#collections-sorted">6.3.1. Sorted collections</a></span></dt><dt><span class="sect2"><a href="#collections-bidirectional">6.3.2. Bidirectional associations</a></span></dt><dt><span class="sect2"><a href="#collections-indexedbidirectional">6.3.3. Bidirectional associations with indexed collections</a></span></dt><dt><span class="sect2"><a href="#collections-ternary">6.3.4. Ternary associations</a></span></dt><dt><span class="sect2"><a href="#collections-idbag">6.3.5. Using an &lt;idbag&gt;</a></span></dt></dl></dd><dt><span class="sect1"><a href="#collections-example">6.4. Collection examples</a></span></dt></dl></dd><dt><span class="chapter"><a href="#associations">7. Association Mappings</a></span></dt><dd><dl><dt><span class="sect1"><a href="#assoc-intro">7.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#assoc-unidirectional">7.2. Unidirectional associations</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-unidirectional-m21">7.2.1. many to one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-121">7.2.2. one to one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-12m">7.2.3. one to many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-unidirectional-join">7.3. Unidirectional associations with join tables</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-unidirectional-join-12m">7.3.1. one to many</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-m21">7.3.2. many to one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-121">7.3.3. one to one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-m2m">7.3.4. many to many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-bidirectional">7.4. Bidirectional associations</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-bidirectional-m21">7.4.1. one to many / many to one</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-121">7.4.2. one to one</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-bidirectional-join">7.5. Bidirectional associations with join tables</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-bidirectional-join-12m">7.5.1. one to many / many to one</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-join-121">7.5.2. one to one</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-join-m2m">7.5.3. many to many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-complex">7.6. More complex association mappings</a></span></dt></dl></dd><dt><span class="chapter"><a href="#components">8. Component Mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#components-dependentobjects">8.1. Dependent objects</a></span></dt><dt><span class="sect1"><a href="#components-incollections">8.2. Collections of dependent objects</a></span></dt><dt><span class="sect1"><a href="#components-asmapindex">8.3. Components as Map indices</a></span></dt><dt><span class="sect1"><a href="#components-compositeid">8.4. Components as composite identifiers</a></span></dt><dt><span class="sect1"><a href="#components-dynamic">8.5. Dynamic components</a></span></dt></dl></dd><dt><span class="chapter"><a href="#inheritance">9. Inheritance Mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#inheritance-strategies">9.1. The Three Strategies</a></span></dt><dd><dl><dt><span class="sect2"><a href="#inheritance-tableperclass">9.1.1. Table per class hierarchy</a></span></dt><dt><span class="sect2"><a href="#inheritance-tablepersubclass">9.1.2. Table per subclass</a></span></dt><dt><span class="sect2"><a href="#inheritance-tablepersubclass-discriminator">9.1.3. Table per subclass, using a discriminator</a></span></dt><dt><span class="sect2"><a href="#inheritance-mixing-tableperclass-tablepersubclass">9.1.4. Mixing table per class hierarchy with table per subclass</a></span></dt><dt><span class="sect2"><a href="#inheritance-tableperconcrete">9.1.5. Table per concrete class</a></span></dt><dt><span class="sect2"><a href="#inheritance-tableperconcreate-polymorphism">9.1.6. Table per concrete class, using implicit polymorphism</a></span></dt><dt><span class="sect2"><a href="#inheritace-mixingpolymorphism">9.1.7. Mixing implicit polymorphism with other inheritance mappings</a></span></dt></dl></dd><dt><span class="sect1"><a href="#inheritance-limitations">9.2. Limitations</a></span></dt></dl></dd><dt><span class="chapter"><a href="#objectstate">10. Working with objects</a></span></dt><dd><dl><dt><span class="sect1"><a href="#objectstate-overview">10.1. Hibernate object states</a></span></dt><dt><span class="sect1"><a href="#objectstate-makingpersistent">10.2. Making objects persistent</a></span></dt><dt><span class="sect1"><a href="#objectstate-loading">10.3. Loading an object</a></span></dt><dt><span class="sect1"><a href="#objectstate-querying">10.4. Querying</a></span></dt><dd><dl><dt><span class="sect2"><a href="#objectstate-querying-executing">10.4.1. Executing queries</a></span></dt><dd><dl><dt><span class="sect3"><a href="#objectstate-querying-executing-iterate">10.4.1.1. Iterating results</a></span></dt><dt><span class="sect3"><a href="#objectstate-querying-executing-tuples">10.4.1.2. Queries that return tuples</a></span></dt><dt><span class="sect3"><a href="#objectstate-querying-executing-scalar">10.4.1.3. Scalar results</a></span></dt><dt><span class="sect3"><a href="#objectstate-querying-executing-parameters">10.4.1.4. Bind parameters</a></span></dt><dt><span class="sect3"><a href="#objectstate-querying-executing-pagination">10.4.1.5. Pagination</a></span></dt><dt><span class="sect3"><a href="#objectstate-querying-executing-scrolling">10.4.1.6. Scrollable iteration</a></span></dt><dt><span class="sect3"><a href="#objectstate-querying-executing-named">10.4.1.7. Externalizing named queries</a></span></dt></dl></dd><dt><span class="sect2"><a href="#objectstate-filtering">10.4.2. Filtering collections</a></span></dt><dt><span class="sect2"><a href="#objecstate-querying-criteria">10.4.3. Criteria queries</a></span></dt><dt><span class="sect2"><a href="#objectstate-querying-nativesql">10.4.4. Queries in native SQL</a></span></dt></dl></dd><dt><span class="sect1"><a href="#objectstate-modifying">10.5. Modifying persistent objects</a></span></dt><dt><span class="sect1"><a href="#objectstate-detached">10.6. Modifying detached objects</a></span></dt><dt><span class="sect1"><a href="#objectstate-saveorupdate">10.7. Automatic state detection</a></span></dt><dt><span class="sect1"><a href="#objectstate-deleting">10.8. Deleting persistent objects</a></span></dt><dt><span class="sect1"><a href="#objectstate-replicating">10.9. Replicating object between two different datastores</a></span></dt><dt><span class="sect1"><a href="#objectstate-flushing">10.10. Flushing the Session</a></span></dt><dt><span class="sect1"><a href="#objectstate-transitive">10.11. Transitive persistence</a></span></dt><dt><span class="sect1"><a href="#objectstate-metadata">10.12. Using metadata</a></span></dt></dl></dd><dt><span class="chapter"><a href="#transactions">11. Transactions And Concurrency</a></span></dt><dd><dl><dt><span class="sect1"><a href="#transactions-basics">11.1. Session and transaction scopes</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-basics-uow">11.1.1. Unit of work</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-apptx">11.1.2. Long conversations</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-identity">11.1.3. Considering object identity</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-issues">11.1.4. Common issues</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-demarcation">11.2. Database transaction demarcation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-demarcation-nonmanaged">11.2.1. Non-managed environment</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-jta">11.2.2. Using JTA</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-exceptions">11.2.3. Exception handling</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-timeout">11.2.4. Transaction timeout</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-optimistic">11.3. Optimistic concurrency control</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-optimistic-manual">11.3.1. Application version checking</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-longsession">11.3.2. Extended session and automatic versioning</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-detached">11.3.3. Detached objects and automatic versioning</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-customizing">11.3.4. Customizing automatic versioning</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-locking">11.4. Pessimistic Locking</a></span></dt><dt><span class="sect1"><a href="#transactions-connection-release">11.5. Connection Release Modes</a></span></dt></dl></dd><dt><span class="chapter"><a href="#events">12. Interceptors and events</a></span></dt><dd><dl><dt><span class="sect1"><a href="#objectstate-interceptors">12.1. Interceptors</a></span></dt><dt><span class="sect1"><a href="#objectstate-events">12.2. Event system</a></span></dt><dt><span class="sect1"><a href="#objectstate-decl-security">12.3. Hibernate declarative security</a></span></dt></dl></dd><dt><span class="chapter"><a href="#batch">13. Batch processing</a></span></dt><dd><dl><dt><span class="sect1"><a href="#batch-inserts">13.1. Batch inserts</a></span></dt><dt><span class="sect1"><a href="#batch-update">13.2. Batch updates</a></span></dt><dt><span class="sect1"><a href="#batch-statelesssession">13.3. The StatelessSession interface</a></span></dt><dt><span class="sect1"><a href="#batch-direct">13.4. DML-style operations</a></span></dt></dl></dd><dt><span class="chapter"><a href="#queryhql">14. HQL: The Hibernate Query Language</a></span></dt><dd><dl><dt><span class="sect1"><a href="#queryhql-casesensitivity">14.1. Case Sensitivity</a></span></dt><dt><span class="sect1"><a href="#queryhql-from">14.2. The from clause</a></span></dt><dt><span class="sect1"><a href="#queryhql-joins">14.3. Associations and joins</a></span></dt><dt><span class="sect1"><a href="#queryhql-joins-forms">14.4. Forms of join syntax</a></span></dt><dt><span class="sect1"><a href="#queryhql-select">14.5. The select clause</a></span></dt><dt><span class="sect1"><a href="#queryhql-aggregation">14.6. Aggregate functions</a></span></dt><dt><span class="sect1"><a href="#queryhql-polymorphism">14.7. Polymorphic queries</a></span></dt><dt><span class="sect1"><a href="#queryhql-where">14.8. The where clause</a></span></dt><dt><span class="sect1"><a href="#queryhql-expressions">14.9. Expressions</a></span></dt><dt><span class="sect1"><a href="#queryhql-ordering">14.10. The order by clause</a></span></dt><dt><span class="sect1"><a href="#queryhql-grouping">14.11. The group by clause</a></span></dt><dt><span class="sect1"><a href="#queryhql-subqueries">14.12. Subqueries</a></span></dt><dt><span class="sect1"><a href="#queryhql-examples">14.13. HQL examples</a></span></dt><dt><span class="sect1"><a href="#queryhql-bulk">14.14. Bulk update and delete</a></span></dt><dt><span class="sect1"><a href="#queryhql-tipstricks">14.15. Tips &amp; Tricks</a></span></dt></dl></dd><dt><span class="chapter"><a href="#querycriteria">15. Criteria Queries</a></span></dt><dd><dl><dt><span class="sect1"><a href="#querycriteria-creating">15.1. Creating a Criteria instance</a></span></dt><dt><span class="sect1"><a href="#querycriteria-narrowing">15.2. Narrowing the result set</a></span></dt><dt><span class="sect1"><a href="#querycriteria-ordering">15.3. Ordering the results</a></span></dt><dt><span class="sect1"><a href="#querycriteria-associations">15.4. Associations</a></span></dt><dt><span class="sect1"><a href="#querycriteria-dynamicfetching">15.5. Dynamic association fetching</a></span></dt><dt><span class="sect1"><a href="#querycriteria-examples">15.6. Example queries</a></span></dt><dt><span class="sect1"><a href="#querycriteria-projection">15.7. Projections, aggregation and grouping</a></span></dt><dt><span class="sect1"><a href="#querycriteria-detachedqueries">15.8. Detached queries and subqueries</a></span></dt><dt><span class="sect1"><a href="#query-criteria-naturalid">15.9. Queries by natural identifier</a></span></dt></dl></dd><dt><span class="chapter"><a href="#querysql">16. Native SQL</a></span></dt><dd><dl><dt><span class="sect1"><a href="#querysql-creating">16.1. Using a SQLQuery</a></span></dt><dt><span class="sect1"><a href="#querysql-aliasreferences">16.2. Alias and property references</a></span></dt><dt><span class="sect1"><a href="#querysql-namedqueries">16.3. Named SQL queries</a></span></dt><dd><dl><dt><span class="sect2"><a href="#propertyresults">16.3.1. Using return-property to explicitly specify column/alias
      names</a></span></dt><dt><span class="sect2"><a href="#sp_query">16.3.2. Using stored procedures for querying</a></span></dt><dd><dl><dt><span class="sect3"><a href="#querysql-limits-storedprocedures">16.3.2.1. Rules/limitations for using stored procedures</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#querysql-cud">16.4. Custom SQL for create, update and delete</a></span></dt><dt><span class="sect1"><a href="#querysql-load">16.5. Custom SQL for loading</a></span></dt></dl></dd><dt><span class="chapter"><a href="#filters">17. Filtering data</a></span></dt><dd><dl><dt><span class="sect1"><a href="#objectstate-filters">17.1. Hibernate filters</a></span></dt></dl></dd><dt><span class="chapter"><a href="#xml">18. XML Mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#xml-intro">18.1. Working with XML data</a></span></dt><dd><dl><dt><span class="sect2"><a href="#xml-intro-mapping">18.1.1. Specifying XML and class mapping together</a></span></dt><dt><span class="sect2"><a href="#xml-onlyxml">18.1.2. Specifying only an XML mapping</a></span></dt></dl></dd><dt><span class="sect1"><a href="#xml-mapping">18.2. XML mapping metadata</a></span></dt><dt><span class="sect1"><a href="#xml-manipulation">18.3. Manipulating XML data</a></span></dt></dl></dd><dt><span class="chapter"><a href="#performance">19. Improving performance</a></span></dt><dd><dl><dt><span class="sect1"><a href="#performance-fetching">19.1. Fetching strategies</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-fetching-lazy">19.1.1. Working with lazy associations</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-custom">19.1.2. Tuning fetch strategies</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-proxies">19.1.3. Single-ended association proxies</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-initialization">19.1.4. Initializing collections and proxies</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-batch">19.1.5. Using batch fetching</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-subselect">19.1.6. Using subselect fetching</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-lazyproperties">19.1.7. Using lazy property fetching</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-cache">19.2. The Second Level Cache</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-cache-mapping">19.2.1. Cache mappings</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readonly">19.2.2. Strategy: read only</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readwrite">19.2.3. Strategy: read/write</a></span></dt><dt><span class="sect2"><a href="#performance-cache-nonstrict">19.2.4. Strategy: nonstrict read/write</a></span></dt><dt><span class="sect2"><a href="#performance-cache-transactional">19.2.5. Strategy: transactional</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-sessioncache">19.3. Managing the caches</a></span></dt><dt><span class="sect1"><a href="#performance-querycache">19.4. The Query Cache</a></span></dt><dt><span class="sect1"><a href="#performance-collections">19.5. Understanding Collection performance</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-collections-taxonomy">19.5.1. Taxonomy</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficientupdate">19.5.2. Lists, maps, idbags and sets are the most efficient collections to update</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficentinverse">19.5.3. Bags and lists are the most efficient inverse collections</a></span></dt><dt><span class="sect2"><a href="#performance-collections-oneshotdelete">19.5.4. One shot delete</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-monitoring">19.6. Monitoring performance</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-monitoring-sf">19.6.1. Monitoring a SessionFactory</a></span></dt><dt><span class="sect2"><a href="#performance-monitoring-metrics">19.6.2. Metrics</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#toolsetguide">20. Toolset Guide</a></span></dt><dd><dl><dt><span class="sect1"><a href="#toolsetguide-s1">20.1. Automatic schema generation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#toolsetguide-s1-2">20.1.1. Customizing the schema</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-3">20.1.2. Running the tool</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-4">20.1.3. Properties</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-5">20.1.4. Using Ant</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-6">20.1.5. Incremental schema updates</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-7">20.1.6. Using Ant for incremental schema updates</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-8">20.1.7. Schema validation</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-9">20.1.8. Using Ant for schema validation</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#example-parentchild">21. Example: Parent/Child</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-parentchild-collections">21.1. A note about collections</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-bidir">21.2. Bidirectional one-to-many</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-cascades">21.3. Cascading lifecycle</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-update">21.4. Cascades and unsaved-value</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-conclusion">21.5. Conclusion</a></span></dt></dl></dd><dt><span class="chapter"><a href="#example-weblog">22. Example: Weblog Application</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-weblog-classes">22.1. Persistent Classes</a></span></dt><dt><span class="sect1"><a href="#example-weblog-mappings">22.2. Hibernate Mappings</a></span></dt><dt><span class="sect1"><a href="#example-weblog-code">22.3. Hibernate Code</a></span></dt></dl></dd><dt><span class="chapter"><a href="#example-mappings">23. Example: Various Mappings</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-mappings-emp">23.1. Employer/Employee</a></span></dt><dt><span class="sect1"><a href="#example-mappings-authorwork">23.2. Author/Work</a></span></dt><dt><span class="sect1"><a href="#example-mappings-customerorderproduct">23.3. Customer/Order/Product</a></span></dt><dt><span class="sect1"><a href="#misc">23.4. Miscellaneous example mappings</a></span></dt><dd><dl><dt><span class="sect2"><a href="#example-mappings-typed-onetone">23.4.1. "Typed" one-to-one association</a></span></dt><dt><span class="sect2"><a href="#example-mappings-composite-key">23.4.2. Composite key example</a></span></dt><dt><span class="sect2"><a href="#example-mappings-composite-key-manytomany">23.4.3. Many-to-many with shared composite key attribute</a></span></dt><dt><span class="sect2"><a href="#example-mappings-content-discrimination">23.4.4. Content based discrimination</a></span></dt><dt><span class="sect2"><a href="#example-mappings-association-alternatekeys">23.4.5. Associations on alternate keys</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#best-practices">24. Best Practices</a></span></dt></dl></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>Preface</h2></div></div><div></div></div><p>
            Working with object-oriented software and a relational database can be cumbersome
            and time consuming in today's enterprise environments. Hibernate is an object/relational
            mapping tool for Java environments. The term object/relational mapping (ORM) refers to
            the technique of mapping a data representation from an object model to a relational
            data model with a SQL-based schema.
        </p><p>
            Hibernate not only takes care of the mapping from Java classes to
            database tables (and from Java data types to SQL data types), but also provides data
            query and retrieval facilities and can significantly reduce development time otherwise
            spent with manual data handling in SQL and JDBC.
        </p><p>
            Hibernates goal is to relieve the developer from 95 percent of common data persistence
            related programming tasks. Hibernate may not be the best solution for data-centric
            applications that only use stored-procedures to implement the business logic in the
            database, it is most useful with object-oriented domain models and business logic in
            the Java-based middle-tier. However, Hibernate can certainly help you to remove or
            encapsulate vendor-specific SQL code and will help with the common task of result set
            translation from a tabular representation to a graph of objects.
        </p><p>
            If you are new to Hibernate and Object/Relational Mapping or even Java,
            please follow these steps:
        </p><div class="orderedlist"><ol type="1"><li><p>
                    Read <a href="#tutorial" title="Chapter&nbsp;1.&nbsp;Introduction to Hibernate">Chapter&nbsp;1, <i>Introduction to Hibernate</i></a> for a tutorial with step-by-step
                    instructions. The source code for the tutorial is included in the
                    distribution in the <tt class="literal">doc/reference/tutorial/</tt>
                    directory.
                </p></li><li><p>
                    Read <a href="#architecture" title="Chapter&nbsp;2.&nbsp;Architecture">Chapter&nbsp;2, <i>Architecture</i></a> to understand the environments where
                    Hibernate can be used.
                </p></li><li><p>
                    Have a look at the <tt class="literal">eg/</tt> directory in the Hibernate
                    distribution, it contains a simple standalone application. Copy your
                    JDBC driver to the <tt class="literal">lib/</tt> directory and edit
                    <tt class="literal">etc/hibernate.properties</tt>, specifying correct values for
                    your database. From a command prompt in the distribution directory,
                    type <tt class="literal">ant eg</tt> (using Ant), or under Windows, type
                    <tt class="literal">build eg</tt>.
                </p></li><li><p>
                    Use this reference documentation as your primary source of information.
                    Consider reading <span class="emphasis"><em>Hibernate in Action</em></span>
                    (http://www.manning.com/bauer) if you need more help with application
                    design or if you prefer a step-by-step tutorial. Also visit
                    http://caveatemptor.hibernate.org and download the example application
                    for Hibernate in Action.
                </p></li><li><p>
					FAQs are answered on the Hibernate website.
				</p></li><li><p>
					Third party demos, examples, and tutorials are linked on the Hibernate
					website.
				</p></li><li><p>
                    The Community Area on the Hibernate website is a good resource for
                    design patterns and various integration solutions (Tomcat, JBoss AS,
                    Struts, EJB, etc.).
                </p></li></ol></div><p>
             If you have questions, use the user forum linked on the Hibernate website. We also
             provide a JIRA issue trackings system for bug reports and feature requests. If you
             are interested in the development of Hibernate, join the developer mailing list. If
             you are interested in translating this documentation into your language, contact us
             on the developer mailing list.
         </p><p>
             Commercial development support, production support, and training for Hibernate is
             available through JBoss Inc. (see http://www.hibernate.org/SupportTraining/).
             Hibernate is a Professional Open Source project and a critical component of the
             JBoss Enterprise Middleware System (JEMS) suite of products.
         </p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tutorial"></a>Chapter&nbsp;1.&nbsp;Introduction to Hibernate</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tutorial-intro"></a>1.1.&nbsp;Preface</h2></div></div><div></div></div><p>
            This chapter is an introductory tutorial for new users of Hibernate. We start
            with a simple command line application using an in-memory database and develop
            it in easy to understand steps.
        </p><p>
            This tutorial is intended for new users of Hibernate but requires Java and
            SQL knowledge. It is based on a tutorial by Michael Gloegl, the third-party
            libraries we name are for JDK 1.4 and 5.0. You might need others for JDK 1.3.
        </p><p>
            The source code for the tutorial is included in the distribution in the
            <tt class="literal">doc/reference/tutorial/</tt> directory.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tutorial-firstapp"></a>1.2.&nbsp;Part 1 - The first Hibernate Application</h2></div></div><div></div></div><p>
            First, we'll create a simple console-based Hibernate application. We use an
            Java database (HSQL DB), so we do not have to install any database server.
        </p><p>
            Let's assume we need a small database application that can store events we want to
            attend, and information about the hosts of these events.
        </p><p>
            The first thing we do, is set up our development directory and put all the
            Java libraries we need into it. Download the Hibernate distribution from the
            Hibernate website. Extract the package and place all required libraries
            found in <tt class="literal">/lib</tt> into into the <tt class="literal">/lib</tt> directory
            of your new development working directory. It should look like this:
        </p><pre class="programlisting">.
+lib
  antlr.jar
  cglib.jar
  asm.jar
  asm-attrs.jars
  commons-collections.jar
  commons-logging.jar
  hibernate3.jar
  jta.jar
  dom4j.jar
  log4j.jar </pre><p>
            This is the minimum set of required libraries (note that we also copied
            hibernate3.jar, the main archive) for Hibernate. See the <tt class="literal">README.txt</tt> file
            in the <tt class="literal">lib/</tt> directory of the Hibernate distribution for more information
            about required and optional third-party libraries. (Actually, Log4j is not
            required but preferred by many developers.)
        </p><p>
            Next we create a class that represents the event we want to store in database.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-firstapp-firstclass"></a>1.2.1.&nbsp;The first class</h3></div></div><div></div></div><p>
                Our first persistent class is a simple JavaBean class with some properties:
            </p><pre class="programlisting">package events;

import java.util.Date;

public class Event {
    private Long id;

    private String title;
    private Date date;

    public Event() {}

    public Long getId() {
        return id;
    }

    private void setId(Long id) {
        this.id = id;
    }

    public Date getDate() {
        return date;
    }

    public void setDate(Date date) {
        this.date = date;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }
}</pre><p>
                You can see that this class uses standard JavaBean naming conventions for property
                getter and setter methods, as well as private visibility for the fields. This is
                a recommended design - but not required. Hibernate can also access fields directly,
                the benefit of accessor methods is robustness for refactoring. The no-argument
                constructor is required to instantiate an object of this class through reflection.
            </p><p>
                The <tt class="literal">id</tt> property holds a unique identifier value for a particular event.
                All persistent entity classes (there are less important dependent classes as well) will need
                such an identifier property if we want to use the full feature set of Hibernate. In fact,
                most applications (esp. web applications) need to distinguish objects by identifier, so you
                should consider this a feature rather than a limitation. However, we usually don't manipulate
                the identity of an object, hence the setter method should be private. Only Hibernate will assign
                identifiers when an object is saved. You can see that Hibernate can access public, private,
                and protected accessor methods, as well as (public, private, protected) fields directly. The
                choice is up to you and you can match it to fit your application design.
            </p><p>
                The no-argument constructor is a requirement for all persistent classes; Hibernate
                has to create objects for you, using Java Reflection. The constructor can be
                private, however, package visibility is required for runtime proxy generation and
                efficient data retrieval without bytecode instrumentation.
            </p><p>
                Place this Java source file in a directory called <tt class="literal">src</tt> in the
                development folder, and in its correct package. The directory should now look like this:
            </p><pre class="programlisting">.
+lib
  &lt;Hibernate and third-party libraries&gt;
+src
  +events
    Event.java</pre><p>
                In the next step, we tell Hibernate about this persistent class.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-firstapp-mapping"></a>1.2.2.&nbsp;The mapping file</h3></div></div><div></div></div><p>
                Hibernate needs to know how to load and store objects of the persistent class.
                This is where the Hibernate mapping file comes into play. The mapping file
                tells Hibernate what table in the database it has to access, and what columns
                in that table it should use.
            </p><p>
                The basic structure of a mapping file looks like this:
            </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping&gt;
[...]
&lt;/hibernate-mapping&gt;</pre><p>
                Note that the Hibernate DTD is very sophisticated. You can use it for
                auto-completion of XML mapping elements and attributes in your editor or
                IDE. You also should open up the DTD file in your text editor - it's the
                easiest way to get an overview of all elements and attributes and to see
                the defaults, as well as some comments. Note that Hibernate will not
                load the DTD file from the web, but first look it up from the classpath
                of the application. The DTD file is included in <tt class="literal">hibernate3.jar</tt>
                as well as in the <tt class="literal">src/</tt> directory of the Hibernate distribution.
            </p><p>
                We will omit the DTD declaration in future examples to shorten the code. It is
                of course not optional.
            </p><p>
                Between the two <tt class="literal">hibernate-mapping</tt> tags, include a
                <tt class="literal">class</tt> element. All persistent entity classes (again, there
                might be dependent classes later on, which are not first-class entities) need
                such a mapping, to a table in the SQL database:
            </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="events.Event" table="EVENTS"&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
                So far we told Hibernate how to persist and load object of class <tt class="literal">Event</tt>
                to the table <tt class="literal">EVENTS</tt>, each instance represented by a row in that table.
                Now we continue with a mapping of the unique identifier property to the tables primary key.
                In addition, as we don't want to care about handling this identifier, we configure Hibernate's
                identifier generation strategy for a surrogate primary key column:
            </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="events.Event" table="EVENTS"&gt;
        &lt;id name="id" column="EVENT_ID"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
                The <tt class="literal">id</tt> element is the declaration of the identifer property,
                <tt class="literal">name="id"</tt> declares the name of the Java property -
                Hibernate will use the getter and setter methods to access the property.
                The column attribute tells Hibernate which column of the
                <tt class="literal">EVENTS</tt> table we use for this primary key. The nested
                <tt class="literal">generator</tt> element specifies the identifier generation strategy,
                in this case we used <tt class="literal">native</tt>, which picks the best strategy depending
                on the configured database (dialect). Hibernate supports database generated, globally
                unique, as well as application assigned identifiers (or any strategy you have written
                an extension for).
            </p><p>
                Finally we include declarations for the persistent properties of the class in
                the mapping file. By default, no properties of the class are considered
                persistent:
            </p><pre class="programlisting">
&lt;hibernate-mapping&gt;

    &lt;class name="events.Event" table="EVENTS"&gt;
        &lt;id name="id" column="EVENT_ID"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="date" type="timestamp" column="EVENT_DATE"/&gt;
        &lt;property name="title"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
                Just as with the <tt class="literal">id</tt> element, the <tt class="literal">name</tt>
                attribute of the <tt class="literal">property</tt> element tells Hibernate which getter
                and setter methods to use. So, in this case, Hibernate will look for
                <tt class="literal">getDate()/setDate()</tt>, as well as <tt class="literal">getTitle()/setTitle()</tt>.
            </p><p>
                Why does the <tt class="literal">date</tt> property mapping include the
                <tt class="literal">column</tt> attribute, but the <tt class="literal">title</tt>
                doesn't? Without the <tt class="literal">column</tt> attribute Hibernate
                by default uses the property name as the column name. This works fine for
                <tt class="literal">title</tt>. However, <tt class="literal">date</tt> is a reserved
                keyword in most database, so we better map it to a different name.
            </p><p>
                The next interesting thing is that the <tt class="literal">title</tt> mapping also lacks
                a <tt class="literal">type</tt> attribute. The types we declare and use in the mapping
                files are not, as you might expect, Java data types. They are also not SQL
                database types. These types are so called <span class="emphasis"><em>Hibernate mapping types</em></span>,
                converters which can translate from Java to SQL data types and vice versa. Again,
                Hibernate will try to determine the correct conversion and mapping type itself if
                the <tt class="literal">type</tt> attribute is not present in the mapping. In some cases this
                automatic detection (using Reflection on the Java class) might not have the default you
                expect or need. This is the case with the <tt class="literal">date</tt> property. Hibernate can't
                know if the property (which is of <tt class="literal">java.util.Date</tt>) should map to a
                SQL <tt class="literal">date</tt>, <tt class="literal">timestamp</tt>, or <tt class="literal">time</tt> column.
                We preserve full date and time information by mapping the property with a
                <tt class="literal">timestamp</tt> converter.
            </p><p>
                This mapping file should be saved as <tt class="literal">Event.hbm.xml</tt>, right in
                the directory next to the <tt class="literal">Event</tt> Java class source file.
                The naming of mapping files can be arbitrary, however the <tt class="literal">hbm.xml</tt>
                suffix  is a convention in the Hibernate developer community. The directory structure
                should now look like this:
            </p><pre class="programlisting">.
+lib
  &lt;Hibernate and third-party libraries&gt;
+src
  +events
    Event.java
    Event.hbm.xml</pre><p>
                 We continue with the main configuration of Hibernate.
             </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-firstapp-configuration"></a>1.2.3.&nbsp;Hibernate configuration</h3></div></div><div></div></div><p>
                We now have a persistent class and its mapping file in place. It is time to configure
                Hibernate. Before we do this, we will need a database. HSQL DB, a java-based SQL DBMS,
                can be downloaded from the HSQL DB website. Actually, you only need the <tt class="literal">hsqldb.jar</tt>
                from this download. Place this file in the <tt class="literal">lib/</tt> directory of the
                development folder.
            </p><p>
                Create a directory called <tt class="literal">data</tt> in the root of the development directory -
                this is where HSQL DB will store its data files. Now start the database by running
                <tt class="literal">java -classpath lib/hsqldb.jar org.hsqldb.Server</tt> in your work directory.
                You can see it start up and bind to a TCP/IP socket, this is where our application
                will connect later. If you want to start with a fresh database during this tutorial,
                shutdown HSQL DB (press <tt class="literal">CTRL + C</tt> in the window), delete the
                <tt class="literal">data/</tt> directory, and start HSQL DB again.
            </p><p>
                Hibernate is the layer in your application which connects to this database, so it needs
                connection information. The connections are made through a JDBC connection pool, which we
                also have to configure. The Hibernate distribution contains several open source JDBC connection
                pooling tools, but will use the Hibernate built-in connection pool for this tutorial. Note that
                you have to copy the required library into your classpath and use different
                connection pooling settings if you want to use a production-quality third party
                JDBC pooling software.
            </p><p>
                For Hibernate's configuration, we can use a simple <tt class="literal">hibernate.properties</tt> file, a
                slightly more sophisticated <tt class="literal">hibernate.cfg.xml</tt> file, or even complete
                programmatic setup. Most users prefer the XML configuration file:
            </p><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;

&lt;hibernate-configuration&gt;

    &lt;session-factory&gt;

        &lt;!-- Database connection settings --&gt;
        &lt;property name="connection.driver_class"&gt;org.hsqldb.jdbcDriver&lt;/property&gt;
        &lt;property name="connection.url"&gt;jdbc:hsqldb:hsql://localhost&lt;/property&gt;
        &lt;property name="connection.username"&gt;sa&lt;/property&gt;
        &lt;property name="connection.password"&gt;&lt;/property&gt;

        &lt;!-- JDBC connection pool (use the built-in) --&gt;
        &lt;property name="connection.pool_size"&gt;1&lt;/property&gt;

        &lt;!-- SQL dialect --&gt;
        &lt;property name="dialect"&gt;org.hibernate.dialect.HSQLDialect&lt;/property&gt;

        &lt;!-- Enable Hibernate's automatic session context management --&gt;
        &lt;property name="current_session_context_class"&gt;thread&lt;/property&gt;

        &lt;!-- Disable the second-level cache  --&gt;
        &lt;property name="cache.provider_class"&gt;org.hibernate.cache.NoCacheProvider&lt;/property&gt;

        &lt;!-- Echo all executed SQL to stdout --&gt;
        &lt;property name="show_sql"&gt;true&lt;/property&gt;

        &lt;!-- Drop and re-create the database schema on startup --&gt;
        &lt;property name="hbm2ddl.auto"&gt;create&lt;/property&gt;

        &lt;mapping resource="events/Event.hbm.xml"/&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre><p>
                Note that this XML configuration uses a different DTD. We configure
                Hibernate's <tt class="literal">SessionFactory</tt> - a global factory responsible
                for a particular database. If you have several databases, use several
                <tt class="literal">&lt;session-factory&gt;</tt> configurations, usually in
                several configuration files (for easier startup).
            </p><p>
                The first four <tt class="literal">property</tt> elements contain the necessary
                configuration for the JDBC connection. The dialect <tt class="literal">property</tt>
                element specifies the particular SQL variant Hibernate generates.
                Hibernate's automatic session management for persistence contexts will
                come in handy as you will soon see.
                The <tt class="literal">hbm2ddl.auto</tt> option turns on automatic generation of
                database schemas - directly into the database. This can of course also be turned
                off (by removing the config option) or redirected to a file with the help of
                the <tt class="literal">SchemaExport</tt> Ant task. Finally, we add the mapping file(s)
                for persistent classes to the configuration.
            </p><p>
                Copy this file into the source directory, so it will end up in the
                root of the classpath. Hibernate automatically looks for a file called
                <tt class="literal">hibernate.cfg.xml</tt> in the root of the classpath, on startup.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-firstapp-ant"></a>1.2.4.&nbsp;Building with Ant</h3></div></div><div></div></div><p>
                We'll now build the tutorial with Ant. You will need to have Ant installed - get
                it from the <a href="http://ant.apache.org/bindownload.cgi" target="_top">Ant download page</a>.
                How to install Ant will not be covered here. Please refer to the
                <a href="http://ant.apache.org/manual/index.html" target="_top">Ant manual</a>. After you
                have installed Ant, we can start to create the buildfile. It will be called
                <tt class="literal">build.xml</tt> and placed directly in the development directory.
            </p><p>
                A basic build file looks like this:
            </p><pre class="programlisting">&lt;project name="hibernate-tutorial" default="compile"&gt;

    &lt;property name="sourcedir" value="${basedir}/src"/&gt;
    &lt;property name="targetdir" value="${basedir}/bin"/&gt;
    &lt;property name="librarydir" value="${basedir}/lib"/&gt;

    &lt;path id="libraries"&gt;
        &lt;fileset dir="${librarydir}"&gt;
            &lt;include name="*.jar"/&gt;
        &lt;/fileset&gt;
    &lt;/path&gt;

    &lt;target name="clean"&gt;
        &lt;delete dir="${targetdir}"/&gt;
        &lt;mkdir dir="${targetdir}"/&gt;
    &lt;/target&gt;

    &lt;target name="compile" depends="clean, copy-resources"&gt;
      &lt;javac srcdir="${sourcedir}"
             destdir="${targetdir}"
             classpathref="libraries"/&gt;
    &lt;/target&gt;

    &lt;target name="copy-resources"&gt;
        &lt;copy todir="${targetdir}"&gt;
            &lt;fileset dir="${sourcedir}"&gt;
                &lt;exclude name="**/*.java"/&gt;
            &lt;/fileset&gt;
        &lt;/copy&gt;
    &lt;/target&gt;

&lt;/project&gt;</pre><p>
                This will tell Ant to add all files in the lib directory ending with <tt class="literal">.jar</tt>
                to the classpath used for compilation. It will also copy all non-Java source files to the
                target directory, e.g. configuration and Hibernate mapping files. If you now run Ant, you
                should get this output:
            </p><pre class="programlisting">C:\hibernateTutorial\&gt;ant
Buildfile: build.xml

copy-resources:
     [copy] Copying 2 files to C:\hibernateTutorial\bin

compile:
    [javac] Compiling 1 source file to C:\hibernateTutorial\bin

BUILD SUCCESSFUL
Total time: 1 second </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-firstapp-helpers"></a>1.2.5.&nbsp;Startup and helpers</h3></div></div><div></div></div><p>
                It's time to load and store some <tt class="literal">Event</tt> objects, but first
                we have to complete the setup with some infrastructure code. We have to startup
                Hibernate. This startup includes building a global <tt class="literal">SessionFactory</tt>
                object and to store it somewhere for easy access in application code.
                A <tt class="literal">SessionFactory</tt> can open up new <tt class="literal">Session</tt>'s.
                A <tt class="literal">Session</tt> represents a single-threaded unit of work, the
                <tt class="literal">SessionFactory</tt> is a thread-safe global object, instantiated once.
            </p><p>
                We'll create a <tt class="literal">HibernateUtil</tt> helper class which takes care
                of startup and makes accessing a <tt class="literal">SessionFactory</tt> convenient.
                Let's have a look at the implementation:
            </p><pre class="programlisting">package util;

import org.hibernate.*;
import org.hibernate.cfg.*;

public class HibernateUtil {

    private static final SessionFactory sessionFactory;

    static {
        try {
            // Create the SessionFactory from hibernate.cfg.xml
            sessionFactory = new Configuration().configure().buildSessionFactory();
        } catch (Throwable ex) {
            // Make sure you log the exception, as it might be swallowed
            System.err.println("Initial SessionFactory creation failed." + ex);
            throw new ExceptionInInitializerError(ex);
        }
    }

    public static SessionFactory getSessionFactory() {
        return sessionFactory;
    }

}</pre><p>
                This class does not only produce the global <tt class="literal">SessionFactory</tt> in
                its static initializer (called once by the JVM when the class is loaded), but also
                hides the fact that it uses a static singleton. It might as well lookup the
                <tt class="literal">SessionFactory</tt> from JNDI in an application server.
            </p><p>
                If you give the <tt class="literal">SessionFactory</tt> a name in your configuration
                file, Hibernate will in fact try to bind it to JNDI after it has been built.
                To avoid this code completely you could also use JMX deployment and let the
                JMX-capable container instantiate and bind a <tt class="literal">HibernateService</tt>
                to JNDI. These advanced options are discussed in the Hibernate reference
                documentation.
            </p><p>
                Place <tt class="literal">HibernateUtil.java</tt> in the development source directory, in
                a package next to <tt class="literal">events</tt>:
            </p><pre class="programlisting">.
+lib
  &lt;Hibernate and third-party libraries&gt;
+src
  +events
    Event.java
    Event.hbm.xml
  +util
    HibernateUtil.java
  hibernate.cfg.xml
+data
build.xml</pre><p>
                This should again compile without problems. We finally need to configure a logging
                system - Hibernate uses commons logging and leaves you the choice between Log4j and
                JDK 1.4 logging. Most developers prefer Log4j: copy <tt class="literal">log4j.properties</tt>
                from the Hibernate distribution (it's in the <tt class="literal">etc/</tt> directory) to
                your <tt class="literal">src</tt> directory, next to <tt class="literal">hibernate.cfg.xml</tt>.
                Have a look at the example configuration and change the settings if you like to have
                more verbose output. By default, only Hibernate startup message are shown on stdout.
            </p><p>
                The tutorial infrastructure is complete - and we are ready to do some real work with
                Hibernate.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-firstapp-workingpersistence"></a>1.2.6.&nbsp;Loading and storing objects</h3></div></div><div></div></div><p>
                Finally, we can use Hibernate to load and store objects. We write an
                <tt class="literal">EventManager</tt> class with a <tt class="literal">main()</tt> method:
            </p><pre class="programlisting">package events;
import org.hibernate.Session;

import java.util.Date;

import util.HibernateUtil;

public class EventManager {

    public static void main(String[] args) {
        EventManager mgr = new EventManager();

        if (args[0].equals("store")) {
            mgr.createAndStoreEvent("My Event", new Date());
        }

        HibernateUtil.getSessionFactory().close();
    }

    private void createAndStoreEvent(String title, Date theDate) {

        Session session = HibernateUtil.getSessionFactory().getCurrentSession();

        session.beginTransaction();

        Event theEvent = new Event();
        theEvent.setTitle(title);
        theEvent.setDate(theDate);

        session.save(theEvent);

        session.getTransaction().commit();
    }

}</pre><p>
                We create a new <tt class="literal">Event</tt> object, and hand it over to Hibernate.
                Hibernate now takes care of the SQL and executes <tt class="literal">INSERT</tt>s
                on the database. Let's have a look at the <tt class="literal">Session</tt> and
                <tt class="literal">Transaction</tt>-handling code before we run this.
            </p><p>
                A <tt class="literal">Session</tt> is a single unit of work. For now we'll keep things
                simple and assume a one-to-one granularity between a Hibernate <tt class="literal">Session</tt>
                and a database transaction. To shield our code from the actual underlying transaction
                system (in this case plain JDBC, but it could also run with JTA) we use the
                <tt class="literal">Transaction</tt> API that is available on the Hibernate <tt class="literal">Session</tt>.
            </p><p>
                What does <tt class="literal">sessionFactory.getCurrentSession()</tt> do? First, you can call it
                as many times and anywhere you like, once you get hold of your <tt class="literal">SessionFactory</tt>
                (easy thanks to <tt class="literal">HibernateUtil</tt>). The <tt class="literal">getCurrentSession()</tt>
                method always returns the "current" unit of work. Remember that we switched the configuration
                option for this mechanism to "thread" in <tt class="literal">hibernate.cfg.xml</tt>? Hence, the scope
                of the current unit of work is the current Java thread that executes our application. However, this
                is not the full truth. A <tt class="literal">Session</tt> begins when it is
                first needed, when the first call to <tt class="literal">getCurrentSession()</tt> is made.
                It is then bound by Hibernate to the current thread. When the transaction ends,
                either committed or rolled back, Hibernate also unbinds the <tt class="literal">Session</tt>
                from the thread and closes it for you. If you call <tt class="literal">getCurrentSession()</tt>
                again, you get a new <tt class="literal">Session</tt> and can start a new unit of work. This
                <span class="emphasis"><em>thread-bound</em></span> programming model is the most popular way of using
                Hibernate.
            </p><p>
                Have a look at <a href="#transactions" title="Chapter&nbsp;11.&nbsp;Transactions And Concurrency">Chapter&nbsp;11, <i>Transactions And Concurrency</i></a> for more information
                about transaction handling and demarcation. We also skipped any error handling and
                rollback in the previous example.
            </p><p>
                To run this first routine we have to add a callable target to the Ant build file:
            </p><pre class="programlisting">&lt;target name="run" depends="compile"&gt;
    &lt;java fork="true" classname="events.EventManager" classpathref="libraries"&gt;
        &lt;classpath path="${targetdir}"/&gt;
        &lt;arg value="${action}"/&gt;
    &lt;/java&gt;
&lt;/target&gt;</pre><p>
                The value of the <tt class="literal">action</tt> argument is set on the command line when
                calling the target:
            </p><pre class="programlisting">C:\hibernateTutorial\&gt;ant run -Daction=store</pre><p>
                You should see, after compilation, Hibernate starting up and, depending on your
                configuration, lots of log output. At the end you will find the following line:
            </p><pre class="programlisting">[java] Hibernate: insert into EVENTS (EVENT_DATE, title, EVENT_ID) values (?, ?, ?)</pre><p>
                This is the <tt class="literal">INSERT</tt> executed by Hibernate, the question marks
                represent JDBC bind parameters. To see the values bound as arguments, or to reduce
                the verbosity of the log, check your <tt class="literal">log4j.properties</tt>.
            </p><p>
                Now we'd like to list stored events as well, so we add an option to the main method:
            </p><pre class="programlisting">if (args[0].equals("store")) {
    mgr.createAndStoreEvent("My Event", new Date());
}
else if (args[0].equals("list")) {
    List events = mgr.listEvents();
    for (int i = 0; i &lt; events.size(); i++) {
        Event theEvent = (Event) events.get(i);
        System.out.println("Event: " + theEvent.getTitle() +
                           " Time: " + theEvent.getDate());
    }
}</pre><p>
                We also add a new <tt class="literal">listEvents() method</tt>:
            </p><pre class="programlisting">private List listEvents() {

    Session session = HibernateUtil.getSessionFactory().getCurrentSession();

    session.beginTransaction();

    List result = session.createQuery("from Event").list();

    session.getTransaction().commit();

    return result;
}</pre><p>
                What we do here is use an HQL (Hibernate Query Language) query to load all existing
                <tt class="literal">Event</tt> objects from the database. Hibernate will generate the
                appropriate SQL, send it to the database and populate <tt class="literal">Event</tt> objects
                with the data. You can create more complex queries with HQL, of course.
            </p><p>
                Now, to execute and test all of this, follow these steps:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        Run <tt class="literal">ant run -Daction=store</tt> to store something into the database
                        and, of course, to generate the database schema before through hbm2ddl.
                    </p></li><li><p>
                        Now disable hbm2ddl by commenting out the property in your <tt class="literal">hibernate.cfg.xml</tt>
                        file. Usually you only leave it turned on in continous unit testing, but another
                        run of hbm2ddl would <span class="emphasis"><em>drop</em></span> everything you have stored - the
                        <tt class="literal">create</tt> configuration setting actually translates into "drop all
                        tables from the schema, then re-create all tables, when the SessionFactory is build".
                    </p></li></ul></div><p>
                If you now call Ant with <tt class="literal">-Daction=list</tt>, you should see the events
                you have stored so far. You can of course also call the <tt class="literal">store</tt> action a few
                times more.
            </p><p>
                Note: Most new Hibernate users fail at this point and we see questions about
                <span class="emphasis"><em>Table not found</em></span> error messages regularly. However, if you follow the
                steps outlined above you will not have this problem, as hbm2ddl creates the database
                schema on the first run, and subsequent application restarts will use this schema. If
                you change the mapping and/or database schema, you have to re-enable hbm2ddl once again.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tutorial-associations"></a>1.3.&nbsp;Part 2 - Mapping associations</h2></div></div><div></div></div><p>
            We mapped a persistent entity class to a table. Let's build on this and add some class associations.
            First we'll add people to our application, and store a list of events they participate in.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-associations-mappinguser"></a>1.3.1.&nbsp;Mapping the Person class</h3></div></div><div></div></div><p>
                The first cut of the <tt class="literal">Person</tt> class is simple:
            </p><pre class="programlisting">package events;

public class Person {

    private Long id;
    private int age;
    private String firstname;
    private String lastname;

    public Person() {}

    // Accessor methods for all properties, private setter for 'id'

}</pre><p>
                Create a new mapping file called <tt class="literal">Person.hbm.xml</tt> (don't forget the
                DTD reference at the top):
            </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="events.Person" table="PERSON"&gt;
        &lt;id name="id" column="PERSON_ID"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="age"/&gt;
        &lt;property name="firstname"/&gt;
        &lt;property name="lastname"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
                Finally, add the new mapping to Hibernate's configuration:
            </p><pre class="programlisting">&lt;mapping resource="events/Event.hbm.xml"/&gt;
&lt;mapping resource="events/Person.hbm.xml"/&gt;</pre><p>
                We'll now create an association between these two entities. Obviously, persons
                can participate in events, and events have participants. The design questions
                we have to deal with are: directionality, multiplicity, and collection
                behavior.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-associations-unidirset"></a>1.3.2.&nbsp;A unidirectional Set-based association</h3></div></div><div></div></div><p>
                We'll add a collection of events to the <tt class="literal">Person</tt> class. That way we can
                easily navigate to the events for a particular person, without executing an explicit query -
                by calling <tt class="literal">aPerson.getEvents()</tt>. We use a Java collection, a <tt class="literal">Set</tt>,
                because the collection will not contain duplicate elements and the ordering is not relevant for us.
            </p><p>
                We need a unidirectional, many-valued associations, implemented with a <tt class="literal">Set</tt>.
                Let's write the code for this in the Java classes and then map it:
            </p><pre class="programlisting">public class Person {

    private Set events = new HashSet();

    public Set getEvents() {
        return events;
    }

    public void setEvents(Set events) {
        this.events = events;
    }
}</pre><p>
                Before we map this association, think about the other side. Clearly, we could just keep this
                unidirectional. Or, we could create another collection on the <tt class="literal">Event</tt>, if we
                want to be able to navigate it bi-directional, i.e. <tt class="literal">anEvent.getParticipants()</tt>.
                This is not necessary, from a functional perspective. You could always execute an explicit query
                to retrieve the participants for a particular event. This is a design choice left to you, but what
                is clear from this discussion is the multiplicity of the association: "many" valued on both sides,
                we call this a <span class="emphasis"><em>many-to-many</em></span> association. Hence, we use Hibernate's
                many-to-many mapping:
            </p><pre class="programlisting">&lt;class name="events.Person" table="PERSON"&gt;
    &lt;id name="id" column="PERSON_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="age"/&gt;
    &lt;property name="firstname"/&gt;
    &lt;property name="lastname"/&gt;

    &lt;set name="events" table="PERSON_EVENT"&gt;
        &lt;key column="PERSON_ID"/&gt;
        &lt;many-to-many column="EVENT_ID" class="Event"/&gt;
    &lt;/set&gt;

&lt;/class&gt;</pre><p>
                Hibernate supports all kinds of collection mappings, a <tt class="literal">&lt;set&gt;</tt> being most
                common. For a many-to-many association (or <span class="emphasis"><em>n:m</em></span> entity relationship), an
                association table is needed. Each row in this table represents a link between a person and an event.
                The table name is configured with the <tt class="literal">table</tt> attribute of the <tt class="literal">set</tt>
                element. The identifier column name in the association, for the person's side, is defined with the
                <tt class="literal">&lt;key&gt;</tt> element, the column name for the event's side with the
                <tt class="literal">column</tt> attribute of the <tt class="literal">&lt;many-to-many&gt;</tt>. You also
                have to tell Hibernate the class of the objects in your collection (correct: the class on the
                other side of the collection of references).
            </p><p>
                The database schema for this mapping is therefore:
            </p><pre class="programlisting">
    _____________        __________________
   |             |      |                  |       _____________
   |   EVENTS    |      |   PERSON_EVENT   |      |             |
   |_____________|      |__________________|      |    PERSON   |
   |             |      |                  |      |_____________|
   | *EVENT_ID   | &lt;--&gt; | *EVENT_ID        |      |             |
   |  EVENT_DATE |      | *PERSON_ID       | &lt;--&gt; | *PERSON_ID  |
   |  TITLE      |      |__________________|      |  AGE        |
   |_____________|                                |  FIRSTNAME  |
                                                  |  LASTNAME   |
                                                  |_____________|
 </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-associations-working"></a>1.3.3.&nbsp;Working the association</h3></div></div><div></div></div><p>
                Let's bring some people and events together in a new method in <tt class="literal">EventManager</tt>:
            </p><pre class="programlisting">private void addPersonToEvent(Long personId, Long eventId) {

    Session session = HibernateUtil.getSessionFactory().getCurrentSession();
    session.beginTransaction();

    Person aPerson = (Person) session.load(Person.class, personId);
    Event anEvent = (Event) session.load(Event.class, eventId);

    aPerson.getEvents().add(anEvent);

    session.getTransaction().commit();
}</pre><p>
                After loading a <tt class="literal">Person</tt> and an <tt class="literal">Event</tt>, simply
                modify the collection using the normal collection methods. As you can see, there is no explicit call
                to <tt class="literal">update()</tt> or <tt class="literal">save()</tt>, Hibernate automatically
                detects that the collection has been modified and needs to be updated. This is called <span class="emphasis"><em>automatic
                dirty checking</em></span>, and you can also try it by modifying the name or the date property of
                any of your objects. As long as they are in <span class="emphasis"><em>persistent</em></span> state, that is, bound
                to a particular Hibernate <tt class="literal">Session</tt> (i.e. they have been just loaded or saved in
                a unit of work), Hibernate monitors any changes and executes SQL in a write-behind fashion. The
                process of synchronizing the memory state with the database, usually only at the end of a unit of
                work, is called <span class="emphasis"><em>flushing</em></span>. In our code, the unit of work ends with a commit
                (or rollback) of the database transaction - as defined by the <tt class="literal">thread</tt> configuration
                option for the <tt class="literal">CurrentSessionContext</tt> class.
            </p><p>
                You might of course load person and event in different units of work. Or you modify an object
                outside of a <tt class="literal">Session</tt>, when it is not in persistent state (if it was persistent
                before, we call this state <span class="emphasis"><em>detached</em></span>). You can even modify a collection when
                it is detached:
            </p><pre class="programlisting">private void addPersonToEvent(Long personId, Long eventId) {

    Session session = HibernateUtil.getSessionFactory().getCurrentSession();
    session.beginTransaction();

    Person aPerson = (Person) session
            .createQuery("select p from Person p left join fetch p.events where p.id = :pid")
            .setParameter("pid", personId)
            .uniqueResult(); // Eager fetch the collection so we can use it detached

    Event anEvent = (Event) session.load(Event.class, eventId);

    session.getTransaction().commit();

    // End of first unit of work

    aPerson.getEvents().add(anEvent); // aPerson (and its collection) is detached

    // Begin second unit of work

    Session session2 = HibernateUtil.getSessionFactory().getCurrentSession();
    session2.beginTransaction();

    session2.update(aPerson); // Reattachment of aPerson

    session2.getTransaction().commit();
}</pre><p>
                The call to <tt class="literal">update</tt> makes a detached object persistent again, you could
                say it binds it to a new unit of work, so any modifications you made to it while detached
                can be saved to the database. This includes any modifications (additions/deletions) you
                made to a collection of that entity object.
            </p><p>
                Well, this is not much use in our current situation, but it's an important concept you can
                design into your own application. For now, complete this exercise by adding a new action
                to the <tt class="literal">EventManager</tt>'s main method and call it from the command line. If
                you need the identifiers of a person and an event - the <tt class="literal">save()</tt> method
                returns it (you might have to modify some of the previous methods to return that identifier):
            </p><pre class="programlisting">else if (args[0].equals("addpersontoevent")) {
    Long eventId = mgr.createAndStoreEvent("My Event", new Date());
    Long personId = mgr.createAndStorePerson("Foo", "Bar");
    mgr.addPersonToEvent(personId, eventId);
    System.out.println("Added person " + personId + " to event " + eventId);</pre><p>
                This was an example of an association between two equally important classes, two entities.
                As mentioned earlier, there are other classes and types in a typical model, usually "less
                important". Some you have already seen, like an <tt class="literal">int</tt> or a <tt class="literal">String</tt>.
                We call these classes <span class="emphasis"><em>value types</em></span>, and their instances <span class="emphasis"><em>depend</em></span>
                on a particular entity. Instances of these types don't have their own identity, nor are they
                shared between entities (two persons don't reference the same <tt class="literal">firstname</tt>
                object, even if they have the same first name). Of course, value types can not only be found in
                the JDK (in fact, in a Hibernate application all JDK classes are considered value types), but
                you can also write dependent classes yourself, <tt class="literal">Address</tt> or <tt class="literal">MonetaryAmount</tt>,
                for example.
            </p><p>
                You can also design a collection of value types. This is conceptually very different from a
                collection of references to other entities, but looks almost the same in Java.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-associations-valuecollections"></a>1.3.4.&nbsp;Collection of values</h3></div></div><div></div></div><p>
                We add a collection of value typed objects to the <tt class="literal">Person</tt> entity. We want to
                store email addresses, so the type we use is <tt class="literal">String</tt>, and the collection is
                again a <tt class="literal">Set</tt>:
            </p><pre class="programlisting">private Set emailAddresses = new HashSet();

public Set getEmailAddresses() {
    return emailAddresses;
}

public void setEmailAddresses(Set emailAddresses) {
    this.emailAddresses = emailAddresses;
}</pre><p>
                The mapping of this <tt class="literal">Set</tt>:
            </p><pre class="programlisting">&lt;set name="emailAddresses" table="PERSON_EMAIL_ADDR"&gt;
    &lt;key column="PERSON_ID"/&gt;
    &lt;element type="string" column="EMAIL_ADDR"/&gt;
&lt;/set&gt;</pre><p>
                The difference compared with the earlier mapping is the <tt class="literal">element</tt> part, which tells Hibernate that the collection
                does not contain references to another entity, but a collection of elements of type
                <tt class="literal">String</tt> (the lowercase name tells you it's a Hibernate mapping type/converter).
                Once again, the <tt class="literal">table</tt> attribute of the <tt class="literal">set</tt> element determines
                the table name for the collection. The <tt class="literal">key</tt> element defines the foreign-key column
                name in the collection table. The <tt class="literal">column</tt> attribute in the <tt class="literal">element</tt>
                element defines the column name where the <tt class="literal">String</tt> values will actually be stored.
            </p><p>
                Have a look at the updated schema:
            </p><pre class="programlisting">
  _____________        __________________
 |             |      |                  |       _____________
 |   EVENTS    |      |   PERSON_EVENT   |      |             |       ___________________
 |_____________|      |__________________|      |    PERSON   |      |                   |
 |             |      |                  |      |_____________|      | PERSON_EMAIL_ADDR |
 | *EVENT_ID   | &lt;--&gt; | *EVENT_ID        |      |             |      |___________________|
 |  EVENT_DATE |      | *PERSON_ID       | &lt;--&gt; | *PERSON_ID  | &lt;--&gt; |  *PERSON_ID       |
 |  TITLE      |      |__________________|      |  AGE        |      |  *EMAIL_ADDR      |
 |_____________|                                |  FIRSTNAME  |      |___________________|
                                                |  LASTNAME   |
                                                |_____________|
 </pre><p>
                You can see that the primary key of the collection table is in fact a composite key,
                using both columns. This also implies that there can't be duplicate email addresses
                per person, which is exactly the semantics we need for a set in Java.
            </p><p>
                You can now try and add elements to this collection, just like we did before by
                linking persons and events. It's the same code in Java:
            </p><pre class="programlisting">private void addEmailToPerson(Long personId, String emailAddress) {

    Session session = HibernateUtil.getSessionFactory().getCurrentSession();
    session.beginTransaction();

    Person aPerson = (Person) session.load(Person.class, personId);

    // The getEmailAddresses() might trigger a lazy load of the collection
    aPerson.getEmailAddresses().add(emailAddress);

    session.getTransaction().commit();
}</pre><p>
                This time we didnt' use a <span class="emphasis"><em>fetch</em></span> query to initialize the collection.
                Hence, the call to its getter method will trigger an additional select to initialize
                it, so we can add an element to it. Monitor the SQL log and try to optimize this with
                an eager fetch.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-associations-bidirectional"></a>1.3.5.&nbsp;Bi-directional associations</h3></div></div><div></div></div><p>
                Next we are going to map a bi-directional association - making the association between
                person and event work from both sides in Java. Of course, the database schema doesn't
                change, we still have many-to-many multiplicity. A relational database is more flexible
                than a network programming language, so it doesn't need anything like a navigation
                direction - data can be viewed and retrieved in any possible way.
            </p><p>
                First, add a collection of participants to the <tt class="literal">Event</tt> Event class:
            </p><pre class="programlisting">private Set participants = new HashSet();

public Set getParticipants() {
    return participants;
}

public void setParticipants(Set participants) {
    this.participants = participants;
}</pre><p>
                Now map this side of the association too, in <tt class="literal">Event.hbm.xml</tt>.
            </p><pre class="programlisting">&lt;set name="participants" table="PERSON_EVENT" inverse="true"&gt;
    &lt;key column="EVENT_ID"/&gt;
    &lt;many-to-many column="PERSON_ID" class="events.Person"/&gt;
&lt;/set&gt;</pre><p>
                As you see, these are normal <tt class="literal">set</tt> mappings in both mapping documents.
                Notice that the column names in <tt class="literal">key</tt> and <tt class="literal">many-to-many</tt> are
                swapped in both mapping documents. The most important addition here is the
                <tt class="literal">inverse="true"</tt> attribute in the <tt class="literal">set</tt> element of the
                <tt class="literal">Event</tt>'s collection mapping.
            </p><p>
                What this means is that Hibernate should take the other side - the <tt class="literal">Person</tt> class -
                when it needs to find out information about the link between the two. This will be a lot easier to
                understand once you see how the bi-directional link between our two entities is created .
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-associations-usingbidir"></a>1.3.6.&nbsp;Working bi-directional links</h3></div></div><div></div></div><p>
                First, keep in mind that Hibernate does not affect normal Java semantics. How did we create a
                link between a <tt class="literal">Person</tt> and an <tt class="literal">Event</tt> in the unidirectional
                example? We added an instance of <tt class="literal">Event</tt> to the collection of event references,
                of an instance of <tt class="literal">Person</tt>. So, obviously, if we want to make this link working
                bi-directional, we have to do the same on the other side - adding a <tt class="literal">Person</tt>
                reference to the collection in an <tt class="literal">Event</tt>. This "setting the link on both sides"
                is absolutely necessary and you should never forget doing it.
            </p><p>
                Many developers program defensive and create a link management methods to
                correctly set both sides, e.g. in <tt class="literal">Person</tt>:
            </p><pre class="programlisting">protected Set getEvents() {
    return events;
}

protected void setEvents(Set events) {
    this.events = events;
}

public void addToEvent(Event event) {
    this.getEvents().add(event);
    event.getParticipants().add(this);
}

public void removeFromEvent(Event event) {
    this.getEvents().remove(event);
    event.getParticipants().remove(this);
}</pre><p>
                Notice that the get and set methods for the collection are now protected - this allows classes in the
                same package and subclasses to still access the methods, but prevents everybody else from messing
                with the collections directly (well, almost). You should probably do the same with the collection
                on the other side.
            </p><p>
                What about the <tt class="literal">inverse</tt> mapping attribute? For you, and for Java, a bi-directional
                link is simply a matter of setting the references on both sides correctly. Hibernate however doesn't
                have enough information to correctly arrange SQL <tt class="literal">INSERT</tt> and <tt class="literal">UPDATE</tt>
                statements (to avoid constraint violations), and needs some help to handle bi-directional associations
                properly. Making one side of the association <tt class="literal">inverse</tt> tells Hibernate to basically
                ignore it, to consider it a <span class="emphasis"><em>mirror</em></span> of the other side. That's all that is necessary
                for Hibernate to work out all of the issues when transformation a directional navigation model to
                a SQL database schema. The rules you have to remember are straightforward: All bi-directional associations
                need one side as <tt class="literal">inverse</tt>. In a one-to-many association it has to be the many-side,
                in many-to-many association you can pick either side, there is no difference.
            </p></div><p>
            Let's turn this into a small web application.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tutorial-webapp"></a>1.4.&nbsp;Part 3 - The EventManager web application</h2></div></div><div></div></div><p>
            A Hibernate web application uses <tt class="literal">Session</tt> and <tt class="literal">Transaction</tt>
            almost like a standalone application. However, some common patterns are useful. We now write
            an <tt class="literal">EventManagerServlet</tt>. This servlet can list all events stored in the
            database, and it provides an HTML form to enter new events.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-webapp-servlet"></a>1.4.1.&nbsp;Writing the basic servlet</h3></div></div><div></div></div><p>
                Create a new class in your source directory, in the <tt class="literal">events</tt>
                package:
            </p><pre class="programlisting">package events;

// Imports

public class EventManagerServlet extends HttpServlet {

    private final SimpleDateFormat dateFormatter =
                            new SimpleDateFormat("dd.MM.yyyy");

    // Servlet code
}</pre><p>
                The <tt class="literal">dateFormatter</tt> is a tool we'll need later to convert
                <tt class="literal">Date</tt> objects from and to strings. It makes sense to only
                have one formatter as a member of the servlet.
            </p><p>
                The servlet handles HTTP <tt class="literal">GET</tt> requests only, hence, the method
                we implement is <tt class="literal">doGet()</tt>:
            </p><pre class="programlisting">protected void doGet(HttpServletRequest request,
                     HttpServletResponse response)
        throws ServletException, IOException {

    try {
        // Begin unit of work
        HibernateUtil.getSessionFactory()
                .getCurrentSession().beginTransaction();

        // Process request and render page...

        // End unit of work
        HibernateUtil.getSessionFactory()
                .getCurrentSession().getTransaction().commit();

    } catch (Exception ex) {
        HibernateUtil.getSessionFactory()
                .getCurrentSession().getTransaction().rollback();
        throw new ServletException(ex);
    }

}</pre><p>
                The pattern we are applying here is called <span class="emphasis"><em>session-per-request</em></span>.
                When a request hits the servlet, a new Hibernate <tt class="literal">Session</tt> is
                opened through the first call to <tt class="literal">getCurrentSession()</tt> on the
                <tt class="literal">SessionFactory</tt>. Then a database transaction is started&#8212;all
                data access as to occur inside a transaction, no matter if data is read or written
                (we don't use the auto-commit mode in applications).
            </p><p>
                Next, the possible actions of the request are processed and the response HTML
                is rendered. We'll get to that part soon.
            </p><p>
                Finally, the unit of work ends when processing and rendering is complete. If any
                problem occured during processing or rendering, an exception will be thrown
                and the database transaction rolled back. This completes the
                <tt class="literal">session-per-request</tt> pattern. Instead of the transaction
                demarcation code in every servlet you could also write a servlet filter.
                See the Hibernate website and Wiki for more information about this pattern,
                called <span class="emphasis"><em>Open Session in View</em></span>&#8212;you'll need it as soon
                as you consider rendering your view in JSP, not in a servlet.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-webapp-processing"></a>1.4.2.&nbsp;Processing and rendering</h3></div></div><div></div></div><p>
                Let's implement the processing of the request and rendering of the page.
            </p><pre class="programlisting">// Write HTML header
PrintWriter out = response.getWriter();
out.println("&lt;html&gt;&lt;head&gt;&lt;title&gt;Event Manager&lt;/title&gt;&lt;/head&gt;&lt;body&gt;");

// Handle actions
if ( "store".equals(request.getParameter("action")) ) {

    String eventTitle = request.getParameter("eventTitle");
    String eventDate = request.getParameter("eventDate");

    if ( "".equals(eventTitle) || "".equals(eventDate) ) {
        out.println("&lt;b&gt;&lt;i&gt;Please enter event title and date.&lt;/i&gt;&lt;/b&gt;");
    } else {
        createAndStoreEvent(eventTitle, dateFormatter.parse(eventDate));
        out.println("&lt;b&gt;&lt;i&gt;Added event.&lt;/i&gt;&lt;/b&gt;");
    }
}

// Print page
printEventForm(out);
listEvents(out);

// Write HTML footer
out.println("&lt;/body&gt;&lt;/html&gt;");
out.flush();
out.close();</pre><p>
                Granted, this coding style with a mix of Java and HTML would not scale
                in a more complex application&#8212;keep in mind that we are only illustrating
                basic Hibernate concepts in this tutorial. The code prints an HTML
                header and a footer. Inside this page, an HTML form for event entry and
                a list of all events in the database are printed. The first method is
                trivial and only outputs HTML:
            </p><pre class="programlisting">private void printEventForm(PrintWriter out) {
    out.println("&lt;h2&gt;Add new event:&lt;/h2&gt;");
    out.println("&lt;form&gt;");
    out.println("Title: &lt;input name='eventTitle' length='50'/&gt;&lt;br/&gt;");
    out.println("Date (e.g. 24.12.2009): &lt;input name='eventDate' length='10'/&gt;&lt;br/&gt;");
    out.println("&lt;input type='submit' name='action' value='store'/&gt;");
    out.println("&lt;/form&gt;");
}</pre><p>
                The <tt class="literal">listEvents()</tt> method uses the Hibernate
                <tt class="literal">Session</tt> bound to the current thread to execute
                a query:
            </p><pre class="programlisting">private void listEvents(PrintWriter out) {
    List result = HibernateUtil.getSessionFactory()
                    .getCurrentSession().createCriteria(Event.class).list();
    if (result.size() &gt; 0) {
        out.println("&lt;h2&gt;Events in database:&lt;/h2&gt;");
        out.println("&lt;table border='1'&gt;");
        out.println("&lt;tr&gt;");
        out.println("&lt;th&gt;Event title&lt;/th&gt;");
        out.println("&lt;th&gt;Event date&lt;/th&gt;");
        out.println("&lt;/tr&gt;");
        for (Iterator it = result.iterator(); it.hasNext();) {
            Event event = (Event) it.next();
            out.println("&lt;tr&gt;");
            out.println("&lt;td&gt;" + event.getTitle() + "&lt;/td&gt;");
            out.println("&lt;td&gt;" + dateFormatter.format(event.getDate()) + "&lt;/td&gt;");
            out.println("&lt;/tr&gt;");
        }
        out.println("&lt;/table&gt;");
    }
}</pre><p>
                Finally, the <tt class="literal">store</tt> action is dispatched to the
                <tt class="literal">createAndStoreEvent()</tt> method, which also uses
                the <tt class="literal">Session</tt> of the current thread:
            </p><pre class="programlisting">protected void createAndStoreEvent(String title, Date theDate) {
    Event theEvent = new Event();
    theEvent.setTitle(title);
    theEvent.setDate(theDate);

    HibernateUtil.getSessionFactory()
                    .getCurrentSession().save(theEvent);
}</pre><p>
                That's it, the servlet is complete. A request to the servlet will be processed
                in a single <tt class="literal">Session</tt> and <tt class="literal">Transaction</tt>. As
                earlier in the standalone application, Hibernate can automatically bind these
                ojects to the current thread of execution. This gives you the freedom to layer
                your code and access the <tt class="literal">SessionFactory</tt> in any way you like.
                Usually you'd use a more sophisticated design and move the data access code
                into data access objects (the DAO pattern). See the Hibernate Wiki for more
                examples.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-webapp-deploy"></a>1.4.3.&nbsp;Deploying and testing</h3></div></div><div></div></div><p>
                To deploy this application you have to create a web archive, a WAR. Add the
                following Ant target to your <tt class="literal">build.xml</tt>:
            </p><pre class="programlisting">&lt;target name="war" depends="compile"&gt;
    &lt;war destfile="hibernate-tutorial.war" webxml="web.xml"&gt;
        &lt;lib dir="${librarydir}"&gt;
          &lt;exclude name="jsdk*.jar"/&gt;
        &lt;/lib&gt;

        &lt;classes dir="${targetdir}"/&gt;
    &lt;/war&gt;
&lt;/target&gt;</pre><p>
                This target creates a file called <tt class="literal">hibernate-tutorial.war</tt>
                in your project directory. It packages all libraries and the <tt class="literal">web.xml</tt>
                descriptor, which is expected in the base directory of your project:
            </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="2.4"
    xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;Event Manager&lt;/servlet-name&gt;
        &lt;servlet-class&gt;events.EventManagerServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Event Manager&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/eventmanager&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre><p>
                Before you compile and deploy the web application, note that an additional library
                is required: <tt class="literal">jsdk.jar</tt>. This is the Java servlet development kit,
                if you don't have this library already, get it from the Sun website and copy it to
                your library directory. However, it will be only used for compliation and excluded
                from the WAR package.
            </p><p>
                To build and deploy call <tt class="literal">ant war</tt> in your project directory
                and copy the <tt class="literal">hibernate-tutorial.war</tt> file into your Tomcat
                <tt class="literal">webapp</tt> directory. If you don't have Tomcat installed, download
                it and follow the installation instructions. You don't have to change any Tomcat
                configuration to deploy this application though.
            </p><p>
                Once deployed and Tomcat is running, access the application at
                <tt class="literal">http://localhost:8080/hibernate-tutorial/eventmanager</tt>. Make
                sure you watch the Tomcat log to see Hibernate initialize when the first
                request hits your servlet (the static initializer in <tt class="literal">HibernateUtil</tt>
                is called) and to get the detailed output if any exceptions occurs.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tutorial-summary"></a>1.5.&nbsp;Summary</h2></div></div><div></div></div><p>
            This tutorial covered the basics of writing a simple standalone Hibernate application
            and a small web application.
        </p><p>
            If you already feel confident with Hibernate, continue browsing through the reference
            documentation table of contents for topics you find interesting - most asked are
            transactional processing (<a href="#transactions" title="Chapter&nbsp;11.&nbsp;Transactions And Concurrency">Chapter&nbsp;11, <i>Transactions And Concurrency</i></a>), fetch
            performance (<a href="#performance" title="Chapter&nbsp;19.&nbsp;Improving performance">Chapter&nbsp;19, <i>Improving performance</i></a>), or the usage of the API (<a href="#objectstate" title="Chapter&nbsp;10.&nbsp;Working with objects">Chapter&nbsp;10, <i>Working with objects</i></a>)
            and the query features (<a href="#objectstate-querying" title="10.4.&nbsp;Querying">Section&nbsp;10.4, &#8220;Querying&#8221;</a>).
        </p><p>
            Don't forget to check the Hibernate website for more (specialized) tutorials.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="architecture"></a>Chapter&nbsp;2.&nbsp;Architecture</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-overview"></a>2.1.&nbsp;Overview</h2></div></div><div></div></div><p>
            A (very) high-level view of the Hibernate architecture:
        </p><div class="mediaobject" align="center"><img src="../shared/images/overview.gif" align="middle"></div><p>
            This diagram shows Hibernate using the database and configuration data to
            provide persistence services (and persistent objects) to the application.
        </p><p>
            We would like to show a more detailed view of the runtime architecture.
            Unfortunately, Hibernate is flexible and supports several approaches. We will
            show the two extremes. The "lite" architecture has the application
            provide its own JDBC connections and manage its own transactions. This approach
            uses a minimal subset of Hibernate's APIs:
        </p><div class="mediaobject" align="center"><img src="../shared/images/lite.gif" align="middle"></div><p>
            The "full cream" architecture abstracts the application away from the
            underlying JDBC/JTA APIs and lets Hibernate take care of the details.
        </p><div class="mediaobject" align="center"><img src="../shared/images/full_cream.gif" align="middle"></div><p>
            Heres some definitions of the objects in the diagrams:

            </p><div class="variablelist"><dl><dt><span class="term">SessionFactory (<tt class="literal">org.hibernate.SessionFactory</tt>)</span></dt><dd><p>
                            A threadsafe (immutable) cache of compiled mappings for a single database.
                            A factory for <tt class="literal">Session</tt> and a client of
                            <tt class="literal">ConnectionProvider</tt>. Might hold an optional (second-level)
                            cache of data that is reusable between transactions, at a
                            process- or cluster-level.
                        </p></dd><dt><span class="term">Session (<tt class="literal">org.hibernate.Session</tt>)</span></dt><dd><p>
                            A single-threaded, short-lived object representing a conversation between
                            the application and the persistent store. Wraps a JDBC connection. Factory
                            for <tt class="literal">Transaction</tt>. Holds a mandatory (first-level) cache
                            of persistent objects, used when navigating the object graph or looking up
                            objects by identifier.
                        </p></dd><dt><span class="term">Persistent objects and collections</span></dt><dd><p>
                            Short-lived, single threaded objects containing persistent state and business
                            function. These might be ordinary JavaBeans/POJOs, the only special thing about
                            them is that they are currently associated with (exactly one)
                            <tt class="literal">Session</tt>. As soon as the <tt class="literal">Session</tt> is closed,
                            they will be detached and free to use in any application layer (e.g. directly
                            as data transfer objects to and from presentation).
                        </p></dd><dt><span class="term">Transient and detached objects and collections</span></dt><dd><p>
                            Instances of persistent classes that are not currently associated with a
                            <tt class="literal">Session</tt>. They may have been instantiated by
                            the application and not (yet) persisted or they may have been instantiated by a
                            closed <tt class="literal">Session</tt>.
                        </p></dd><dt><span class="term">Transaction (<tt class="literal">org.hibernate.Transaction</tt>)</span></dt><dd><p>
                            (Optional) A single-threaded, short-lived object used by the application to
                            specify atomic units of work. Abstracts application from underlying JDBC,
                            JTA or CORBA transaction. A <tt class="literal">Session</tt> might span several
                            <tt class="literal">Transaction</tt>s in some cases. However, transaction demarcation,
                            either using the underlying API or <tt class="literal">Transaction</tt>, is never
                            optional!
                        </p></dd><dt><span class="term">ConnectionProvider (<tt class="literal">org.hibernate.connection.ConnectionProvider</tt>)</span></dt><dd><p>
                            (Optional) A factory for (and pool of) JDBC connections. Abstracts application from
                            underlying <tt class="literal">Datasource</tt> or <tt class="literal">DriverManager</tt>.
                            Not exposed to application, but can be extended/implemented by the developer.
                        </p></dd><dt><span class="term">TransactionFactory (<tt class="literal">org.hibernate.TransactionFactory</tt>)</span></dt><dd><p>
                            (Optional) A factory for <tt class="literal">Transaction</tt> instances. Not exposed to the
                            application, but can be extended/implemented by the developer.
                        </p></dd><dt><span class="term"><span class="emphasis"><em>Extension Interfaces</em></span></span></dt><dd><p>
                            Hibernate offers many optional extension interfaces you can implement to customize
                            the behavior of your persistence layer. See the API documentation for details.
                        </p></dd></dl></div><p>
        </p><p>
            Given a "lite" architecture, the application bypasses the
            <tt class="literal">Transaction</tt>/<tt class="literal">TransactionFactory</tt> and/or
            <tt class="literal">ConnectionProvider</tt> APIs to talk to JTA or JDBC directly.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-states"></a>2.2.&nbsp;Instance states</h2></div></div><div></div></div><p>
            An instance of a persistent classes may be in one of three different states,
            which are defined with respect to a <span class="emphasis"><em>persistence context</em></span>.
            The Hibernate <tt class="literal">Session</tt> object is the persistence context:
        </p><div class="variablelist"><dl><dt><span class="term">transient</span></dt><dd><p>
                        The instance is not, and has never been associated with
                        any persistence context. It has no persistent identity
                        (primary key value).
                    </p></dd><dt><span class="term">persistent</span></dt><dd><p>
                        The instance is currently associated with a persistence 
                        context. It has a persistent identity (primary key value)
                        and, perhaps, a corresponding row in the database. For a
                        particular persistence context, Hibernate 
                        <span class="emphasis"><em>guarantees</em></span> that persistent identity
                        is equivalent to Java identity (in-memory location of the
                        object).
                    </p></dd><dt><span class="term">detached</span></dt><dd><p>
                        The instance was once associated with a persistence
                        context, but that context was closed, or the instance
                        was serialized to another process. It has a persistent 
                        identity and, perhaps, a corrsponding row in the database.
                        For detached instances, Hibernate makes no guarantees 
                        about the relationship between persistent identity and
                        Java identity.
                    </p></dd></dl></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-jmx"></a>2.3.&nbsp;JMX Integration</h2></div></div><div></div></div><p>
            JMX is the J2EE standard for management of Java components. Hibernate may be managed via
            a JMX standard service. We provide an MBean implementation in the distribution,
            <tt class="literal">org.hibernate.jmx.HibernateService</tt>.
        </p><p>
            For an example how to deploy Hibernate as a JMX service on the JBoss Application Server,
            please see the JBoss User Guide. On JBoss AS, you also get these benefits if you deploy
            using JMX:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <span class="emphasis"><em>Session Management:</em></span> The Hibernate <tt class="literal">Session</tt>'s lifecycle
                    can be automatically bound to the scope of a JTA transaction. This means you no
                    longer have to manually open and close the <tt class="literal">Session</tt>, this
                    becomes the job of a JBoss EJB interceptor. You also don't have to worry about
                    transaction demarcation in your code anymore (unless you'd like to write a portable
                    persistence layer of course, use the optional Hibernate <tt class="literal">Transaction</tt>
                    API for this). You call the <tt class="literal">HibernateContext</tt> to access a
                    <tt class="literal">Session</tt>.
                </p></li><li><p>
                    <span class="emphasis"><em>HAR deployment:</em></span> Usually you deploy the Hibernate JMX service using a JBoss
                    service deployment descriptor (in an EAR and/or SAR file), it supports all the usual
                    configuration options of a Hibernate <tt class="literal">SessionFactory</tt>. However, you still
                    have to name all your mapping files in the deployment descriptor. If you decide to use
                    the optional HAR deployment, JBoss will automatically detect all mapping files in your
                    HAR file.
                </p></li></ul></div><p>
            Consult the JBoss AS user guide for more information about these options.
        </p><p>
            Another feature available as a JMX service are runtime Hibernate statistics. See
            <a href="#configuration-optional-statistics" title="3.4.6.&nbsp;Hibernate statistics">Section&nbsp;3.4.6, &#8220;Hibernate statistics&#8221;</a>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-jca"></a>2.4.&nbsp;JCA Support</h2></div></div><div></div></div><p>
            Hibernate may also be configured as a JCA connector. Please see the website for more
            details. Please note that Hibernate JCA support is still considered experimental.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-current-session"></a>2.5.&nbsp;Contextual Sessions</h2></div></div><div></div></div><p>
            Most applications using Hibernate need some form of "contextual" sessions, where a given
            session is in effect throughout the scope of a given context. However, across applications
            the definition of what constitutes a context is typically different; and different contexts
            define different scopes to the notion of current. Applications using Hibernate prior
            to version 3.0 tended to utilize either home-grown <tt class="literal">ThreadLocal</tt>-based
            contextual sessions, helper classes such as <tt class="literal">HibernateUtil</tt>, or utilized
            third-party frameworks (such as Spring or Pico) which provided proxy/interception-based contextual sessions.
        </p><p>
            Starting with version 3.0.1, Hibernate added the <tt class="literal">SessionFactory.getCurrentSession()</tt>
            method.  Initially, this assumed usage of <tt class="literal">JTA</tt> transactions, where the
            <tt class="literal">JTA</tt> transaction defined both the scope and context of a current session.
            The Hibernate team maintains that, given the maturity of the numerous stand-alone
            <tt class="literal">JTA TransactionManager</tt> implementations out there, most (if not all)
            applications should be using <tt class="literal">JTA</tt> transaction management whether or not
            they are deployed into a <tt class="literal">J2EE</tt> container.  Based on that, the
            <tt class="literal">JTA</tt>-based contextual sessions is all you should ever need to use.
        </p><p>
            However, as of version 3.1, the processing behind
            <tt class="literal">SessionFactory.getCurrentSession()</tt> is now pluggable.  To that
            end, a new extension interface (<tt class="literal">org.hibernate.context.CurrentSessionContext</tt>)
            and a new configuration parameter (<tt class="literal">hibernate.current_session_context_class</tt>)
            have been added to allow pluggability of the scope and context of defining current sessions.
        </p><p>
            See the Javadocs for the <tt class="literal">org.hibernate.context.CurrentSessionContext</tt>
            interface for a detailed discussion of its contract.  It defines a single method,
            <tt class="literal">currentSession()</tt>, by which the implementation is responsible for
            tracking the current contextual session.  Out-of-the-box, Hibernate comes with two
            implementations of this interface.
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <tt class="literal">org.hibernate.context.JTASessionContext</tt> - current sessions
                    are tracked and scoped by a <tt class="literal">JTA</tt> transaction.  The processing
                    here is exactly the same as in the older JTA-only approach.  See the Javadocs
                    for details.
                </p></li><li><p>
                    <tt class="literal">org.hibernate.context.ThreadLocalSessionContext</tt> - current
                    sessions are tracked by thread of execution. Again, see the Javadocs for details.
                </p></li></ul></div><p>
            Both implementations provide a "one session - one database transaction" programming
            model, also known and used as <span class="emphasis"><em>session-per-request</em></span>. The beginning
            and end of a Hibernate session is defined by the duration of a database transaction.
            If you use programatic transaction demarcation (e.g. in pure J2SE or with
            JTA/UserTransaction/BMT), you are adviced to use the Hibernate <tt class="literal">Transaction</tt>
            API to hide the underlying transaction system from your code. If you execute in
            an EJB container that supports CMT, transaction boundaries are defined declaratively
            and you don't need any transaction or session demarcation operations in your code.
            Refer to <a href="#transactions" title="Chapter&nbsp;11.&nbsp;Transactions And Concurrency">Chapter&nbsp;11, <i>Transactions And Concurrency</i></a> for more information and code examples.
        </p><p>
            The <tt class="literal">hibernate.current_session_context_class</tt> configuration parameter
            defines which <tt class="literal">org.hibernate.context.CurrentSessionContext</tt> implementation
            should be used.  Note that for backwards compatibility, if this config param is not set
            but a <tt class="literal">org.hibernate.transaction.TransactionManagerLookup</tt> is configured,
            Hibernate will use the <tt class="literal">org.hibernate.context.JTASessionContext</tt>.
            Typically, the value of this parameter would just name the implementation class to
            use; for the two out-of-the-box implementations, however, there are two corresponding
            short names, "jta" and "thread".
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="session-configuration"></a>Chapter&nbsp;3.&nbsp;Configuration</h2></div></div><div></div></div><p>
        Because Hibernate is designed to operate in many different environments, there
        are a large number of configuration parameters. Fortunately, most have sensible
        default values and Hibernate is distributed with an example 
        <tt class="literal">hibernate.properties</tt> file in <tt class="literal">etc/</tt> that shows
        the various options. Just put the example file in your classpath and customize it.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-programmatic"></a>3.1.&nbsp;Programmatic configuration</h2></div></div><div></div></div><p>
            An instance of <tt class="literal">org.hibernate.cfg.Configuration</tt>
            represents an entire set of mappings of an application's Java types to an
            SQL database. The <tt class="literal">Configuration</tt> is used to build an
            (immutable) <tt class="literal">SessionFactory</tt>. The mappings are compiled
            from various XML mapping files.
        </p><p>
            You may obtain a <tt class="literal">Configuration</tt> instance by instantiating 
            it directly and specifying XML mapping documents. If the mapping files are
            in the classpath, use <tt class="literal">addResource()</tt>:
        </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addResource("Item.hbm.xml")
    .addResource("Bid.hbm.xml");</pre><p>
            An alternative (sometimes better) way is to specify the mapped class, and
            let Hibernate find the mapping document for you:
        </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class);</pre><p>
            Then Hibernate will look for mapping files named
            <tt class="literal">/org/hibernate/auction/Item.hbm.xml</tt> and
            <tt class="literal">/org/hibernate/auction/Bid.hbm.xml</tt> in the classpath.
            This approach eliminates any hardcoded filenames.
        </p><p>
            A <tt class="literal">Configuration</tt> also allows you to specify configuration
            properties:
        </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class)
    .setProperty("hibernate.dialect", "org.hibernate.dialect.MySQLInnoDBDialect")
    .setProperty("hibernate.connection.datasource", "java:comp/env/jdbc/test")
    .setProperty("hibernate.order_updates", "true");</pre><p>
            This is not the only way to pass configuration properties to Hibernate. 
            The various options include:
        </p><div class="orderedlist"><ol type="1" compact><li><p>
                    Pass an instance of <tt class="literal">java.util.Properties</tt> to
                    <tt class="literal">Configuration.setProperties()</tt>.
                </p></li><li><p>
                    Place <tt class="literal">hibernate.properties</tt> in a root directory 
                    of the classpath.
                </p></li><li><p>
                    Set <tt class="literal">System</tt> properties using
                    <tt class="literal">java -Dproperty=value</tt>.
                </p></li><li><p>
                    Include <tt class="literal">&lt;property&gt;</tt> elements in
                    <tt class="literal">hibernate.cfg.xml</tt> (discussed later).
                </p></li></ol></div><p>
            <tt class="literal">hibernate.properties</tt> is the easiest approach if you
            want to get started quickly.
        </p><p>
            The <tt class="literal">Configuration</tt> is intended as a startup-time object, 
            to be discarded once a <tt class="literal">SessionFactory</tt> is created.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-sessionfactory"></a>3.2.&nbsp;Obtaining a SessionFactory</h2></div></div><div></div></div><p>
            When all mappings have been parsed by the <tt class="literal">Configuration</tt>, 
            the application must obtain a factory for <tt class="literal">Session</tt> instances. 
            This factory is intended to be shared by all application threads:
        </p><pre class="programlisting">SessionFactory sessions = cfg.buildSessionFactory();</pre><p>
            Hibernate does allow your application to instantiate more than one
            <tt class="literal">SessionFactory</tt>. This is useful if you are using more than 
            one database.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-hibernatejdbc"></a>3.3.&nbsp;JDBC connections</h2></div></div><div></div></div><p>
            Usually, you want to have the <tt class="literal">SessionFactory</tt> create and pool JDBC 
            connections for you. If you take this approach, opening a <tt class="literal">Session</tt> 
            is as simple as:
        </p><pre class="programlisting">Session session = sessions.openSession(); // open a new Session</pre><p>
            As soon as you do something that requires access to the database, a JDBC connection
            will be obtained from the pool.
        </p><p>
            For this to work, we need to pass some JDBC connection properties to Hibernate.
            All Hibernate property names and semantics are defined on the class 
            <tt class="literal">org.hibernate.cfg.Environment</tt>. We will now describe the most
            important settings for JDBC connection configuration.
        </p><p>
            Hibernate will obtain (and pool) connections using <tt class="literal">java.sql.DriverManager</tt> 
            if you set the following properties:
        </p><div class="table"><a name="d0e1589"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;Hibernate JDBC Properties</b></p><table summary="Hibernate JDBC Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.connection.driver_class</tt></td><td><span class="emphasis"><em>jdbc driver class</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.url</tt></td><td><span class="emphasis"><em>jdbc URL</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.username</tt></td><td><span class="emphasis"><em>database user</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.password</tt></td><td><span class="emphasis"><em>database user password</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.pool_size</tt></td><td><span class="emphasis"><em>maximum number of pooled connections</em></span></td></tr></tbody></table></div><p>
            Hibernate's own connection pooling algorithm is however quite rudimentary. 
            It is intended to help you get started and is <span class="emphasis"><em>not intended for use 
            in a production system</em></span> or even for performance testing. You should
            use a third party pool for best performance and stability. Just replace the 
            <tt class="literal">hibernate.connection.pool_size</tt> property with connection 
            pool specific settings. This will turn off Hibernate's internal pool. For
            example, you might like to use C3P0.
        </p><p>
            C3P0 is an open source JDBC connection pool distributed along with 
            Hibernate in the <tt class="literal">lib</tt> directory. Hibernate will use its
            <tt class="literal">C3P0ConnectionProvider</tt> for connection pooling if you set 
            <tt class="literal">hibernate.c3p0.*</tt> properties. If you'd like to use Proxool
            refer to the packaged <tt class="literal">hibernate.properties</tt> and the Hibernate
            web site for more information.
        </p><p>
            Here is an example <tt class="literal">hibernate.properties</tt> file for C3P0:
        </p><a name="c3p0-configuration"></a><pre class="programlisting">hibernate.connection.driver_class = org.postgresql.Driver
hibernate.connection.url = jdbc:postgresql://localhost/mydatabase
hibernate.connection.username = myuser
hibernate.connection.password = secret
hibernate.c3p0.min_size=5
hibernate.c3p0.max_size=20
hibernate.c3p0.timeout=1800
hibernate.c3p0.max_statements=50
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect</pre><p>
            For use inside an application server, you should almost always configure 
            Hibernate to obtain connections from an application server  
            <tt class="literal">Datasource</tt> registered in JNDI. You'll need to set at
            least one of the following properties:
        </p><div class="table"><a name="d0e1671"></a><p class="title"><b>Table&nbsp;3.2.&nbsp;Hibernate Datasource Properties</b></p><table summary="Hibernate Datasource Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Propery name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.connection.datasource</tt></td><td><span class="emphasis"><em>datasource JNDI name</em></span></td></tr><tr><td><tt class="literal">hibernate.jndi.url</tt></td><td><span class="emphasis"><em>URL of the JNDI provider</em></span> (optional)
                </td></tr><tr><td><tt class="literal">hibernate.jndi.class</tt></td><td><span class="emphasis"><em>class of the JNDI <tt class="literal">InitialContextFactory</tt></em></span> (optional)
                </td></tr><tr><td><tt class="literal">hibernate.connection.username</tt></td><td><span class="emphasis"><em>database user</em></span> (optional)
                </td></tr><tr><td><tt class="literal">hibernate.connection.password</tt></td><td><span class="emphasis"><em>database user password</em></span> (optional)
                </td></tr></tbody></table></div><p>
            Here's an example <tt class="literal">hibernate.properties</tt> file for an
            application server provided JNDI datasource:
        </p><pre class="programlisting">hibernate.connection.datasource = java:/comp/env/jdbc/test
hibernate.transaction.factory_class = \
    org.hibernate.transaction.JTATransactionFactory
hibernate.transaction.manager_lookup_class = \
    org.hibernate.transaction.JBossTransactionManagerLookup
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect</pre><p>
            JDBC connections obtained from a JNDI datasource will automatically participate
            in the container-managed transactions of the application server.
        </p><p>
            Arbitrary connection properties may be given by prepending
            "<tt class="literal">hibernate.connnection</tt>" to the property name. For example, you
            may specify a <tt class="literal">charSet</tt> using <tt class="literal">hibernate.connection.charSet</tt>.
        </p><p>
            You may define your own plugin strategy for obtaining JDBC connections by implementing the
            interface <tt class="literal">org.hibernate.connection.ConnectionProvider</tt>. You may select
            a custom implementation by setting <tt class="literal">hibernate.connection.provider_class</tt>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-optional"></a>3.4.&nbsp;Optional configuration properties</h2></div></div><div></div></div><p>
            There are a number of other properties that control the behaviour of Hibernate
            at runtime. All are optional and have reasonable default values.
        </p><p>
        	<span class="emphasis"><em>Warning: some of these properties are "system-level" only.</em></span>
            System-level properties can be set only via <tt class="literal">java -Dproperty=value</tt> or
            <tt class="literal">hibernate.properties</tt>. They may <span class="emphasis"><em>not</em></span> be set by
            the other techniques described above.
        </p><div class="table"><a name="configuration-optional-properties"></a><p class="title"><b>Table&nbsp;3.3.&nbsp;Hibernate Configuration Properties</b></p><table summary="Hibernate Configuration Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.dialect</tt></td><td>
                            The classname of a Hibernate <tt class="literal">Dialect</tt> which 
                            allows Hibernate to generate SQL optimized for a particular
                            relational database.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">full.classname.of.Dialect</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.show_sql</tt></td><td>
                            Write all SQL statements to console. This is an alternative
                            to setting the log category <tt class="literal">org.hibernate.SQL</tt>
                            to <tt class="literal">debug</tt>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.format_sql</tt></td><td>
                            Pretty print the SQL in the log and console.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.default_schema</tt></td><td>
                            Qualify unqualified tablenames with the given schema/tablespace
                            in generated SQL.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">SCHEMA_NAME</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.default_catalog</tt></td><td>
                            Qualify unqualified tablenames with the given catalog
                            in generated SQL.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">CATALOG_NAME</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.session_factory_name</tt></td><td>
                            The <tt class="literal">SessionFactory</tt> will be automatically
                            bound to this name in JNDI after it has been created.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">jndi/composite/name</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.max_fetch_depth</tt></td><td>
                            Set a maximum "depth" for the outer join fetch tree
                            for single-ended associations (one-to-one, many-to-one).
                            A <tt class="literal">0</tt> disables default outer join fetching.
                            <p>
                                <span class="strong">eg.</span> 
                                recommended values between <tt class="literal">0</tt> and 
                                <tt class="literal">3</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.default_batch_fetch_size</tt></td><td>
                            Set a default size for Hibernate batch fetching of associations.
                            <p>
                                <span class="strong">eg.</span> 
                                recommended values <tt class="literal">4</tt>, <tt class="literal">8</tt>, 
                                <tt class="literal">16</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.default_entity_mode</tt></td><td>
                            Set a default mode for entity representation for all sessions
                            opened from this <tt class="literal">SessionFactory</tt><p>
                                <tt class="literal">dynamic-map</tt>, <tt class="literal">dom4j</tt>,
                                <tt class="literal">pojo</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.order_updates</tt></td><td>
                            Force Hibernate to order SQL updates by the primary key value
                            of the items being updated. This will result in fewer transaction
                            deadlocks in highly concurrent systems.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.generate_statistics</tt></td><td>
                            If enabled, Hibernate will collect statistics useful for
                            performance tuning.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.use_identifer_rollback</tt></td><td>
                            If enabled, generated identifier properties will be
                            reset to default values when objects are deleted.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.use_sql_comments</tt></td><td>
                            If turned on, Hibernate will generate comments inside the SQL, for
                            easier debugging, defaults to <tt class="literal">false</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr></tbody></table></div><div class="table"><a name="configuration-jdbc-properties"></a><p class="title"><b>Table&nbsp;3.4.&nbsp;Hibernate JDBC and Connection Properties</b></p><table summary="Hibernate JDBC and Connection Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.jdbc.fetch_size</tt></td><td>
                            A non-zero value determines the JDBC fetch size (calls
                            <tt class="literal">Statement.setFetchSize()</tt>).
                        </td></tr><tr><td><tt class="literal">hibernate.jdbc.batch_size</tt></td><td>
                            A non-zero value enables use of JDBC2 batch updates by Hibernate.
                            <p>
                                <span class="strong">eg.</span>
                                recommended values between <tt class="literal">5</tt> and <tt class="literal">30</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.batch_versioned_data</tt></td><td>
                            Set this property to <tt class="literal">true</tt> if your JDBC driver returns
                            correct row counts from <tt class="literal">executeBatch()</tt> (it is usually
                            safe to turn this option on). Hibernate will then use batched DML for
                            automatically versioned data. Defaults to <tt class="literal">false</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.factory_class</tt></td><td>
                            Select a custom <tt class="literal">Batcher</tt>. Most applications
                            will not need this configuration property.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">classname.of.Batcher</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.use_scrollable_resultset</tt></td><td>
                            Enables use of JDBC2 scrollable resultsets by Hibernate.
                            This property is only necessary when using user supplied
                            JDBC connections, Hibernate uses connection metadata otherwise.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.use_streams_for_binary</tt></td><td>
                            Use streams when writing/reading <tt class="literal">binary</tt>
                            or <tt class="literal">serializable</tt> types to/from JDBC
                            (system-level property).
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.use_get_generated_keys</tt></td><td>
                            Enable use of JDBC3 <tt class="literal">PreparedStatement.getGeneratedKeys()</tt>
                            to retrieve natively generated keys after insert. Requires JDBC3+ driver
                            and JRE1.4+, set to false if your driver has problems with the Hibernate
                            identifier generators. By default, tries to determine the driver capabilites
                            using connection metadata.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.connection.provider_class</tt></td><td>
                            The classname of a custom <tt class="literal">ConnectionProvider</tt> which provides
                            JDBC connections to Hibernate.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">classname.of.ConnectionProvider</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.connection.isolation</tt></td><td>
                        Set the JDBC transaction isolation level. Check
                        <tt class="literal">java.sql.Connection</tt> for meaningful values but
                        note that most databases do not support all isolation levels.
                        <p>
                            <span class="strong">eg.</span> 
                            <tt class="literal">1, 2, 4, 8</tt>
                        </p></td></tr><tr><td><tt class="literal">hibernate.connection.autocommit</tt></td><td>
                            Enables autocommit for JDBC pooled connections (not recommended).
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.connection.release_mode</tt></td><td>
                            Specify when Hibernate should release JDBC connections. By default, 
                            a JDBC connection is held until the session is explicitly closed or
                            disconnected. For an application server JTA datasource, you should use
                            <tt class="literal">after_statement</tt> to aggressively release connections
                            after every JDBC call. For a non-JTA connection, it often makes sense to
                            release the connection at the end of each transaction, by using
                            <tt class="literal">after_transaction</tt>. <tt class="literal">auto</tt> will
                            choose <tt class="literal">after_statement</tt> for the JTA and CMT transaction
                            strategies and <tt class="literal">after_transaction</tt> for the JDBC 
                            transaction strategy.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">on_close</tt> (default) | <tt class="literal">after_transaction</tt> |
                                <tt class="literal">after_statement</tt> | <tt class="literal">auto</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.connection.<span class="emphasis"><em>&lt;propertyName&gt;</em></span></tt></td><td>
                        Pass the JDBC property <tt class="literal">propertyName</tt>
                        to <tt class="literal">DriverManager.getConnection()</tt>.
                    </td></tr><tr><td><tt class="literal">hibernate.jndi.<span class="emphasis"><em>&lt;propertyName&gt;</em></span></tt></td><td>
                            Pass the property <tt class="literal">propertyName</tt> to
                            the JNDI <tt class="literal">InitialContextFactory</tt>.
                        </td></tr></tbody></table></div><div class="table"><a name="configuration-cache-properties"></a><p class="title"><b>Table&nbsp;3.5.&nbsp;Hibernate Cache Properties</b></p><table summary="Hibernate Cache Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.cache.provider_class</tt></td><td>
                            The classname of a custom <tt class="literal">CacheProvider</tt>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">classname.of.CacheProvider</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.use_minimal_puts</tt></td><td>
                            Optimize second-level cache operation to minimize writes, at the
                            cost of more frequent reads. This setting is most useful for 
                            clustered caches and, in Hibernate3, is enabled by default for
                            clustered cache implementations.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.use_query_cache</tt></td><td>
                            Enable the query cache, individual queries still have to be set cachable.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.use_second_level_cache</tt></td><td>
                            May be used to completely disable the second level cache, which is enabled
                            by default for classes which specify a <tt class="literal">&lt;cache&gt;</tt>
                            mapping.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.query_cache_factory</tt></td><td>
                            The classname of a custom <tt class="literal">QueryCache</tt> interface,
                            defaults to the built-in <tt class="literal">StandardQueryCache</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">classname.of.QueryCache</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.region_prefix</tt></td><td>
                            A prefix to use for second-level cache region names.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">prefix</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.use_structured_entries</tt></td><td>
                            Forces Hibernate to store data in the second-level cache
                            in a more human-friendly format.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true|false</tt>
                            </p></td></tr></tbody></table></div><div class="table"><a name="configuration-transaction-properties"></a><p class="title"><b>Table&nbsp;3.6.&nbsp;Hibernate Transaction Properties</b></p><table summary="Hibernate Transaction Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.transaction.factory_class</tt></td><td>
                            The classname of a <tt class="literal">TransactionFactory</tt>
                            to use with Hibernate <tt class="literal">Transaction</tt> API
                            (defaults to <tt class="literal">JDBCTransactionFactory</tt>).
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">classname.of.TransactionFactory</tt>
                            </p></td></tr><tr><td><tt class="literal">jta.UserTransaction</tt></td><td>
                            A JNDI name used by <tt class="literal">JTATransactionFactory</tt> to
                            obtain the JTA <tt class="literal">UserTransaction</tt> from the
                            application server.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">jndi/composite/name</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.transaction.manager_lookup_class</tt></td><td>
                            The classname of a <tt class="literal">TransactionManagerLookup</tt>
                            - required when JVM-level caching is enabled or when using hilo 
                            generator in a JTA environment.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">classname.of.TransactionManagerLookup</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.transaction.flush_before_completion</tt></td><td>
                            If enabled, the session will be automatically flushed during the
                            before completion phase of the transaction. Built-in and
                            automatic session context management is preferred, see
                            <a href="#architecture-current-session" title="2.5.&nbsp;Contextual Sessions">Section&nbsp;2.5, &#8220;Contextual Sessions&#8221;</a>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.transaction.auto_close_session</tt></td><td>
                            If enabled, the session will be automatically closed during the
                            after completion phase of the transaction. Built-in and
                            utomatic session context management is preferred, see
                            <a href="#architecture-current-session" title="2.5.&nbsp;Contextual Sessions">Section&nbsp;2.5, &#8220;Contextual Sessions&#8221;</a>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr></tbody></table></div><div class="table"><a name="configuration-misc-properties"></a><p class="title"><b>Table&nbsp;3.7.&nbsp;Miscellaneous Properties</b></p><table summary="Miscellaneous Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.current_session_context_class</tt></td><td>
                            Supply a (custom) strategy for the scoping of the "current"
                            <tt class="literal">Session</tt>. See
                            <a href="#architecture-current-session" title="2.5.&nbsp;Contextual Sessions">Section&nbsp;2.5, &#8220;Contextual Sessions&#8221;</a> for more
                            information about the built-in strategies.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">jta</tt> | <tt class="literal">thread</tt> |
                                <tt class="literal">custom.Class</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.query.factory_class</tt></td><td>
                            Chooses the HQL parser implementation.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">org.hibernate.hql.ast.ASTQueryTranslatorFactory</tt> or
                                <tt class="literal">org.hibernate.hql.classic.ClassicQueryTranslatorFactory</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.query.substitutions</tt></td><td>
                            Mapping from tokens in Hibernate queries to SQL tokens
                            (tokens might be function or literal names, for example).
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.hbm2ddl.auto</tt></td><td>
                            Automatically validate or export schema DDL to the database 
                            when the <tt class="literal">SessionFactory</tt> is created. With
                            <tt class="literal">create-drop</tt>, the database schema will be 
                            dropped when the <tt class="literal">SessionFactory</tt> is closed 
                            explicitly.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">validate</tt> | <tt class="literal">update</tt> | 
                                <tt class="literal">create</tt> | <tt class="literal">create-drop</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cglib.use_reflection_optimizer</tt></td><td>
                            Enables use of CGLIB instead of runtime reflection (System-level
                            property). Reflection can sometimes be useful when troubleshooting,
                            note that Hibernate always requires CGLIB even if you turn off the
                            optimizer. You can not set this property in <tt class="literal">hibernate.cfg.xml</tt>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr></tbody></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-dialects"></a>3.4.1.&nbsp;SQL Dialects</h3></div></div><div></div></div><p>
                You should always set the <tt class="literal">hibernate.dialect</tt> property to the correct
                <tt class="literal">org.hibernate.dialect.Dialect</tt> subclass for your database. If you
                specify a dialect, Hibernate will use sensible defaults for some of the
                other properties listed above, saving you the effort of specifying them manually.
            </p><div class="table"><a name="sql-dialects"></a><p class="title"><b>Table&nbsp;3.8.&nbsp;Hibernate SQL Dialects (<tt class="literal">hibernate.dialect</tt>)</b></p><table summary="Hibernate SQL Dialects (hibernate.dialect)" border="1"><colgroup><col><col></colgroup><thead><tr><th>RDBMS</th><th>Dialect</th></tr></thead><tbody><tr><td>DB2</td><td><tt class="literal">org.hibernate.dialect.DB2Dialect</tt></td></tr><tr><td>DB2 AS/400</td><td><tt class="literal">org.hibernate.dialect.DB2400Dialect</tt></td></tr><tr><td>DB2 OS390</td><td><tt class="literal">org.hibernate.dialect.DB2390Dialect</tt></td></tr><tr><td>PostgreSQL</td><td><tt class="literal">org.hibernate.dialect.PostgreSQLDialect</tt></td></tr><tr><td>MySQL</td><td><tt class="literal">org.hibernate.dialect.MySQLDialect</tt></td></tr><tr><td>MySQL with InnoDB</td><td><tt class="literal">org.hibernate.dialect.MySQLInnoDBDialect</tt></td></tr><tr><td>MySQL with MyISAM</td><td><tt class="literal">org.hibernate.dialect.MySQLMyISAMDialect</tt></td></tr><tr><td>Oracle (any version)</td><td><tt class="literal">org.hibernate.dialect.OracleDialect</tt></td></tr><tr><td>Oracle 9i/10g</td><td><tt class="literal">org.hibernate.dialect.Oracle9Dialect</tt></td></tr><tr><td>Sybase</td><td><tt class="literal">org.hibernate.dialect.SybaseDialect</tt></td></tr><tr><td>Sybase Anywhere</td><td><tt class="literal">org.hibernate.dialect.SybaseAnywhereDialect</tt></td></tr><tr><td>Microsoft SQL Server</td><td><tt class="literal">org.hibernate.dialect.SQLServerDialect</tt></td></tr><tr><td>SAP DB</td><td><tt class="literal">org.hibernate.dialect.SAPDBDialect</tt></td></tr><tr><td>Informix</td><td><tt class="literal">org.hibernate.dialect.InformixDialect</tt></td></tr><tr><td>HypersonicSQL</td><td><tt class="literal">org.hibernate.dialect.HSQLDialect</tt></td></tr><tr><td>Ingres</td><td><tt class="literal">org.hibernate.dialect.IngresDialect</tt></td></tr><tr><td>Progress</td><td><tt class="literal">org.hibernate.dialect.ProgressDialect</tt></td></tr><tr><td>Mckoi SQL</td><td><tt class="literal">org.hibernate.dialect.MckoiDialect</tt></td></tr><tr><td>Interbase</td><td><tt class="literal">org.hibernate.dialect.InterbaseDialect</tt></td></tr><tr><td>Pointbase</td><td><tt class="literal">org.hibernate.dialect.PointbaseDialect</tt></td></tr><tr><td>FrontBase</td><td><tt class="literal">org.hibernate.dialect.FrontbaseDialect</tt></td></tr><tr><td>Firebird</td><td><tt class="literal">org.hibernate.dialect.FirebirdDialect</tt></td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-outerjoin"></a>3.4.2.&nbsp;Outer Join Fetching</h3></div></div><div></div></div><p>
                If your database supports ANSI, Oracle or Sybase style outer joins, <span class="emphasis"><em>outer join
                fetching</em></span> will often increase performance by limiting the number of round
                trips to and from the database (at the cost of possibly more work performed by
                the database itself). Outer join fetching allows a whole graph of objects connected
                by many-to-one, one-to-many, many-to-many and one-to-one associations to be retrieved 
                in a single SQL <tt class="literal">SELECT</tt>.
            </p><p>
                Outer join fetching may be disabled <span class="emphasis"><em>globally</em></span> by setting
                the property <tt class="literal">hibernate.max_fetch_depth</tt> to <tt class="literal">0</tt>.
                A setting of <tt class="literal">1</tt> or higher enables outer join fetching for
                one-to-one and many-to-one associations which have been mapped with 
                <tt class="literal">fetch="join"</tt>.
            </p><p>
                See <a href="#performance-fetching" title="19.1.&nbsp;Fetching strategies">Section&nbsp;19.1, &#8220;Fetching strategies&#8221;</a> for more information.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-binarystreams"></a>3.4.3.&nbsp;Binary Streams</h3></div></div><div></div></div><p>
                Oracle limits the size of <tt class="literal">byte</tt> arrays that may
                be passed to/from its JDBC driver. If you wish to use large instances of
                <tt class="literal">binary</tt> or <tt class="literal">serializable</tt> type, you should
                enable <tt class="literal">hibernate.jdbc.use_streams_for_binary</tt>.
                <span class="emphasis"><em>This is a system-level setting only.</em></span>
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-cacheprovider"></a>3.4.4.&nbsp;Second-level and query cache</h3></div></div><div></div></div><p>
                The properties prefixed by <tt class="literal">hibernate.cache</tt>
                allow you to use a process or cluster scoped second-level cache system
                with Hibernate. See the <a href="#performance-cache" title="19.2.&nbsp;The Second Level Cache">Section&nbsp;19.2, &#8220;The Second Level Cache&#8221;</a> for
                more details.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-querysubstitution"></a>3.4.5.&nbsp;Query Language Substitution</h3></div></div><div></div></div><p>
                You may define new Hibernate query tokens using <tt class="literal">hibernate.query.substitutions</tt>.
                For example:
            </p><pre class="programlisting">hibernate.query.substitutions true=1, false=0</pre><p>
                would cause the tokens <tt class="literal">true</tt> and <tt class="literal">false</tt> to be translated to
                integer literals in the generated SQL.
            </p><pre class="programlisting">hibernate.query.substitutions toLowercase=LOWER</pre><p>
                would allow you to rename the SQL <tt class="literal">LOWER</tt> function.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-statistics"></a>3.4.6.&nbsp;Hibernate statistics</h3></div></div><div></div></div><p>
                If you enable <tt class="literal">hibernate.generate_statistics</tt>, Hibernate will 
                expose a number of metrics that are useful when tuning a running system via
                <tt class="literal">SessionFactory.getStatistics()</tt>. Hibernate can even be configured
                to expose these statistics via JMX. Read the Javadoc of the interfaces in
                <tt class="literal">org.hibernate.stats</tt> for more information.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-logging"></a>3.5.&nbsp;Logging</h2></div></div><div></div></div><p>
            Hibernate logs various events using Apache commons-logging.
        </p><p>
            The commons-logging service will direct output to either Apache Log4j
            (if you include <tt class="literal">log4j.jar</tt> in your classpath) or
            JDK1.4 logging (if running under JDK1.4 or above). You may download
            Log4j from <tt class="literal">http://jakarta.apache.org</tt>.
            To use Log4j you will need to place a <tt class="literal">log4j.properties</tt>
            file in your classpath, an example properties file is distributed with
            Hibernate in the <tt class="literal">src/</tt> directory.
        </p><p>
            We strongly recommend that you familiarize yourself with Hibernate's log
            messages. A lot of work has been put into making the Hibernate log as
            detailed as possible, without making it unreadable. It is an essential
            troubleshooting device. The most interesting log categories are the
            following:
        </p><div class="table"><a name="log-categories"></a><p class="title"><b>Table&nbsp;3.9.&nbsp;Hibernate Log Categories</b></p><table summary="Hibernate Log Categories" border="1"><colgroup><col><col></colgroup><thead><tr><th>Category</th><th>Function</th></tr></thead><tbody><tr><td><tt class="literal">org.hibernate.SQL</tt></td><td>Log all SQL DML statements as they are executed</td></tr><tr><td><tt class="literal">org.hibernate.type</tt></td><td>Log all JDBC parameters</td></tr><tr><td><tt class="literal">org.hibernate.tool.hbm2ddl</tt></td><td>Log all SQL DDL statements as they are executed</td></tr><tr><td><tt class="literal">org.hibernate.pretty</tt></td><td>
                                Log the state of all entities (max 20 entities) associated
                                with the session at flush time
                            </td></tr><tr><td><tt class="literal">org.hibernate.cache</tt></td><td>Log all second-level cache activity</td></tr><tr><td><tt class="literal">org.hibernate.transaction</tt></td><td>Log transaction related activity</td></tr><tr><td><tt class="literal">org.hibernate.jdbc</tt></td><td>Log all JDBC resource acquisition</td></tr><tr><td><tt class="literal">org.hibernate.hql.ast.AST</tt></td><td>
                                Log HQL and SQL ASTs during query parsing
                            </td></tr><tr><td><tt class="literal">org.hibernate.secure</tt></td><td>Log all JAAS authorization requests</td></tr><tr><td><tt class="literal">org.hibernate</tt></td><td>
                                Log everything (a lot of information, but very useful for
                                troubleshooting)
                            </td></tr></tbody></table></div><p>
            When developing applications with Hibernate, you should almost always work with
            <tt class="literal">debug</tt> enabled for the category <tt class="literal">org.hibernate.SQL</tt>,
            or, alternatively, the property <tt class="literal">hibernate.show_sql</tt> enabled.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-namingstrategy"></a>3.6.&nbsp;Implementing a <tt class="literal">NamingStrategy</tt></h2></div></div><div></div></div><p>
            The interface <tt class="literal">org.hibernate.cfg.NamingStrategy</tt> allows you
            to specify a "naming standard" for database objects and schema elements.
        </p><p>
            You may provide rules for automatically generating database identifiers from
            Java identifiers or for processing "logical" column and table names given in
            the mapping file into  "physical" table and column names. This feature helps
            reduce the verbosity of the mapping document, eliminating repetitive noise
            (<tt class="literal">TBL_</tt> prefixes, for example). The default strategy used by
            Hibernate is quite minimal.
        </p><p>
            You may specify a different strategy by calling
            <tt class="literal">Configuration.setNamingStrategy()</tt> before adding mappings:
        </p><pre class="programlisting">SessionFactory sf = new Configuration()
    .setNamingStrategy(ImprovedNamingStrategy.INSTANCE)
    .addFile("Item.hbm.xml")
    .addFile("Bid.hbm.xml")
    .buildSessionFactory();</pre><p>
            <tt class="literal">org.hibernate.cfg.ImprovedNamingStrategy</tt> is a built-in
            strategy that might be a useful starting point for some applications.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-xmlconfig"></a>3.7.&nbsp;XML configuration file</h2></div></div><div></div></div><p>
            An alternative approach to configuration is to specify a full configuration in
            a file named <tt class="literal">hibernate.cfg.xml</tt>. This file can be used as a
            replacement for the <tt class="literal">hibernate.properties</tt> file or, if both
            are present, to override properties.
        </p><p>
            The XML configuration file is by default expected to be in the root o
            your <tt class="literal">CLASSPATH</tt>. Here is an example:
        </p><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
    "-//Hibernate/Hibernate Configuration DTD//EN"
    "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;

&lt;hibernate-configuration&gt;

    &lt;!-- a SessionFactory instance listed as /jndi/name --&gt;
    &lt;session-factory
        name="java:hibernate/SessionFactory"&gt;

        &lt;!-- properties --&gt;
        &lt;property name="connection.datasource"&gt;java:/comp/env/jdbc/MyDB&lt;/property&gt;
        &lt;property name="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;
        &lt;property name="show_sql"&gt;false&lt;/property&gt;
        &lt;property name="transaction.factory_class"&gt;
            org.hibernate.transaction.JTATransactionFactory
        &lt;/property&gt;
        &lt;property name="jta.UserTransaction"&gt;java:comp/UserTransaction&lt;/property&gt;

        &lt;!-- mapping files --&gt;
        &lt;mapping resource="org/hibernate/auction/Item.hbm.xml"/&gt;
        &lt;mapping resource="org/hibernate/auction/Bid.hbm.xml"/&gt;

        &lt;!-- cache settings --&gt;
        &lt;class-cache class="org.hibernate.auction.Item" usage="read-write"/&gt;
        &lt;class-cache class="org.hibernate.auction.Bid" usage="read-only"/&gt;
        &lt;collection-cache collection="org.hibernate.auction.Item.bids" usage="read-write"/&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre><p>
            As you can see, the advantage of this approach is the externalization of the
            mapping file names to configuration. The <tt class="literal">hibernate.cfg.xml</tt>
            is also more convenient once you have to tune the Hibernate cache. Note that is
            your choice to use either <tt class="literal">hibernate.properties</tt> or
            <tt class="literal">hibernate.cfg.xml</tt>, both are equivalent, except for the above
            mentioned benefits of using the XML syntax.
        </p><p>
           With the XML configuration, starting Hibernate is then as simple as
       </p><pre class="programlisting">SessionFactory sf = new Configuration().configure().buildSessionFactory();</pre><p>
           You can pick a different XML configuration file using
       </p><pre class="programlisting">SessionFactory sf = new Configuration()
    .configure("catdb.cfg.xml")
    .buildSessionFactory();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-j2ee"></a>3.8.&nbsp;J2EE Application Server integration</h2></div></div><div></div></div><p>
            Hibernate has the following integration points for J2EE infrastructure:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                <span class="emphasis"><em>Container-managed datasources</em></span>: Hibernate can use
                JDBC connections managed by the container and provided through JNDI. Usually,
                a JTA compatible <tt class="literal">TransactionManager</tt> and a
                <tt class="literal">ResourceManager</tt> take care of transaction management (CMT),
                esp. distributed transaction handling across several datasources. You may
                of course also demarcate transaction boundaries programatically (BMT) or
                you might want to use the optional Hibernate <tt class="literal">Transaction</tt>
                API for this to keep your code portable.
                </p></li></ul></div><div class="itemizedlist"><ul type="disc"><li><p>
                <span class="emphasis"><em>Automatic JNDI binding</em></span>: Hibernate can bind its
                <tt class="literal">SessionFactory</tt> to JNDI after startup.
                </p></li></ul></div><div class="itemizedlist"><ul type="disc"><li><p>
                <span class="emphasis"><em>JTA Session binding:</em></span> The Hibernate <tt class="literal">Session</tt>
                may be automatically bound to the scope of JTA transactions. Simply
                lookup the <tt class="literal">SessionFactory</tt> from JNDI and get the current
                <tt class="literal">Session</tt>. Let Hibernate take care of flushing and closing the
                <tt class="literal">Session</tt> when your JTA transaction completes. Transaction
                demarcation is either declarative (CMT) or programmatic (BMT/UserTransaction).
                </p></li></ul></div><div class="itemizedlist"><ul type="disc"><li><p>
                <span class="emphasis"><em>JMX deployment:</em></span> If you have a JMX capable application server
                (e.g. JBoss AS), you can chose to deploy Hibernate as a managed MBean. This saves
                you the one line startup code to build your <tt class="literal">SessionFactory</tt> from
                a <tt class="literal">Configuration</tt>. The container will startup your
                <tt class="literal">HibernateService</tt>, and ideally also take care of service
                dependencies (Datasource has to be available before Hibernate starts, etc).
                </p></li></ul></div><p>
            Depending on your environment, you might have to set the configuration option
            <tt class="literal">hibernate.connection.aggressive_release</tt> to true if your
            application server shows "connection containment" exceptions.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-transactionstrategy"></a>3.8.1.&nbsp;Transaction strategy configuration</h3></div></div><div></div></div><p>
                The Hibernate <tt class="literal">Session</tt> API is independent of any transaction
                demarcation system in your architecture. If you let Hibernate use JDBC directly,
                through a connection pool, you may begin and end your transactions by calling
                the JDBC API. If you run in a J2EE application server, you might want to use bean-managed
                transactions and call the JTA API and <tt class="literal">UserTransaction</tt> when needed.
            </p><p>
                To keep your code portable between these two (and other) environments we recommend the optional
                Hibernate <tt class="literal">Transaction</tt> API, which wraps and hides the underlying system.
                You have to specify a factory class for <tt class="literal">Transaction</tt> instances by setting the
                Hibernate configuration property <tt class="literal">hibernate.transaction.factory_class</tt>.
            </p><p>
                There are three standard (built-in) choices:
            </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">org.hibernate.transaction.JDBCTransactionFactory</tt></span></dt><dd><p>delegates to database (JDBC) transactions (default)</p></dd><dt><span class="term"><tt class="literal">org.hibernate.transaction.JTATransactionFactory</tt></span></dt><dd><p>
                            delegates to container-managed transaction if an existing transaction is
                            underway in this context (e.g. EJB session bean method), otherwise
                            a new transaction is started and bean-managed transaction are used.
                        </p></dd><dt><span class="term"><tt class="literal">org.hibernate.transaction.CMTTransactionFactory</tt></span></dt><dd><p>delegates to container-managed JTA transactions</p></dd></dl></div><p>
                You may also define your own transaction strategies (for a CORBA transaction service,
                for example).
            </p><p>
                Some features in Hibernate (i.e. the second level cache, Contextual Sessions with JTA, etc.)
                require access to the JTA <tt class="literal">TransactionManager</tt> in a managed environment.
                In an application server you have to specify how Hibernate should obtain a reference to the
                <tt class="literal">TransactionManager</tt>, since J2EE does not standardize a single mechanism:
            </p><div class="table"><a name="jtamanagerlookup"></a><p class="title"><b>Table&nbsp;3.10.&nbsp;JTA TransactionManagers</b></p><table summary="JTA TransactionManagers" border="1"><colgroup><col><col></colgroup><thead><tr><th>Transaction Factory</th><th align="center">Application Server</th></tr></thead><tbody><tr><td><tt class="literal">org.hibernate.transaction.JBossTransactionManagerLookup</tt></td><td align="center">JBoss</td></tr><tr><td><tt class="literal">org.hibernate.transaction.WeblogicTransactionManagerLookup</tt></td><td align="center">Weblogic</td></tr><tr><td><tt class="literal">org.hibernate.transaction.WebSphereTransactionManagerLookup</tt></td><td align="center">WebSphere</td></tr><tr><td><tt class="literal">org.hibernate.transaction.WebSphereExtendedJTATransactionLookup</tt></td><td align="center">WebSphere 6</td></tr><tr><td><tt class="literal">org.hibernate.transaction.OrionTransactionManagerLookup</tt></td><td align="center">Orion</td></tr><tr><td><tt class="literal">org.hibernate.transaction.ResinTransactionManagerLookup</tt></td><td align="center">Resin</td></tr><tr><td><tt class="literal">org.hibernate.transaction.JOTMTransactionManagerLookup</tt></td><td align="center">JOTM</td></tr><tr><td><tt class="literal">org.hibernate.transaction.JOnASTransactionManagerLookup</tt></td><td align="center">JOnAS</td></tr><tr><td><tt class="literal">org.hibernate.transaction.JRun4TransactionManagerLookup</tt></td><td align="center">JRun4</td></tr><tr><td><tt class="literal">org.hibernate.transaction.BESTransactionManagerLookup</tt></td><td align="center">Borland ES</td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-jndi"></a>3.8.2.&nbsp;JNDI-bound <tt class="literal">SessionFactory</tt></h3></div></div><div></div></div><p>
                A JNDI bound Hibernate <tt class="literal">SessionFactory</tt> can simplify the lookup
                of the factory and the creation of new <tt class="literal">Session</tt>s. Note that this
                is not related to a JNDI bound <tt class="literal">Datasource</tt>, both simply use the
                same registry!
            </p><p>
                If you wish to have the <tt class="literal">SessionFactory</tt> bound to a JNDI namespace, specify
                a name (eg. <tt class="literal">java:hibernate/SessionFactory</tt>) using the property
                <tt class="literal">hibernate.session_factory_name</tt>. If this property is omitted, the
                <tt class="literal">SessionFactory</tt> will not be bound to JNDI. (This is especially useful in
                environments with a read-only JNDI default implementation, e.g. Tomcat.)
            </p><p>
                When binding the <tt class="literal">SessionFactory</tt> to JNDI, Hibernate will use the values of
                <tt class="literal">hibernate.jndi.url</tt>, <tt class="literal">hibernate.jndi.class</tt> to instantiate
                an initial context. If they are not specified, the default <tt class="literal">InitialContext</tt>
                will be used.
            </p><p>
                Hibernate will automatically place the <tt class="literal">SessionFactory</tt> in JNDI after
                you call <tt class="literal">cfg.buildSessionFactory()</tt>. This means you will at least have
                this call in some startup code (or utility class) in your application, unless you use
                JMX deployment with the <tt class="literal">HibernateService</tt> (discussed later).
            </p><p>
                If you use a JNDI <tt class="literal">SessionFactory</tt>, an EJB or any other class may
                obtain the  <tt class="literal">SessionFactory</tt> using a JNDI lookup.
            </p><p>
                We recommend that you bind the <tt class="literal">SessionFactory</tt> to JNDI in
                a managend environment and use a <tt class="literal">static</tt> singleton otherwise.
                To shield your application code from these details, we also recommend to hide the
                actual lookup code for a <tt class="literal">SessionFactory</tt> in a helper class,
                such as <tt class="literal">HibernateUtil.getSessionFactory()</tt>. Note that such a
                class is also a convenient way to startup Hibernate&#8212;see chapter 1.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-j2ee-currentsession"></a>3.8.3.&nbsp;Current Session context management with JTA</h3></div></div><div></div></div><p>
                The easiest way to handle <tt class="literal">Session</tt>s and transactions is
                Hibernates automatic "current" <tt class="literal">Session</tt> management.
                See the discussion of <a href="#architecture-current-session" title="2.5.&nbsp;Contextual Sessions">Section&nbsp;2.5, &#8220;Contextual Sessions&#8221;</a>.
                Using the <tt class="literal">"jta"</tt> session context, if there is no Hibernate
                <tt class="literal">Session</tt> associated with the current JTA transaction, one will
	            be started and associated with that JTA transaction the first time you call
	            <tt class="literal">sessionFactory.getCurrentSession()</tt>. The <tt class="literal">Session</tt>s
	            retrieved via <tt class="literal">getCurrentSession()</tt> in <tt class="literal">"jta"</tt> context
	            will be set to automatically flush before the transaction completes, close
	            after the transaction completes, and aggressively release JDBC connections
	            after each statement.  This allows the <tt class="literal">Session</tt>s to
	            be managed by the lifecycle of the JTA transaction to which it is associated,
	            keeping user code clean of such management concerns. Your code can either use
	            JTA programmatically through <tt class="literal">UserTransaction</tt>, or (recommended
	            for portable code) use the Hibernate <tt class="literal">Transaction</tt> API to set
	            transaction boundaries. If you run in an EJB container, declarative transaction
	            demarcation with CMT is preferred.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-j2ee-jmx"></a>3.8.4.&nbsp;JMX deployment</h3></div></div><div></div></div><p>
                The line <tt class="literal">cfg.buildSessionFactory()</tt> still has to be executed
                somewhere to get a <tt class="literal">SessionFactory</tt> into JNDI. You can do this
                either in a <tt class="literal">static</tt> initializer block (like the one in
                <tt class="literal">HibernateUtil</tt>) or you deploy Hibernate as a <span class="emphasis"><em>managed
                service</em></span>.
            </p><p>
                Hibernate is distributed with <tt class="literal">org.hibernate.jmx.HibernateService</tt>
                for deployment on an application server with JMX capabilities, such as JBoss AS.
                The actual deployment and configuration is vendor specific. Here is an example
                <tt class="literal">jboss-service.xml</tt> for JBoss 4.0.x:
            </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;server&gt;

&lt;mbean code="org.hibernate.jmx.HibernateService"
    name="jboss.jca:service=HibernateFactory,name=HibernateFactory"&gt;

    &lt;!-- Required services --&gt;
    &lt;depends&gt;jboss.jca:service=RARDeployer&lt;/depends&gt;
    &lt;depends&gt;jboss.jca:service=LocalTxCM,name=HsqlDS&lt;/depends&gt;

    &lt;!-- Bind the Hibernate service to JNDI --&gt;
    &lt;attribute name="JndiName"&gt;java:/hibernate/SessionFactory&lt;/attribute&gt;

    &lt;!-- Datasource settings --&gt;
    &lt;attribute name="Datasource"&gt;java:HsqlDS&lt;/attribute&gt;
    &lt;attribute name="Dialect"&gt;org.hibernate.dialect.HSQLDialect&lt;/attribute&gt;

    &lt;!-- Transaction integration --&gt;
    &lt;attribute name="TransactionStrategy"&gt;
        org.hibernate.transaction.JTATransactionFactory&lt;/attribute&gt;
    &lt;attribute name="TransactionManagerLookupStrategy"&gt;
        org.hibernate.transaction.JBossTransactionManagerLookup&lt;/attribute&gt;
    &lt;attribute name="FlushBeforeCompletionEnabled"&gt;true&lt;/attribute&gt;
    &lt;attribute name="AutoCloseSessionEnabled"&gt;true&lt;/attribute&gt;

    &lt;!-- Fetching options --&gt;
    &lt;attribute name="MaximumFetchDepth"&gt;5&lt;/attribute&gt;

    &lt;!-- Second-level caching --&gt;
    &lt;attribute name="SecondLevelCacheEnabled"&gt;true&lt;/attribute&gt;
    &lt;attribute name="CacheProviderClass"&gt;org.hibernate.cache.EhCacheProvider&lt;/attribute&gt;
    &lt;attribute name="QueryCacheEnabled"&gt;true&lt;/attribute&gt;

    &lt;!-- Logging --&gt;
    &lt;attribute name="ShowSqlEnabled"&gt;true&lt;/attribute&gt;

    &lt;!-- Mapping files --&gt;
    &lt;attribute name="MapResources"&gt;auction/Item.hbm.xml,auction/Category.hbm.xml&lt;/attribute&gt;

&lt;/mbean&gt;

&lt;/server&gt;</pre><p>
                This file is deployed in a directory called <tt class="literal">META-INF</tt> and packaged
                in a JAR file with the extension <tt class="literal">.sar</tt> (service archive). You also need
                to package Hibernate, its required third-party libraries, your compiled persistent classes,
                as well as your mapping files in the same archive. Your enterprise beans (usually session
                beans) may be kept in their own JAR file, but you may include this EJB JAR file in the
                main service archive to get a single (hot-)deployable unit. Consult the JBoss AS
                documentation for more information about JMX service and EJB deployment.
            </p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="persistent-classes"></a>Chapter&nbsp;4.&nbsp;Persistent Classes</h2></div></div><div></div></div><p>
        Persistent classes are classes in an application that implement the entities
        of the business problem (e.g. Customer and Order in an E-commerce application).
        Not all instances of a persistent class are considered to be in the persistent 
        state - an instance may instead be transient or detached.
    </p><p>
        Hibernate works best if these classes follow some simple rules, also known
        as the Plain Old Java Object (POJO) programming model. However, none of these
        rules are hard requirements. Indeed, Hibernate3 assumes very little about
        the nature of your persistent objects. You may express a domain model in other 
        ways: using trees of <tt class="literal">Map</tt> instances, for example.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-pojo"></a>4.1.&nbsp;A simple POJO example</h2></div></div><div></div></div><p>
            Most Java applications require a persistent class representing felines.
        </p><pre class="programlisting">package eg;
import java.util.Set;
import java.util.Date;

public class Cat {
    private Long id; // identifier

    private Date birthdate;
    private Color color;
    private char sex;
    private float weight;
    private int litterId;

    private Cat mother;
    private Set kittens = new HashSet();

    private void setId(Long id) {
        this.id=id;
    }
    public Long getId() {
        return id;
    }

    void setBirthdate(Date date) {
        birthdate = date;
    }
    public Date getBirthdate() {
        return birthdate;
    }

    void setWeight(float weight) {
        this.weight = weight;
    }
    public float getWeight() {
        return weight;
    }

    public Color getColor() {
        return color;
    }
    void setColor(Color color) {
        this.color = color;
    }

    void setSex(char sex) {
        this.sex=sex;
    }
    public char getSex() {
        return sex;
    }

    void setLitterId(int id) {
        this.litterId = id;
    }
    public int getLitterId() {
        return litterId;
    }

    void setMother(Cat mother) {
        this.mother = mother;
    }
    public Cat getMother() {
        return mother;
    }
    void setKittens(Set kittens) {
        this.kittens = kittens;
    }
    public Set getKittens() {
        return kittens;
    }
    
    // addKitten not needed by Hibernate
    public void addKitten(Cat kitten) {
    	kitten.setMother(this);
	kitten.setLitterId( kittens.size() ); 
        kittens.add(kitten);
    }
}</pre><p>
            There are four main rules to follow here:
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-pojo-constructor"></a>4.1.1.&nbsp;Implement a no-argument constructor</h3></div></div><div></div></div><p>
                <tt class="literal">Cat</tt> has a no-argument constructor. All persistent classes must 
                have a default constructor (which may be non-public) so that Hibernate can instantiate 
                them using <tt class="literal">Constructor.newInstance()</tt>. We strongly recommend having a 
                default constructor with at least <span class="emphasis"><em>package</em></span> visibility for runtime proxy 
                generation in Hibernate.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-pojo-identifier"></a>4.1.2.&nbsp;Provide an identifier property (optional)</h3></div></div><div></div></div><p>
                <tt class="literal">Cat</tt> has a property called <tt class="literal">id</tt>. This property 
                maps to the primary key column of a database table. The property might have been called
                anything, and its type might have been any primitive type, any primitive "wrapper" 
                type, <tt class="literal">java.lang.String</tt> or <tt class="literal">java.util.Date</tt>. (If 
                your legacy database table has composite keys, you can even use a user-defined class 
                with properties of these types - see the section on composite identifiers later.)
            </p><p>
                The identifier property is strictly optional. You can leave them off and let Hibernate 
                keep track of object identifiers internally. We do not recommend this, however.
            </p><p>
                In fact, some functionality is available only to classes which declare an
                identifier property:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        Transitive reattachment for detached objects (cascade update or cascade
                        merge) - see <a href="#objectstate-transitive" title="10.11.&nbsp;Transitive persistence">Section&nbsp;10.11, &#8220;Transitive persistence&#8221;</a>
                    </p></li><li><p>
                        <tt class="literal">Session.saveOrUpdate()</tt>
                    </p></li><li><p>
                        <tt class="literal">Session.merge()</tt>
                    </p></li></ul></div><p>
                We recommend you declare consistently-named identifier properties on persistent
                classes. We further recommend that you use a nullable (ie. non-primitive) type.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-pojo-final"></a>4.1.3.&nbsp;Prefer non-final classes (optional)</h3></div></div><div></div></div><p>
                A central feature of Hibernate, <span class="emphasis"><em>proxies</em></span>, depends upon the
                persistent class being either non-final, or the implementation of an interface
                that declares all public methods.
            </p><p>
                You can persist <tt class="literal">final</tt> classes that do not implement an interface
                with Hibernate, but you won't be able to use proxies for lazy association fetching -
                which will limit your options for performance tuning.
            </p><p>
                You should also avoid declaring <tt class="literal">public final</tt> methods on the 
                non-final classes. If you want to use a class with a <tt class="literal">public final</tt> 
                method, you must explicitly disable proying by setting <tt class="literal">lazy="false"</tt>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-pojo-accessors"></a>4.1.4.&nbsp;Declare accessors and mutators for persistent fields (optional)</h3></div></div><div></div></div><p>
                <tt class="literal">Cat</tt> declares accessor methods for all its persistent fields.
                Many other ORM tools directly persist instance variables. We believe it is 
                better to provide an indirection between the relational schema and internal
                data structures of the class. By default, Hibernate persists JavaBeans style 
                properties, and recognizes method names of the form <tt class="literal">getFoo</tt>, 
                <tt class="literal">isFoo</tt> and <tt class="literal">setFoo</tt>. You may switch to direct 
                field access for particular properties, if needed.
            </p><p>
                Properties need <span class="emphasis"><em>not</em></span> be declared public - Hibernate can
                persist a property with a default, <tt class="literal">protected</tt> or 
                <tt class="literal">private</tt> get / set pair.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-inheritance"></a>4.2.&nbsp;Implementing inheritance</h2></div></div><div></div></div><p>
            A subclass must also observe the first and second rules. It inherits its
            identifier property from the superclass, <tt class="literal">Cat</tt>.
        </p><pre class="programlisting">package eg;

public class DomesticCat extends Cat {
        private String name;

        public String getName() {
                return name;
        }
        protected void setName(String name) {
                this.name=name;
        }
}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-equalshashcode"></a>4.3.&nbsp;Implementing <tt class="literal">equals()</tt> and <tt class="literal">hashCode()</tt></h2></div></div><div></div></div><p>
            You have to override the <tt class="literal">equals()</tt> and <tt class="literal">hashCode()</tt>
            methods if you 
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    intend to put instances of persistent classes in a <tt class="literal">Set</tt>
                    (the recommended way to represent many-valued associations) 
                    <span class="emphasis"><em>and</em></span>
                </p></li><li><p>
                    intend to use reattachment of detached instances
                </p></li></ul></div><p>
            Hibernate guarantees equivalence of persistent identity (database row) and Java identity
            only inside a particular session scope. So as soon as we mix instances retrieved in
            different sessions, we must implement <tt class="literal">equals()</tt> and
            <tt class="literal">hashCode()</tt> if we wish to have meaningful semantics for
            <tt class="literal">Set</tt>s.
        </p><p>
            The most obvious way is to implement <tt class="literal">equals()</tt>/<tt class="literal">hashCode()</tt>
            by comparing the identifier value of both objects. If the value is the same, both must
            be the same database row, they are therefore equal (if both are added to a <tt class="literal">Set</tt>,
            we will only have one element in the <tt class="literal">Set</tt>). Unfortunately, we can't use that
            approach with generated identifiers! Hibernate will only assign identifier values to objects 
            that are persistent, a newly created instance will not have any identifier value! Furthermore,
            if an instance is unsaved and currently in a <tt class="literal">Set</tt>, saving it will assign
            an identifier value to the object. If <tt class="literal">equals()</tt> and <tt class="literal">hashCode()</tt>
            are based on the identifier value, the hash code would change, breaking the contract of the
            <tt class="literal">Set</tt>. See the Hibernate website for a full discussion of this problem. Note
            that this is not a Hibernate issue, but normal Java semantics of object identity and equality.
        </p><p>
            We recommend  implementing <tt class="literal">equals()</tt> and <tt class="literal">hashCode()</tt>
            using <span class="emphasis"><em>Business key equality</em></span>. Business key equality means that the
            <tt class="literal">equals()</tt> method compares only the properties that form the business
            key, a key that would identify our instance in the real world (a
            <span class="emphasis"><em>natural</em></span> candidate key):
        </p><pre class="programlisting">public class Cat {

    ...
    public boolean equals(Object other) {
        if (this == other) return true;
        if ( !(other instanceof Cat) ) return false;

        final Cat cat = (Cat) other;

        if ( !cat.getLitterId().equals( getLitterId() ) ) return false;
        if ( !cat.getMother().equals( getMother() ) ) return false;

        return true;
    }

    public int hashCode() {
        int result;
        result = getMother().hashCode();
        result = 29 * result + getLitterId();
        return result;
    }

}</pre><p>
            Note that a business key does not have to be as solid as a database
            primary key candidate (see <a href="#transactions-basics-identity" title="11.1.3.&nbsp;Considering object identity">Section&nbsp;11.1.3, &#8220;Considering object identity&#8221;</a>).
            Immutable or unique properties are usually good
            candidates for a business key.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-dynamicmodels"></a>4.4.&nbsp;Dynamic models</h2></div></div><div></div></div><p>
            <span class="emphasis"><em>Note that the following features are currently considered
            experimental and may change in the near future.</em></span>
        </p><p>
            Persistent entities don't necessarily have to be represented as POJO classes
            or as JavaBean objects at runtime. Hibernate also supports dynamic models
            (using <tt class="literal">Map</tt>s of <tt class="literal">Map</tt>s at runtime) and the
            representation of entities as DOM4J trees. With this approach, you don't
            write persistent classes, only mapping files.
        </p><p>
            By default, Hibernate works in normal POJO mode. You may set a default entity
            representation mode for a particular <tt class="literal">SessionFactory</tt> using the
            <tt class="literal">default_entity_mode</tt> configuration option (see
            <a href="#configuration-optional-properties" title="Table&nbsp;3.3.&nbsp;Hibernate Configuration Properties">Table&nbsp;3.3, &#8220;Hibernate Configuration Properties&#8221;</a>.
        </p><p>
            The following examples demonstrates the representation using <tt class="literal">Map</tt>s.
            First, in the mapping file, an <tt class="literal">entity-name</tt> has to be declared
            instead of (or in addition to) a class name:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class entity-name="Customer"&gt;

        &lt;id name="id"
            type="long"
            column="ID"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;

        &lt;property name="name"
            column="NAME"
            type="string"/&gt;

        &lt;property name="address"
            column="ADDRESS"
            type="string"/&gt;

        &lt;many-to-one name="organization"
            column="ORGANIZATION_ID"
            class="Organization"/&gt;

        &lt;bag name="orders"
            inverse="true"
            lazy="false"
            cascade="all"&gt;
            &lt;key column="CUSTOMER_ID"/&gt;
            &lt;one-to-many class="Order"/&gt;
        &lt;/bag&gt;

    &lt;/class&gt;
    
&lt;/hibernate-mapping&gt;</pre><p>

            Note that even though associations are declared using target class names,
            the target type of an associations may also be a dynamic entity instead
            of a POJO.
        </p><p>
            After setting the default entity mode to <tt class="literal">dynamic-map</tt>
            for the <tt class="literal">SessionFactory</tt>, we can at runtime work with
            <tt class="literal">Map</tt>s of <tt class="literal">Map</tt>s:
        </p><pre class="programlisting">Session s = openSession();
Transaction tx = s.beginTransaction();
Session s = openSession();

// Create a customer
Map david = new HashMap();
david.put("name", "David");

// Create an organization
Map foobar = new HashMap();
foobar.put("name", "Foobar Inc.");

// Link both
david.put("organization", foobar);

// Save both
s.save("Customer", david);
s.save("Organization", foobar);

tx.commit();
s.close();</pre><p>
            The advantages of a dynamic mapping are quick turnaround time for prototyping
            without the need for entity class implementation. However, you lose compile-time
            type checking and will very likely deal with many exceptions at runtime. Thanks
            to the Hibernate mapping, the database schema can easily be normalized and sound,
            allowing to add a proper domain model implementation on top later on.
        </p><p>
            Entity representation modes can also be set on a per <tt class="literal">Session</tt>
            basis:
        </p><pre class="programlisting">Session dynamicSession = pojoSession.getSession(EntityMode.MAP);

// Create a customer
Map david = new HashMap();
david.put("name", "David");
dynamicSession.save("Customer", david);
...
dynamicSession.flush();
dynamicSession.close()
...
// Continue on pojoSession
</pre><p>
            Please note that the call to <tt class="literal">getSession()</tt> using an
            <tt class="literal">EntityMode</tt> is on the <tt class="literal">Session</tt> API, not the
            <tt class="literal">SessionFactory</tt>. That way, the new <tt class="literal">Session</tt>
            shares the underlying JDBC connection, transaction, and other context
            information. This means you don't have tocall <tt class="literal">flush()</tt>
            and <tt class="literal">close()</tt> on the secondary <tt class="literal">Session</tt>, and
            also leave the transaction and connection handling to the primary unit of work.
        </p><p>
            More information about the XML representation capabilities can be found
            in <a href="#xml" title="Chapter&nbsp;18.&nbsp;XML Mapping">Chapter&nbsp;18, <i>XML Mapping</i></a>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-tuplizers"></a>4.5.&nbsp;Tuplizers</h2></div></div><div></div></div><p>
            <tt class="literal">org.hibernate.tuple.Tuplizer</tt>, and its sub-interfaces, are responsible
            for managing a particular representation of a piece of data, given that representation's
            <tt class="literal">org.hibernate.EntityMode</tt>.  If a given piece of data is thought of as
            a data structure, then a tuplizer is the thing which knows how to create such a data structure
            and how to extract values from and inject values into such a data structure.  For example,
            for the POJO entity mode, the correpsonding tuplizer knows how create the POJO through its
            constructor and how to access the POJO properties using the defined property accessors.
            There are two high-level types of Tuplizers, represented by the
            <tt class="literal">org.hibernate.tuple.EntityTuplizer</tt> and <tt class="literal">org.hibernate.tuple.ComponentTuplizer</tt>
            interfaces.  <tt class="literal">EntityTuplizer</tt>s are responsible for managing the above mentioned
            contracts in regards to entities, while <tt class="literal">ComponentTuplizer</tt>s do the same for
            components.
        </p><p>
            Users may also plug in their own tuplizers.  Perhaps you require that a <tt class="literal">java.util.Map</tt>
            implementation other than <tt class="literal">java.util.HashMap</tt> be used while in the
            dynamic-map entity-mode; or perhaps you need to define a different proxy generation strategy
            than the one used by default.  Both would be achieved by defining a custom tuplizer
            implementation.  Tuplizers definitions are attached to the entity or component mapping they
            are meant to manage.  Going back to the example of our customer entity:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    &lt;class entity-name="Customer"&gt;
        &lt;!--
            Override the dynamic-map entity-mode
            tuplizer for the customer entity
        --&gt;
        &lt;tuplizer entity-mode="dynamic-map"
                class="CustomMapTuplizerImpl"/&gt;

        &lt;id name="id" type="long" column="ID"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;

        &lt;!-- other properties --&gt;
        ...
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;


public class CustomMapTuplizerImpl
        extends org.hibernate.tuple.DynamicMapEntityTuplizer {
    // override the buildInstantiator() method to plug in our custom map...
    protected final Instantiator buildInstantiator(
            org.hibernate.mapping.PersistentClass mappingInfo) {
        return new CustomMapInstantiator( mappingInfo );
    }

    private static final class CustomMapInstantiator
            extends org.hibernate.tuple.DynamicMapInstantitor {
        // override the generateMap() method to return our custom map...
	    protected final Map generateMap() {
		    return new CustomMap();
	    }
    }
}</pre></div><p>
        TODO: Document user-extension framework in the property and proxy packages
    </p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="mapping"></a>Chapter&nbsp;5.&nbsp;Basic O/R Mapping</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-declaration"></a>5.1.&nbsp;Mapping declaration</h2></div></div><div></div></div><p>
            Object/relational mappings are usually defined in an XML document. The mapping
            document is designed to be readable and hand-editable. The mapping language is
            Java-centric, meaning that mappings are constructed around persistent class
            declarations, not table declarations.
        </p><p>
            Note that, even though many Hibernate users choose to write the XML by hand,
            a number of tools exist to generate the mapping document, including XDoclet,
            Middlegen and AndroMDA.
        </p><p>
            Lets kick off with an example mapping:
        </p><a name="mapping-declaration-ex1"></a><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
      "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
          "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

        &lt;class name="Cat" 
            table="cats"
            discriminator-value="C"&gt;
                
                &lt;id name="id"&gt;
                        &lt;generator class="native"/&gt;
                &lt;/id&gt;

                &lt;discriminator column="subclass" 
                     type="character"/&gt;

                &lt;property name="weight"/&gt;

                &lt;property name="birthdate"
                    type="date" 
                    not-null="true" 
                    update="false"/&gt;

                &lt;property name="color"
                    type="eg.types.ColorUserType"
                    not-null="true"
                    update="false"/&gt;

                &lt;property name="sex"
                    not-null="true" 
                    update="false"/&gt;

                &lt;property name="litterId"
                    column="litterId"
                    update="false"/&gt;

                &lt;many-to-one name="mother"
                    column="mother_id"
                    update="false"/&gt;

                &lt;set name="kittens"
                    inverse="true"
                    order-by="litter_id"&gt;
                        &lt;key column="mother_id"/&gt;
                        &lt;one-to-many class="Cat"/&gt;
                &lt;/set&gt;

                &lt;subclass name="DomesticCat"
                    discriminator-value="D"&gt;

                        &lt;property name="name" 
                            type="string"/&gt;

                &lt;/subclass&gt;

        &lt;/class&gt;

        &lt;class name="Dog"&gt;
                &lt;!-- mapping for Dog could go here --&gt;
        &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
             We will now discuss the content of the mapping document. We will only describe the 
             document elements and attributes that are used by Hibernate at runtime. The mapping 
             document also contains some extra optional attributes and elements that affect the 
             database schemas exported by the schema export tool. (For example the <tt class="literal">
             not-null</tt> attribute.)
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-doctype"></a>5.1.1.&nbsp;Doctype</h3></div></div><div></div></div><p>
                All XML mappings should declare the doctype shown. The actual DTD may be found 
                at the URL above, in the directory <tt class="literal">hibernate-x.x.x/src/org/hibernate
                </tt> or in <tt class="literal">hibernate3.jar</tt>. Hibernate will always look for
                the DTD in its classpath first. If you experience lookups of the DTD using an
                Internet connection, check your DTD declaration against the contents of your
                claspath.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-mapping"></a>5.1.2.&nbsp;hibernate-mapping</h3></div></div><div></div></div><p>
                This element has several optional attributes. The <tt class="literal">schema</tt> and 
                <tt class="literal">catalog</tt> attributes specify that tables referred to in this mapping 
                belong to the named schema and/or catalog. If specified, tablenames will be qualified 
                by the given schema and catalog names. If missing, tablenames will be unqualified. 
                The <tt class="literal">default-cascade</tt> attribute specifies what cascade style
                should be assumed for properties and collections which do not specify a 
                <tt class="literal">cascade</tt> attribute. The <tt class="literal">auto-import</tt> attribute lets us
                use unqualified class names in the query language, by default.
            </p><div class="programlistingco"><pre class="programlisting">&lt;hibernate-mapping
         schema="schemaName"                          <span class="co">(1)</span>
         catalog="catalogName"                        <span class="co">(2)</span>
         default-cascade="cascade_style"              <span class="co">(3)</span>
         default-access="field|property|ClassName"    <span class="co">(4)</span>
         default-lazy="true|false"                    <span class="co">(5)</span>
         auto-import="true|false"                     <span class="co">(6)</span>
         package="package.name"                       <span class="co">(7)</span>
 /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                             <tt class="literal">schema</tt> (optional): The name of a database schema.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                             <tt class="literal">catalog</tt> (optional): The name of a database catalog.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                             <tt class="literal">default-cascade</tt> (optional - defaults to <tt class="literal">none</tt>): 
                             A default cascade style.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                             <tt class="literal">default-access</tt> (optional - defaults to <tt class="literal">property</tt>):
                             The strategy Hibernate should use for accessing all properties. Can be a custom
                             implementation of <tt class="literal">PropertyAccessor</tt>.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                             <tt class="literal">default-lazy</tt> (optional - defaults to <tt class="literal">true</tt>):
                             The default value for unspecifed <tt class="literal">lazy</tt> attributes of class and
                             collection mappings.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                             <tt class="literal">auto-import</tt> (optional - defaults to <tt class="literal">true</tt>):
                             Specifies whether we can use unqualified class names (of classes in this mapping)
                             in the query language.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                             <tt class="literal">package</tt> (optional): Specifies a package prefix to assume for 
                             unqualified class names in the mapping document.
                         </p></td></tr></table></div></div><p>
                 If you have two persistent classes with the same (unqualified) name, you should set 
                 <tt class="literal">auto-import="false"</tt>. Hibernate will throw an exception if you attempt
                 to assign two classes to the same "imported" name.
             </p><p>
                 Note that the <tt class="literal">hibernate-mapping</tt> element allows you to nest
                 several persistent <tt class="literal">&lt;class&gt;</tt> mappings, as shown above.
                 It is however good practice (and expected by some tools) to map only a single
                 persistent class (or a single class hierarchy) in one mapping file and name
                 it after the persistent superclass, e.g. <tt class="literal">Cat.hbm.xml</tt>,
                 <tt class="literal">Dog.hbm.xml</tt>, or if using inheritance,
                 <tt class="literal">Animal.hbm.xml</tt>.
             </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-class"></a>5.1.3.&nbsp;class</h3></div></div><div></div></div><p>
                You may declare a persistent class using the <tt class="literal">class</tt> element:
            </p><div class="programlistingco"><pre class="programlisting">&lt;class
        name="ClassName"                              <span class="co">(1)</span>
        table="tableName"                             <span class="co">(2)</span>
        discriminator-value="discriminator_value"     <span class="co">(3)</span>
        mutable="true|false"                          <span class="co">(4)</span>
        schema="owner"                                <span class="co">(5)</span>
        catalog="catalog"                             <span class="co">(6)</span>
        proxy="ProxyInterface"                        <span class="co">(7)</span>
        dynamic-update="true|false"                   <span class="co">(8)</span>
        dynamic-insert="true|false"                   <span class="co">(9)</span>
        select-before-update="true|false"             <span class="co">(10)</span>
        polymorphism="implicit|explicit"              <span class="co">(11)</span>
        where="arbitrary sql where condition"         <span class="co">(12)</span>
        persister="PersisterClass"                    <span class="co">(13)</span>
        batch-size="N"                                <span class="co">(14)</span>
        optimistic-lock="none|version|dirty|all"      <span class="co">(15)</span>
        lazy="true|false"                             <span class="co">(16)</span>
        entity-name="EntityName"                      <span class="co">(17)</span>
        check="arbitrary sql check condition"         <span class="co">(18)</span>
        rowid="rowid"                                 <span class="co">(19)</span>
        subselect="SQL expression"                    <span class="co">(20)</span>
        abstract="true|false"                         <span class="co">(21)</span>
        node="element-name"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> (optional): The fully qualified Java class name of the 
                            persistent class (or interface). If this attribute is missing, it is assumed 
                            that the mapping is for a non-POJO entity.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">table</tt> (optional - defaults to the unqualified class name):  The
                            name of its database table.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">discriminator-value</tt> (optional - defaults to the class name): A value
                            that distiguishes individual subclasses, used for polymorphic behaviour. Acceptable
                            values include <tt class="literal">null</tt> and <tt class="literal">not null</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">mutable</tt> (optional, defaults to <tt class="literal">true</tt>): Specifies 
                            that instances of the class are (not) mutable.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">schema</tt> (optional): Override the schema name specified by
                            the root <tt class="literal">&lt;hibernate-mapping&gt;</tt> element.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">catalog</tt> (optional): Override the catalog name specified by
                            the root <tt class="literal">&lt;hibernate-mapping&gt;</tt> element.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">proxy</tt> (optional): Specifies an interface to use for lazy
                            initializing proxies. You may specify the name of the class itself.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">dynamic-update</tt> (optional, defaults to <tt class="literal">false</tt>): 
                            Specifies that <tt class="literal">UPDATE</tt> SQL should be generated at runtime and 
                            contain only those columns whose values have changed.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                            <tt class="literal">dynamic-insert</tt> (optional, defaults to <tt class="literal">false</tt>): 
                            Specifies that <tt class="literal">INSERT</tt> SQL should be generated at runtime and 
                            contain only the columns whose values are not null.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                            <tt class="literal">select-before-update</tt> (optional, defaults to <tt class="literal">false</tt>): 
                            Specifies that Hibernate should <span class="emphasis"><em>never</em></span> perform an SQL <tt class="literal">UPDATE</tt> 
                            unless it is certain that an object is actually modified. In certain cases (actually, only
                            when a transient object has been associated with a new session using <tt class="literal">update()</tt>),
                            this means that Hibernate will perform an extra SQL <tt class="literal">SELECT</tt> to determine
                            if an <tt class="literal">UPDATE</tt> is actually required.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(11)</td><td valign="top" align="left"><p>
                            <tt class="literal">polymorphism</tt> (optional, defaults to <tt class="literal">implicit</tt>): 
                            Determines whether implicit or explicit query polymorphism is used.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(12)</td><td valign="top" align="left"><p>
                            <tt class="literal">where</tt> (optional) specify an arbitrary SQL <tt class="literal">WHERE</tt> 
                            condition to be used when retrieving objects of this class
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(13)</td><td valign="top" align="left"><p>
                            <tt class="literal">persister</tt> (optional): Specifies a custom <tt class="literal">ClassPersister</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(14)</td><td valign="top" align="left"><p>
                            <tt class="literal">batch-size</tt> (optional, defaults to <tt class="literal">1</tt>) specify a "batch size" 
                            for fetching instances of this class by identifier.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(15)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (optional, defaults to <tt class="literal">version</tt>): 
                            Determines the optimistic locking strategy.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(16)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional): Lazy fetching may be completely disabled by setting 
                            <tt class="literal">lazy="false"</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(17)</td><td valign="top" align="left"><p>
                            <tt class="literal">entity-name</tt> (optional, defaults to the class name): Hibernate3 
                            allows a class to be mapped multiple times (to different tables, potentially), 
                            and allows entity mappings that are represented by Maps or XML at the Java level. 
                            In these cases, you should provide an explicit arbitrary name for the entity. See 
                            <a href="#persistent-classes-dynamicmodels" title="4.4.&nbsp;Dynamic models">Section&nbsp;4.4, &#8220;Dynamic models&#8221;</a> and <a href="#xml" title="Chapter&nbsp;18.&nbsp;XML Mapping">Chapter&nbsp;18, <i>XML Mapping</i></a>
                            for more information.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(18)</td><td valign="top" align="left"><p>
                            <tt class="literal">check</tt> (optional): A SQL expression used to generate a multi-row
                            <span class="emphasis"><em>check</em></span> constraint for automatic schema generation.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(19)</td><td valign="top" align="left"><p>
                            <tt class="literal">rowid</tt> (optional): Hibernate can use so called ROWIDs on databases
                            which support. E.g. on Oracle, Hibernate can use the <tt class="literal">rowid</tt> extra
                            column for fast updates if you set this option to <tt class="literal">rowid</tt>. A ROWID
                            is an implementation detail and represents the physical location of a stored tuple.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(20)</td><td valign="top" align="left"><p>
                            <tt class="literal">subselect</tt> (optional): Maps an immutable and read-only entity
                            to a database subselect. Useful if you want to have a view instead of a base table,
                            but don't. See below for more information.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(21)</td><td valign="top" align="left"><p>
                            <tt class="literal">abstract</tt> (optional): Used to mark abstract superclasses in
                            <tt class="literal">&lt;union-subclass&gt;</tt> hierarchies.
                        </p></td></tr></table></div></div><p>
                It is perfectly acceptable for the named persistent class to be an interface. You would then
                declare implementing classes of that interface using the <tt class="literal">&lt;subclass&gt;</tt>
                element. You may persist any <span class="emphasis"><em>static</em></span> inner class. You should specify the
                class name using the standard form ie. <tt class="literal">eg.Foo$Bar</tt>.
            </p><p>
                Immutable classes, <tt class="literal">mutable="false"</tt>, may not be updated or deleted by the 
                application. This allows Hibernate to make some minor performance optimizations.
            </p><p>
                The optional <tt class="literal">proxy</tt> attribute enables lazy initialization of persistent
                instances of the class. Hibernate will initially return CGLIB proxies which implement 
                the named interface. The actual persistent object will be loaded when a method of the 
                proxy is invoked. See "Proxies for Lazy Initialization" below.
            </p><p><span class="emphasis"><em>Implicit</em></span> polymorphism means that instances of the class will be returned
                by a query that names any superclass or implemented interface or the class and that instances
                of any subclass of the class will be returned by a query that names the class itself. 
                <span class="emphasis"><em>Explicit</em></span> polymorphism means that class instances will be returned only
                by queries that explicitly name that class and that queries that name the class will return
                only instances of subclasses mapped inside this <tt class="literal">&lt;class&gt;</tt> declaration
                as a <tt class="literal">&lt;subclass&gt;</tt> or <tt class="literal">&lt;joined-subclass&gt;</tt>. For
                most purposes the default, <tt class="literal">polymorphism="implicit"</tt>, is appropriate.
                Explicit polymorphism is useful when two different classes are mapped to the same table
                (this allows a "lightweight" class that contains a subset of the table columns).
            </p><p>
                The <tt class="literal">persister</tt> attribute lets you customize the persistence strategy used for
                the class. You may, for example, specify your own subclass of 
                <tt class="literal">org.hibernate.persister.EntityPersister</tt> or you might even provide a
                completely new implementation of the interface 
                <tt class="literal">org.hibernate.persister.ClassPersister</tt> that implements persistence via,
                for example, stored procedure calls, serialization to flat files or LDAP. See
                <tt class="literal">org.hibernate.test.CustomPersister</tt> for a simple example (of "persistence"
                to a <tt class="literal">Hashtable</tt>).
            </p><p>
                Note that the <tt class="literal">dynamic-update</tt> and <tt class="literal">dynamic-insert</tt>
                settings are not inherited by subclasses and so may also be specified on the
                <tt class="literal">&lt;subclass&gt;</tt> or <tt class="literal">&lt;joined-subclass&gt;</tt> elements. 
                These settings may increase performance in some cases, but might actually decrease 
                performance in others. Use judiciously.
            </p><p>
                Use of <tt class="literal">select-before-update</tt> will usually decrease performance. It is very
                useful to prevent a database update trigger being called unnecessarily if you reattach a
                graph of detached instances to a <tt class="literal">Session</tt>.
            </p><p>
                If you enable <tt class="literal">dynamic-update</tt>, you will have a choice of optimistic
                locking strategies:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        <tt class="literal">version</tt> check the version/timestamp columns
                    </p></li><li><p>
                        <tt class="literal">all</tt> check all columns
                    </p></li><li><p>
                        <tt class="literal">dirty</tt> check the changed columns, allowing some concurrent updates
                    </p></li><li><p>
                        <tt class="literal">none</tt> do not use optimistic locking
                    </p></li></ul></div><p>
                We <span class="emphasis"><em>very</em></span> strongly recommend that you use version/timestamp
                columns for optimistic locking with Hibernate. This is the optimal strategy with
                respect to performance and is the only strategy that correctly handles modifications
                made to detached instances (ie. when <tt class="literal">Session.merge()</tt> is used).
            </p><p>
                There is no difference between a view and a base table for a Hibernate mapping, as
                expected this is transparent at the database level (note that some DBMS don't support
                views properly, especially with updates). Sometimes you want to use a view, but can't
                create one in the database (ie. with a legacy schema). In this case, you can map an
                immutable and read-only entity to a given SQL subselect expression:
            </p><pre class="programlisting">&lt;class name="Summary"&gt;
    &lt;subselect&gt;
        select item.name, max(bid.amount), count(*)
        from item
        join bid on bid.item_id = item.id
        group by item.name
    &lt;/subselect&gt;
    &lt;synchronize table="item"/&gt;
    &lt;synchronize table="bid"/&gt;
    &lt;id name="name"/&gt;
    ...
&lt;/class&gt;</pre><p>
                Declare the tables to synchronize this entity with, ensuring that auto-flush happens
                correctly, and that queries against the derived entity do not return stale data.
                The <tt class="literal">&lt;subselect&gt;</tt> is available as both as an attribute and
                a nested mapping element.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-id"></a>5.1.4.&nbsp;id</h3></div></div><div></div></div><p>
                Mapped classes <span class="emphasis"><em>must</em></span> declare the primary key column of the database 
                table. Most classes will also have a JavaBeans-style property holding the unique identifier 
                of an instance. The <tt class="literal">&lt;id&gt;</tt> element defines the mapping from that
                property to the primary key column.
            </p><div class="programlistingco"><pre class="programlisting">&lt;id
        name="propertyName"                                          <span class="co">(1)</span>
        type="typename"                                              <span class="co">(2)</span>
        column="column_name"                                         <span class="co">(3)</span>
        unsaved-value="null|any|none|undefined|id_value"             <span class="co">(4)</span>
        access="field|property|ClassName"&gt;                           <span class="co">(5)</span>
        node="element-name|@attribute-name|element/@attribute|."

        &lt;generator class="generatorClass"/&gt;
&lt;/id&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> (optional): The name of the identifier property.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optional): A name that indicates the Hibernate type.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional - defaults to the property name): The
                            name of the primary key column.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">unsaved-value</tt> (optional - defaults to a "sensible" value): 
                            An identifier property value that indicates that an instance is newly instantiated
                            (unsaved), distinguishing it from detached instances that were saved or loaded
                            in a previous session.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy Hibernate should use for accessing the property value.
                        </p></td></tr></table></div></div><p>
                If the <tt class="literal">name</tt> attribute is missing, it is assumed that the class has no 
                identifier property.
            </p><p>
                The <tt class="literal">unsaved-value</tt> attribute is almost never needed in Hibernate3.
            </p><p>
                There is an alternative <tt class="literal">&lt;composite-id&gt;</tt> declaration to allow access to
                legacy data with composite keys. We strongly discourage its use for anything else.
            </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-generator"></a>5.1.4.1.&nbsp;Generator</h4></div></div><div></div></div><p>
                    The optional <tt class="literal">&lt;generator&gt;</tt> child element names a Java class used
                    to generate unique identifiers for instances of the persistent class. If any parameters
                    are required to configure or initialize the generator instance, they are passed using the
                    <tt class="literal">&lt;param&gt;</tt> element.
                </p><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="org.hibernate.id.TableHiLoGenerator"&gt;
                &lt;param name="table"&gt;uid_table&lt;/param&gt;
                &lt;param name="column"&gt;next_hi_value_column&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>
                    All generators implement the interface <tt class="literal">org.hibernate.id.IdentifierGenerator</tt>.
                    This is a very simple interface; some applications may choose to provide their own specialized
                    implementations. However, Hibernate provides a range of built-in implementations. There are shortcut
                    names for the built-in generators:

                    </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">increment</tt></span></dt><dd><p>
                                generates identifiers of type <tt class="literal">long</tt>, <tt class="literal">short</tt> or
                                <tt class="literal">int</tt> that are unique only when no other process is inserting data
                                into the same table.
                                <span class="emphasis"><em>Do not use in a cluster.</em></span>
                            </p></dd><dt><span class="term"><tt class="literal">identity</tt></span></dt><dd><p>
                                supports identity columns in DB2, MySQL, MS SQL Server, Sybase and
                                HypersonicSQL. The returned identifier is of type <tt class="literal">long</tt>,
                                <tt class="literal">short</tt> or <tt class="literal">int</tt>.
                            </p></dd><dt><span class="term"><tt class="literal">sequence</tt></span></dt><dd><p>
                                uses a sequence in DB2, PostgreSQL, Oracle, SAP DB, McKoi or a generator
                                in Interbase. The returned identifier is of type <tt class="literal">long</tt>,
                                <tt class="literal">short</tt> or <tt class="literal">int</tt>
                            </p></dd><dt><span class="term"><tt class="literal">hilo</tt></span></dt><dd><p><a name="mapping-declaration-id-hilodescription"></a>
                                uses a hi/lo algorithm to efficiently generate identifiers of
                                type <tt class="literal">long</tt>, <tt class="literal">short</tt> or <tt class="literal">int</tt>,
                                given a table and column (by default <tt class="literal">hibernate_unique_key</tt> and
                                <tt class="literal">next_hi</tt> respectively) as a source of hi values. The hi/lo 
                                algorithm generates identifiers that are unique only for a particular database.
                            </p></dd><dt><span class="term"><tt class="literal">seqhilo</tt></span></dt><dd><p>
                                uses a hi/lo algorithm to efficiently generate identifiers of type
                                <tt class="literal">long</tt>, <tt class="literal">short</tt> or <tt class="literal">int</tt>,
                                given a named database sequence.
                            </p></dd><dt><span class="term"><tt class="literal">uuid</tt></span></dt><dd><p>
                                uses a 128-bit UUID algorithm to generate identifiers of type string,
                                unique within a network (the IP address is used). The UUID is encoded
                                as a string of hexadecimal digits of length 32.
                            </p></dd><dt><span class="term"><tt class="literal">guid</tt></span></dt><dd><p>
                                uses a database-generated GUID string on MS SQL Server and MySQL.
                            </p></dd><dt><span class="term"><tt class="literal">native</tt></span></dt><dd><p>
                                picks <tt class="literal">identity</tt>, <tt class="literal">sequence</tt> or
                                <tt class="literal">hilo</tt> depending upon the capabilities of the
                                underlying database.
                            </p></dd><dt><span class="term"><tt class="literal">assigned</tt></span></dt><dd><p>
                                lets the application to assign an identifier to the object before
                                <tt class="literal">save()</tt> is called. This is the default strategy
                                if no <tt class="literal">&lt;generator&gt;</tt> element is specified.
                            </p></dd><dt><span class="term"><tt class="literal">select</tt></span></dt><dd><p>
                                retrieves a primary key assigned by a database trigger by selecting
                                the row by some unique key and retrieving the primary key value.
                            </p></dd><dt><span class="term"><tt class="literal">foreign</tt></span></dt><dd><p>
                                uses the identifier of another associated object. Usually used in conjunction
                                with a <tt class="literal">&lt;one-to-one&gt;</tt> primary key association.
                            </p></dd></dl></div><p>

                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-hilo"></a>5.1.4.2.&nbsp;Hi/lo algorithm</h4></div></div><div></div></div><p>
                    The <tt class="literal">hilo</tt> and <tt class="literal">seqhilo</tt> generators provide two alternate
                    implementations of the hi/lo algorithm, a favorite approach to identifier generation. The
                    first implementation requires a "special" database table to hold the next available "hi" value.
                    The second uses an Oracle-style sequence (where supported).
                </p><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="hilo"&gt;
                &lt;param name="table"&gt;hi_value&lt;/param&gt;
                &lt;param name="column"&gt;next_value&lt;/param&gt;
                &lt;param name="max_lo"&gt;100&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="seqhilo"&gt;
                &lt;param name="sequence"&gt;hi_value&lt;/param&gt;
                &lt;param name="max_lo"&gt;100&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>
                    Unfortunately, you can't use <tt class="literal">hilo</tt> when supplying your own
                    <tt class="literal">Connection</tt> to Hibernate. When Hibernate is using an application
                    server datasource to obtain connections enlisted with JTA, you must properly configure
                    the <tt class="literal">hibernate.transaction.manager_lookup_class</tt>.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-uuid"></a>5.1.4.3.&nbsp;UUID algorithm</h4></div></div><div></div></div><p>
                    The UUID contains: IP address, startup time of the JVM (accurate to a quarter
                    second), system time and a counter value (unique within the JVM). It's not
                    possible to obtain a MAC address or memory address from Java code, so this is
                    the best we can do without using JNI.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-sequences"></a>5.1.4.4.&nbsp;Identity columns and sequences</h4></div></div><div></div></div><p>
                    For databases which support identity columns (DB2, MySQL, Sybase, MS SQL), you
                    may use <tt class="literal">identity</tt> key generation. For databases that support
                    sequences (DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB) you may use
                    <tt class="literal">sequence</tt> style key generation. Both these strategies require
                    two SQL queries to insert a new object.
                </p><pre class="programlisting">&lt;id name="id" type="long" column="person_id"&gt;
        &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;person_id_sequence&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><pre class="programlisting">&lt;id name="id" type="long" column="person_id" unsaved-value="0"&gt;
        &lt;generator class="identity"/&gt;
&lt;/id&gt;</pre><p>
                    For cross-platform development, the <tt class="literal">native</tt> strategy will
                    choose from the <tt class="literal">identity</tt>, <tt class="literal">sequence</tt> and
                    <tt class="literal">hilo</tt> strategies, dependant upon the capabilities of the
                    underlying database.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-assigned"></a>5.1.4.5.&nbsp;Assigned identifiers</h4></div></div><div></div></div><p>
                    If you want the application to assign identifiers (as opposed to having
                    Hibernate generate them), you may use the <tt class="literal">assigned</tt> generator.
                    This special generator will use the identifier value already assigned to the
                    object's identifier property. This generator is used when the primary key
                    is a natural key instead of a surrogate key. This is the default behavior
                    if you do no specify a <tt class="literal">&lt;generator&gt;</tt> element.
                </p><p>
                    Choosing the <tt class="literal">assigned</tt> generator makes Hibernate use 
                    <tt class="literal">unsaved-value="undefined"</tt>, forcing Hibernate to go to
                    the database to determine if an instance is transient or detached, unless
                    there is a version or timestamp property, or you define 
                    <tt class="literal">Interceptor.isUnsaved()</tt>.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-select"></a>5.1.4.6.&nbsp;Primary keys assigned by triggers</h4></div></div><div></div></div><p>
                    For legacy schemas only (Hibernate does not generate DDL with triggers).
                </p><pre class="programlisting">&lt;id name="id" type="long" column="person_id"&gt;
        &lt;generator class="select"&gt;
                &lt;param name="key"&gt;socialSecurityNumber&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>
                    In the above example, there is a unique valued property named 
                    <tt class="literal">socialSecurityNumber</tt> defined by the class, as a
                    natural key, and a surrogate key named <tt class="literal">person_id</tt>
                    whose value is generated by a trigger.
                </p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-compositeid"></a>5.1.5.&nbsp;composite-id</h3></div></div><div></div></div><pre class="programlisting">&lt;composite-id
        name="propertyName"
        class="ClassName"
        mapped="true|false"
        access="field|property|ClassName"&gt;
        node="element-name|."

        &lt;key-property name="propertyName" type="typename" column="column_name"/&gt;
        &lt;key-many-to-one name="propertyName class="ClassName" column="column_name"/&gt;
        ......
&lt;/composite-id&gt;</pre><p>
                For a table with a composite key, you may map multiple properties of the class
                as identifier properties. The <tt class="literal">&lt;composite-id&gt;</tt> element
                accepts <tt class="literal">&lt;key-property&gt;</tt> property mappings and
                <tt class="literal">&lt;key-many-to-one&gt;</tt> mappings as child elements.
            </p><pre class="programlisting">&lt;composite-id&gt;
        &lt;key-property name="medicareNumber"/&gt;
        &lt;key-property name="dependent"/&gt;
&lt;/composite-id&gt;</pre><p>
                Your persistent class <span class="emphasis"><em>must</em></span> override <tt class="literal">equals()</tt>
                and <tt class="literal">hashCode()</tt> to implement composite identifier equality. It must
                also implements <tt class="literal">Serializable</tt>.
            </p><p>
                Unfortunately, this approach to composite identifiers means that a persistent object 
                is its own identifier. There is no convenient "handle" other than the object itself. 
                You must instantiate an instance of the persistent class itself and populate its 
                identifier properties before you can <tt class="literal">load()</tt> the persistent state
                associated with a composite key. We call this approach an <span class="emphasis"><em>embedded</em></span>
                composite identifier, and discourage it for serious applications.
            </p><p>
                A second approach is what we call a <span class="emphasis"><em>mapped</em></span> composite identifier,
                where the identifier properties named inside the <tt class="literal">&lt;composite-id&gt;</tt> 
                element are duplicated on both the persistent class and a separate identifier class.
            </p><pre class="programlisting">&lt;composite-id class="MedicareId" mapped="true"&gt;
        &lt;key-property name="medicareNumber"/&gt;
        &lt;key-property name="dependent"/&gt;
&lt;/composite-id&gt;</pre><p>
                In this example, both the composite identifier class, <tt class="literal">MedicareId</tt>,
                and the entity class itself have properties named <tt class="literal">medicareNumber</tt>
                and <tt class="literal">dependent</tt>. The identifier class must override 
                <tt class="literal">equals()</tt> and <tt class="literal">hashCode()</tt> and implement. 
                <tt class="literal">Serializable</tt>. The disadvantage of this approach is quite
                obvious&#8212;code duplication.
            </p><p>
                The following attributes are used to specify a mapped composite identifier:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">mapped</tt> (optional, defaults to <tt class="literal">false</tt>):
                        indicates that a mapped composite identifier is used, and that the contained
                        property mappings refer to both the entity class and the composite identifier
                        class.
                    </p></li><li><p>
                        <tt class="literal">class</tt> (optional, but required for a mapped composite identifier): 
                        The class used as a composite identifier.
                    </p></li></ul></div><p>
                We will describe a third, even more convenient approach where the composite identifier 
                is implemented as a component class in <a href="#components-compositeid" title="8.4.&nbsp;Components as composite identifiers">Section&nbsp;8.4, &#8220;Components as composite identifiers&#8221;</a>. The 
                attributes described below apply only to this alternative approach:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">name</tt> (optional, required for this approach): A property of 
                        component type that holds the composite identifier (see chapter 9).
                    </p></li><li><p>
                        <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): 
                        The strategy Hibernate should use for accessing the property value.
                    </p></li><li><p>
                        <tt class="literal">class</tt> (optional - defaults to the property type determined by 
                        reflection): The component class used as a composite identifier (see next section).
                    </p></li></ul></div><p>
                This third approach, an <span class="emphasis"><em>identifier component</em></span> is the one we recommend
                for almost all applications.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-discriminator"></a>5.1.6.&nbsp;discriminator</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;discriminator&gt;</tt> element is required for polymorphic persistence 
                using the table-per-class-hierarchy mapping strategy and declares a discriminator column of the 
                table. The discriminator column contains marker values that tell the persistence layer what 
                subclass to instantiate for a particular row. A restricted set of types may be used: 
                <tt class="literal">string</tt>, <tt class="literal">character</tt>, <tt class="literal">integer</tt>, 
                <tt class="literal">byte</tt>, <tt class="literal">short</tt>, <tt class="literal">boolean</tt>, 
                <tt class="literal">yes_no</tt>, <tt class="literal">true_false</tt>.
            </p><div class="programlistingco"><pre class="programlisting">&lt;discriminator
        column="discriminator_column"                      <span class="co">(1)</span>
        type="discriminator_type"                          <span class="co">(2)</span>
        force="true|false"                                 <span class="co">(3)</span>
        insert="true|false"                                <span class="co">(4)</span>
        formula="arbitrary sql expression"                 <span class="co">(5)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional - defaults to <tt class="literal">class</tt>) the
                            name of the discriminator column.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optional - defaults to <tt class="literal">string</tt>) a
                            name that indicates the Hibernate type
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">force</tt> (optional - defaults to <tt class="literal">false</tt>) 
                            "force" Hibernate to specify allowed discriminator values even when retrieving 
                            all instances of the root class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">insert</tt> (optional - defaults to <tt class="literal">true</tt>)
                            set this to <tt class="literal">false</tt> if your discriminator column is also part
                            of a mapped composite identifier. (Tells Hibernate to not include the column
                            in SQL <tt class="literal">INSERT</tt>s.)
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">formula</tt> (optional) an arbitrary SQL expression that is 
                            executed when a type has to be evaluated. Allows content-based discrimination.
                        </p></td></tr></table></div></div><p>
                Actual values of the discriminator column are specified by the
                <tt class="literal">discriminator-value</tt> attribute of the <tt class="literal">&lt;class&gt;</tt> and
                <tt class="literal">&lt;subclass&gt;</tt> elements.
            </p><p>
                The <tt class="literal">force</tt> attribute is (only) useful if the table contains rows with
                "extra" discriminator values that are not mapped to a persistent class. This will not
                usually be the case.
            </p><p>
                Using the <tt class="literal">formula</tt> attribute you can declare an arbitrary SQL expression
                that will be used to evaluate the type of a row:
            </p><pre class="programlisting">&lt;discriminator
    formula="case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end"
    type="integer"/&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-version"></a>5.1.7.&nbsp;version (optional)</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;version&gt;</tt> element is optional and indicates that
                the table contains versioned data. This is particularly useful if you plan to
                use <span class="emphasis"><em>long transactions</em></span> (see below).
            </p><div class="programlistingco"><pre class="programlisting">&lt;version
        column="version_column"                                      <span class="co">(1)</span>
        name="propertyName"                                          <span class="co">(2)</span>
        type="typename"                                              <span class="co">(3)</span>
        access="field|property|ClassName"                            <span class="co">(4)</span>
        unsaved-value="null|negative|undefined"                      <span class="co">(5)</span>
        generated="never|always"                                     <span class="co">(6)</span>
        insert="true|false"                                          <span class="co">(7)</span>
        node="element-name|@attribute-name|element/@attribute|."
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional - defaults to the property name): The name
                            of the column holding the version number.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The name of a property  of the persistent class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optional - defaults to <tt class="literal">integer</tt>): 
                            The type of the version number.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy Hibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">unsaved-value</tt> (optional - defaults to <tt class="literal">undefined</tt>): 
                            A version property value that indicates that an instance is newly instantiated
                            (unsaved), distinguishing it from detached instances that were saved or loaded
                            in a previous session. (<tt class="literal">undefined</tt> specifies that the identifier
                            property value should be used.)
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">generated</tt> (optional - defaults to <tt class="literal">never</tt>):
                            Specifies that this version property value is actually generated by the database.
                            See the discussion of <a href="#mapping-generated" title="5.6.&nbsp;Generated Properties">Section&nbsp;5.6, &#8220;Generated Properties&#8221;</a>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">insert</tt> (optional - defaults to <tt class="literal">true</tt>):
                            Specifies whether the version column should be included in SQL insert statements.
                            May be set to <tt class="literal">false</tt> if and only if the database column
                            is defined with a default value of <tt class="literal">0</tt>.
                        </p></td></tr></table></div></div><p>
                Version numbers may be of Hibernate type <tt class="literal">long</tt>, <tt class="literal">integer</tt>,
                <tt class="literal">short</tt>, <tt class="literal">timestamp</tt> or <tt class="literal">calendar</tt>.
            </p><p>
                A version or timestamp property should never be null for a detached instance, so
                Hibernate will detact any instance with a null version or timestamp as transient,
                no matter what other <tt class="literal">unsaved-value</tt> strategies are specified.
                <span class="emphasis"><em>Declaring a nullable version or timestamp property is an easy way to avoid 
                any problems with transitive reattachment in Hibernate, especially useful for people 
                using assigned identifiers or composite keys!</em></span>
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-timestamp"></a>5.1.8.&nbsp;timestamp (optional)</h3></div></div><div></div></div><p>
                The optional <tt class="literal">&lt;timestamp&gt;</tt> element indicates that the table contains 
                timestamped data. This is intended as an alternative to versioning. Timestamps are by nature
                a less safe implementation of optimistic locking. However, sometimes the application might
                use the timestamps in other ways.
            </p><div class="programlistingco"><pre class="programlisting">&lt;timestamp
        column="timestamp_column"                                    <span class="co">(1)</span>
        name="propertyName"                                          <span class="co">(2)</span>
        access="field|property|ClassName"                            <span class="co">(3)</span>
        unsaved-value="null|undefined"                               <span class="co">(4)</span>
        source="vm|db"                                               <span class="co">(5)</span>
        generated="never|always"                                     <span class="co">(6)</span>
        node="element-name|@attribute-name|element/@attribute|."
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional - defaults to the property name): The name
                            of a column holding the timestamp.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The name of a JavaBeans style property of
                            Java type <tt class="literal">Date</tt> or <tt class="literal">Timestamp</tt> of the
                            persistent class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy Hibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">unsaved-value</tt> (optional - defaults to <tt class="literal">null</tt>): 
                            A version property value that indicates that an instance is newly instantiated
                            (unsaved), distinguishing it from detached instances that were saved or loaded
                            in a previous session. (<tt class="literal">undefined</tt> specifies that the identifier
                            property value should be used.)
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">source</tt> (optional - defaults to <tt class="literal">vm</tt>):
                            From where should Hibernate retrieve the timestamp value?  From the database,
                            or from the current JVM?  Database-based timestamps incur an overhead because
                            Hibernate must hit the database in order to determine the "next value",
                            but will be safer for use in clustered environments.  Note also, that not
                            all <tt class="literal">Dialect</tt>s are known to support retrieving of the
                            database's current timestamp, while others might be unsafe for usage
                            in locking due to lack of precision (Oracle 8 for example).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">generated</tt> (optional - defaults to <tt class="literal">never</tt>):
                            Specifies that this timestamp property value is actually generated by the database.
                            See the discussion of <a href="#mapping-generated" title="5.6.&nbsp;Generated Properties">Section&nbsp;5.6, &#8220;Generated Properties&#8221;</a>.
                        </p></td></tr></table></div></div><p>
                Note that <tt class="literal">&lt;timestamp&gt;</tt> is equivalent to 
                <tt class="literal">&lt;version type="timestamp"&gt;</tt>.  And
                 <tt class="literal">&lt;timestamp use-db="true"&gt;</tt> is equivalent to
                <tt class="literal">&lt;version type="dbtimestamp"&gt;</tt>
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-property"></a>5.1.9.&nbsp;property</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;property&gt;</tt> element declares a persistent, JavaBean style 
                property of the class.
            </p><div class="programlistingco"><pre class="programlisting">&lt;property
        name="propertyName"                                          <span class="co">(1)</span>
        column="column_name"                                         <span class="co">(2)</span>
        type="typename"                                              <span class="co">(3)</span>
        update="true|false"                                          <span class="co">(4)</span>
        insert="true|false"                                          <span class="co">(4)</span>
        formula="arbitrary SQL expression"                           <span class="co">(5)</span>
        access="field|property|ClassName"                            <span class="co">(6)</span>
        lazy="true|false"                                            <span class="co">(7)</span>
        unique="true|false"                                          <span class="co">(8)</span>
        not-null="true|false"                                        <span class="co">(9)</span>
        optimistic-lock="true|false"                                 <span class="co">(10)</span>
        generated="never|insert|always"                              <span class="co">(11)</span>
        node="element-name|@attribute-name|element/@attribute|."
        index="index_name"
        unique_key="unique_key_id"
        length="L"
        precision="P"
        scale="S"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: the name of the property, with an initial lowercase
                            letter.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional - defaults to the property name): the name
                            of the mapped database table column. This may also be specified by nested 
                            <tt class="literal">&lt;column&gt;</tt> element(s).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optional): a name that indicates the Hibernate type.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">update, insert</tt> (optional - defaults to <tt class="literal">true</tt>) :
                            specifies that the mapped columns should be included in SQL <tt class="literal">UPDATE</tt> 
                            and/or <tt class="literal">INSERT</tt> statements. Setting both to <tt class="literal">false</tt>
                            allows a pure "derived" property whose value is initialized from some other
                            property that maps to the same colum(s) or by a trigger or other application.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">formula</tt> (optional): an SQL expression that defines the value for a
                            <span class="emphasis"><em>computed</em></span> property. Computed properties do not have a column
                            mapping of their own.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy Hibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional - defaults to <tt class="literal">false</tt>): Specifies
                            that this property should be fetched lazily when the instance variable is first 
                            accessed (requires build-time bytecode instrumentation).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">unique</tt> (optional): Enable the DDL generation of a unique
                            constraint for the columns. Also, allow this to be the target of 
                            a <tt class="literal">property-ref</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                            <tt class="literal">not-null</tt> (optional): Enable the DDL generation of a nullability
                            constraint for the columns.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (optional - defaults to <tt class="literal">true</tt>): 
                            Specifies that updates to this property do or do not require acquisition of the
                            optimistic lock. In other words, determines if a version increment should occur when 
                            this property is dirty.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(11)</td><td valign="top" align="left"><p>
                            <tt class="literal">generated</tt> (optional - defaults to <tt class="literal">never</tt>):
                            Specifies that this property value is actually generated by the database.
                            See the discussion of <a href="#mapping-generated" title="5.6.&nbsp;Generated Properties">Section&nbsp;5.6, &#8220;Generated Properties&#8221;</a>.
                        </p></td></tr></table></div></div><p>
                <span class="emphasis"><em>typename</em></span> could be:
            </p><div class="orderedlist"><ol type="1" compact><li><p>
                        The name of a Hibernate basic type (eg. <tt class="literal">integer, string, character,
                        date, timestamp, float, binary, serializable, object, blob</tt>).
                    </p></li><li><p>
                        The name of a Java class with a default basic type (eg. <tt class="literal">int, float,
                        char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</tt>).
                    </p></li><li><p>
                        The name of a serializable Java class.
                    </p></li><li><p>
                        The class name of a custom type (eg. <tt class="literal">com.illflow.type.MyCustomType</tt>).
                    </p></li></ol></div><p>
                If you do not specify a type, Hibernate will use reflection upon the named
                property to take a guess at the correct Hibernate type. Hibernate will try to
                interpret the name of the return class of the property getter using rules 2, 3,
                4 in that order. However, this is not always enough.
                In certain cases you will still need the <tt class="literal">type</tt>
                attribute. (For example, to distinguish between <tt class="literal">Hibernate.DATE</tt> and
                <tt class="literal">Hibernate.TIMESTAMP</tt>, or to specify a custom type.)
            </p><p>
                The <tt class="literal">access</tt> attribute lets you control how Hibernate will access
                the property at runtime. By default, Hibernate will call the property get/set pair.
                If you specify <tt class="literal">access="field"</tt>, Hibernate will bypass the get/set
                pair and access the field directly, using reflection. You may specify your own
                strategy for property access by naming a class that implements the interface
                <tt class="literal">org.hibernate.property.PropertyAccessor</tt>.
            </p><p>
                An especially powerful feature are derived properties. These properties are by
                definition read-only, the property value is computed at load time. You declare
                the computation as a SQL expression, this translates to a <tt class="literal">SELECT</tt>
                clause subquery in the SQL query that loads an instance:
            </p><pre class="programlisting">
&lt;property name="totalPrice"
    formula="( SELECT SUM (li.quantity*p.price) FROM LineItem li, Product p
                WHERE li.productId = p.productId
                AND li.customerId = customerId
                AND li.orderNumber = orderNumber )"/&gt;</pre><p>
                Note that you can reference the entities own table by not declaring an alias on
                a particular column (<tt class="literal">customerId</tt> in the given example). Also note
                that you can use the nested <tt class="literal">&lt;formula&gt;</tt> mapping element
                if you don't like to use the attribute.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-manytoone"></a>5.1.10.&nbsp;many-to-one</h3></div></div><div></div></div><p>
                An ordinary association to another persistent class is declared using a
                <tt class="literal">many-to-one</tt> element. The relational model is a
                many-to-one association: a foreign key in one table is referencing
                the primary key column(s) of the target table.
            </p><div class="programlistingco"><pre class="programlisting">&lt;many-to-one
        name="propertyName"                                          <span class="co">(1)</span>
        column="column_name"                                         <span class="co">(2)</span>
        class="ClassName"                                            <span class="co">(3)</span>
        cascade="cascade_style"                                      <span class="co">(4)</span>
        fetch="join|select"                                          <span class="co">(5)</span>
        update="true|false"                                          <span class="co">(6)</span>
        insert="true|false"                                          <span class="co">(6)</span>
        property-ref="propertyNameFromAssociatedClass"               <span class="co">(7)</span>
        access="field|property|ClassName"                            <span class="co">(8)</span>
        unique="true|false"                                          <span class="co">(9)</span>
        not-null="true|false"                                        <span class="co">(10)</span>
        optimistic-lock="true|false"                                 <span class="co">(11)</span>
        lazy="proxy|no-proxy|false"                                  <span class="co">(12)</span>
        not-found="ignore|exception"                                 <span class="co">(13)</span>
        entity-name="EntityName"                                     <span class="co">(14)</span>
        formula="arbitrary SQL expression"                           <span class="co">(15)</span>
        node="element-name|@attribute-name|element/@attribute|."
        embed-xml="true|false"
        index="index_name"
        unique_key="unique_key_id"
        foreign-key="foreign_key_name"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The name of the property.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional): The name of the foreign key column. 
                            This may also be specified by nested <tt class="literal">&lt;column&gt;</tt>
                            element(s).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (optional - defaults to the property type
                            determined by reflection): The name of the associated class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">cascade</tt> (optional): Specifies which operations should
                            be cascaded from the parent object to the associated object.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">fetch</tt> (optional - defaults to <tt class="literal">select</tt>): 
                            Chooses between outer-join fetching or sequential select fetching.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">update, insert</tt> (optional - defaults to <tt class="literal">true</tt>) 
                            specifies that the mapped columns should be included in SQL <tt class="literal">UPDATE</tt> 
                            and/or <tt class="literal">INSERT</tt> statements. Setting both to <tt class="literal">false</tt>
                            allows a pure "derived" association whose value is initialized from some other
                            property that maps to the same colum(s) or by a trigger or other application.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">property-ref</tt>: (optional) The name of a property of the associated 
                            class that is joined to this foreign key. If not specified, the primary key of
                            the associated class is used.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy Hibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                            <tt class="literal">unique</tt> (optional): Enable the DDL generation of a unique
                            constraint for the foreign-key column. Also, allow this to be the target of 
                            a <tt class="literal">property-ref</tt>. This makes the association multiplicity 
                            effectively one to one.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                            <tt class="literal">not-null</tt> (optional): Enable the DDL generation of a nullability
                            constraint for the foreign key columns.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(11)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (optional - defaults to <tt class="literal">true</tt>): 
                            Specifies that updates to this property do or do not require acquisition of the
                            optimistic lock. In other words, dertermines if a version increment should occur when 
                            this property is dirty.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(12)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional - defaults to <tt class="literal">proxy</tt>): 
                            By default, single point associations are proxied. <tt class="literal">lazy="no-proxy"</tt>
                            specifies that the property should be fetched lazily when the instance variable 
                            is first accessed (requires build-time bytecode instrumentation). 
                            <tt class="literal">lazy="false"</tt> specifies that the association will always
                            be eagerly fetched.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(13)</td><td valign="top" align="left"><p>
                            <tt class="literal">not-found</tt> (optional - defaults to <tt class="literal">exception</tt>): 
                            Specifies how foreign keys that reference missing rows will be handled: 
                            <tt class="literal">ignore</tt> will treat a missing row as a null association.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(14)</td><td valign="top" align="left"><p>
                            <tt class="literal">entity-name</tt> (optional): The entity name of the associated class.
                        </p></td></tr></table></div></div><p>
                Setting a value of the <tt class="literal">cascade</tt> attribute to any meaningful
                value other than <tt class="literal">none</tt> will propagate certain operations to the
                associated object. The meaningful values are the names of Hibernate's basic 
                operations, <tt class="literal">persist, merge, delete, save-update, evict, replicate, lock,
                refresh</tt>, as well as the special values <tt class="literal">delete-orphan</tt> 
                and <tt class="literal">all</tt> and comma-separated combinations of operation
                names, for example, <tt class="literal">cascade="persist,merge,evict"</tt> or
                <tt class="literal">cascade="all,delete-orphan"</tt>. See <a href="#objectstate-transitive" title="10.11.&nbsp;Transitive persistence">Section&nbsp;10.11, &#8220;Transitive persistence&#8221;</a>
                for a full explanation. Note that single valued associations (many-to-one and 
                one-to-one associations) do not support orphan delete.
            </p><p>
                A typical <tt class="literal">many-to-one</tt> declaration looks as simple as this:
            </p><pre class="programlisting">&lt;many-to-one name="product" class="Product" column="PRODUCT_ID"/&gt;</pre><p>
                The <tt class="literal">property-ref</tt> attribute should only be used for mapping legacy
                data where a foreign key refers to a unique key of the associated table other than
                the primary key. This is an ugly relational model. For example, suppose the 
                <tt class="literal">Product</tt> class had a unique serial number, that is not the primary 
                key. (The <tt class="literal">unique</tt> attribute controls Hibernate's DDL generation with
                the SchemaExport tool.)
            </p><pre class="programlisting">&lt;property name="serialNumber" unique="true" type="string" column="SERIAL_NUMBER"/&gt;</pre><p>
                Then the mapping for <tt class="literal">OrderItem</tt> might use:
            </p><pre class="programlisting">&lt;many-to-one name="product" property-ref="serialNumber" column="PRODUCT_SERIAL_NUMBER"/&gt;</pre><p>
                This is certainly not encouraged, however.
            </p><p>
                If the referenced unique key comprises multiple properties of the associated entity, you should
                map the referenced properties inside a named <tt class="literal">&lt;properties&gt;</tt> element.
            </p><p>
            	If the referenced unique key is the property of a component, you may specify a property path:
            </p><pre class="programlisting">&lt;many-to-one name="owner" property-ref="identity.ssn" column="OWNER_SSN"/&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-onetoone"></a>5.1.11.&nbsp;one-to-one</h3></div></div><div></div></div><p>
                A one-to-one association to another persistent class is declared using a 
                <tt class="literal">one-to-one</tt> element.
            </p><div class="programlistingco"><pre class="programlisting">&lt;one-to-one
        name="propertyName"                                          <span class="co">(1)</span>
        class="ClassName"                                            <span class="co">(2)</span>
        cascade="cascade_style"                                      <span class="co">(3)</span>
        constrained="true|false"                                     <span class="co">(4)</span>
        fetch="join|select"                                          <span class="co">(5)</span>
        property-ref="propertyNameFromAssociatedClass"               <span class="co">(6)</span>
        access="field|property|ClassName"                            <span class="co">(7)</span>
        formula="any SQL expression"                                 <span class="co">(8)</span>
        lazy="proxy|no-proxy|false"                                  <span class="co">(9)</span>
        entity-name="EntityName"                                     <span class="co">(10)</span>
        node="element-name|@attribute-name|element/@attribute|."
        embed-xml="true|false"
        foreign-key="foreign_key_name"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The name of the property.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (optional - defaults to the property type
                            determined by reflection): The name of the associated class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">cascade</tt> (optional) specifies which operations should
                            be cascaded from the parent object to the associated object.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">constrained</tt> (optional) specifies that a foreign key constraint
                            on the primary key of the mapped table references the table of the associated
                            class. This option affects the order in which <tt class="literal">save()</tt> and
                            <tt class="literal">delete()</tt> are cascaded, and determines whether the association
                            may be proxied (it is also used by the schema export tool).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">fetch</tt> (optional - defaults to <tt class="literal">select</tt>): 
                            Chooses between outer-join fetching or sequential select fetching.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">property-ref</tt>: (optional) The name of a property of the associated class
                            that is joined to the primary key of this class. If not specified, the primary key of
                            the associated class is used.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy Hibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">formula</tt> (optional): Almost all one to one associations map to the
                            primary key of the owning entity. In the rare case that this is not the case, you may
                            specify a some other column, columns or expression to join on using an SQL formula. (See 
                            <tt class="literal">org.hibernate.test.onetooneformula</tt> for an example.)
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional - defaults to <tt class="literal">proxy</tt>): 
                            By default, single point associations are proxied. <tt class="literal">lazy="no-proxy"</tt>
                            specifies that the property should be fetched lazily when the instance variable 
                            is first accessed (requires build-time bytecode instrumentation). 
                            <tt class="literal">lazy="false"</tt> specifies that the association will always
                            be eagerly fetched. <span class="emphasis"><em>Note that if <tt class="literal">constrained="false"</tt>,
                            proxying is impossible and Hibernate will eager fetch the association!</em></span>
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                            <tt class="literal">entity-name</tt> (optional): The entity name of the associated class.
                        </p></td></tr></table></div></div><p>
                There are two varieties of one-to-one association:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                primary key associations
            </p></li><li><p>
                unique foreign key associations
            </p></li></ul></div><p>
                Primary key associations don't need an extra table column; if two rows are related by
                the association then the two table rows share the same primary key value. So if you want 
                two objects to be related by a primary key association, you must make sure that they
                are assigned the same identifier value!
            </p><p>
                For a primary key association, add the following mappings to <tt class="literal">Employee</tt> and 
                <tt class="literal">Person</tt>, respectively.
            </p><pre class="programlisting">&lt;one-to-one name="person" class="Person"/&gt;</pre><pre class="programlisting">&lt;one-to-one name="employee" class="Employee" constrained="true"/&gt;</pre><p>
                Now we must ensure that the primary keys of related rows in the PERSON and
                EMPLOYEE tables are equal. We use a special Hibernate identifier generation strategy
                called <tt class="literal">foreign</tt>:
            </p><pre class="programlisting">&lt;class name="person" table="PERSON"&gt;
    &lt;id name="id" column="PERSON_ID"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"&gt;employee&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    ...
    &lt;one-to-one name="employee"
        class="Employee"
        constrained="true"/&gt;
&lt;/class&gt;</pre><p>
                A newly saved instance of <tt class="literal">Person</tt> is then assigned the same primary
                key value as the <tt class="literal">Employee</tt> instance refered with the <tt class="literal">employee</tt>
                property of that <tt class="literal">Person</tt>.
            </p><p>
                Alternatively, a foreign key with a unique constraint, from <tt class="literal">Employee</tt> to 
                <tt class="literal">Person</tt>, may be expressed as:
            </p><pre class="programlisting">&lt;many-to-one name="person" class="Person" column="PERSON_ID" unique="true"/&gt;</pre><p>
                And this association may be made bidirectional by adding the following to the 
                <tt class="literal">Person</tt> mapping:
            </p><pre class="programlisting">&lt;one-to-one name"employee" class="Employee" property-ref="person"/&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-naturalid"></a>5.1.12.&nbsp;natural-id</h3></div></div><div></div></div><pre class="programlisting">&lt;natural-id mutable="true|false"/&gt;
        &lt;property ... /&gt;
        &lt;many-to-one ... /&gt;
        ......
&lt;/natural-id&gt;</pre><p>
                Even though we recommend the use of surrogate keys as primary keys, you should still try
                to identify natural keys for all entities. A natural key is a property or combination of
                properties that is unique and non-null. If it is also immutable, even better. Map the
                properties of the natural key inside the <tt class="literal">&lt;natural-id&gt;</tt> element.
                Hibernate will generate the necessary unique key and nullability constraints, and your
                mapping will be more self-documenting.
            </p><p>
                We strongly recommend that you implement <tt class="literal">equals()</tt> and 
                <tt class="literal">hashCode()</tt> to compare the natural key properties of the entity.
            </p><p>
                This mapping is not intended for use with entities with natural primary keys.
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">mutable</tt> (optional, defaults to <tt class="literal">false</tt>): 
                        By default, natural identifier properties as assumed to be immutable (constant).
                    </p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-component"></a>5.1.13.&nbsp;component, dynamic-component</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;component&gt;</tt> element maps properties of a
                child object to columns of the table of a parent class. Components may, in
                turn, declare their own properties, components or collections. See
                "Components" below.
            </p><div class="programlistingco"><pre class="programlisting">&lt;component 
        name="propertyName"                 <span class="co">(1)</span>
        class="className"                   <span class="co">(2)</span>
        insert="true|false"                 <span class="co">(3)</span>
        update="true|false"                 <span class="co">(4)</span>
        access="field|property|ClassName"   <span class="co">(5)</span>
        lazy="true|false"                   <span class="co">(6)</span>
        optimistic-lock="true|false"        <span class="co">(7)</span>
        unique="true|false"                 <span class="co">(8)</span>
        node="element-name|."
&gt;
        
        &lt;property ...../&gt;
        &lt;many-to-one .... /&gt;
        ........
&lt;/component&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The name of the property.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (optional - defaults to the property type
                            determined by reflection): The name of the component (child) class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">insert</tt>: Do the mapped columns appear in SQL 
                            <tt class="literal">INSERT</tt>s?
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">update</tt>: Do the mapped columns appear in SQL 
                            <tt class="literal">UPDATE</tt>s?
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy Hibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional - defaults to <tt class="literal">false</tt>): Specifies
                            that this component should be fetched lazily when the instance variable is first 
                            accessed (requires build-time bytecode instrumentation).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                                <tt class="literal">optimistic-lock</tt> (optional - defaults to <tt class="literal">true</tt>):
                                Specifies that updates to this component do or do not require acquisition of the
                                optimistic lock. In other words, determines if a version increment should occur when 
                                this property is dirty.
                            </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                                <tt class="literal">unique</tt> (optional - defaults to <tt class="literal">false</tt>):
                                Specifies that a unique constraint exists upon all mapped columns of the
                                component.
                            </p></td></tr></table></div></div><p>
                The child <tt class="literal">&lt;property&gt;</tt> tags map properties of the
                child class to table columns.
            </p><p>
                The <tt class="literal">&lt;component&gt;</tt> element allows a <tt class="literal">&lt;parent&gt;</tt>
                subelement that maps a property of the component class as a reference back to the
                containing entity.
            </p><p>
                The <tt class="literal">&lt;dynamic-component&gt;</tt> element allows a <tt class="literal">Map</tt>
                to be mapped as a component, where the property names refer to keys of the map, see
                <a href="#components-dynamic" title="8.5.&nbsp;Dynamic components">Section&nbsp;8.5, &#8220;Dynamic components&#8221;</a>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-properties"></a>5.1.14.&nbsp;properties</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;properties&gt;</tt> element allows the definition of a named,
                logical grouping of properties of a class. The most important use of the construct
                is that it allows a combination of properties to be the target of a 
                <tt class="literal">property-ref</tt>. It is also a convenient way to define a multi-column
                unique constraint.
            </p><div class="programlistingco"><pre class="programlisting">&lt;properties 
        name="logicalName"                  <span class="co">(1)</span>
        insert="true|false"                 <span class="co">(2)</span>
        update="true|false"                 <span class="co">(3)</span>
        optimistic-lock="true|false"        <span class="co">(4)</span>
        unique="true|false"                 <span class="co">(5)</span>
&gt;
        
        &lt;property ...../&gt;
        &lt;many-to-one .... /&gt;
        ........
&lt;/properties&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The logical name of the grouping - 
                            <span class="emphasis"><em>not</em></span> an actual property name.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">insert</tt>: Do the mapped columns appear in SQL 
                            <tt class="literal">INSERT</tt>s?
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">update</tt>: Do the mapped columns appear in SQL 
                            <tt class="literal">UPDATE</tt>s?
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                                <tt class="literal">optimistic-lock</tt> (optional - defaults to <tt class="literal">true</tt>):
                                Specifies that updates to these properties do or do not require acquisition of the
                                optimistic lock. In other words, determines if a version increment should occur when
                                these properties are dirty.
                            </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                                <tt class="literal">unique</tt> (optional - defaults to <tt class="literal">false</tt>):
                                Specifies that a unique constraint exists upon all mapped columns of the
                                component.
                            </p></td></tr></table></div></div><p>
                For example, if we have the following <tt class="literal">&lt;properties&gt;</tt> mapping:
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="personNumber"/&gt;
    ...
    &lt;properties name="name" 
            unique="true" update="false"&gt;
        &lt;property name="firstName"/&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="lastName"/&gt;
    &lt;/properties&gt;
&lt;/class&gt;</pre><p>
                Then we might have some legacy data association which refers to this unique key of 
                the <tt class="literal">Person</tt> table, instead of to the primary key:
            </p><pre class="programlisting">&lt;many-to-one name="person" 
         class="Person" property-ref="name"&gt;
    &lt;column name="firstName"/&gt;
    &lt;column name="initial"/&gt;
    &lt;column name="lastName"/&gt;
&lt;/many-to-one&gt;</pre><p>
                We don't recommend the use of this kind of thing outside the context of mapping
                legacy data.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-subclass"></a>5.1.15.&nbsp;subclass</h3></div></div><div></div></div><p>
                Finally, polymorphic persistence requires the declaration of each subclass of
                the root persistent class. For the table-per-class-hierarchy
                mapping strategy, the <tt class="literal">&lt;subclass&gt;</tt> declaration is used.
            </p><div class="programlistingco"><pre class="programlisting">&lt;subclass
        name="ClassName"                              <span class="co">(1)</span>
        discriminator-value="discriminator_value"     <span class="co">(2)</span>
        proxy="ProxyInterface"                        <span class="co">(3)</span>
        lazy="true|false"                             <span class="co">(4)</span>
        dynamic-update="true|false"
        dynamic-insert="true|false"
        entity-name="EntityName"
        node="element-name"
        extends="SuperclassName"&gt;

        &lt;property .... /&gt;
        .....
&lt;/subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The fully qualified class name of the subclass.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">discriminator-value</tt> (optional - defaults to the class name): A
                            value that distiguishes individual subclasses.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">proxy</tt> (optional): Specifies a class or interface to use for 
                            lazy initializing proxies.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional, defaults to <tt class="literal">true</tt>): Setting 
                            <tt class="literal">lazy="false"</tt> disables the use of lazy fetching.
                        </p></td></tr></table></div></div><p>
                Each subclass should declare its own persistent properties and subclasses.
                <tt class="literal">&lt;version&gt;</tt> and <tt class="literal">&lt;id&gt;</tt> properties
                are assumed to be inherited from the root class. Each subclass in a heirarchy must
                define a unique <tt class="literal">discriminator-value</tt>. If none is specified, the
                fully qualified Java class name is used.
            </p><p>
                For information about inheritance mappings, see <a href="#inheritance" title="Chapter&nbsp;9.&nbsp;Inheritance Mapping">Chapter&nbsp;9, <i>Inheritance Mapping</i></a>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-joinedsubclass"></a>5.1.16.&nbsp;joined-subclass</h3></div></div><div></div></div><p>
                Alternatively, each subclass may be mapped to its own table (table-per-subclass 
                mapping strategy). Inherited state is retrieved by joining with the table of the 
                superclass. We use the <tt class="literal">&lt;joined-subclass&gt;</tt> element.
            </p><div class="programlistingco"><pre class="programlisting">&lt;joined-subclass
        name="ClassName"                    <span class="co">(1)</span>
        table="tablename"                   <span class="co">(2)</span>
        proxy="ProxyInterface"              <span class="co">(3)</span>
        lazy="true|false"                   <span class="co">(4)</span>
        dynamic-update="true|false"
        dynamic-insert="true|false"
        schema="schema"
        catalog="catalog"
        extends="SuperclassName"
        persister="ClassName"
        subselect="SQL expression"
        entity-name="EntityName"
        node="element-name"&gt;

        &lt;key .... &gt;

        &lt;property .... /&gt;
        .....
&lt;/joined-subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The fully qualified class name of the subclass.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">table</tt>: The name of the subclass table.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">proxy</tt> (optional): Specifies a class or interface to use 
                            for lazy initializing proxies.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                             <tt class="literal">lazy</tt> (optional, defaults to <tt class="literal">true</tt>): Setting 
                            <tt class="literal">lazy="false"</tt> disables the use of lazy fetching.
                         </p></td></tr></table></div></div><p>
                No discriminator column is required for this mapping strategy. Each subclass must,
                however, declare a table column holding the object identifier using the
                <tt class="literal">&lt;key&gt;</tt> element. The mapping at the start of the chapter
                would be re-written as:
            </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

        &lt;class name="Cat" table="CATS"&gt;
                &lt;id name="id" column="uid" type="long"&gt;
                        &lt;generator class="hilo"/&gt;
                &lt;/id&gt;
                &lt;property name="birthdate" type="date"/&gt;
                &lt;property name="color" not-null="true"/&gt;
                &lt;property name="sex" not-null="true"/&gt;
                &lt;property name="weight"/&gt;
                &lt;many-to-one name="mate"/&gt;
                &lt;set name="kittens"&gt;
                        &lt;key column="MOTHER"/&gt;
                        &lt;one-to-many class="Cat"/&gt;
                &lt;/set&gt;
                &lt;joined-subclass name="DomesticCat" table="DOMESTIC_CATS"&gt;
                    &lt;key column="CAT"/&gt;
                    &lt;property name="name" type="string"/&gt;
                &lt;/joined-subclass&gt;
        &lt;/class&gt;

        &lt;class name="eg.Dog"&gt;
                &lt;!-- mapping for Dog could go here --&gt;
        &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
                 For information about inheritance mappings, see <a href="#inheritance" title="Chapter&nbsp;9.&nbsp;Inheritance Mapping">Chapter&nbsp;9, <i>Inheritance Mapping</i></a>.
             </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-unionsubclass"></a>5.1.17.&nbsp;union-subclass</h3></div></div><div></div></div><p>
               A third option is to map only the concrete classes of an inheritance hierarchy
               to tables, (the table-per-concrete-class strategy) where each table defines all 
               persistent state of the class, including inherited state. In Hibernate, it is
               not absolutely necessary to explicitly map such inheritance hierarchies. You
               can simply map each class with a separate <tt class="literal">&lt;class&gt;</tt>
               declaration. However, if you wish use polymorphic associations (e.g. an association
               to the superclass of your hierarchy), you need to
               use the <tt class="literal">&lt;union-subclass&gt;</tt> mapping.
           </p><div class="programlistingco"><pre class="programlisting">&lt;union-subclass
        name="ClassName"                    <span class="co">(1)</span>
        table="tablename"                   <span class="co">(2)</span>
        proxy="ProxyInterface"              <span class="co">(3)</span>
        lazy="true|false"                   <span class="co">(4)</span>
        dynamic-update="true|false"
        dynamic-insert="true|false"
        schema="schema"
        catalog="catalog"
        extends="SuperclassName"
        abstract="true|false"
        persister="ClassName"
        subselect="SQL expression"
        entity-name="EntityName"
        node="element-name"&gt;

        &lt;property .... /&gt;
        .....
&lt;/union-subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The fully qualified class name of the subclass.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">table</tt>: The name of the subclass table.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">proxy</tt> (optional): Specifies a class or interface to use 
                            for lazy initializing proxies.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional, defaults to <tt class="literal">true</tt>): Setting 
                            <tt class="literal">lazy="false"</tt> disables the use of lazy fetching.
                         </p></td></tr></table></div></div><p>
                No discriminator column or key column is required for this mapping strategy.
            </p><p>
                For information about inheritance mappings, see <a href="#inheritance" title="Chapter&nbsp;9.&nbsp;Inheritance Mapping">Chapter&nbsp;9, <i>Inheritance Mapping</i></a>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-join"></a>5.1.18.&nbsp;join</h3></div></div><div></div></div><p>
                Using the <tt class="literal">&lt;join&gt;</tt> element, it is possible to map
                properties of one class to several tables.
            </p><div class="programlistingco"><pre class="programlisting">&lt;join
        table="tablename"                        <span class="co">(1)</span>
        schema="owner"                           <span class="co">(2)</span>
        catalog="catalog"                        <span class="co">(3)</span>
        fetch="join|select"                      <span class="co">(4)</span>
        inverse="true|false"                     <span class="co">(5)</span>
        optional="true|false"&gt;                   <span class="co">(6)</span>
        
        &lt;key ... /&gt;
        
        &lt;property ... /&gt;
        ...
&lt;/join&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">table</tt>: The name of the joined table.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">schema</tt> (optional): Override the schema name specified by
                            the root <tt class="literal">&lt;hibernate-mapping&gt;</tt> element.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">catalog</tt> (optional): Override the catalog name specified by
                            the root <tt class="literal">&lt;hibernate-mapping&gt;</tt> element.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">fetch</tt> (optional - defaults to <tt class="literal">join</tt>):
                            If set to <tt class="literal">join</tt>, the default, Hibernate will use an inner join 
                            to retrieve a <tt class="literal">&lt;join&gt;</tt> defined by a class or its superclasses 
                            and an outer join for a <tt class="literal">&lt;join&gt;</tt> defined by a subclass.
                            If set to <tt class="literal">select</tt> then Hibernate will use a sequential select for 
                            a <tt class="literal">&lt;join&gt;</tt> defined on a subclass, which will be issued only 
                            if a row turns out to represent an instance of the subclass. Inner joins will still
                            be used to retrieve a <tt class="literal">&lt;join&gt;</tt> defined by the class and its 
                            superclasses.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">inverse</tt> (optional - defaults to <tt class="literal">false</tt>):
                            If enabled, Hibernate will not try to insert or update the properties defined
                            by this join.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">optional</tt> (optional - defaults to <tt class="literal">false</tt>):
                            If enabled, Hibernate will insert a row only if the properties defined by this 
                            join are non-null and will always use an outer join to retrieve the properties.
                        </p></td></tr></table></div></div><p>
                For example, the address information for a person can be mapped to a separate
                table (while preserving value type semantics for all properties):
            </p><pre class="programlisting">&lt;class name="Person"
    table="PERSON"&gt;

    &lt;id name="id" column="PERSON_ID"&gt;...&lt;/id&gt;

    &lt;join table="ADDRESS"&gt;
        &lt;key column="ADDRESS_ID"/&gt;
        &lt;property name="address"/&gt;
        &lt;property name="zip"/&gt;
        &lt;property name="country"/&gt;
    &lt;/join&gt;
    ...</pre><p>
                This feature is often only useful for legacy data models, we recommend fewer
                tables than classes and a fine-grained domain model. However, it is useful
                for switching between inheritance mapping strategies in a single hierarchy, as
                explained later.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-key"></a>5.1.19.&nbsp;key</h3></div></div><div></div></div><p>
                We've seen the <tt class="literal">&lt;key&gt;</tt> element crop up a few times
                now. It appears anywhere the parent mapping element defines a join to
                a new table, and defines the foreign key in the joined table, that references
                the primary key of the original table.
            </p><div class="programlistingco"><pre class="programlisting">&lt;key
        column="columnname"                      <span class="co">(1)</span>
        on-delete="noaction|cascade"             <span class="co">(2)</span>
        property-ref="propertyName"              <span class="co">(3)</span>
        not-null="true|false"                    <span class="co">(4)</span>
        update="true|false"                      <span class="co">(5)</span>
        unique="true|false"                      <span class="co">(6)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional): The name of the foreign key column.
                            This may also be specified by nested <tt class="literal">&lt;column&gt;</tt>
                            element(s).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">on-delete</tt> (optional, defaults to <tt class="literal">noaction</tt>): 
                            Specifies whether the foreign key constraint has database-level cascade delete 
                            enabled.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">property-ref</tt> (optional): Specifies that the foreign key refers
                            to columns that are not the primary key of the orginal table. (Provided for 
                            legacy data.)
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">not-null</tt> (optional): Specifies that the foreign key columns
                            are not nullable (this is implied whenever the foreign key is also part of the
                            primary key).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">update</tt> (optional): Specifies that the foreign key should never
                            be updated (this is implied whenever the foreign key is also part of the primary 
                            key).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">unique</tt> (optional): Specifies that the foreign key should have
                            a unique constraint (this is implied whenever the foreign key is also the primary key).
                        </p></td></tr></table></div></div><p>
                We recommend that for systems where delete performance is important, all keys should be 
                defined <tt class="literal">on-delete="cascade"</tt>, and Hibernate will use a database-level
                <tt class="literal">ON CASCADE DELETE</tt> constraint, instead of many individual 
                <tt class="literal">DELETE</tt> statements. Be aware that this feature bypasses Hibernate's
                usual optimistic locking strategy for versioned data.
            </p><p>
                The <tt class="literal">not-null</tt> and <tt class="literal">update</tt> attributes are useful when
                mapping a unidirectional one to many association. If you map a unidirectional one to many
                to a non-nullable foreign key, you <span class="emphasis"><em>must</em></span> declare the key column using
                <tt class="literal">&lt;key not-null="true"&gt;</tt>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-column"></a>5.1.20.&nbsp;column and formula elements</h3></div></div><div></div></div><p>
               Any mapping element which accepts a <tt class="literal">column</tt> attribute will alternatively
               accept a <tt class="literal">&lt;column&gt;</tt> subelement. Likewise, <tt class="literal">&lt;formula&gt;</tt>
               is an alternative to the <tt class="literal">formula</tt> attribute.
           </p><pre class="programlisting">&lt;column
        name="column_name"
        length="N"
        precision="N"
        scale="N"
        not-null="true|false"
        unique="true|false"
        unique-key="multicolumn_unique_key_name"
        index="index_name"
        sql-type="sql_type_name"
        check="SQL expression"
        default="SQL expression"/&gt;</pre><pre class="programlisting">&lt;formula&gt;SQL expression&lt;/formula&gt;</pre><p>
                <tt class="literal">column</tt> and <tt class="literal">formula</tt> attributes may even be combined
                within the same property or association mapping to express, for example, exotic join
                conditions.
            </p><pre class="programlisting">&lt;many-to-one name="homeAddress" class="Address"
        insert="false" update="false"&gt;
    &lt;column name="person_id" not-null="true" length="10"/&gt;
    &lt;formula&gt;'MAILING'&lt;/formula&gt;
&lt;/many-to-one&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-import"></a>5.1.21.&nbsp;import</h3></div></div><div></div></div><p>
                Suppose your application has two persistent classes with the same name, and you don't want to
                specify the fully qualified (package) name in Hibernate queries. Classes may be "imported" 
                explicitly, rather than relying upon <tt class="literal">auto-import="true"</tt>. You may even import 
                classes and interfaces that are not explicitly mapped.
            </p><pre class="programlisting">&lt;import class="java.lang.Object" rename="Universe"/&gt;</pre><div class="programlistingco"><pre class="programlisting">&lt;import
        class="ClassName"              <span class="co">(1)</span>
        rename="ShortName"             <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt>: The fully qualified class name of of any Java class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">rename</tt> (optional - defaults to the unqualified class name):
                            A name that may be used in the query language.
                        </p></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-anymapping"></a>5.1.22.&nbsp;any</h3></div></div><div></div></div><p>
                There is one further type of property mapping. The <tt class="literal">&lt;any&gt;</tt> mapping element 
                defines a polymorphic association to classes from multiple tables. This type of mapping always
                requires more than one column. The first column holds the type of the associated entity. 
                The remaining columns hold the identifier. It is impossible to specify a foreign key constraint
                for this kind of association, so this is most certainly not meant as the usual way of mapping 
                (polymorphic) associations. You should use this only in very special cases (eg. audit logs,
                user session data, etc).
            </p><p>
                 The <tt class="literal">meta-type</tt> attribute lets the application specify a custom type that 
                 maps database column values to persistent classes which have identifier properties of the 
                 type specified by <tt class="literal">id-type</tt>. You must specify the mapping from values of
                 the meta-type to class names.
            </p><pre class="programlisting">&lt;any name="being" id-type="long" meta-type="string"&gt;
    &lt;meta-value value="TBL_ANIMAL" class="Animal"/&gt;
    &lt;meta-value value="TBL_HUMAN" class="Human"/&gt;
    &lt;meta-value value="TBL_ALIEN" class="Alien"/&gt;
    &lt;column name="table_name"/&gt;
    &lt;column name="id"/&gt;
&lt;/any&gt;</pre><div class="programlistingco"><pre class="programlisting">&lt;any
        name="propertyName"                      <span class="co">(1)</span>
        id-type="idtypename"                     <span class="co">(2)</span>
        meta-type="metatypename"                 <span class="co">(3)</span>
        cascade="cascade_style"                  <span class="co">(4)</span>
        access="field|property|ClassName"        <span class="co">(5)</span>
        optimistic-lock="true|false"             <span class="co">(6)</span>
&gt;
        &lt;meta-value ... /&gt;
        &lt;meta-value ... /&gt;
        .....
        &lt;column .... /&gt;
        &lt;column .... /&gt;
        .....
&lt;/any&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: the property name.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">id-type</tt>: the identifier type.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">meta-type</tt> (optional - defaults to <tt class="literal">string</tt>): 
                            Any type that is allowed for a discriminator mapping.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">cascade</tt> (optional- defaults to <tt class="literal">none</tt>): 
                            the cascade style.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy Hibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (optional - defaults to <tt class="literal">true</tt>): 
                            Specifies that updates to this property do or do not require acquisition of the
                            optimistic lock. In other words, define if a version increment should occur if this
                            property is dirty.
                        </p></td></tr></table></div></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-types"></a>5.2.&nbsp;Hibernate Types</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-entitiesvalues"></a>5.2.1.&nbsp;Entities and values</h3></div></div><div></div></div><p>
                To understand the behaviour of various Java language-level objects with respect
                to the persistence service, we need to classify them into two groups:
            </p><p>
                An <span class="emphasis"><em>entity</em></span> exists independently of any other objects holding
                references to the entity. Contrast this with the usual Java model where an
                unreferenced object is garbage collected. Entities must be explicitly saved and
                deleted (except that saves and deletions may be <span class="emphasis"><em>cascaded</em></span>
                from a parent entity to its children). This is different from the ODMG model of
                object persistence by reachablity - and corresponds more closely to how
                application objects are usually used in large systems. Entities support
                circular and shared references. They may also be versioned.
            </p><p>
                An entity's persistent state consists of references to other entities and
                instances of <span class="emphasis"><em>value</em></span> types. Values are primitives,
                collections (not what's inside a collection), components and certain immutable
                objects. Unlike entities, values (in particular collections and components)
                <span class="emphasis"><em>are</em></span> persisted and deleted by reachability. Since value
                objects (and primitives) are persisted and deleted along with their containing
                entity they may not be independently versioned. Values have no independent
                identity, so they cannot be shared by two entities or collections.
            </p><p>
                Up until now, we've been using the term "persistent class" to refer to
                entities. We will continue to do that. Strictly speaking, however, not all
                user-defined classes with persistent state are entities. A
                <span class="emphasis"><em>component</em></span> is a user defined class with value semantics.
                A Java property of type <tt class="literal">java.lang.String</tt> also has value
                semantics. Given this definition, we can say that all types (classes) provided
                by the JDK have value type semantics in Java, while user-defined types may
                be mapped with entity or value type semantics. This decision is up to the
                application developer. A good hint for an entity class in a domain model are
                shared references to a single instance of that class, while composition or
                aggregation usually translates to a value type.
            </p><p>
                We'll revisit both concepts throughout the documentation.
            </p><p>
                The challenge is to map the Java type system (and the developers' definition of
                entities and value types) to the SQL/database type system. The bridge between
                both systems is provided by Hibernate: for entities we use
                <tt class="literal">&lt;class&gt;</tt>, <tt class="literal">&lt;subclass&gt;</tt> and so on.
                For value types we use <tt class="literal">&lt;property&gt;</tt>,
                <tt class="literal">&lt;component&gt;</tt>, etc, usually with a <tt class="literal">type</tt>
                attribute. The value of this attribute is the name of a Hibernate
                <span class="emphasis"><em>mapping type</em></span>. Hibernate provides many mappings (for standard
                JDK value types) out of the box. You can write your own mapping types and implement your
                custom conversion strategies as well, as you'll see later.
            </p><p>
                All built-in Hibernate types except collections support null semantics.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-basictypes"></a>5.2.2.&nbsp;Basic value types</h3></div></div><div></div></div><p>
                The built-in <span class="emphasis"><em>basic mapping types</em></span> may be roughly categorized into

                </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">integer, long, short, float, double, character, byte,
                            boolean, yes_no, true_false</tt></span></dt><dd><p>
                                Type mappings from Java primitives or wrapper classes to appropriate
                                (vendor-specific) SQL column types. <tt class="literal">boolean, yes_no</tt>
                                and <tt class="literal">true_false</tt> are all alternative encodings for
                                a Java <tt class="literal">boolean</tt> or <tt class="literal">java.lang.Boolean</tt>.
                            </p></dd><dt><span class="term"><tt class="literal">string</tt></span></dt><dd><p>
                                A type mapping from <tt class="literal">java.lang.String</tt> to
                                <tt class="literal">VARCHAR</tt> (or Oracle <tt class="literal">VARCHAR2</tt>).
                            </p></dd><dt><span class="term"><tt class="literal">date, time, timestamp</tt></span></dt><dd><p>
                                Type mappings from <tt class="literal">java.util.Date</tt> and its subclasses 
                                to SQL types <tt class="literal">DATE</tt>, <tt class="literal">TIME</tt> and
                                <tt class="literal">TIMESTAMP</tt> (or equivalent).
                            </p></dd><dt><span class="term"><tt class="literal">calendar, calendar_date</tt></span></dt><dd><p>
                                Type mappings from <tt class="literal">java.util.Calendar</tt> to
                                SQL types <tt class="literal">TIMESTAMP</tt> and <tt class="literal">DATE</tt>
                                (or equivalent).
                            </p></dd><dt><span class="term"><tt class="literal">big_decimal, big_integer</tt></span></dt><dd><p>
                                Type mappings from <tt class="literal">java.math.BigDecimal</tt> and
                                <tt class="literal">java.math.BigInteger</tt> to <tt class="literal">NUMERIC</tt> 
                                (or Oracle <tt class="literal">NUMBER</tt>).
                            </p></dd><dt><span class="term"><tt class="literal">locale, timezone, currency</tt></span></dt><dd><p>
                                Type mappings from <tt class="literal">java.util.Locale</tt>,
                                <tt class="literal">java.util.TimeZone</tt> and 
                                <tt class="literal">java.util.Currency</tt> 
                                to <tt class="literal">VARCHAR</tt> (or Oracle <tt class="literal">VARCHAR2</tt>).
                                Instances of <tt class="literal">Locale</tt> and <tt class="literal">Currency</tt> are 
                                mapped to their ISO codes. Instances of <tt class="literal">TimeZone</tt> are
                                mapped to their <tt class="literal">ID</tt>. 
                            </p></dd><dt><span class="term"><tt class="literal">class</tt></span></dt><dd><p>
                                A type mapping from <tt class="literal">java.lang.Class</tt> to
                                <tt class="literal">VARCHAR</tt> (or Oracle <tt class="literal">VARCHAR2</tt>).
                                A <tt class="literal">Class</tt> is mapped to its fully qualified name.
                            </p></dd><dt><span class="term"><tt class="literal">binary</tt></span></dt><dd><p>
                                Maps byte arrays to an appropriate SQL binary type.
                            </p></dd><dt><span class="term"><tt class="literal">text</tt></span></dt><dd><p>
                                Maps long Java strings to a SQL <tt class="literal">CLOB</tt> or 
                                <tt class="literal">TEXT</tt> type.
                            </p></dd><dt><span class="term"><tt class="literal">serializable</tt></span></dt><dd><p>
                                Maps serializable Java types to an appropriate SQL binary type. You
                                may also indicate the Hibernate type <tt class="literal">serializable</tt> with
                                the name of a serializable Java class or interface that does not default 
                                to a basic type.
                            </p></dd><dt><span class="term"><tt class="literal">clob, blob</tt></span></dt><dd><p>
                                Type mappings for the JDBC classes <tt class="literal">java.sql.Clob</tt> and
                                <tt class="literal">java.sql.Blob</tt>. These types may be inconvenient for some
                                applications, since the blob or clob object may not be reused outside of
                                a transaction. (Furthermore, driver support is patchy and inconsistent.)
                            </p></dd><dt><span class="term">
                            <tt class="literal">imm_date, imm_time, imm_timestamp, imm_calendar, imm_calendar_date,
                            imm_serializable, imm_binary</tt>
                        </span></dt><dd><p>
                                Type mappings for what are usually considered mutable Java types, where
                                Hibernate makes certain optimizations appropriate only for immutable
                                Java types, and the application treats the object as immutable. For
                                example, you should not call <tt class="literal">Date.setTime()</tt> for an
                                instance mapped as <tt class="literal">imm_timestamp</tt>. To change the
                                value of the property, and have that change made persistent, the 
                                application must assign a new (nonidentical) object to the property.
                            </p></dd></dl></div><p>
            
            </p><p>
                Unique identifiers of entities and collections may be of any basic type except
                <tt class="literal">binary</tt>, <tt class="literal">blob</tt> and <tt class="literal">clob</tt>. 
                (Composite identifiers are also allowed, see below.)
            </p><p>
                The basic value types have corresponding <tt class="literal">Type</tt> constants defined on
                <tt class="literal">org.hibernate.Hibernate</tt>. For example, <tt class="literal">Hibernate.STRING</tt>
                represents the <tt class="literal">string</tt> type.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-custom"></a>5.2.3.&nbsp;Custom value types</h3></div></div><div></div></div><p>
                It is relatively easy for developers to create their own value types. For example,
                you might want to persist properties of type <tt class="literal">java.lang.BigInteger</tt>
                to <tt class="literal">VARCHAR</tt> columns. Hibernate does not provide a built-in type 
                for this. But custom types are not limited to mapping a property (or collection element) 
                to a single table column. So, for example, you might have a Java property 
                <tt class="literal">getName()</tt>/<tt class="literal">setName()</tt> of type
                <tt class="literal">java.lang.String</tt> that is persisted to the columns 
                <tt class="literal">FIRST_NAME</tt>, <tt class="literal">INITIAL</tt>, <tt class="literal">SURNAME</tt>. 
            </p><p>
                To implement a custom type, implement either <tt class="literal">org.hibernate.UserType</tt>
                or <tt class="literal">org.hibernate.CompositeUserType</tt> and declare properties using the
                fully qualified classname of the type. Check out 
                <tt class="literal">org.hibernate.test.DoubleStringType</tt> to see the kind of things that
                are possible.
            </p><pre class="programlisting">&lt;property name="twoStrings" type="org.hibernate.test.DoubleStringType"&gt;
    &lt;column name="first_string"/&gt;
    &lt;column name="second_string"/&gt;
&lt;/property&gt;</pre><p>
                Notice the use of <tt class="literal">&lt;column&gt;</tt> tags to map a property to multiple
                columns.
            </p><p>
                The <tt class="literal">CompositeUserType</tt>, <tt class="literal">EnhancedUserType</tt>,
                <tt class="literal">UserCollectionType</tt>, and <tt class="literal">UserVersionType</tt> 
                interfaces provide support for more specialized uses.
            </p><p>
                You may even supply parameters to a <tt class="literal">UserType</tt> in the mapping file. To 
                do this, your <tt class="literal">UserType</tt> must implement the 
                <tt class="literal">org.hibernate.usertype.ParameterizedType</tt> interface. To supply parameters 
                to your custom type, you can use the <tt class="literal">&lt;type&gt;</tt> element in your mapping 
                files.
            </p><pre class="programlisting">&lt;property name="priority"&gt;
    &lt;type name="com.mycompany.usertypes.DefaultValueIntegerType"&gt;
        &lt;param name="default"&gt;0&lt;/param&gt;
    &lt;/type&gt;
&lt;/property&gt;</pre><p>
                The <tt class="literal">UserType</tt> can now retrieve the value for the parameter named 
                <tt class="literal">default</tt> from the <tt class="literal">Properties</tt> object passed to it.
            </p><p>
                If you use a certain <tt class="literal">UserType</tt> very often, it may be useful to define a 
                shorter name for it. You can do this using the <tt class="literal">&lt;typedef&gt;</tt> element.
                Typedefs assign a name to a custom type, and may also contain a list of default
                parameter values if the type is parameterized.
            </p><pre class="programlisting">&lt;typedef class="com.mycompany.usertypes.DefaultValueIntegerType" name="default_zero"&gt;
    &lt;param name="default"&gt;0&lt;/param&gt;
&lt;/typedef&gt;</pre><pre class="programlisting">&lt;property name="priority" type="default_zero"/&gt;</pre><p>
                It is also possible to override the parameters supplied in a typedef on a case-by-case basis
                by using type parameters on the property mapping.
            </p><p>
                Even though Hibernate's rich range of built-in types and support for components means you
                will very rarely <span class="emphasis"><em>need</em></span> to use a custom type, it is nevertheless
                considered good form to use custom types for (non-entity) classes that occur frequently
                in your application. For example, a <tt class="literal">MonetaryAmount</tt> class is a good
                candidate for a <tt class="literal">CompositeUserType</tt>, even though it could easily be mapped 
                as a component. One motivation for this is abstraction. With a custom type, your mapping 
                documents would be future-proofed against possible changes in your way of representing 
                monetary values.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-entityname"></a>5.3.&nbsp;Mapping a class more than once</h2></div></div><div></div></div><p>
            It is possible to provide more than one mapping for a particular persistent class. In this
            case you must specify an <span class="emphasis"><em>entity name</em></span> do disambiguate between instances
            of the two mapped entities. (By default, the entity name is the same as the class name.)
            Hibernate lets you specify the entity name when working with persistent objects, when writing
            queries, or when mapping associations to the named entity.
        </p><pre class="programlisting">&lt;class name="Contract" table="Contracts" 
        entity-name="CurrentContract"&gt;
    ...
    &lt;set name="history" inverse="true" 
            order-by="effectiveEndDate desc"&gt;
        &lt;key column="currentContractId"/&gt;
        &lt;one-to-many entity-name="HistoricalContract"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Contract" table="ContractHistory" 
        entity-name="HistoricalContract"&gt;
    ...
    &lt;many-to-one name="currentContract" 
            column="currentContractId" 
            entity-name="CurrentContract"/&gt;
&lt;/class&gt;</pre><p>
            Notice how associations are now specified using <tt class="literal">entity-name</tt> instead of
            <tt class="literal">class</tt>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-quotedidentifiers"></a>5.4.&nbsp;SQL quoted identifiers</h2></div></div><div></div></div><p>
                You may force Hibernate to quote an identifier in the generated SQL by enclosing the table or
                column name in backticks in the mapping document. Hibernate will use the correct quotation
                style for the SQL <tt class="literal">Dialect</tt> (usually double quotes, but brackets for SQL
                Server and backticks for MySQL).
            </p><pre class="programlisting">&lt;class name="LineItem" table="`Line Item`"&gt;
    &lt;id name="id" column="`Item Id`"/&gt;&lt;generator class="assigned"/&gt;&lt;/id&gt;
    &lt;property name="itemNumber" column="`Item #`"/&gt;
    ...
&lt;/class&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-alternatives"></a>5.5.&nbsp;Metadata alternatives</h2></div></div><div></div></div><p>
   	    XML isn't for everyone, and so there are some alternative ways to define O/R mapping metadata in Hibernate.
   	</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-xdoclet"></a>5.5.1.&nbsp;Using XDoclet markup</h3></div></div><div></div></div><p>
            Many Hibernate users prefer to embed mapping information directly in sourcecode using
            XDoclet <tt class="literal">@hibernate.tags</tt>. We will not cover this approach in this
            document, since strictly it is considered part of XDoclet. However, we include the
            following example of the <tt class="literal">Cat</tt> class with XDoclet mappings.
        </p><pre class="programlisting">package eg;
import java.util.Set;
import java.util.Date;

/**
 * @hibernate.class
 *  table="CATS"
 */
public class Cat {
    private Long id; // identifier
    private Date birthdate;
    private Cat mother;
    private Set kittens
    private Color color;
    private char sex;
    private float weight;

    /*
     * @hibernate.id
     *  generator-class="native"
     *  column="CAT_ID"
     */
    public Long getId() {
        return id;
    }
    private void setId(Long id) {
        this.id=id;
    }

    /**
     * @hibernate.many-to-one
     *  column="PARENT_ID"
     */
    public Cat getMother() {
        return mother;
    }
    void setMother(Cat mother) {
        this.mother = mother;
    }

    /**
     * @hibernate.property
     *  column="BIRTH_DATE"
     */
    public Date getBirthdate() {
        return birthdate;
    }
    void setBirthdate(Date date) {
        birthdate = date;
    }
    /**
     * @hibernate.property
     *  column="WEIGHT"
     */
    public float getWeight() {
        return weight;
    }
    void setWeight(float weight) {
        this.weight = weight;
    }

    /**
     * @hibernate.property
     *  column="COLOR"
     *  not-null="true"
     */
    public Color getColor() {
        return color;
    }
    void setColor(Color color) {
        this.color = color;
    }
    /**
     * @hibernate.set
     *  inverse="true"
     *  order-by="BIRTH_DATE"
     * @hibernate.collection-key
     *  column="PARENT_ID"
     * @hibernate.collection-one-to-many
     */
    public Set getKittens() {
        return kittens;
    }
    void setKittens(Set kittens) {
        this.kittens = kittens;
    }
    // addKitten not needed by Hibernate
    public void addKitten(Cat kitten) {
        kittens.add(kitten);
    }

    /**
     * @hibernate.property
     *  column="SEX"
     *  not-null="true"
     *  update="false"
     */
    public char getSex() {
        return sex;
    }
    void setSex(char sex) {
        this.sex=sex;
    }
}</pre><p>
            See the Hibernate web site for more examples of XDoclet and Hibernate.
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-annotations"></a>5.5.2.&nbsp;Using JDK 5.0 Annotations</h3></div></div><div></div></div><p>
            JDK 5.0 introduced XDoclet-style annotations at the language level, type-safe and
            checked at compile time. This mechnism is more powerful than XDoclet annotations and
            better supported by tools and IDEs. IntelliJ IDEA, for example, supports auto-completion
            and syntax highlighting of JDK 5.0 annotations. The new revision of the EJB specification
            (JSR-220) uses JDK 5.0 annotations as the primary metadata mechanism for entity beans.
            Hibernate3 implements the <tt class="literal">EntityManager</tt> of JSR-220 (the persistence API),
            support for mapping metadata is available via the <span class="emphasis"><em>Hibernate Annotations</em></span>
            package, as a separate download. Both EJB3 (JSR-220) and Hibernate3 metadata is supported.
        </p><p>
            This is an example of a POJO class annotated as an EJB entity bean:
        </p><pre class="programlisting">@Entity(access = AccessType.FIELD)
public class Customer implements Serializable {

    @Id;
    Long id;

    String firstName;
    String lastName;
    Date birthday;

    @Transient
    Integer age;

    @Embedded
    private Address homeAddress;

    @OneToMany(cascade=CascadeType.ALL)
    @JoinColumn(name="CUSTOMER_ID")
    Set&lt;Order&gt; orders;

    // Getter/setter and business methods
}</pre><p>
            Note that support for JDK 5.0 Annotations (and JSR-220) is still work in progress and
            not completed. Please refer to the Hibernate Annotations module for more details.
        </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-generated"></a>5.6.&nbsp;Generated Properties</h2></div></div><div></div></div><p>
            Generated properties are properties which have their values generated by the
            database.  Typically, Hibernate applications needed to <tt class="literal">refresh</tt>
            objects which contain any properties for which the database was generating values.
            Marking properties as generated, however, lets the application delegate this
            responsibility to Hibernate.  Essentially, whenever Hibernate issues an SQL INSERT
            or UPDATE for an entity which has defined generated properties, it immediately
            issues a select afterwards to retrieve the generated values.
        </p><p>
            Properties marked as generated must additionally be non-insertable and non-updateable.
            Only <a href="#mapping-declaration-version" title="5.1.7.&nbsp;version (optional)">Section&nbsp;5.1.7, &#8220;version (optional)&#8221;</a>,
            <a href="#mapping-declaration-timestamp" title="5.1.8.&nbsp;timestamp (optional)">Section&nbsp;5.1.8, &#8220;timestamp (optional)&#8221;</a>, and
            <a href="#mapping-declaration-property" title="5.1.9.&nbsp;property">Section&nbsp;5.1.9, &#8220;property&#8221;</a> can be marked as
            generated.
        </p><p>
		    <tt class="literal">never</tt> (the default) - means that the given property value
		    is not generated within the database.
	    </p><p>
		    <tt class="literal">insert</tt> - states that the given property value is generated on
		    insert, but is not regenerated on subsequent updates.  Things like created-date would
		    fall into this category.  Note that even thought
		    <a href="#mapping-declaration-version" title="5.1.7.&nbsp;version (optional)">Section&nbsp;5.1.7, &#8220;version (optional)&#8221;</a> and
		    <a href="#mapping-declaration-timestamp" title="5.1.8.&nbsp;timestamp (optional)">Section&nbsp;5.1.8, &#8220;timestamp (optional)&#8221;</a> properties can
		    be marked as generated, this option is not available there...
	    </p><p>
		    <tt class="literal">always</tt> - states that the property value is generated both
		    on insert and on update.
	    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-database-object"></a>5.7.&nbsp;Auxiliary Database Objects</h2></div></div><div></div></div><p>
            Allows CREATE and DROP of arbitrary database objects, in conjunction with
            Hibernate's schema evolution tools, to provide the ability to fully define
            a user schema within the Hibernate mapping files.  Although designed specifically
            for creating and dropping things like triggers or stored procedures, really any
            SQL command that can be run via a <tt class="literal">java.sql.Statement.execute()</tt>
            method is valid here (ALTERs, INSERTS, etc).  There are essentially two modes for
            defining auxiliary database objects...
        </p><p>
            The first mode is to explicitly list the CREATE and DROP commands out in the mapping
            file:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    ...
    &lt;database-object&gt;
        &lt;create&gt;CREATE TRIGGER my_trigger ...&lt;/create&gt;
        &lt;drop&gt;DROP TRIGGER my_trigger&lt;/drop&gt;
    &lt;/database-object&gt;
&lt;/hibernate-mapping&gt;</pre><p>
            The second mode is to supply a custom class which knows how to construct the
            CREATE and DROP commands.  This custom class must implement the
            <tt class="literal">org.hibernate.mapping.AuxiliaryDatabaseObject</tt> interface.
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    ...
    &lt;database-object&gt;
        &lt;definition class="MyTriggerDefinition"/&gt;
    &lt;/database-object&gt;
&lt;/hibernate-mapping&gt;</pre><p>
            Additionally, these database objects can be optionally scoped such that they only
            apply when certain dialects are used.
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    ...
    &lt;database-object&gt;
        &lt;definition class="MyTriggerDefinition"/&gt;
        &lt;dialect-scope name="org.hibernate.dialect.Oracle9Dialect"/&gt;
        &lt;dialect-scope name="org.hibernate.dialect.OracleDialect"/&gt;
    &lt;/database-object&gt;
&lt;/hibernate-mapping&gt;</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="collections"></a>Chapter&nbsp;6.&nbsp;Collection Mapping</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-persistent"></a>6.1.&nbsp;Persistent collections</h2></div></div><div></div></div><p>
            Hibernate requires that persistent collection-valued fields be declared
            as an interface type, for example:
        </p><pre class="programlisting">public class Product {
    private String serialNumber;
    private Set parts = new HashSet();
    
    public Set getParts() { return parts; }
    void setParts(Set parts) { this.parts = parts; }
    public String getSerialNumber() { return serialNumber; }
    void setSerialNumber(String sn) { serialNumber = sn; }
}</pre><p>
            The actual interface might be <tt class="literal">java.util.Set</tt>,
            <tt class="literal">java.util.Collection</tt>, <tt class="literal">java.util.List</tt>,
            <tt class="literal">java.util.Map</tt>, <tt class="literal">java.util.SortedSet</tt>,
            <tt class="literal">java.util.SortedMap</tt> or ... anything you like! (Where 
            "anything you like" means you will have to write an implementation of 
            <tt class="literal">org.hibernate.usertype.UserCollectionType</tt>.)
        </p><p>
            Notice how we initialized the instance variable with an instance of
            <tt class="literal">HashSet</tt>. This is the best way to initialize collection
            valued properties of newly instantiated (non-persistent) instances. When
            you make the instance persistent - by calling <tt class="literal">persist()</tt>,
            for example - Hibernate will actually replace the <tt class="literal">HashSet</tt>
            with an instance of Hibernate's own implementation of <tt class="literal">Set</tt>.
            Watch out for errors like this:
        </p><pre class="programlisting">Cat cat = new DomesticCat();
Cat kitten = new DomesticCat();
....
Set kittens = new HashSet();
kittens.add(kitten);
cat.setKittens(kittens);
session.persist(cat);
kittens = cat.getKittens(); // Okay, kittens collection is a Set
(HashSet) cat.getKittens(); // Error!</pre><p>
            The persistent collections injected by Hibernate behave like
            <tt class="literal">HashMap</tt>, <tt class="literal">HashSet</tt>,
            <tt class="literal">TreeMap</tt>, <tt class="literal">TreeSet</tt> or
            <tt class="literal">ArrayList</tt>, depending upon the interface type.
        </p><p>
            Collections instances have the usual behavior of value types. They are 
            automatically persisted when referenced by a persistent object and 
            automatically deleted when unreferenced. If a collection is passed from one
            persistent object to another, its elements might be moved from one table to
            another. Two entities may not share a reference to the same collection 
            instance. Due to the underlying relational model, collection-valued properties
            do not support null value semantics; Hibernate does not distinguish between 
            a null collection reference and an empty collection.
        </p><p>
            You shouldn't have to worry much about any of this. Use persistent collections 
            the same way you use ordinary Java collections. Just make sure you understand 
            the semantics of bidirectional associations (discussed later).
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-mapping"></a>6.2.&nbsp;Collection mappings</h2></div></div><div></div></div><p>
            The Hibernate mapping element used for mapping a collection depends upon
            the type of the interface. For example, a <tt class="literal">&lt;set&gt;</tt> 
            element is used for mapping properties of type <tt class="literal">Set</tt>.
        </p><pre class="programlisting">&lt;class name="Product"&gt;
    &lt;id name="serialNumber" column="productSerialNumber"/&gt;
    &lt;set name="parts"&gt;
        &lt;key column="productSerialNumber" not-null="true"/&gt;
        &lt;one-to-many class="Part"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
            Apart from <tt class="literal">&lt;set&gt;</tt>, there is also 
            <tt class="literal">&lt;list&gt;</tt>, <tt class="literal">&lt;map&gt;</tt>,
            <tt class="literal">&lt;bag&gt;</tt>, <tt class="literal">&lt;array&gt;</tt> and
            <tt class="literal">&lt;primitive-array&gt;</tt> mapping elements. The
            <tt class="literal">&lt;map&gt;</tt> element is representative:
        </p><div class="programlistingco"><pre class="programlisting">&lt;map
    name="propertyName"                                         <span class="co">(1)</span>
    table="table_name"                                          <span class="co">(2)</span>
    schema="schema_name"                                        <span class="co">(3)</span>
    lazy="true|extra|false"                                     <span class="co">(4)</span>
    inverse="true|false"                                        <span class="co">(5)</span>
    cascade="all|none|save-update|delete|all-delete-orphan|delet<span class="co">(6)</span>e-orphan"
    sort="unsorted|natural|comparatorClass"                     <span class="co">(7)</span>
    order-by="column_name asc|desc"                             <span class="co">(8)</span>
    where="arbitrary sql where condition"                       <span class="co">(9)</span>
    fetch="join|select|subselect"                               <span class="co">(10)</span>
    batch-size="N"                                              <span class="co">(11)</span>
    access="field|property|ClassName"                           <span class="co">(12)</span>
    optimistic-lock="true|false"                                <span class="co">(13)</span>
    mutable="true|false"                                        <span class="co">(14)</span>
    node="element-name|."
    embed-xml="true|false"
&gt;

    &lt;key .... /&gt;
    &lt;map-key .... /&gt;
    &lt;element .... /&gt;
&lt;/map&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">name</tt> the collection property name
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">table</tt> (optional - defaults to property name) the
                        name of the collection table (not used for one-to-many associations)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">schema</tt> (optional) the name of a table schema to
                        override the schema declared on the root element
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                        <tt class="literal">lazy</tt> (optional - defaults to <tt class="literal">true</tt>)
                        may be used to disable lazy fetching and specify that the association is 
                        always eagerly fetched, or to enable "extra-lazy" fetching where most 
                        operations do not initialize the collection (suitable for very large 
                        collections)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                        <tt class="literal">inverse</tt> (optional - defaults to <tt class="literal">false</tt>)
                        mark this collection as the "inverse" end of a bidirectional association
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                        <tt class="literal">cascade</tt> (optional - defaults to <tt class="literal">none</tt>)
                        enable operations to cascade to child entities
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                        <tt class="literal">sort</tt> (optional) specify a sorted collection with
                        <tt class="literal">natural</tt> sort order, or a given comparator class
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                        <tt class="literal">order-by</tt> (optional, JDK1.4 only) specify a table column (or columns)
                        that define the iteration order of the <tt class="literal">Map</tt>, <tt class="literal">Set</tt>
                        or bag, together with an optional <tt class="literal">asc</tt> or <tt class="literal">desc</tt>
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                        <tt class="literal">where</tt> (optional) specify an arbitrary SQL <tt class="literal">WHERE</tt>
                        condition to be used when retrieving or removing the collection (useful if the
                        collection should contain only a subset of the available data)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                        <tt class="literal">fetch</tt> (optional, defaults to <tt class="literal">select</tt>) Choose
                        between outer-join fetching, fetching by sequential select, and fetching by sequential
                        subselect.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(11)</td><td valign="top" align="left"><p>
                        <tt class="literal">batch-size</tt> (optional, defaults to <tt class="literal">1</tt>) specify a
                        "batch size" for lazily fetching instances of this collection.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(12)</td><td valign="top" align="left"><p>
                        <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                        strategy Hibernate should use for accessing the collection property value.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(13)</td><td valign="top" align="left"><p>
                        <tt class="literal">optimistic-lock</tt> (optional - defaults to <tt class="literal">true</tt>): 
                        Species that changes to the state of the collection results in increment of the
                        owning entity's version. (For one to many associations, it is often reasonable to
                        disable this setting.)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(14)</td><td valign="top" align="left"><p>
                        <tt class="literal">mutable</tt> (optional - defaults to <tt class="literal">true</tt>): 
                        A value of <tt class="literal">false</tt> specifies that the elements of the 
                        collection never change (a minor performance optimization in some cases).
                    </p></td></tr></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-foreignkeys"></a>6.2.1.&nbsp;Collection foreign keys</h3></div></div><div></div></div><p>
                Collection instances are distinguished in the database by the foreign key of
                the entity that owns the collection. This foreign key is referred to as the
                <span class="emphasis"><em>collection key column</em></span> (or columns) of the collection 
                table. The collection key column is mapped by the <tt class="literal">&lt;key&gt;</tt> 
                element. 
            </p><p>
                There may be a nullability constraint on the foreign key column. For most
                collections, this is implied. For unidirectional one to many associations,
                the foreign key column is nullable by default, so you might need to specify
                <tt class="literal">not-null="true"</tt>.
            </p><pre class="programlisting">&lt;key column="productSerialNumber" not-null="true"/&gt;</pre><p>
                The foreign key constraint may use <tt class="literal">ON DELETE CASCADE</tt>.
            </p><pre class="programlisting">&lt;key column="productSerialNumber" on-delete="cascade"/&gt;</pre><p>
                See the previous chapter for a full definition of the <tt class="literal">&lt;key&gt;</tt> 
                element.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-elements"></a>6.2.2.&nbsp;Collection elements</h3></div></div><div></div></div><p>
                Collections may contain almost any other Hibernate type, including all basic types,
                custom types, components, and of course, references to other entities. This is an
                important distinction: an object in a collection might be handled with "value" 
                semantics (its lifecycle fully depends on the collection owner) or it might be a
                reference to another entity, with its own lifecycle. In the latter case, only the 
                "link" between the two objects is considered to be state held by the collection. 
            </p><p>
                The contained type is referred to as the <span class="emphasis"><em>collection element type</em></span>. 
                Collection elements are mapped by <tt class="literal">&lt;element&gt;</tt> or
                <tt class="literal">&lt;composite-element&gt;</tt>, or in the case of entity references, 
                with <tt class="literal">&lt;one-to-many&gt;</tt> or <tt class="literal">&lt;many-to-many&gt;</tt>. 
                The first two map elements with value semantics, the next two are used to map entity 
                associations.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-indexed"></a>6.2.3.&nbsp;Indexed collections</h3></div></div><div></div></div><p>
                All collection mappings, except those with set and bag semantics, need an
                <span class="emphasis"><em>index column</em></span> in the collection table - a column that maps to an
                array index, or <tt class="literal">List</tt> index, or <tt class="literal">Map</tt> key. The
                index of a <tt class="literal">Map</tt> may be of any basic type, mapped with 
                <tt class="literal">&lt;map-key&gt;</tt>, it may be an entity reference mapped with 
                <tt class="literal">&lt;map-key-many-to-many&gt;</tt>, or it may be a composite type,
                mapped with <tt class="literal">&lt;composite-map-key&gt;</tt>. The index of an array or 
                list is always of type <tt class="literal">integer</tt> and is mapped using the 
                <tt class="literal">&lt;list-index&gt;</tt> element. The mapped column contains 
                sequential integers (numbered from zero, by default).
            </p><div class="programlistingco"><pre class="programlisting">&lt;list-index 
        column="column_name"                <span class="co">(1)</span>
        base="0|1|..."/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column_name</tt> (required): The name of the column holding the
                        collection index values.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">base</tt> (optional, defaults to <tt class="literal">0</tt>): The value
                        of the index column that corresponds to the first element of the list or array.
                    </p></td></tr></table></div></div><div class="programlistingco"><pre class="programlisting">&lt;map-key 
        column="column_name"                <span class="co">(1)</span>
        formula="any SQL expression"        <span class="co">(2)</span>
        type="type_name"                    <span class="co">(3)</span>
        node="@attribute-name"
        length="N"/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (optional): The name of the column holding the
                        collection index values.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">formula</tt> (optional): A SQL formula used to evaluate the
                        key of the map.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">type</tt> (reguired): The type of the map keys.
                    </p></td></tr></table></div></div><div class="programlistingco"><pre class="programlisting">&lt;map-key-many-to-many
        column="column_name"                <span class="co">(1)</span>
        formula="any SQL expression"        <span class="co">(2)</span><span class="co">(3)</span>
        class="ClassName"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (optional): The name of the foreign key
                        column for the collection index values.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">formula</tt> (optional): A SQL formula used to evaluate the
                        foreign key of the map key.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">class</tt> (required): The entity class used as the map key.
                    </p></td></tr></table></div></div><p>
                If your table doesn't have an index column, and you still wish to use <tt class="literal">List</tt> 
                as the property type, you should map the property as a Hibernate <span class="emphasis"><em>&lt;bag&gt;</em></span>.
                A bag does not retain its order when it is retrieved from the database, but it may be 
                optionally sorted or ordered.
            </p></div><p>
            There are quite a range of mappings that can be generated for collections, covering 
            many common relational models. We suggest you experiment with the schema generation tool 
            to get a feeling for how various mapping declarations translate to database tables.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-ofvalues"></a>6.2.4.&nbsp;Collections of values and many-to-many associations</h3></div></div><div></div></div><p>
            Any collection of values or many-to-many association requires a dedicated 
            <span class="emphasis"><em>collection table</em></span> with a foreign key column or columns, 
            <span class="emphasis"><em>collection element column</em></span> or columns and possibly 
            an index column or columns.
        </p><p>
            For a collection of values, we use the <tt class="literal">&lt;element&gt;</tt> tag.
        </p><div class="programlistingco"><pre class="programlisting">&lt;element
        column="column_name"                     <span class="co">(1)</span>
        formula="any SQL expression"             <span class="co">(2)</span>
        type="typename"                          <span class="co">(3)</span>
        length="L"
        precision="P"
        scale="S"
        not-null="true|false"
        unique="true|false"
        node="element-name"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (optional): The name of the column holding the
                        collection element values.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">formula</tt> (optional): An SQL formula used to evaluate the
                        element.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">type</tt> (required): The type of the collection element.
                    </p></td></tr></table></div></div><p>
            A <span class="emphasis"><em>many-to-many association</em></span> is specified using the 
            <tt class="literal">&lt;many-to-many&gt;</tt> element.
        </p><div class="programlistingco"><pre class="programlisting">&lt;many-to-many
        column="column_name"                               <span class="co">(1)</span>
        formula="any SQL expression"                       <span class="co">(2)</span>
        class="ClassName"                                  <span class="co">(3)</span>
        fetch="select|join"                                <span class="co">(4)</span>
        unique="true|false"                                <span class="co">(5)</span>
        not-found="ignore|exception"                       <span class="co">(6)</span>
        entity-name="EntityName"                           <span class="co">(7)</span>
        property-ref="propertyNameFromAssociatedClass"     <span class="co">(8)</span>
        node="element-name"
        embed-xml="true|false"
    /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (optional): The name of the element foreign key column.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">formula</tt> (optional): An SQL formula used to evaluate the element
                        foreign key value.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">class</tt> (required): The name of the associated class.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                        <tt class="literal">fetch</tt> (optional - defaults to <tt class="literal">join</tt>):
                        enables outer-join or sequential select fetching for this association. This
                        is a special case; for full eager fetching (in a single <tt class="literal">SELECT</tt>)
                        of an entity and its many-to-many relationships to other entities, you would
                        enable <tt class="literal">join</tt> fetching not only of the collection itself,
                        but also with this attribute on the <tt class="literal">&lt;many-to-many&gt;</tt>
                        nested element.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                        <tt class="literal">unique</tt> (optional): Enable the DDL generation of a unique
                        constraint for the foreign-key column. This makes the association multiplicity
                        effectively one to many.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
	                    <tt class="literal">not-found</tt> (optional - defaults to <tt class="literal">exception</tt>): 
	                    Specifies how foreign keys that reference missing rows will be handled: 
	                    <tt class="literal">ignore</tt> will treat a missing row as a null association.
	                </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                        <tt class="literal">entity-name</tt> (optional): The entity name of the associated class,
                        as an alternative to <tt class="literal">class</tt>.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                        <tt class="literal">property-ref</tt>: (optional) The name of a property of the associated 
                        class that is joined to this foreign key. If not specified, the primary key of
                        the associated class is used.
                    </p></td></tr></table></div></div><p>
            Some examples, first, a set of strings:
        </p><pre class="programlisting">&lt;set name="names" table="person_names"&gt;
    &lt;key column="person_id"/&gt;
    &lt;element column="person_name" type="string"/&gt;
&lt;/set&gt;</pre><p>
            A bag containing integers (with an iteration order determined by the
            <tt class="literal">order-by</tt> attribute):
        </p><pre class="programlisting">&lt;bag name="sizes" 
        table="item_sizes" 
        order-by="size asc"&gt;
    &lt;key column="item_id"/&gt;
    &lt;element column="size" type="integer"/&gt;
&lt;/bag&gt;</pre><p>
            An array of entities - in this case, a many to many association:
        </p><pre class="programlisting">&lt;array name="addresses" 
        table="PersonAddress" 
        cascade="persist"&gt;
    &lt;key column="personId"/&gt;
    &lt;list-index column="sortOrder"/&gt;
    &lt;many-to-many column="addressId" class="Address"/&gt;
&lt;/array&gt;</pre><p>
            A map from string indices to dates:
        </p><pre class="programlisting">&lt;map name="holidays" 
        table="holidays" 
        schema="dbo" 
        order-by="hol_name asc"&gt;
    &lt;key column="id"/&gt;
    &lt;map-key column="hol_name" type="string"/&gt;
    &lt;element column="hol_date" type="date"/&gt;
&lt;/map&gt;</pre><p>
            A list of components (discussed in the next chapter):
        </p><pre class="programlisting">&lt;list name="carComponents" 
        table="CarComponents"&gt;
    &lt;key column="carId"/&gt;
    &lt;list-index column="sortOrder"/&gt;
    &lt;composite-element class="CarComponent"&gt;
        &lt;property name="price"/&gt;
        &lt;property name="type"/&gt;
        &lt;property name="serialNumber" column="serialNum"/&gt;
    &lt;/composite-element&gt;
&lt;/list&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-onetomany"></a>6.2.5.&nbsp;One-to-many associations</h3></div></div><div></div></div><p>
            A <span class="emphasis"><em>one to many association</em></span> links the tables of two classes
            via a foreign key, with no intervening collection table. This mapping loses 
            certain semantics of normal Java collections:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    An instance of the contained entity class may not belong to more than
                    one instance of the collection
                </p></li><li><p>
                    An instance of the contained entity class may not appear at more than
                    one value of the collection index
                </p></li></ul></div><p>
            An association from <tt class="literal">Product</tt> to <tt class="literal">Part</tt> requires 
            existence of a foreign key column and possibly an index column to the <tt class="literal">Part</tt> 
            table. A <tt class="literal">&lt;one-to-many&gt;</tt> tag indicates that this is a one to many 
            association.
        </p><div class="programlistingco"><pre class="programlisting">&lt;one-to-many 
        class="ClassName"                                  <span class="co">(1)</span>
        not-found="ignore|exception"                       <span class="co">(2)</span>
        entity-name="EntityName"                           <span class="co">(3)</span>
        node="element-name"
        embed-xml="true|false"
    /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">class</tt> (required): The name of the associated class.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
		                <tt class="literal">not-found</tt> (optional - defaults to <tt class="literal">exception</tt>): 
		                Specifies how cached identifiers that reference missing rows will be handled: 
		                <tt class="literal">ignore</tt> will treat a missing row as a null association.
		            </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">entity-name</tt> (optional): The entity name of the associated class,
                        as an alternative to <tt class="literal">class</tt>.
                    </p></td></tr></table></div></div><p>
            Notice that the <tt class="literal">&lt;one-to-many&gt;</tt> element does not need to
            declare any columns. Nor is it necessary to specify the <tt class="literal">table</tt>
            name anywhere.
        </p><p>
            <span class="emphasis"><em>Very important note:</em></span> If the foreign key column of a 
            <tt class="literal">&lt;one-to-many&gt;</tt> association is declared <tt class="literal">NOT NULL</tt>, 
            you must declare the <tt class="literal">&lt;key&gt;</tt> mapping 
            <tt class="literal">not-null="true"</tt> or <span class="emphasis"><em>use a bidirectional association</em></span> 
            with the collection mapping marked <tt class="literal">inverse="true"</tt>. See the discussion 
            of bidirectional associations later in this chapter.
        </p><p>
            This example shows a map of <tt class="literal">Part</tt> entities by name (where
            <tt class="literal">partName</tt> is a persistent property of <tt class="literal">Part</tt>).
            Notice the use of a formula-based index.
        </p><pre class="programlisting">&lt;map name="parts"
        cascade="all"&gt;
    &lt;key column="productId" not-null="true"/&gt;
    &lt;map-key formula="partName"/&gt;
    &lt;one-to-many class="Part"/&gt;
&lt;/map&gt;</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-advancedmappings"></a>6.3.&nbsp;Advanced collection mappings</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-sorted"></a>6.3.1.&nbsp;Sorted collections</h3></div></div><div></div></div><p>
            Hibernate supports collections implementing <tt class="literal">java.util.SortedMap</tt> and
            <tt class="literal">java.util.SortedSet</tt>. You must specify a comparator in the mapping file:
        </p><pre class="programlisting">&lt;set name="aliases" 
            table="person_aliases" 
            sort="natural"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="string"/&gt;
&lt;/set&gt;

&lt;map name="holidays" sort="my.custom.HolidayComparator"&gt;
    &lt;key column="year_id"/&gt;
    &lt;map-key column="hol_name" type="string"/&gt;
    &lt;element column="hol_date" type="date"/&gt;
&lt;/map&gt;</pre><p>
            Allowed values of the <tt class="literal">sort</tt> attribute are <tt class="literal">unsorted</tt>,
            <tt class="literal">natural</tt> and the name of a class implementing
            <tt class="literal">java.util.Comparator</tt>.
        </p><p>
            Sorted collections actually behave like <tt class="literal">java.util.TreeSet</tt> or
            <tt class="literal">java.util.TreeMap</tt>.
        </p><p>
            If you want the database itself to order the collection elements use the
            <tt class="literal">order-by</tt> attribute of <tt class="literal">set</tt>, <tt class="literal">bag</tt>
            or <tt class="literal">map</tt> mappings. This solution is only available under
            JDK 1.4 or higher (it is implemented using <tt class="literal">LinkedHashSet</tt> or
            <tt class="literal">LinkedHashMap</tt>). This performs the ordering in the SQL query, 
            not in memory.
        </p><pre class="programlisting">&lt;set name="aliases" table="person_aliases" order-by="lower(name) asc"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="string"/&gt;
&lt;/set&gt;

&lt;map name="holidays" order-by="hol_date, hol_name"&gt;
    &lt;key column="year_id"/&gt;
    &lt;map-key column="hol_name" type="string"/&gt;
    &lt;element column="hol_date type="date"/&gt;
&lt;/map&gt;</pre><p>
            Note that the value of the <tt class="literal">order-by</tt> attribute is an SQL ordering, not
            a HQL ordering!
        </p><p>
            Associations may even be sorted by some arbitrary criteria at runtime using a collection
            <tt class="literal">filter()</tt>.
        </p><pre class="programlisting">sortedUsers = s.createFilter( group.getUsers(), "order by this.name" ).list();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-bidirectional"></a>6.3.2.&nbsp;Bidirectional associations</h3></div></div><div></div></div><p>
            A <span class="emphasis"><em>bidirectional association</em></span> allows navigation from both
            "ends" of the association. Two kinds of bidirectional association are
            supported:

            </p><div class="variablelist"><dl><dt><span class="term">one-to-many</span></dt><dd><p>
                            set or bag valued at one end, single-valued at the other
                        </p></dd><dt><span class="term">many-to-many</span></dt><dd><p>
                            set or bag valued at both ends
                        </p></dd></dl></div><p>

        </p><p>
            You may specify a bidirectional many-to-many association simply by mapping two
            many-to-many associations to the same database table and declaring one end as
            <span class="emphasis"><em>inverse</em></span> (which one is your choice, but it can not be an
            indexed collection).
        </p><p>
            Here's an example of a bidirectional many-to-many association; each category can
            have many items and each item can be in many categories:
        </p><pre class="programlisting">&lt;class name="Category"&gt;
    &lt;id name="id" column="CATEGORY_ID"/&gt;
    ...
    &lt;bag name="items" table="CATEGORY_ITEM"&gt;
        &lt;key column="CATEGORY_ID"/&gt;
        &lt;many-to-many class="Item" column="ITEM_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;

&lt;class name="Item"&gt;
    &lt;id name="id" column="CATEGORY_ID"/&gt;
    ...

    &lt;!-- inverse end --&gt;
    &lt;bag name="categories" table="CATEGORY_ITEM" inverse="true"&gt;
        &lt;key column="ITEM_ID"/&gt;
        &lt;many-to-many class="Category" column="CATEGORY_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;</pre><p>
            Changes made only to the inverse end of the association are <span class="emphasis"><em>not</em></span>
            persisted. This means that Hibernate has two representations in memory for every
            bidirectional association, one link from A to B and another link from B to A. This
            is easier to understand if you think about the Java object model and how we create
            a many-to-many relationship in Java:
        </p><pre class="programlisting">
category.getItems().add(item);          // The category now "knows" about the relationship
item.getCategories().add(category);     // The item now "knows" about the relationship

session.persist(item);                   // The relationship won't be saved!
session.persist(category);               // The relationship will be saved</pre><p>
            The non-inverse side is used to save the in-memory representation to the database.
        </p><p>
            You may define a bidirectional one-to-many association by mapping a one-to-many association
            to the same table column(s) as a many-to-one association and declaring the many-valued
            end <tt class="literal">inverse="true"</tt>.
        </p><pre class="programlisting">&lt;class name="Parent"&gt;
    &lt;id name="id" column="parent_id"/&gt;
    ....
    &lt;set name="children" inverse="true"&gt;
        &lt;key column="parent_id"/&gt;
        &lt;one-to-many class="Child"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Child"&gt;
    &lt;id name="id" column="child_id"/&gt;
    ....
    &lt;many-to-one name="parent" 
        class="Parent" 
        column="parent_id"
        not-null="true"/&gt;
&lt;/class&gt;</pre><p>
            Mapping one end of an association with <tt class="literal">inverse="true"</tt> doesn't
            affect the operation of cascades, these are orthogonal concepts!
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-indexedbidirectional"></a>6.3.3.&nbsp;Bidirectional associations with indexed collections</h3></div></div><div></div></div><p>
            A bidirectional association where one end is represented as a <tt class="literal">&lt;list&gt;</tt>
            or <tt class="literal">&lt;map&gt;</tt> requires special consideration. If there is a property of
            the child class which maps to the index column, no problem, we can continue using 
            <tt class="literal">inverse="true"</tt> on the collection mapping:
        </p><pre class="programlisting">&lt;class name="Parent"&gt;
    &lt;id name="id" column="parent_id"/&gt;
    ....
    &lt;map name="children" inverse="true"&gt;
        &lt;key column="parent_id"/&gt;
        &lt;map-key column="name" 
            type="string"/&gt;
        &lt;one-to-many class="Child"/&gt;
    &lt;/map&gt;
&lt;/class&gt;

&lt;class name="Child"&gt;
    &lt;id name="id" column="child_id"/&gt;
    ....
    &lt;property name="name" 
        not-null="true"/&gt;
    &lt;many-to-one name="parent" 
        class="Parent" 
        column="parent_id"
        not-null="true"/&gt;
&lt;/class&gt;</pre><p>
            But, if there is no such property on the child class, we can't think of the association as
            truly bidirectional (there is information available at one end of the association that is
            not available at the other end). In this case, we can't map the collection 
            <tt class="literal">inverse="true"</tt>. Instead, we could use the following mapping:
        </p><pre class="programlisting">&lt;class name="Parent"&gt;
    &lt;id name="id" column="parent_id"/&gt;
    ....
    &lt;map name="children"&gt;
        &lt;key column="parent_id"
            not-null="true"/&gt;
        &lt;map-key column="name" 
            type="string"/&gt;
        &lt;one-to-many class="Child"/&gt;
    &lt;/map&gt;
&lt;/class&gt;

&lt;class name="Child"&gt;
    &lt;id name="id" column="child_id"/&gt;
    ....
    &lt;many-to-one name="parent" 
        class="Parent" 
        column="parent_id"
        insert="false"
        update="false"
        not-null="true"/&gt;
&lt;/class&gt;</pre><p>
           Note that in this mapping, the collection-valued end of the association is responsible for 
           updates to the foreign key. TODO: Does this really result in some unnecessary update statements?
       </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-ternary"></a>6.3.4.&nbsp;Ternary associations</h3></div></div><div></div></div><p>
            There are three possible approaches to mapping a ternary association. One is to use a 
            <tt class="literal">Map</tt> with an association as its index:
        </p><pre class="programlisting">&lt;map name="contracts"&gt;
    &lt;key column="employer_id" not-null="true"/&gt;
    &lt;map-key-many-to-many column="employee_id" class="Employee"/&gt;
    &lt;one-to-many class="Contract"/&gt;
&lt;/map&gt;</pre><pre class="programlisting">&lt;map name="connections"&gt;
    &lt;key column="incoming_node_id"/&gt;
    &lt;map-key-many-to-many column="outgoing_node_id" class="Node"/&gt;
    &lt;many-to-many column="connection_id" class="Connection"/&gt;
&lt;/map&gt;</pre><p>
            A second approach is to simply remodel the association as an entity class. This
            is the approach we use most commonly.
        </p><p>
            A final alternative is to use composite elements, which we will discuss later. 
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-idbag"></a>6.3.5.&nbsp;<tt class="literal">Using an &lt;idbag&gt;</tt></h3></div></div><div></div></div><p>
            If you've fully embraced our view that composite keys are a bad thing and that
            entities should have synthetic identifiers (surrogate keys), then you might
            find it a bit odd that the many to many associations and collections of values
            that we've shown so far all map to tables with composite keys! Now, this point
            is quite arguable; a pure association table doesn't seem to benefit much from
            a surrogate key (though a collection of composite values <span class="emphasis"><em>might</em></span>).
            Nevertheless, Hibernate provides a feature that allows you to map many to many
            associations and collections of values to a table with a surrogate key.
        </p><p>
            The <tt class="literal">&lt;idbag&gt;</tt> element lets you map a <tt class="literal">List</tt>
            (or <tt class="literal">Collection</tt>) with bag semantics.
        </p><pre class="programlisting">&lt;idbag name="lovers" table="LOVERS"&gt;
    &lt;collection-id column="ID" type="long"&gt;
        &lt;generator class="sequence"/&gt;
    &lt;/collection-id&gt;
    &lt;key column="PERSON1"/&gt;
    &lt;many-to-many column="PERSON2" class="Person" fetch="join"/&gt;
&lt;/idbag&gt;</pre><p>
            As you can see, an <tt class="literal">&lt;idbag&gt;</tt> has a synthetic id generator,
            just like an entity class! A different surrogate key is assigned to each collection
            row. Hibernate does not provide any mechanism to discover the surrogate key value
            of a particular row, however.
        </p><p>
            Note that the update performance of an <tt class="literal">&lt;idbag&gt;</tt> is
            <span class="emphasis"><em>much</em></span> better than a regular <tt class="literal">&lt;bag&gt;</tt>!
            Hibernate can locate individual rows efficiently and update or delete them
            individually, just like a list, map or set.
        </p><p>
            In the current implementation, the <tt class="literal">native</tt> identifier generation
            strategy is not supported for <tt class="literal">&lt;idbag&gt;</tt> collection identifiers.
        </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-example"></a>6.4.&nbsp;Collection examples</h2></div></div><div></div></div><p>
            The previous sections are pretty confusing. So lets look at an example. This
            class:
        </p><pre class="programlisting">package eg;
import java.util.Set;

public class Parent {
    private long id;
    private Set children;

    public long getId() { return id; }
    private void setId(long id) { this.id=id; }

    private Set getChildren() { return children; }
    private void setChildren(Set children) { this.children=children; }

    ....
    ....
}</pre><p>
            has a collection of <tt class="literal">Child</tt> instances. If each
            child has at most one parent, the most natural mapping is a 
            one-to-many association:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            This maps to the following table definitions:
        </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null primary key, name varchar(255), parent_id bigint )
alter table child add constraint childfk0 (parent_id) references parent</pre><p>
            If the parent is <span class="emphasis"><em>required</em></span>, use a bidirectional one-to-many
            association:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" inverse="true"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
        &lt;many-to-one name="parent" class="Parent" column="parent_id" not-null="true"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            Notice the <tt class="literal">NOT NULL</tt> constraint:
        </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null
                     primary key,
                     name varchar(255),
                     parent_id bigint not null )
alter table child add constraint childfk0 (parent_id) references parent</pre><p>
            Alternatively, if you absolutely insist that this association should be unidirectional,
            you can declare the <tt class="literal">NOT NULL</tt> constraint on the <tt class="literal">&lt;key&gt;</tt>
            mapping:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children"&gt;
            &lt;key column="parent_id" not-null="true"/&gt;
            &lt;one-to-many class="Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            On the other hand, if a child might have multiple parents, a many-to-many
            association is appropriate:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" table="childset"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;many-to-many class="Child" column="child_id"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            Table definitions:
        </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null primary key, name varchar(255) )
create table childset ( parent_id bigint not null,
                        child_id bigint not null,
                        primary key ( parent_id, child_id ) )
alter table childset add constraint childsetfk0 (parent_id) references parent
alter table childset add constraint childsetfk1 (child_id) references child</pre><p>
            For more examples and a complete walk-through a parent/child relationship mapping,
            see <a href="#example-parentchild" title="Chapter&nbsp;21.&nbsp;Example: Parent/Child">Chapter&nbsp;21, <i>Example: Parent/Child</i></a>.
        </p><p>
            Even more exotic association mappings are possible, we will catalog all possibilities
            in the next chapter.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="associations"></a>Chapter&nbsp;7.&nbsp;Association Mappings</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="assoc-intro"></a>7.1.&nbsp;Introduction</h2></div></div><div></div></div><p>
            Association mappings are the often most difficult thing to get right. In
            this section we'll go through the canonical cases one by one, starting
            with unidirectional mappings, and then considering the bidirectional cases.
            We'll use <tt class="literal">Person</tt> and <tt class="literal">Address</tt> in all
            the examples.
        </p><p>
        	We'll classify associations by whether or not they map to an intervening
        	join table, and by multiplicity.
        </p><p>
        	Nullable foreign keys are not considered good practice in traditional data
        	modelling, so all our examples use not null foreign keys. This is not a
        	requirement of Hibernate, and the mappings will all work if you drop the
        	nullability constraints.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="assoc-unidirectional"></a>7.2.&nbsp;Unidirectional associations</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-unidirectional-m21"></a>7.2.1.&nbsp;many to one</h3></div></div><div></div></div><p>
            A <span class="emphasis"><em>unidirectional many-to-one association</em></span> is the most 
            common kind of unidirectional association.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-unidirectional-121"></a>7.2.2.&nbsp;one to one</h3></div></div><div></div></div><p>
            A <span class="emphasis"><em>unidirectional one-to-one association on a foreign key</em></span>
            is almost identical. The only difference is the column unique constraint.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId" 
        unique="true"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre><p>
            A <span class="emphasis"><em>unidirectional one-to-one association on a primary key</em></span>
            usually uses a special id generator. (Notice that we've reversed the direction
            of the association in this example.)
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"&gt;person&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    &lt;one-to-one name="person" constrained="true"/&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table Address ( personId bigint not null primary key )
        </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-unidirectional-12m"></a>7.2.3.&nbsp;one to many</h3></div></div><div></div></div><p>
            A <span class="emphasis"><em>unidirectional one-to-many association on a foreign key</em></span> 
            is a very unusual case, and is not really recommended.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses"&gt;
        &lt;key column="personId" 
            not-null="true"/&gt;
        &lt;one-to-many class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table Address ( addressId bigint not null primary key, personId bigint not null )
        </pre><p>
            We think it's better to use a join table for this kind of association.
        </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="assoc-unidirectional-join"></a>7.3.&nbsp;Unidirectional associations with join tables</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-unidirectional-join-12m"></a>7.3.1.&nbsp;one to many</h3></div></div><div></div></div><p>
            A <span class="emphasis"><em>unidirectional one-to-many association on a join table</em></span> 
            is much preferred. Notice that by specifying <tt class="literal">unique="true"</tt>,
            we have changed the multiplicity from many-to-many to one-to-many.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses" table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            unique="true"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId not null, addressId bigint not null primary key )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-unidirectional-join-m21"></a>7.3.2.&nbsp;many to one</h3></div></div><div></div></div><p>
            A <span class="emphasis"><em>unidirectional many-to-one association on a join table</em></span> 
            is quite common when the association is optional.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"&gt;
        &lt;key column="personId" unique="true"/&gt;
        &lt;many-to-one name="address"
            column="addressId" 
            not-null="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null primary key, addressId bigint not null )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-unidirectional-join-121"></a>7.3.3.&nbsp;one to one</h3></div></div><div></div></div><p>
            A <span class="emphasis"><em>unidirectional one-to-one association on a join table</em></span> 
            is extremely unusual, but possible.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"&gt;
        &lt;key column="personId" 
            unique="true"/&gt;
        &lt;many-to-one name="address"
            column="addressId" 
            not-null="true"
            unique="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-unidirectional-join-m2m"></a>7.3.4.&nbsp;many to many</h3></div></div><div></div></div><p>
            Finally, we have a <span class="emphasis"><em>unidirectional many-to-many association</em></span>.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses" table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null, addressId bigint not null, primary key (personId, addressId) )
create table Address ( addressId bigint not null primary key )
        </pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="assoc-bidirectional"></a>7.4.&nbsp;Bidirectional associations</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-bidirectional-m21"></a>7.4.1.&nbsp;one to many / many to one</h3></div></div><div></div></div><p>
            A <span class="emphasis"><em>bidirectional many-to-one association</em></span> is the
            most common kind of association. (This is the standard parent/child
            relationship.)
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="people" inverse="true"&gt;
        &lt;key column="addressId"/&gt;
        &lt;one-to-many class="Person"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null )
create table Address ( addressId bigint not null primary key )
        </pre><p>
            If you use a <tt class="literal">List</tt> (or other indexed collection) you need
            to set the <tt class="literal">key</tt> column of the foreign key to <tt class="literal">not null</tt>,
            and let Hibernate manage the association from the collections side to maintain the index
            of each element (making the other side virtually inverse by setting
            <tt class="literal">update="false"</tt> and <tt class="literal">insert="false"</tt>):
        </p><pre class="programlisting">&lt;class name="Person"&gt;
   &lt;id name="id"/&gt;
   ...
   &lt;many-to-one name="address"
      column="addressId"
      not-null="true"
      insert="false"
      update="false"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
   &lt;id name="id"/&gt;
   ...
   &lt;list name="people"&gt;
      &lt;key column="addressId" not-null="true"/&gt;
      &lt;list-index column="peopleIdx"/&gt;
      &lt;one-to-many class="Person"/&gt;
   &lt;/list&gt;
&lt;/class&gt;</pre><p>
                It is important that you define <tt class="literal">not-null="true"</tt> on the
                <tt class="literal">&lt;key&gt;</tt> element of the collection mapping if the
                underlying foreign key column is <tt class="literal">NOT NULL</tt>. Don't only
                declare <tt class="literal">not-null="true"</tt> on a possible nested
                <tt class="literal">&lt;column&gt;</tt> element, but on the <tt class="literal">&lt;key&gt;</tt>
                element.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-bidirectional-121"></a>7.4.2.&nbsp;one to one</h3></div></div><div></div></div><p>
            A <span class="emphasis"><em>bidirectional one-to-one association on a foreign key</em></span>
            is quite common.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId" 
        unique="true"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
   &lt;one-to-one name="person" 
        property-ref="address"/&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre><p>
            A <span class="emphasis"><em>bidirectional one-to-one association on a primary key</em></span>
            uses the special id generator.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;one-to-one name="address"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"&gt;person&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    &lt;one-to-one name="person" 
        constrained="true"/&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table Address ( personId bigint not null primary key )
        </pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="assoc-bidirectional-join"></a>7.5.&nbsp;Bidirectional associations with join tables</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-bidirectional-join-12m"></a>7.5.1.&nbsp;one to many / many to one</h3></div></div><div></div></div><p>
            A <span class="emphasis"><em>bidirectional one-to-many association on a join table</em></span>.
            Note that the <tt class="literal">inverse="true"</tt> can go on either end of the
            association, on the collection, or on the join.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses" 
        table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            unique="true"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        inverse="true" 
        optional="true"&gt;
        &lt;key column="addressId"/&gt;
        &lt;many-to-one name="person"
            column="personId"
            not-null="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null, addressId bigint not null primary key )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-bidirectional-join-121"></a>7.5.2.&nbsp;one to one</h3></div></div><div></div></div><p>
            A <span class="emphasis"><em>bidirectional one-to-one association on a join table</em></span> 
            is extremely unusual, but possible.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"&gt;
        &lt;key column="personId" 
            unique="true"/&gt;
        &lt;many-to-one name="address"
            column="addressId" 
            not-null="true"
            unique="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"
        inverse="true"&gt;
        &lt;key column="addressId" 
            unique="true"/&gt;
        &lt;many-to-one name="person"
            column="personId" 
            not-null="true"
            unique="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-bidirectional-join-m2m"></a>7.5.3.&nbsp;many to many</h3></div></div><div></div></div><p>
            Finally, we have a <span class="emphasis"><em>bidirectional many-to-many association</em></span>.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses" table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="people" inverse="true" table="PersonAddress"&gt;
        &lt;key column="addressId"/&gt;
        &lt;many-to-many column="personId"
            class="Person"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null, addressId bigint not null, primary key (personId, addressId) )
create table Address ( addressId bigint not null primary key )
        </pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="assoc-complex"></a>7.6.&nbsp;More complex association mappings</h2></div></div><div></div></div><p>
            More complex association joins are <span class="emphasis"><em>extremely</em></span> rare. 
            Hibernate makes it possible to handle more complex situations using
            SQL fragments embedded in the mapping document. For example, if a table
            with historical account information data defines 
            <tt class="literal">accountNumber</tt>, <tt class="literal">effectiveEndDate</tt> 
            and <tt class="literal">effectiveStartDate</tt>columns, mapped as follows:
        </p><pre class="programlisting">&lt;properties name="currentAccountKey"&gt;
    &lt;property name="accountNumber" type="string" not-null="true"/&gt;
    &lt;property name="currentAccount" type="boolean"&gt;
        &lt;formula&gt;case when effectiveEndDate is null then 1 else 0 end&lt;/formula&gt;
    &lt;/property&gt;
&lt;/properties&gt;
&lt;property name="effectiveEndDate" type="date"/&gt;
&lt;property name="effectiveStateDate" type="date" not-null="true"/&gt;</pre><p>
            Then we can map an association to the <span class="emphasis"><em>current</em></span> instance 
            (the one with null <tt class="literal">effectiveEndDate</tt>) using:
        </p><pre class="programlisting">&lt;many-to-one name="currentAccountInfo" 
        property-ref="currentAccountKey"
        class="AccountInfo"&gt;
    &lt;column name="accountNumber"/&gt;
    &lt;formula&gt;'1'&lt;/formula&gt;
&lt;/many-to-one&gt;</pre><p>
            In a more complex example, imagine that the association between 
            <tt class="literal">Employee</tt> and <tt class="literal">Organization</tt> is maintained
            in an <tt class="literal">Employment</tt> table full of historical employment data.
            Then an association to the employee's <span class="emphasis"><em>most recent</em></span> employer
            (the one with the most recent <tt class="literal">startDate</tt>) might be mapped this way:
        </p><pre class="programlisting">&lt;join&gt;
    &lt;key column="employeeId"/&gt;
    &lt;subselect&gt;
        select employeeId, orgId 
        from Employments 
        group by orgId 
        having startDate = max(startDate)
    &lt;/subselect&gt;
    &lt;many-to-one name="mostRecentEmployer" 
            class="Organization" 
            column="orgId"/&gt;
&lt;/join&gt;</pre><p>
            You can get quite creative with this functionality, but it is usually more practical 
            to handle these kinds of cases using HQL or a criteria query.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="components"></a>Chapter&nbsp;8.&nbsp;Component Mapping</h2></div></div><div></div></div><p>
        The notion of a <span class="emphasis"><em>component</em></span> is re-used in several different contexts,
        for different purposes, throughout Hibernate.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-dependentobjects"></a>8.1.&nbsp;Dependent objects</h2></div></div><div></div></div><p>
            A component is a contained object that is persisted as a value type, not an entity
            reference. The term "component" refers to the object-oriented notion of composition
            (not to architecture-level components). For example, you might model a person like this:
        </p><pre class="programlisting">public class Person {
    private java.util.Date birthday;
    private Name name;
    private String key;
    public String getKey() {
        return key;
    }
    private void setKey(String key) {
        this.key=key;
    }
    public java.util.Date getBirthday() {
        return birthday;
    }
    public void setBirthday(java.util.Date birthday) {
        this.birthday = birthday;
    }
    public Name getName() {
        return name;
    }
    public void setName(Name name) {
        this.name = name;
    }
    ......
    ......
}</pre><pre class="programlisting">public class Name {
    char initial;
    String first;
    String last;
    public String getFirst() {
        return first;
    }
    void setFirst(String first) {
        this.first = first;
    }
    public String getLast() {
        return last;
    }
    void setLast(String last) {
        this.last = last;
    }
    public char getInitial() {
        return initial;
    }
    void setInitial(char initial) {
        this.initial = initial;
    }
}</pre><p>
            Now <tt class="literal">Name</tt> may be persisted as a component of
            <tt class="literal">Person</tt>. Notice that <tt class="literal">Name</tt> defines getter
            and setter methods for its persistent properties, but doesn't need to declare
            any interfaces or identifier properties.
        </p><p>
            Our Hibernate mapping would look like:
        </p><pre class="programlisting">&lt;class name="eg.Person" table="person"&gt;
    &lt;id name="Key" column="pid" type="string"&gt;
        &lt;generator class="uuid"/&gt;
    &lt;/id&gt;
    &lt;property name="birthday" type="date"/&gt;
    &lt;component name="Name" class="eg.Name"&gt; &lt;!-- class attribute optional --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/component&gt;
&lt;/class&gt;</pre><p>
            The person table would have the columns <tt class="literal">pid</tt>,
            <tt class="literal">birthday</tt>,
            <tt class="literal">initial</tt>,
            <tt class="literal">first</tt> and
            <tt class="literal">last</tt>.
        </p><p>
            Like all value types, components do not support shared references. In other words, two
            persons could have the same name, but the two person objects would contain two independent
            name ojects, only "the same" by value. The null value semantics of a component are
            <span class="emphasis"><em>ad hoc</em></span>. When reloading the containing object, Hibernate will assume
            that if all component columns are null, then the entire component is null. This should
            be okay for most purposes.
        </p><p>
            The properties of a component may be of any Hibernate type (collections, many-to-one 
            associations, other components, etc). Nested components should <span class="emphasis"><em>not</em></span> 
            be considered an exotic usage. Hibernate is intended to support a very fine-grained 
            object model.
        </p><p>
            The <tt class="literal">&lt;component&gt;</tt> element allows a <tt class="literal">&lt;parent&gt;</tt>
            subelement that maps a property of the component class as a reference back to the
            containing entity.
        </p><pre class="programlisting">&lt;class name="eg.Person" table="person"&gt;
    &lt;id name="Key" column="pid" type="string"&gt;
        &lt;generator class="uuid"/&gt;
    &lt;/id&gt;
    &lt;property name="birthday" type="date"/&gt;
    &lt;component name="Name" class="eg.Name" unique="true"&gt;
        &lt;parent name="namedPerson"/&gt; &lt;!-- reference back to the Person --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/component&gt;
&lt;/class&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-incollections"></a>8.2.&nbsp;Collections of dependent objects</h2></div></div><div></div></div><p>
            Collections of components are supported (eg. an array of type
            <tt class="literal">Name</tt>). Declare your component collection by
            replacing the <tt class="literal">&lt;element&gt;</tt> tag with a
            <tt class="literal">&lt;composite-element&gt;</tt> tag.
        </p><pre class="programlisting">&lt;set name="someNames" table="some_names" lazy="true"&gt;
    &lt;key column="id"/&gt;
    &lt;composite-element class="eg.Name"&gt; &lt;!-- class attribute required --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/composite-element&gt;
&lt;/set&gt;</pre><p>
            Note: if you define a <tt class="literal">Set</tt> of composite elements, it is 
            very important to implement <tt class="literal">equals()</tt> and 
            <tt class="literal">hashCode()</tt> correctly.
        </p><p>
            Composite elements may contain components but not collections. If your
            composite element itself contains 
            components, use the <tt class="literal">&lt;nested-composite-element&gt;</tt> 
            tag. This is a pretty exotic case - a collection of components which 
            themselves have components. By this stage you should be asking yourself 
            if a one-to-many association is more appropriate. Try remodelling the 
            composite element as an entity - but note that even though the Java model 
            is the same, the relational model and persistence semantics are still 
            slightly different.
        </p><p>
            Please note that a composite element mapping doesn't support null-able properties
            if you're using a <tt class="literal">&lt;set&gt;</tt>. Hibernate
            has to use each columns value to identify a record when deleting objects
            (there is no separate primary key column in the composite element table),
            which is not possible with null values. You have to either use only
            not-null properties in a composite-element or choose a
            <tt class="literal">&lt;list&gt;</tt>, <tt class="literal">&lt;map&gt;</tt>,
            <tt class="literal">&lt;bag&gt;</tt> or <tt class="literal">&lt;idbag&gt;</tt>.
        </p><p>
            A special case of a composite element is a composite element with a nested
            <tt class="literal">&lt;many-to-one&gt;</tt> element. A mapping like this allows
            you to map extra columns of a many-to-many association table to the
            composite element class. The following is a many-to-many association
            from <tt class="literal">Order</tt> to <tt class="literal">Item</tt> where 
            <tt class="literal">purchaseDate</tt>, <tt class="literal">price</tt> and
            <tt class="literal">quantity</tt> are properties of the association:
        </p><pre class="programlisting">&lt;class name="eg.Order" .... &gt;
    ....
    &lt;set name="purchasedItems" table="purchase_items" lazy="true"&gt;
        &lt;key column="order_id"&gt;
        &lt;composite-element class="eg.Purchase"&gt;
            &lt;property name="purchaseDate"/&gt;
            &lt;property name="price"/&gt;
            &lt;property name="quantity"/&gt;
            &lt;many-to-one name="item" class="eg.Item"/&gt; &lt;!-- class attribute is optional --&gt;
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
            Of course, there can't be a reference to the purchae on the other side, for
            bidirectional association navigation. Remember that components are value types and
            don't allow shared references. A single <tt class="literal">Purchase</tt> can be in the
            set of an <tt class="literal">Order</tt>, but it can't be referenced by the <tt class="literal">Item</tt>
            at the same time.
        </p><p>Even ternary (or quaternary, etc) associations are possible:</p><pre class="programlisting">&lt;class name="eg.Order" .... &gt;
    ....
    &lt;set name="purchasedItems" table="purchase_items" lazy="true"&gt;
        &lt;key column="order_id"&gt;
        &lt;composite-element class="eg.OrderLine"&gt;
            &lt;many-to-one name="purchaseDetails class="eg.Purchase"/&gt;
            &lt;many-to-one name="item" class="eg.Item"/&gt;
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
            Composite elements may appear in queries using the same syntax as
            associations to other entities.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-asmapindex"></a>8.3.&nbsp;Components as Map indices</h2></div></div><div></div></div><p>
            The <tt class="literal">&lt;composite-map-key&gt;</tt> element lets you map a
            component class as the key of a <tt class="literal">Map</tt>. Make sure you override
            <tt class="literal">hashCode()</tt> and <tt class="literal">equals()</tt> correctly on
            the component class.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-compositeid"></a>8.4.&nbsp;Components as composite identifiers</h2></div></div><div></div></div><p>
            You may use a component as an identifier of an entity class. Your component
            class must satisfy certain requirements:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    It must implement <tt class="literal">java.io.Serializable</tt>.
                </p></li><li><p>
                    It must re-implement <tt class="literal">equals()</tt> and
                    <tt class="literal">hashCode()</tt>, consistently with the database's 
                    notion of composite key equality.
                </p></li></ul></div><p>
            <span class="emphasis"><em>Note: in Hibernate3, the second requirement is not an absolutely hard
            requirement of Hibernate. But do it anyway.</em></span>
        </p><p>
            You can't use an <tt class="literal">IdentifierGenerator</tt> to generate composite keys.
            Instead the application must assign its own identifiers.
        </p><p>
            Use the <tt class="literal">&lt;composite-id&gt;</tt> tag (with nested 
            <tt class="literal">&lt;key-property&gt;</tt> elements) in place of the usual 
            <tt class="literal">&lt;id&gt;</tt> declaration. For example, the
            <tt class="literal">OrderLine</tt> class has a primary key that depends upon
            the (composite) primary key of <tt class="literal">Order</tt>.
        </p><pre class="programlisting">&lt;class name="OrderLine"&gt;
    
    &lt;composite-id name="id" class="OrderLineId"&gt;
        &lt;key-property name="lineId"/&gt;
        &lt;key-property name="orderId"/&gt;
        &lt;key-property name="customerId"/&gt;
    &lt;/composite-id&gt;
    
    &lt;property name="name"/&gt;
    
    &lt;many-to-one name="order" class="Order"
            insert="false" update="false"&gt;
        &lt;column name="orderId"/&gt;
        &lt;column name="customerId"/&gt;
    &lt;/many-to-one&gt;
    ....
    
&lt;/class&gt;</pre><p>
            Now, any foreign keys referencing the <tt class="literal">OrderLine</tt> table are also 
            composite. You must declare this in your mappings for other classes. An association 
            to <tt class="literal">OrderLine</tt> would be mapped like this:
        </p><pre class="programlisting">&lt;many-to-one name="orderLine" class="OrderLine"&gt;
&lt;!-- the "class" attribute is optional, as usual --&gt;
    &lt;column name="lineId"/&gt;
    &lt;column name="orderId"/&gt;
    &lt;column name="customerId"/&gt;
&lt;/many-to-one&gt;</pre><p>
            (Note that the <tt class="literal">&lt;column&gt;</tt> tag is an alternative to the 
            <tt class="literal">column</tt> attribute everywhere.) 
        </p><p>
            A <tt class="literal">many-to-many</tt> association to <tt class="literal">OrderLine</tt> also
            uses the composite foreign key:
        </p><pre class="programlisting">&lt;set name="undeliveredOrderLines"&gt;
    &lt;key column name="warehouseId"/&gt;
    &lt;many-to-many class="OrderLine"&gt;
        &lt;column name="lineId"/&gt;
        &lt;column name="orderId"/&gt;
        &lt;column name="customerId"/&gt;
    &lt;/many-to-many&gt;
&lt;/set&gt;</pre><p>
            The collection of <tt class="literal">OrderLine</tt>s in <tt class="literal">Order</tt> would 
            use:
        </p><pre class="programlisting">&lt;set name="orderLines" inverse="true"&gt;
    &lt;key&gt;
        &lt;column name="orderId"/&gt;
        &lt;column name="customerId"/&gt;
    &lt;/key&gt;
    &lt;one-to-many class="OrderLine"/&gt;
&lt;/set&gt;</pre><p>
            (The <tt class="literal">&lt;one-to-many&gt;</tt> element, as usual, declares no columns.)
        </p><p>
            If <tt class="literal">OrderLine</tt> itself owns a collection, it also has a composite 
            foreign key.
        </p><pre class="programlisting">&lt;class name="OrderLine"&gt;
    ....
    ....
    &lt;list name="deliveryAttempts"&gt;
        &lt;key&gt;   &lt;!-- a collection inherits the composite key type --&gt;
            &lt;column name="lineId"/&gt;
            &lt;column name="orderId"/&gt;
            &lt;column name="customerId"/&gt;
        &lt;/key&gt;
        &lt;list-index column="attemptId" base="1"/&gt;
        &lt;composite-element class="DeliveryAttempt"&gt;
            ...
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-dynamic"></a>8.5.&nbsp;Dynamic components</h2></div></div><div></div></div><p>
            You may even map a property of type <tt class="literal">Map</tt>:
        </p><pre class="programlisting">&lt;dynamic-component name="userAttributes"&gt;
    &lt;property name="foo" column="FOO" type="string"/&gt;
    &lt;property name="bar" column="BAR" type="integer"/&gt;
    &lt;many-to-one name="baz" class="Baz" column="BAZ_ID"/&gt;
&lt;/dynamic-component&gt;</pre><p>
            The semantics of a <tt class="literal">&lt;dynamic-component&gt;</tt> mapping are identical
            to <tt class="literal">&lt;component&gt;</tt>. The advantage of this kind of mapping is 
            the ability to determine the actual properties of the bean at deployment time, just
            by editing the mapping document. Runtime manipulation of the mapping document is 
            also possible, using a DOM parser. Even better, you can access (and change) Hibernate's
            configuration-time metamodel via the <tt class="literal">Configuration</tt> object.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="inheritance"></a>Chapter&nbsp;9.&nbsp;Inheritance Mapping</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="inheritance-strategies"></a>9.1.&nbsp;The Three Strategies</h2></div></div><div></div></div><p>
            Hibernate supports the three basic inheritance mapping strategies:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
            table per class hierarchy
        </p></li><li><p>
            table per subclass
        </p></li><li><p>
            table per concrete class
        </p></li></ul></div><p>
            In addition, Hibernate supports a fourth, slightly different kind of 
            polymorphism:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
            implicit polymorphism
        </p></li></ul></div><p>
            It is possible to use different mapping strategies for different
            branches of the same inheritance hierarchy, and then make use of implicit
            polymorphism to achieve polymorphism across the whole hierarchy. However, 
            Hibernate does not support mixing <tt class="literal">&lt;subclass&gt;</tt>,
            and <tt class="literal">&lt;joined-subclass&gt;</tt> and 
            <tt class="literal">&lt;union-subclass&gt;</tt> mappings under the same root
            <tt class="literal">&lt;class&gt;</tt> element. It is possible to mix together
            the table per hierarchy and table per subclass strategies, under the
            the same <tt class="literal">&lt;class&gt;</tt> element, by combining the 
            <tt class="literal">&lt;subclass&gt;</tt> and <tt class="literal">&lt;join&gt;</tt>
            elements (see below).
        </p><p>
             It is possible to define <tt class="literal">subclass</tt>, <tt class="literal">union-subclass</tt>,
             and <tt class="literal">joined-subclass</tt> mappings in separate mapping documents, directly beneath
             <tt class="literal">hibernate-mapping</tt>. This allows you to extend a class hierachy just by adding
             a new mapping file. You must specify an <tt class="literal">extends</tt> attribute in the subclass mapping,
             naming a previously mapped superclass. Note: Previously this feature made the ordering of the mapping
             documents important. Since Hibernate3, the ordering of mapping files does not matter when using the
             extends keyword. The ordering inside a single mapping file still needs to be defined as superclasses
             before subclasses.
         </p><pre class="programlisting">
 &lt;hibernate-mapping&gt;
     &lt;subclass name="DomesticCat" extends="Cat" discriminator-value="D"&gt;
          &lt;property name="name" type="string"/&gt;
     &lt;/subclass&gt;
 &lt;/hibernate-mapping&gt;</pre><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-tableperclass"></a>9.1.1.&nbsp;Table per class hierarchy</h3></div></div><div></div></div><p>
            Suppose we have an interface <tt class="literal">Payment</tt>, with implementors
            <tt class="literal">CreditCardPayment</tt>, <tt class="literal">CashPayment</tt>,
            <tt class="literal">ChequePayment</tt>. The table per hierarchy mapping would
            look like:
        </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        &lt;property name="creditCardType" column="CCTYPE"/&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        ...
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
            Exactly one table is required. There is one big limitation of this mapping 
            strategy: columns declared by the subclasses, such as <tt class="literal">CCTYPE</tt>, 
            may not have <tt class="literal">NOT NULL</tt> constraints.
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-tablepersubclass"></a>9.1.2.&nbsp;Table per subclass</h3></div></div><div></div></div><p>
            A table per subclass mapping would look like:
        </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;joined-subclass name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="creditCardType" column="CCTYPE"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
&lt;/class&gt;</pre><p>
            Four tables are required. The three subclass tables have primary
            key associations to the superclass table (so the relational model
            is actually a one-to-one association).
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-tablepersubclass-discriminator"></a>9.1.3.&nbsp;Table per subclass, using a discriminator</h3></div></div><div></div></div><p>
            Note that Hibernate's implementation of table per subclass requires
            no discriminator column. Other object/relational mappers use a
            different implementation of table per subclass which requires a type
            discriminator column in the superclass table. The approach taken by
            Hibernate is much more difficult to implement but arguably more
            correct from a relational point of view. If you would like to use
            a discriminator column with the table per subclass strategy, you
            may combine the use of <tt class="literal">&lt;subclass&gt;</tt> and 
            <tt class="literal">&lt;join&gt;</tt>, as follow:
        </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        &lt;join table="CREDIT_PAYMENT"&gt;
            &lt;key column="PAYMENT_ID"/&gt;
            &lt;property name="creditCardType" column="CCTYPE"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        &lt;join table="CASH_PAYMENT"&gt;
            &lt;key column="PAYMENT_ID"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        &lt;join table="CHEQUE_PAYMENT" fetch="select"&gt;
            &lt;key column="PAYMENT_ID"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
            The optional <tt class="literal">fetch="select"</tt> declaration tells Hibernate 
            not to fetch the <tt class="literal">ChequePayment</tt> subclass data using an
            outer join when querying the superclass.
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-mixing-tableperclass-tablepersubclass"></a>9.1.4.&nbsp;Mixing table per class hierarchy with table per subclass</h3></div></div><div></div></div><p>
            You may even mix the table per hierarchy and table per subclass strategies
            using this approach:
        </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        &lt;join table="CREDIT_PAYMENT"&gt;
            &lt;property name="creditCardType" column="CCTYPE"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        ...
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
            For any of these mapping strategies, a polymorphic association to the root
            <tt class="literal">Payment</tt> class is mapped using 
            <tt class="literal">&lt;many-to-one&gt;</tt>.
        </p><pre class="programlisting">&lt;many-to-one name="payment" column="PAYMENT_ID" class="Payment"/&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-tableperconcrete"></a>9.1.5.&nbsp;Table per concrete class</h3></div></div><div></div></div><p>
            There are two ways we could go about mapping the table per concrete class
            strategy. The first is to use <tt class="literal">&lt;union-subclass&gt;</tt>.
        </p><pre class="programlisting">&lt;class name="Payment"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="sequence"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;union-subclass name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
        &lt;property name="creditCardType" column="CCTYPE"/&gt;
        ...
    &lt;/union-subclass&gt;
    &lt;union-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        ...
    &lt;/union-subclass&gt;
    &lt;union-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        ...
    &lt;/union-subclass&gt;
&lt;/class&gt;</pre><p>
            Three tables are involved for the subclasses. Each table defines columns for
            all properties of the class, including inherited properties.
        </p><p>
            The limitation of this approach is that if a property is mapped on the 
            superclass, the column name must be the same on all subclass tables.
            (We might relax this in a future release of Hibernate.) The identity
			generator strategy is not allowed in union subclass inheritance, indeed
			the primary key seed has to be shared accross all unioned subclasses
			of a hierarchy.
        </p><p>
            If your superclass is abstract, map it with <tt class="literal">abstract="true"</tt>.
            Of course, if it is not abstract, an additional table (defaults to
            <tt class="literal">PAYMENT</tt> in the example above) is needed to hold instances
            of the superclass.
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-tableperconcreate-polymorphism"></a>9.1.6.&nbsp;Table per concrete class, using implicit polymorphism</h3></div></div><div></div></div><p>
            An alternative approach is to make use of implicit polymorphism:
        </p><pre class="programlisting">&lt;class name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CREDIT_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CREDIT_AMOUNT"/&gt;
    ...
&lt;/class&gt;

&lt;class name="CashPayment" table="CASH_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CASH_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CASH_AMOUNT"/&gt;
    ...
&lt;/class&gt;

&lt;class name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CHEQUE_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CHEQUE_AMOUNT"/&gt;
    ...
&lt;/class&gt;</pre><p>
            Notice that nowhere do we mention the <tt class="literal">Payment</tt> interface 
            explicitly. Also notice that properties of <tt class="literal">Payment</tt> are 
            mapped in each of the subclasses. If you want to avoid duplication, consider
            using XML entities
            (e.g. <tt class="literal">[ &lt;!ENTITY allproperties SYSTEM "allproperties.xml"&gt; ]</tt>
            in the <tt class="literal">DOCTYPE</tt> declartion and 
            <tt class="literal">&amp;allproperties;</tt> in the mapping).
        </p><p>
            The disadvantage of this approach is that Hibernate does not generate SQL
            <tt class="literal">UNION</tt>s when performing polymorphic queries.
        </p><p>
            For this mapping strategy, a polymorphic association to <tt class="literal">Payment</tt> 
            is usually mapped using <tt class="literal">&lt;any&gt;</tt>.
        </p><pre class="programlisting">&lt;any name="payment" meta-type="string" id-type="long"&gt;
    &lt;meta-value value="CREDIT" class="CreditCardPayment"/&gt;
    &lt;meta-value value="CASH" class="CashPayment"/&gt;
    &lt;meta-value value="CHEQUE" class="ChequePayment"/&gt;
    &lt;column name="PAYMENT_CLASS"/&gt;
    &lt;column name="PAYMENT_ID"/&gt;
&lt;/any&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritace-mixingpolymorphism"></a>9.1.7.&nbsp;Mixing implicit polymorphism with other inheritance mappings</h3></div></div><div></div></div><p>
            There is one further thing to notice about this mapping. Since the subclasses 
            are each mapped in their own <tt class="literal">&lt;class&gt;</tt> element (and since
            <tt class="literal">Payment</tt> is just an interface), each of the subclasses could 
            easily be part of another inheritance hierarchy! (And you can still use polymorphic
            queries against the <tt class="literal">Payment</tt> interface.)
       </p><pre class="programlisting">&lt;class name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CREDIT_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="CREDIT_CARD" type="string"/&gt;
    &lt;property name="amount" column="CREDIT_AMOUNT"/&gt;
    ...
    &lt;subclass name="MasterCardPayment" discriminator-value="MDC"/&gt;
    &lt;subclass name="VisaPayment" discriminator-value="VISA"/&gt;
&lt;/class&gt;

&lt;class name="NonelectronicTransaction" table="NONELECTRONIC_TXN"&gt;
    &lt;id name="id" type="long" column="TXN_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    ...
    &lt;joined-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="amount" column="CASH_AMOUNT"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="amount" column="CHEQUE_AMOUNT"/&gt;
        ...
    &lt;/joined-subclass&gt;
&lt;/class&gt;</pre><p>
            Once again, we don't mention <tt class="literal">Payment</tt> explicitly. If we
            execute a query against the <tt class="literal">Payment</tt> interface - for
            example, <tt class="literal">from Payment</tt> - Hibernate
            automatically returns instances of <tt class="literal">CreditCardPayment</tt>
            (and its subclasses, since they also implement <tt class="literal">Payment</tt>),
            <tt class="literal">CashPayment</tt> and <tt class="literal">ChequePayment</tt> but
            not instances of <tt class="literal">NonelectronicTransaction</tt>.
        </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="inheritance-limitations"></a>9.2.&nbsp;Limitations</h2></div></div><div></div></div><p>
            There are certain limitations to the "implicit polymorphism" approach to
            the table per concrete-class mapping strategy. There are somewhat less
            restrictive limitations to <tt class="literal">&lt;union-subclass&gt;</tt>
            mappings.
        </p><p>
            The following table shows the limitations of table per concrete-class
            mappings, and of implicit polymorphism, in Hibernate.
        </p><div class="table"><a name="d0e8687"></a><p class="title"><b>Table&nbsp;9.1.&nbsp;Features of inheritance mappings</b></p><table summary="Features of inheritance mappings" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Inheritance strategy</th><th align="left">Polymorphic many-to-one</th><th align="left">Polymorphic one-to-one</th><th align="left">Polymorphic one-to-many</th><th align="left">Polymorphic many-to-many</th><th align="left">Polymorphic <tt class="literal">load()/get()</tt></th><th align="left">Polymorphic queries</th><th align="left">Polymorphic joins</th><th align="left">Outer join fetching</th></tr></thead><tbody><tr><td align="left">table per class-hierarchy</td><td align="left"><tt class="literal">&lt;many-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-many&gt;</tt></td><td align="left"><tt class="literal">&lt;many-to-many&gt;</tt></td><td align="left"><tt class="literal">s.get(Payment.class, id)</tt></td><td align="left"><tt class="literal">from Payment p</tt></td><td align="left"><tt class="literal">from Order o join o.payment p</tt></td><td align="left"><span class="emphasis"><em>supported</em></span></td></tr><tr><td align="left">table per subclass</td><td align="left"><tt class="literal">&lt;many-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-many&gt;</tt></td><td align="left"><tt class="literal">&lt;many-to-many&gt;</tt></td><td align="left"><tt class="literal">s.get(Payment.class, id)</tt></td><td align="left"><tt class="literal">from Payment p</tt></td><td align="left"><tt class="literal">from Order o join o.payment p</tt></td><td align="left"><span class="emphasis"><em>supported</em></span></td></tr><tr><td align="left">table per concrete-class (union-subclass)</td><td align="left"><tt class="literal">&lt;many-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-many&gt;</tt> (for <tt class="literal">inverse="true"</tt> only)</td><td align="left"><tt class="literal">&lt;many-to-many&gt;</tt></td><td align="left"><tt class="literal">s.get(Payment.class, id)</tt></td><td align="left"><tt class="literal">from Payment p</tt></td><td align="left"><tt class="literal">from Order o join o.payment p</tt></td><td align="left"><span class="emphasis"><em>supported</em></span></td></tr><tr><td align="left">table per concrete class (implicit polymorphism)</td><td align="left"><tt class="literal">&lt;any&gt;</tt></td><td align="left"><span class="emphasis"><em>not supported</em></span></td><td align="left"><span class="emphasis"><em>not supported</em></span></td><td align="left"><tt class="literal">&lt;many-to-any&gt;</tt></td><td align="left"><tt class="literal">s.createCriteria(Payment.class).add( Restrictions.idEq(id) ).uniqueResult()</tt></td><td align="left"><tt class="literal">from Payment p</tt></td><td align="left"><span class="emphasis"><em>not supported</em></span></td><td align="left"><span class="emphasis"><em>not supported</em></span></td></tr></tbody></table></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="objectstate"></a>Chapter&nbsp;10.&nbsp;Working with objects</h2></div></div><div></div></div><p>
        Hibernate is a full object/relational mapping solution that not only shields
        the developer from the details of the underlying database management
        system, but also offers <span class="emphasis"><em>state management</em></span> of objects. This is,
        contrary to the management of SQL <tt class="literal">statements</tt> in common JDBC/SQL
        persistence layers, a very natural object-oriented view of persistence in Java
        applications.
    </p><p>
        In other words, Hibernate application developers should always think about the
        <span class="emphasis"><em>state</em></span> of their objects, and not necessarily about the
        execution of SQL statements. This part is taken care of by Hibernate and is only
        relevant for the application developer when tuning the performance of the system.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-overview"></a>10.1.&nbsp;Hibernate object states</h2></div></div><div></div></div><p>
            Hibernate defines and supports the following object states:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <span class="emphasis"><em>Transient</em></span> - an object is transient if it has just
                    been instantiated using the <tt class="literal">new</tt> operator, and it
                    is not associated with a Hibernate <tt class="literal">Session</tt>. It has no
                    persistent representation in the database and no identifier value has been
                    assigned. Transient instances will be destroyed by the garbage collector if
                    the application doesn't hold a reference anymore. Use the Hibernate
                    <tt class="literal">Session</tt> to make an object persistent (and let Hibernate
                    take care of the SQL statements that need to be executed for this transition).
                </p></li><li><p>
                    <span class="emphasis"><em>Persistent</em></span> - a persistent instance has a representation
                    in the database and an identifier value. It might just have been saved or loaded,
                    however, it is by definition in the scope of a <tt class="literal">Session</tt>.
                    Hibernate will detect any changes made to an object in persistent state and
                    synchronize the state with the database when the unit of work completes.
                    Developers don't execute manual <tt class="literal">UPDATE</tt> statements, or
                    <tt class="literal">DELETE</tt> statements when an object should be made transient.
                </p></li><li><p>
                    <span class="emphasis"><em>Detached</em></span> - a detached instance is an object that has been
                    persistent, but its <tt class="literal">Session</tt> has been closed. The reference
                    to the object is still valid, of course, and the detached instance might even
                    be modified in this state. A detached instance can be reattached to a new
                    <tt class="literal">Session</tt> at a later point in time, making it (and all the
                    modifications) persistent again. This feature enables a programming model for
                    long running units of work that require user think-time. We call them
                    <span class="emphasis"><em>application transactions</em></span>, i.e. a unit of work from the
                    point of view of the user.
                </p></li></ul></div><p>
            We'll now discuss the states and state transitions (and the Hibernate methods that
            trigger a transition) in more detail.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-makingpersistent"></a>10.2.&nbsp;Making objects persistent</h2></div></div><div></div></div><p>
            Newly instantiated instances of a a persistent class are considered 
            <span class="emphasis"><em>transient</em></span> by Hibernate. We can make a transient 
            instance <span class="emphasis"><em>persistent</em></span> by associating it with a 
            session:
        </p><pre class="programlisting">DomesticCat fritz = new DomesticCat();
fritz.setColor(Color.GINGER);
fritz.setSex('M');
fritz.setName("Fritz");
Long generatedId = (Long) sess.save(fritz);</pre><p>
            If <tt class="literal">Cat</tt> has a generated identifier, the identifier is
            generated and assigned to the <tt class="literal">cat</tt> when <tt class="literal">save()</tt> 
            is called. If <tt class="literal">Cat</tt> has an <tt class="literal">assigned</tt>
            identifier, or a composite key, the identifier should be assigned to 
            the <tt class="literal">cat</tt> instance before calling <tt class="literal">save()</tt>.
            You may also use <tt class="literal">persist()</tt> instead of <tt class="literal">save()</tt>,
            with the semantics defined in the EJB3 early draft.
        </p><p>
            Alternatively, you may assign the identifier using an overloaded version
            of <tt class="literal">save()</tt>.
        </p><pre class="programlisting">DomesticCat pk = new DomesticCat();
pk.setColor(Color.TABBY);
pk.setSex('F');
pk.setName("PK");
pk.setKittens( new HashSet() );
pk.addKitten(fritz);
sess.save( pk, new Long(1234) );</pre><p>
            If the object you make persistent has associated objects (e.g. the
            <tt class="literal">kittens</tt> collection in the previous example),
            these objects may be made persistent in any order you like unless you
            have a <tt class="literal">NOT NULL</tt> constraint upon a foreign key column.
            There is never a risk of violating foreign key constraints. However, you 
            might violate a <tt class="literal">NOT NULL</tt> constraint if you
            <tt class="literal">save()</tt> the objects in the wrong order.
        </p><p>
            Usually you don't bother with this detail, as you'll very likely use Hibernate's
            <span class="emphasis"><em>transitive persistence</em></span> feature to save the associated
            objects automatically. Then, even <tt class="literal">NOT NULL</tt>
            constraint violations don't occur - Hibernate will take care of everything.
            Transitive persistence is discussed later in this chapter.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-loading"></a>10.3.&nbsp;Loading an object</h2></div></div><div></div></div><p>
            The <tt class="literal">load()</tt> methods of <tt class="literal">Session</tt> gives you
            a way to retrieve a persistent instance if you already know its identifier. 
            <tt class="literal">load()</tt> takes a class object and will load the state into 
            a newly instantiated instance of that class, in persistent state.
        </p><pre class="programlisting">Cat fritz = (Cat) sess.load(Cat.class, generatedId);</pre><pre class="programlisting">// you need to wrap primitive identifiers
long id = 1234;
DomesticCat pk = (DomesticCat) sess.load( DomesticCat.class, new Long(id) );</pre><p>
            Alternatively, you can load state into a given instance:
        </p><pre class="programlisting">Cat cat = new DomesticCat();
// load pk's state into cat
sess.load( cat, new Long(pkId) );
Set kittens = cat.getKittens();</pre><p>
            Note that <tt class="literal">load()</tt> will throw an unrecoverable exception if 
            there is no matching database row. If the class is mapped with a proxy, 
            <tt class="literal">load()</tt> just returns an uninitialized proxy and does not 
            actually hit the database until you invoke a method of the proxy. This 
            behaviour is very useful if you wish to create an association to an object
            without actually loading it from the database. It also allows multiple
            instances to be loaded as a batch if <tt class="literal">batch-size</tt> is
            defined for the class mapping.
        </p><p>
            If you are not certain that a matching row exists, you should use the 
            <tt class="literal">get()</tt> method, which hits the database immediately and 
            returns null if there is no matching row.
        </p><pre class="programlisting">Cat cat = (Cat) sess.get(Cat.class, id);
if (cat==null) {
    cat = new Cat();
    sess.save(cat, id);
}
return cat;</pre><p>
            You may even load an object using an SQL <tt class="literal">SELECT ... FOR UPDATE</tt>,
            using a <tt class="literal">LockMode</tt>. See the API documentation for more information.
        </p><pre class="programlisting">Cat cat = (Cat) sess.get(Cat.class, id, LockMode.UPGRADE);</pre><p>
            Note that any associated instances or contained collections are 
            <span class="emphasis"><em>not</em></span> selected <tt class="literal">FOR UPDATE</tt>, unless you decide
            to specify <tt class="literal">lock</tt> or <tt class="literal">all</tt> as a
            cascade style for the association.
        </p><p>
            It is possible to re-load an object and all its collections at any time, using the 
            <tt class="literal">refresh()</tt> method. This is useful when database triggers are used to
            initialize some of the properties of the object.
        </p><pre class="programlisting">sess.save(cat);
sess.flush(); //force the SQL INSERT
sess.refresh(cat); //re-read the state (after the trigger executes)</pre><p>
            An important question usually appears at this point: How much does Hibernate load
            from the database and how many SQL <tt class="literal">SELECT</tt>s will it use? This
            depends on the <span class="emphasis"><em>fetching strategy</em></span> and is explained in
            <a href="#performance-fetching" title="19.1.&nbsp;Fetching strategies">Section&nbsp;19.1, &#8220;Fetching strategies&#8221;</a>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-querying"></a>10.4.&nbsp;Querying</h2></div></div><div></div></div><p>
            If you don't know the identifiers of the objects you are looking for, 
            you need a query. Hibernate supports an easy-to-use but powerful object 
            oriented query language (HQL). For programmatic query creation, Hibernate
            supports a sophisticated Criteria and Example query feature (QBC and QBE).
            You may also express your query in the native SQL of your database, with
            optional support from Hibernate for result set conversion into objects.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="objectstate-querying-executing"></a>10.4.1.&nbsp;Executing queries</h3></div></div><div></div></div><p>
                HQL and native SQL queries are represented with an instance of <tt class="literal">org.hibernate.Query</tt>.
                This interface offers methods for parameter binding, result set handling, and for the execution
                of the actual query. You always obtain a <tt class="literal">Query</tt> using the current
                <tt class="literal">Session</tt>:
            </p><pre class="programlisting">List cats = session.createQuery(
    "from Cat as cat where cat.birthdate &lt; ?")
    .setDate(0, date)
    .list();

List mothers = session.createQuery(
    "select mother from Cat as cat join cat.mother as mother where cat.name = ?")
    .setString(0, name)
    .list();

List kittens = session.createQuery(
    "from Cat as cat where cat.mother = ?")
    .setEntity(0, pk)
    .list();

Cat mother = (Cat) session.createQuery(
    "select cat.mother from Cat as cat where cat = ?")
    .setEntity(0, izi)
    .uniqueResult();</pre><p>
                A query is usually executed by invoking <tt class="literal">list()</tt>, the
                result of the query will be loaded completely into a collection in memory.
                Entity instances retrieved by a query are in persistent state. The
                <tt class="literal">uniqueResult()</tt> method offers a shortcut if you
                know your query will only return a single object.
            </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="objectstate-querying-executing-iterate"></a>10.4.1.1.&nbsp;Iterating results</h4></div></div><div></div></div><p>
                    Occasionally, you might be able to achieve better performance by
                    executing the query using the <tt class="literal">iterate()</tt> method.
                    This will only usually be the case if you expect that the actual
                    entity instances returned by the query will already be in the session
                    or second-level cache. If they are not already cached,
                    <tt class="literal">iterate()</tt> will be slower than <tt class="literal">list()</tt>
                    and might require many database hits for a simple query, usually
                    <span class="emphasis"><em>1</em></span> for the initial select which only returns identifiers,
                    and <span class="emphasis"><em>n</em></span> additional selects to initialize the actual instances.
                </p><pre class="programlisting">// fetch ids
Iterator iter = sess.createQuery("from eg.Qux q order by q.likeliness").iterate();
while ( iter.hasNext() ) {
    Qux qux = (Qux) iter.next();  // fetch the object
    // something we couldnt express in the query
    if ( qux.calculateComplicatedAlgorithm() ) {
        // delete the current instance
        iter.remove();
        // dont need to process the rest
        break;
    }
}</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="objectstate-querying-executing-tuples"></a>10.4.1.2.&nbsp;Queries that return tuples</h4></div></div><div></div></div><p>
                    Hibernate queries sometimes return tuples of objects, in which case each tuple
                    is returned as an array:
                </p><pre class="programlisting">Iterator kittensAndMothers = sess.createQuery(
            "select kitten, mother from Cat kitten join kitten.mother mother")
            .list()
            .iterator();

while ( kittensAndMothers.hasNext() ) {
    Object[] tuple = (Object[]) kittensAndMothers.next();
    Cat kitten  = tuple[0];
    Cat mother  = tuple[1];
    ....
}</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="objectstate-querying-executing-scalar"></a>10.4.1.3.&nbsp;Scalar results</h4></div></div><div></div></div><p>
                    Queries may specify a property of a class in the <tt class="literal">select</tt> clause.
                    They may even call SQL aggregate functions. Properties or aggregates are considered
                    "scalar" results (and not entities in persistent state).
                </p><pre class="programlisting">Iterator results = sess.createQuery(
        "select cat.color, min(cat.birthdate), count(cat) from Cat cat " +
        "group by cat.color")
        .list()
        .iterator();

while ( results.hasNext() ) {
    Object[] row = (Object[]) results.next();
    Color type = (Color) row[0];
    Date oldest = (Date) row[1];
    Integer count = (Integer) row[2];
    .....
}</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="objectstate-querying-executing-parameters"></a>10.4.1.4.&nbsp;Bind parameters</h4></div></div><div></div></div><p>
                    Methods on <tt class="literal">Query</tt> are provided for binding values to
                    named parameters or JDBC-style <tt class="literal">?</tt> parameters. 
                    <span class="emphasis"><em>Contrary to JDBC, Hibernate numbers parameters from zero.</em></span>
                    Named parameters are identifiers of the form <tt class="literal">:name</tt> in 
                    the query string. The advantages of named parameters are:
                </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                            named parameters are insensitive to the order they occur in the
                            query string
                        </p></li><li><p>
                            they may occur multiple times in the same query
                        </p></li><li><p>
                            they are self-documenting
                        </p></li></ul></div><pre class="programlisting">//named parameter (preferred)
Query q = sess.createQuery("from DomesticCat cat where cat.name = :name");
q.setString("name", "Fritz");
Iterator cats = q.iterate();</pre><pre class="programlisting">//positional parameter
Query q = sess.createQuery("from DomesticCat cat where cat.name = ?");
q.setString(0, "Izi");
Iterator cats = q.iterate();</pre><pre class="programlisting">//named parameter list
List names = new ArrayList();
names.add("Izi");
names.add("Fritz");
Query q = sess.createQuery("from DomesticCat cat where cat.name in (:namesList)");
q.setParameterList("namesList", names);
List cats = q.list();</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="objectstate-querying-executing-pagination"></a>10.4.1.5.&nbsp;Pagination</h4></div></div><div></div></div><p>
                    If you need to specify bounds upon your result set (the maximum number of rows
                    you want to retrieve and / or the first row you want to retrieve) you should
                    use methods of the <tt class="literal">Query</tt> interface:
                </p><pre class="programlisting">Query q = sess.createQuery("from DomesticCat cat");
q.setFirstResult(20);
q.setMaxResults(10);
List cats = q.list();</pre><p>
                    Hibernate knows how to translate this limit query into the native
                    SQL of your DBMS.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="objectstate-querying-executing-scrolling"></a>10.4.1.6.&nbsp;Scrollable iteration</h4></div></div><div></div></div><p>
                    If your JDBC driver supports scrollable <tt class="literal">ResultSet</tt>s, the
                    <tt class="literal">Query</tt> interface may be used to obtain a
                    <tt class="literal">ScrollableResults</tt> object, which allows flexible
                    navigation of the query results.
                </p><pre class="programlisting">Query q = sess.createQuery("select cat.name, cat from DomesticCat cat " +
                            "order by cat.name");
ScrollableResults cats = q.scroll();
if ( cats.first() ) {

    // find the first name on each page of an alphabetical list of cats by name
    firstNamesOfPages = new ArrayList();
    do {
        String name = cats.getString(0);
        firstNamesOfPages.add(name);
    }
    while ( cats.scroll(PAGE_SIZE) );

    // Now get the first page of cats
    pageOfCats = new ArrayList();
    cats.beforeFirst();
    int i=0;
    while( ( PAGE_SIZE &gt; i++ ) &amp;&amp; cats.next() ) pageOfCats.add( cats.get(1) );

}
cats.close()</pre><p>
                    Note that an open database connection (and cursor) is required for this
                    functionality, use <tt class="literal">setMaxResult()</tt>/<tt class="literal">setFirstResult()</tt>
                    if you need offline pagination functionality.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="objectstate-querying-executing-named"></a>10.4.1.7.&nbsp;Externalizing named queries</h4></div></div><div></div></div><p>
                    You may also define named queries in the mapping document. (Remember to use a
                    <tt class="literal">CDATA</tt> section if your query contains characters that could
                    be interpreted as markup.)
                </p><pre class="programlisting">&lt;query name="eg.DomesticCat.by.name.and.minimum.weight"&gt;&lt;![CDATA[
    from eg.DomesticCat as cat
        where cat.name = ?
        and cat.weight &gt; ?
] ]&gt;&lt;/query&gt;</pre><p>
                    Parameter binding and executing is done programatically:
                </p><pre class="programlisting">Query q = sess.getNamedQuery("eg.DomesticCat.by.name.and.minimum.weight");
q.setString(0, name);
q.setInt(1, minWeight);
List cats = q.list();</pre><p>
                    Note that the actual program code is independent of the query language that
                    is used, you may also define native SQL queries in metadata, or migrate
                    existing queries to Hibernate by placing them in mapping files.
                </p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="objectstate-filtering"></a>10.4.2.&nbsp;Filtering collections</h3></div></div><div></div></div><p>
                A collection <span class="emphasis"><em>filter</em></span> is a special type of query that may be applied to
                a persistent collection or array. The query string may refer to <tt class="literal">this</tt>,
                meaning the current collection element.
            </p><pre class="programlisting">Collection blackKittens = session.createFilter(
    pk.getKittens(), 
    "where this.color = ?")
    .setParameter( Color.BLACK, Hibernate.custom(ColorUserType.class) )
    .list()
);</pre><p>
                The returned collection is considered a bag, and it's a copy of the given
                collection. The original collection is not modified (this is contrary to
                the implication of the name "filter", but consistent with expected behavior).
            </p><p>
                Observe that filters do not require a <tt class="literal">from</tt> clause (though they may have
                one if required). Filters are not limited to returning the collection elements themselves.
            </p><pre class="programlisting">Collection blackKittenMates = session.createFilter(
    pk.getKittens(), 
    "select this.mate where this.color = eg.Color.BLACK.intValue")
    .list();</pre><p>
                Even an empty filter query is useful, e.g. to load a subset of elements in a
                huge collection:
            </p><pre class="programlisting">Collection tenKittens = session.createFilter(
    mother.getKittens(), "")
    .setFirstResult(0).setMaxResults(10)
    .list();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="objecstate-querying-criteria"></a>10.4.3.&nbsp;Criteria queries</h3></div></div><div></div></div><p>
                HQL is extremely powerful but some developers prefer to build queries dynamically,
                using an object-oriented API, rather than building query strings. Hibernate provides
                an intuitive <tt class="literal">Criteria</tt> query API for these cases:
            </p><pre class="programlisting">Criteria crit = session.createCriteria(Cat.class);
crit.add( Expression.eq( "color", eg.Color.BLACK ) );
crit.setMaxResults(10);
List cats = crit.list();</pre><p>
                The <tt class="literal">Criteria</tt> and the associated <tt class="literal">Example</tt>
                API are discussed in more detail in <a href="#querycriteria" title="Chapter&nbsp;15.&nbsp;Criteria Queries">Chapter&nbsp;15, <i>Criteria Queries</i></a>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="objectstate-querying-nativesql"></a>10.4.4.&nbsp;Queries in native SQL</h3></div></div><div></div></div><p>
                You may express a query in SQL, using <tt class="literal">createSQLQuery()</tt> and
                let Hibernate take care of the mapping from result sets to objects. Note
                that you may at any time call <tt class="literal">session.connection()</tt> and
                use the JDBC <tt class="literal">Connection</tt> directly. If you chose to use the
                Hibernate API, you must enclose SQL aliases in braces:
            </p><pre class="programlisting">List cats = session.createSQLQuery(
    "SELECT {cat.*} FROM CAT {cat} WHERE ROWNUM&lt;10",
    "cat",
    Cat.class
).list();</pre><pre class="programlisting">List cats = session.createSQLQuery(
    "SELECT {cat}.ID AS {cat.id}, {cat}.SEX AS {cat.sex}, " +
           "{cat}.MATE AS {cat.mate}, {cat}.SUBCLASS AS {cat.class}, ... " +
    "FROM CAT {cat} WHERE ROWNUM&lt;10",
    "cat",
    Cat.class
).list()</pre><p>
                SQL queries may contain named and positional parameters, just like Hibernate queries.
                More information about native SQL queries in Hibernate can be found in
                <a href="#querysql" title="Chapter&nbsp;16.&nbsp;Native SQL">Chapter&nbsp;16, <i>Native SQL</i></a>.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-modifying"></a>10.5.&nbsp;Modifying persistent objects</h2></div></div><div></div></div><p>
            <span class="emphasis"><em>Transactional persistent instances</em></span> (ie. objects loaded, saved, created or
            queried by the <tt class="literal">Session</tt>) may be manipulated by the application
            and any changes to persistent state will be persisted when the <tt class="literal">Session</tt>
            is <span class="emphasis"><em>flushed</em></span> (discussed later in this chapter). There is no need
            to call a particular method (like <tt class="literal">update()</tt>, which has a different
            purpose) to make your modifications persistent. So the most straightforward way to update
            the state of an object is to <tt class="literal">load()</tt> it,
            and then manipulate it directly, while the <tt class="literal">Session</tt> is open:
        </p><pre class="programlisting">DomesticCat cat = (DomesticCat) sess.load( Cat.class, new Long(69) );
cat.setName("PK");
sess.flush();  // changes to cat are automatically detected and persisted</pre><p>
            Sometimes this programming model is inefficient since it would require both an SQL
            <tt class="literal">SELECT</tt> (to load an object) and an SQL <tt class="literal">UPDATE</tt>
            (to persist its updated state) in the same session. Therefore Hibernate offers an
            alternate approach, using detached instances.
        </p><p>
            <span class="emphasis"><em>Note that Hibernate does not offer its own API for direct execution of
            <tt class="literal">UPDATE</tt> or <tt class="literal">DELETE</tt> statements. Hibernate is a
            <span class="emphasis"><em>state management</em></span> service, you don't have to think in
            <span class="emphasis"><em>statements</em></span> to use it. JDBC is a perfect API for executing
            SQL statements, you can get a JDBC <tt class="literal">Connection</tt> at any time
            by calling <tt class="literal">session.connection()</tt>. Furthermore, the notion
            of mass operations conflicts with object/relational mapping for online
            transaction processing-oriented applications. Future versions of Hibernate
            may however provide special mass operation functions. See <a href="#batch" title="Chapter&nbsp;13.&nbsp;Batch processing">Chapter&nbsp;13, <i>Batch processing</i></a>
            for some possible batch operation tricks.</em></span>
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-detached"></a>10.6.&nbsp;Modifying detached objects</h2></div></div><div></div></div><p>
            Many applications need to retrieve an object in one transaction, send it to the
            UI layer for manipulation, then save the changes in a new transaction.
            Applications that use this kind of approach in a high-concurrency environment
            usually use versioned  data to ensure isolation for the "long" unit of work.
        </p><p>
            Hibernate supports this model by providing for reattachment of detached instances
            using the <tt class="literal">Session.update()</tt> or <tt class="literal">Session.merge()</tt>
            methods:
        </p><pre class="programlisting">// in the first session
Cat cat = (Cat) firstSession.load(Cat.class, catId);
Cat potentialMate = new Cat();
firstSession.save(potentialMate);

// in a higher layer of the application
cat.setMate(potentialMate);

// later, in a new session
secondSession.update(cat);  // update cat
secondSession.update(mate); // update mate</pre><p>
            If the <tt class="literal">Cat</tt> with identifier <tt class="literal">catId</tt> had already
            been loaded  by <tt class="literal">secondSession</tt> when the application tried to
            reattach it, an exception would have been thrown.
        </p><p>
            Use <tt class="literal">update()</tt> if you are sure that the session does
            not contain an already persistent instance with the same identifier, and
            <tt class="literal">merge()</tt> if you want to merge your modifications at any time
            without consideration of the state of the session. In other words, <tt class="literal">update()</tt>
            is usually the first method you would call in a fresh session, ensuring that
            reattachment of your detached instances is the first operation that is executed.
        </p><p>
            The application should individually <tt class="literal">update()</tt> detached instances
            reachable from the given detached instance if and <span class="emphasis"><em>only</em></span> if it wants
            their state also updated. This can be automated of course, using <span class="emphasis"><em>transitive
            persistence</em></span>, see <a href="#objectstate-transitive" title="10.11.&nbsp;Transitive persistence">Section&nbsp;10.11, &#8220;Transitive persistence&#8221;</a>.
        </p><p>
            The <tt class="literal">lock()</tt> method also allows an application to reassociate
            an object with a new session. However, the detached instance has to be unmodified!
        </p><pre class="programlisting">//just reassociate:
sess.lock(fritz, LockMode.NONE);
//do a version check, then reassociate:
sess.lock(izi, LockMode.READ);
//do a version check, using SELECT ... FOR UPDATE, then reassociate:
sess.lock(pk, LockMode.UPGRADE);</pre><p>
            Note that <tt class="literal">lock()</tt> can be used with various
            <tt class="literal">LockMode</tt>s, see the API documentation and the
            chapter on transaction handling for more information. Reattachment is not
            the only usecase for <tt class="literal">lock()</tt>.
        </p><p>
            Other models for long units of work are discussed in <a href="#transactions-optimistic" title="11.3.&nbsp;Optimistic concurrency control">Section&nbsp;11.3, &#8220;Optimistic concurrency control&#8221;</a>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-saveorupdate"></a>10.7.&nbsp;Automatic state detection</h2></div></div><div></div></div><p>
            Hibernate users have requested a general purpose method that either saves a
            transient instance by generating a new identifier or updates/reattaches
            the detached instances associated with its current identifier.
            The <tt class="literal">saveOrUpdate()</tt> method implements this functionality.
        </p><pre class="programlisting">// in the first session
Cat cat = (Cat) firstSession.load(Cat.class, catID);

// in a higher tier of the application
Cat mate = new Cat();
cat.setMate(mate);

// later, in a new session
secondSession.saveOrUpdate(cat);   // update existing state (cat has a non-null id)
secondSession.saveOrUpdate(mate);  // save the new instance (mate has a null id)</pre><p>
            The usage and semantics of <tt class="literal">saveOrUpdate()</tt> seems to be confusing
            for new users. Firstly, so long as you are not trying to use instances from one session
            in another new session, you should not need to use <tt class="literal">update()</tt>,
            <tt class="literal">saveOrUpdate()</tt>, or <tt class="literal">merge()</tt>. Some whole
            applications will never use either of these methods.
        </p><p>
            Usually <tt class="literal">update()</tt> or <tt class="literal">saveOrUpdate()</tt> are used in
            the following scenario:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    the application loads an object in the first session
                </p></li><li><p>
                    the object is passed up to the UI tier
                </p></li><li><p>
                    some modifications are made to the object
                </p></li><li><p>
                    the object is passed back down to the business logic tier
                </p></li><li><p>
                    the application persists these modifications by calling
                    <tt class="literal">update()</tt> in a second session
                </p></li></ul></div><p>
            <tt class="literal">saveOrUpdate()</tt> does the following:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    if the object is already persistent in this session, do nothing
                </p></li><li><p>
                    if another object associated with the session has the same identifier, 
                    throw an exception
                </p></li><li><p>
                    if the object has no identifier property, <tt class="literal">save()</tt> it
                </p></li><li><p>
                    if the object's identifier has the value assigned to a newly instantiated
                    object, <tt class="literal">save()</tt> it
                </p></li><li><p>
                    if the object is versioned (by a <tt class="literal">&lt;version&gt;</tt> or
                    <tt class="literal">&lt;timestamp&gt;</tt>), and the version property value
                    is the same value assigned to a newly instantiated object, 
                    <tt class="literal">save()</tt> it
                </p></li><li><p>
                    otherwise <tt class="literal">update()</tt> the object
                </p></li></ul></div><p>
            and <tt class="literal">merge()</tt> is very different:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    if there is a persistent instance with the same identifier currently 
                    associated with the session, copy the state of the given object onto 
                    the persistent instance
                </p></li><li><p>
                    if there is no persistent instance currently associated with the session, 
                    try to load it from the database, or create a new persistent instance
                </p></li><li><p>
                    the persistent instance is returned
                </p></li><li><p>
                    the given instance does not become associated with the session, it
                    remains detached
                </p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-deleting"></a>10.8.&nbsp;Deleting persistent objects</h2></div></div><div></div></div><p>
            <tt class="literal">Session.delete()</tt> will remove an object's state from the database.
            Of course, your application might still hold a reference to a deleted object.
            It's best to think of <tt class="literal">delete()</tt> as making a persistent instance
            transient.
        </p><pre class="programlisting">sess.delete(cat);</pre><p>
            You may delete objects in any order you like, without risk of foreign key
            constraint violations. It is still possible to violate a <tt class="literal">NOT
            NULL</tt> constraint on a foreign key column by deleting objects in
            the wrong order, e.g. if you delete the parent, but forget to delete the
            children.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-replicating"></a>10.9.&nbsp;Replicating object between two different datastores</h2></div></div><div></div></div><p>
    	    It is occasionally useful to be able to take a graph of persistent instances
    	    and make them persistent in a different datastore, without regenerating identifier
    	    values.
    	</p><pre class="programlisting">//retrieve a cat from one database
Session session1 = factory1.openSession();
Transaction tx1 = session1.beginTransaction();
Cat cat = session1.get(Cat.class, catId);
tx1.commit();
session1.close();

//reconcile with a second database
Session session2 = factory2.openSession();
Transaction tx2 = session2.beginTransaction();
session2.replicate(cat, ReplicationMode.LATEST_VERSION);
tx2.commit();
session2.close();</pre><p>
            The <tt class="literal">ReplicationMode</tt> determines how <tt class="literal">replicate()</tt>
            will deal with conflicts with existing rows in the database.
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">ReplicationMode.IGNORE</tt> - ignore the object when there is
                    an existing database row with the same identifier
                </p></li><li><p>
                    <tt class="literal">ReplicationMode.OVERWRITE</tt> - overwrite any existing database 
                    row with the same identifier
                </p></li><li><p>
                    <tt class="literal">ReplicationMode.EXCEPTION</tt> - throw an exception if there is
                    an existing database row with the same identifier
                </p></li><li><p>
                    <tt class="literal">ReplicationMode.LATEST_VERSION</tt> - overwrite the row if its
                    version number is earlier than the version number of the object, or ignore
                    the object otherwise
                </p></li></ul></div><p>
            Usecases for this feature include reconciling data entered into different database
            instances, upgrading system configuration information during product upgrades,
            rolling back changes made during non-ACID transactions and more.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-flushing"></a>10.10.&nbsp;Flushing the Session</h2></div></div><div></div></div><p>
            From time to time the <tt class="literal">Session</tt> will execute the SQL statements 
            needed to synchronize the JDBC connection's state with the state of objects held in 
            memory. This process, <span class="emphasis"><em>flush</em></span>, occurs by default at the following 
            points
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    before some query executions
                </p></li><li><p>
                    from <tt class="literal">org.hibernate.Transaction.commit()</tt>
                </p></li><li><p>
                    from <tt class="literal">Session.flush()</tt>
                </p></li></ul></div><p>
            The SQL statements are issued in the following order
        </p><div class="orderedlist"><ol type="1" compact><li><p>
                    all entity insertions, in the same order the corresponding objects
                    were saved using <tt class="literal">Session.save()</tt>
                </p></li><li><p>
                    all entity updates
                </p></li><li><p>
                    all collection deletions
                </p></li><li><p>
                    all collection element deletions, updates and insertions
                </p></li><li><p>
                    all collection insertions
                </p></li><li><p>
                    all entity deletions, in the same order the corresponding objects
                    were deleted using <tt class="literal">Session.delete()</tt>
                </p></li></ol></div><p>
            (An exception is that objects using <tt class="literal">native</tt> ID generation are 
            inserted when they are saved.)
        </p><p>
            Except when you explicity <tt class="literal">flush()</tt>, there are absolutely no 
            guarantees about <span class="emphasis"><em>when</em></span> the <tt class="literal">Session</tt> executes 
            the JDBC calls, only the <span class="emphasis"><em>order</em></span> in which they are executed.
            However, Hibernate does guarantee that the <tt class="literal">Query.list(..)</tt> 
            will never return stale data; nor will they return the wrong data.
        </p><p>
            It is possible to change the default behavior so that flush occurs less frequently.
            The <tt class="literal">FlushMode</tt> class defines three different modes: only flush
            at commit time (and only when the Hibernate <tt class="literal">Transaction</tt> API
            is used), flush automatically using the explained routine, or never flush unless
            <tt class="literal">flush()</tt> is called explicitly. The last mode is useful for long running
            units of work, where a <tt class="literal">Session</tt> is kept open and disconnected for
            a long time (see <a href="#transactions-optimistic-longsession" title="11.3.2.&nbsp;Extended session and automatic versioning">Section&nbsp;11.3.2, &#8220;Extended session and automatic versioning&#8221;</a>).
        </p><pre class="programlisting">sess = sf.openSession();
Transaction tx = sess.beginTransaction();
sess.setFlushMode(FlushMode.COMMIT); // allow queries to return stale state

Cat izi = (Cat) sess.load(Cat.class, id);
izi.setName(iznizi);

// might return stale data
sess.find("from Cat as cat left outer join cat.kittens kitten");

// change to izi is not flushed!
...
tx.commit(); // flush occurs
sess.close();</pre><p>
            During flush, an exception might occur (e.g. if a DML operation violates a constraint).
            Since handling exceptions involves some understanding of Hibernate's transactional 
            behavior, we discuss it in <a href="#transactions" title="Chapter&nbsp;11.&nbsp;Transactions And Concurrency">Chapter&nbsp;11, <i>Transactions And Concurrency</i></a>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-transitive"></a>10.11.&nbsp;Transitive persistence</h2></div></div><div></div></div><p>
            It is quite cumbersome to save, delete, or reattach individual objects,
            especially if you deal with a graph of associated objects. A common case is
            a parent/child relationship. Consider the following example:
        </p><p>
            If the children in a parent/child relationship would be value typed (e.g. a collection
            of addresses or strings), their lifecycle would depend on the parent and no
            further action would be required for convenient "cascading" of state changes.
            When the parent is saved, the value-typed child objects are saved as
            well, when the parent is deleted, the children will be deleted, etc. This
            even works for operations such as the removal of a child from the collection;
            Hibernate will detect this and, since value-typed objects can't have shared
            references, delete the child from the database.
        </p><p>
            Now consider the same scenario with parent and child objects being entities,
            not value-types (e.g. categories and items, or parent and child cats). Entities
            have their own lifecycle, support shared references (so removing an entity from
            the collection does not mean it can be deleted), and there is by default no
            cascading of state from one entity to any other associated entities. Hibernate
            does not implement <span class="emphasis"><em>persistence by reachability</em></span> by default.
        </p><p>
            For each basic operation of the Hibernate session - including <tt class="literal">persist(), merge(),
            saveOrUpdate(), delete(), lock(), refresh(), evict(), replicate()</tt> - there is a 
            corresponding cascade style. Respectively, the cascade styles are named <tt class="literal">create, 
            merge, save-update, delete, lock, refresh, evict, replicate</tt>. If you want an 
            operation to be cascaded along an association, you must indicate that in the mapping
            document. For example:
        </p><pre class="programlisting">&lt;one-to-one name="person" cascade="persist"/&gt;</pre><p>
            Cascade styles my be combined:
        </p><pre class="programlisting">&lt;one-to-one name="person" cascade="persist,delete,lock"/&gt;</pre><p>
            You may even use <tt class="literal">cascade="all"</tt> to specify that <span class="emphasis"><em>all</em></span>
            operations should be cascaded along the association. The default <tt class="literal">cascade="none"</tt>
            specifies that no operations are to be cascaded.
        </p><p>
            A special cascade style, <tt class="literal">delete-orphan</tt>, applies only to one-to-many
            associations, and indicates that the <tt class="literal">delete()</tt> operation should
            be applied to any child object that is removed from the association.
        </p><p>
            Recommendations:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    It doesn't usually make sense to enable cascade on a <tt class="literal">&lt;many-to-one&gt;</tt>
                    or <tt class="literal">&lt;many-to-many&gt;</tt> association. Cascade is often useful for 
                    <tt class="literal">&lt;one-to-one&gt;</tt> and <tt class="literal">&lt;one-to-many&gt;</tt>
                    associations.
                </p></li><li><p>
                    If the child object's lifespan is bounded by the lifespan of the of the parent
                    object make it a <span class="emphasis"><em>lifecycle object</em></span> by specifying
                    <tt class="literal">cascade="all,delete-orphan"</tt>.
                </p></li><li><p>
                    Otherwise, you might not need cascade at all. But if you think that you will often be
                    working with the parent and children together in the same transaction, and you want to save 
                    yourself some typing, consider using <tt class="literal">cascade="persist,merge,save-update"</tt>.
                </p></li></ul></div><p>
            Mapping an association (either a single valued association, or a collection) with 
            <tt class="literal">cascade="all"</tt> marks the association as a 
            <span class="emphasis"><em>parent/child</em></span> style relationship where save/update/delete of the 
            parent results in save/update/delete of the child or children.
        </p><p>
            Futhermore, a mere reference to a child from a persistent parent will result in 
            save/update of the child. This metaphor is incomplete, however. A child which becomes 
            unreferenced by its parent is <span class="emphasis"><em>not</em></span> automatically deleted, except 
            in the case of a <tt class="literal">&lt;one-to-many&gt;</tt> association mapped with
            <tt class="literal">cascade="delete-orphan"</tt>. The precise semantics of cascading 
            operations for a parent/child relationship are as follows:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    If a parent is passed to <tt class="literal">persist()</tt>, all children are passed to 
                    <tt class="literal">persist()</tt>
                </p></li><li><p>
                    If a parent is passed to <tt class="literal">merge()</tt>, all children are passed to 
                    <tt class="literal">merge()</tt>
                </p></li><li><p>
                    If a parent is passed to <tt class="literal">save()</tt>, <tt class="literal">update()</tt> or 
                    <tt class="literal">saveOrUpdate()</tt>, all children are passed to <tt class="literal">saveOrUpdate()</tt>
                </p></li><li><p>
                    If a transient or detached child becomes referenced by a persistent parent, 
                    it is passed to <tt class="literal">saveOrUpdate()</tt>
                </p></li><li><p>
                    If a parent is deleted, all children are passed to <tt class="literal">delete()</tt>
                </p></li><li><p>
                    If a child is dereferenced by a persistent parent, <span class="emphasis"><em>nothing
                    special happens</em></span> - the application should explicitly delete 
                    the child if necessary - unless <tt class="literal">cascade="delete-orphan"</tt>, 
                    in which case the "orphaned" child is deleted.
                </p></li></ul></div><p>
            Finally, note that cascading of operations can be applied to an object graph at
            <span class="emphasis"><em>call time</em></span> or at <span class="emphasis"><em>flush time</em></span>. All operations,
            if enabled, are cascaded to associated entities reachable when the operation is
            executed. However, <tt class="literal">save-upate</tt> and <tt class="literal">delete-orphan</tt>
            are transitive for all associated entities reachable during flush of the
            <tt class="literal">Session</tt>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-metadata"></a>10.12.&nbsp;Using metadata</h2></div></div><div></div></div><p>
            Hibernate requires a very rich meta-level model of all entity and value types. From time
            to time, this model is very useful to the application itself. For example, the application
            might use Hibernate's metadata to implement a "smart" deep-copy algorithm that understands
            which objects should be copied (eg. mutable value types) and which should not (eg. 
            immutable value types and, possibly, associated entities).
        </p><p>
            Hibernate exposes metadata via the <tt class="literal">ClassMetadata</tt> and
            <tt class="literal">CollectionMetadata</tt> interfaces and the <tt class="literal">Type</tt>
            hierarchy. Instances of the metadata interfaces may be obtained from the 
            <tt class="literal">SessionFactory</tt>.
        </p><pre class="programlisting">Cat fritz = ......;
ClassMetadata catMeta = sessionfactory.getClassMetadata(Cat.class);

Object[] propertyValues = catMeta.getPropertyValues(fritz);
String[] propertyNames = catMeta.getPropertyNames();
Type[] propertyTypes = catMeta.getPropertyTypes();

// get a Map of all properties which are not collections or associations
Map namedValues = new HashMap();
for ( int i=0; i&lt;propertyNames.length; i++ ) {
    if ( !propertyTypes[i].isEntityType() &amp;&amp; !propertyTypes[i].isCollectionType() ) {
        namedValues.put( propertyNames[i], propertyValues[i] );
    }
}</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="transactions"></a>Chapter&nbsp;11.&nbsp;Transactions And Concurrency</h2></div></div><div></div></div><p>
        The most important point about Hibernate and concurrency control is that it is very
        easy to understand. Hibernate directly uses JDBC connections and JTA resources without
        adding any additional locking behavior. We highly recommend you spend some time with the
        JDBC, ANSI, and transaction isolation specification of your database management system.
    </p><p>
        Hibernate does not lock objects in memory. Your application can expect the behavior as
        defined by the isolation level of your database transactions. Note that thanks to the
        <tt class="literal">Session</tt>, which is also a transaction-scoped cache, Hibernate
        provides repeatable reads for lookup by identifier and entity queries (not
        reporting queries that return scalar values).
    </p><p>
        In addition to versioning for automatic optimistic concurrency control, Hibernate also
        offers a (minor) API for pessimistic locking of rows, using the
        <tt class="literal">SELECT FOR UPDATE</tt> syntax. Optimistic concurrency control and
        this API are discussed later in this chapter.
    </p><p>
        We start the discussion of concurrency control in Hibernate with the granularity of
        <tt class="literal">Configuration</tt>, <tt class="literal">SessionFactory</tt>, and
        <tt class="literal">Session</tt>, as well as database transactions and long conversations.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-basics"></a>11.1.&nbsp;Session and transaction scopes</h2></div></div><div></div></div><p>
            A <tt class="literal">SessionFactory</tt> is an expensive-to-create, threadsafe object 
            intended to be shared by all application threads. It is created once, usually on
            application startup, from a <tt class="literal">Configuration</tt> instance.
        </p><p>
            A <tt class="literal">Session</tt> is an inexpensive, non-threadsafe object that should be
            used once, for a single request, a conversation, single unit of work, and then discarded.
            A <tt class="literal">Session</tt> will not obtain a JDBC <tt class="literal">Connection</tt>
            (or a <tt class="literal">Datasource</tt>) unless it is needed, hence consume no
            resources until used.
        </p><p>
            To complete this picture you also have to think about database transactions. A
            database transaction has to be as short as possible, to reduce lock contention in
            the database. Long database transactions will prevent your application from scaling
            to highly concurrent load. Hence, it is almost never good design to hold a
            database transaction open during user think time, until the unit of work is
            complete.
        </p><p>
            What is the scope of a unit of work? Can a single Hibernate <tt class="literal">Session</tt>
            span several database transactions or is this a one-to-one relationship of scopes? When
            should you open and close a <tt class="literal">Session</tt> and how do you demarcate the
            database transaction boundaries?
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-basics-uow"></a>11.1.1.&nbsp;Unit of work</h3></div></div><div></div></div><p>
                First, don't use the <span class="emphasis"><em>session-per-operation</em></span> antipattern, that is,
                don't open and close a <tt class="literal">Session</tt> for every simple database call in
                a single thread! Of course, the same is true for database transactions. Database calls
                in an application are made using a planned sequence, they are grouped into atomic
                units of work. (Note that this also means that auto-commit after every single
                SQL statement is useless in an application, this mode is intended for ad-hoc SQL
                console work. Hibernate disables, or expects the application server to do so,
                auto-commit mode immediately.) Database transactions are never optional, all
                communication with a database has to occur inside a transaction, no matter if
                you read or write data. As explained, auto-commit behavior for reading data
                should be avoided, as many small transactions are unlikely to perform better than
                one clearly defined unit of work. The latter is also much more maintainable
                and extensible.
            </p><p>
                The most common pattern in a multi-user client/server application is
                <span class="emphasis"><em>session-per-request</em></span>. In this model, a request from the client
                is send to the server (where the Hibernate persistence layer runs), a new Hibernate
                <tt class="literal">Session</tt> is opened, and all database operations are executed in this unit
                of work. Once the work has been completed (and the response for the client has been prepared),
                the session is flushed and closed. You would also use a single database transaction to
                serve the clients request, starting and committing it when you open and close the
                <tt class="literal">Session</tt>. The relationship between the two is one-to-one and this
                model is a perfect fit for many applications.
            </p><p>
                The challenge lies in the implementation. Hibernate provides built-in management of
                the "current session" to simplify this pattern. All you have to do is start a
                transaction when a server request has to be processed, and end the transaction
                before the response is send to the client. You can do this in any way you
                like, common solutions are <tt class="literal">ServletFilter</tt>, AOP interceptor with a
                pointcut on the service methods, or a proxy/interception container. An EJB container
                is a standardized way to implement cross-cutting aspects such as transaction
                demarcation on EJB session beans, declaratively with CMT. If you decide to
                use programmatic transaction demarcation, prefer the Hibernate <tt class="literal">Transaction</tt>
                API shown later in this chapter, for ease of use and code portability.
            </p><p>
                Your application code can access a "current session" to process the request
                by simply calling <tt class="literal">sessionFactory.getCurrentSession()</tt> anywhere
                and as often as needed. You will always get a <tt class="literal">Session</tt> scoped
                to the current database transaction. This has to be configured for either
                resource-local or JTA environments, see <a href="#architecture-current-session" title="2.5.&nbsp;Contextual Sessions">Section&nbsp;2.5, &#8220;Contextual Sessions&#8221;</a>.
            </p><p>
                Sometimes it is convenient to extend the scope of a <tt class="literal">Session</tt> and
                database transaction until the "view has been rendered". This is especially useful
                in servlet applications that utilize a separate rendering phase after the request
                has been processed. Extending the database transaction until view rendering is
                complete is easy to do if you implement your own interceptor. However, it is not
                easily doable if you rely on EJBs with container-managed transactions, as a
                transaction will be completed when an EJB method returns, before rendering of any
                view can start. See the Hibernate website and forum for tips and examples around
                this <span class="emphasis"><em>Open Session in View</em></span> pattern.
             </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-basics-apptx"></a>11.1.2.&nbsp;Long conversations</h3></div></div><div></div></div><p>
                The session-per-request pattern is not the only useful concept you can use to design
                units of work. Many business processes require a whole series of interactions with the user
                interleaved with database accesses. In web and enterprise applications it is
                not acceptable for a database transaction to span a user interaction. Consider the following
                example:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        The first screen of a dialog opens, the data seen by the user has been loaded in
                        a particular <tt class="literal">Session</tt> and database transaction. The user is free to
                        modify the objects.
                    </p></li><li><p>
                        The user clicks "Save" after 5 minutes and expects his modifications to be made
                        persistent; he also expects that he was the only person editing this information and
                        that no conflicting modification can occur.
                    </p></li></ul></div><p>
                We call this unit of work, from the point of view of the user, a long running
                <span class="emphasis"><em>conversation</em></span> (or <span class="emphasis"><em>application transaction</em></span>).
                There are many ways how you can implement this in your application.
            </p><p>
                A first naive implementation might keep the <tt class="literal">Session</tt> and database
                transaction open during user think time, with locks held in the database to prevent
                concurrent modification, and to guarantee isolation and atomicity. This is of course
                an anti-pattern, since lock contention would not allow the application to scale with
                the number of concurrent users.
            </p><p>
                Clearly, we have to use several database transactions to implement the converastion.
                In this case, maintaining isolation of business processes becomes the
                partial responsibility of the application tier. A single conversation
                usually spans several database transactions. It will be atomic if only one of
                these database transactions (the last one) stores the updated data, all others
                simply read data (e.g. in a wizard-style dialog spanning several request/response
                cycles). This is easier to implement than it might sound, especially if
                you use Hibernate's features:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        <span class="emphasis"><em>Automatic Versioning</em></span> - Hibernate can do automatic
                        optimistic concurrency control for you, it can automatically detect
                        if a concurrent modification occured during user think time. Usually
                        we only check at the end of the conversation.
                    </p></li><li><p>
                        <span class="emphasis"><em>Detached Objects</em></span> - If you decide to use the already
                        discussed <span class="emphasis"><em>session-per-request</em></span> pattern, all loaded instances
                        will be in detached state during user think time. Hibernate allows you to
                        reattach the objects and persist the modifications, the pattern is called
                        <span class="emphasis"><em>session-per-request-with-detached-objects</em></span>. Automatic
                        versioning is used to isolate concurrent modifications.
                    </p></li><li><p>
                        <span class="emphasis"><em>Extended (or Long) Session</em></span> - The Hibernate
                        <tt class="literal">Session</tt> may be disconnected from the underlying JDBC
                        connection after the database transaction has been committed, and reconnected
                        when a new client request occurs. This pattern is known as
                        <span class="emphasis"><em>session-per-conversation</em></span> and makes
                        even reattachment unnecessary. Automatic versioning is used to isolate
                        concurrent modifications and the <tt class="literal">Session</tt> is usually
                        not allowed to be flushed automatically, but explicitely.
                    </p></li></ul></div><p>
                Both <span class="emphasis"><em>session-per-request-with-detached-objects</em></span> and
                <span class="emphasis"><em>session-per-conversation</em></span> have advantages and disadvantages,
                we discuss them later in this chapter in the context of optimistic concurrency control.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-basics-identity"></a>11.1.3.&nbsp;Considering object identity</h3></div></div><div></div></div><p>
                An application may concurrently access the same persistent state in two
                different <tt class="literal">Session</tt>s. However, an instance of a persistent class
                is never shared between two <tt class="literal">Session</tt> instances. Hence there are
                two different notions of identity:
            </p><div class="variablelist"><dl><dt><span class="term">Database Identity</span></dt><dd><p>
                            <tt class="literal">foo.getId().equals( bar.getId() )</tt>
                        </p></dd><dt><span class="term">JVM Identity</span></dt><dd><p>
                            <tt class="literal">foo==bar</tt>
                        </p></dd></dl></div><p>
                Then for objects attached to a <span class="emphasis"><em>particular</em></span> <tt class="literal">Session</tt>
                (i.e. in the scope of a <tt class="literal">Session</tt>) the two notions are equivalent, and
                JVM identity for database identity is guaranteed by Hibernate. However, while the application
                might concurrently access the "same" (persistent identity) business object in two different
                sessions, the two instances will actually be "different" (JVM identity). Conflicts are
                resolved using (automatic versioning) at flush/commit time, using an optimistic approach.
            </p><p>
                This approach leaves Hibernate and the database to worry about concurrency; it also provides
                the best scalability, since guaranteeing identity in single-threaded units of work only doesn't
                need expensive locking or other means of synchronization. The application never needs to
                synchronize on any business object, as long as it sticks to a single thread per
                <tt class="literal">Session</tt>. Within a <tt class="literal">Session</tt> the  application may safely use
                <tt class="literal">==</tt> to compare objects.
            </p><p>
                However, an application that uses <tt class="literal">==</tt> outside of a <tt class="literal">Session</tt>,
                might see unexpected results. This might occur even in some unexpected places, for example,
                if you put two detached instances into the same <tt class="literal">Set</tt>. Both might have the same
                database identity (i.e. they represent the same row), but JVM identity is by definition not
                guaranteed for instances in detached state. The developer has to override the <tt class="literal">equals()</tt>
                and <tt class="literal">hashCode()</tt> methods in persistent classes and implement
                his own notion of object equality. There is one caveat: Never use the database
                identifier to implement equality, use a business key, a combination of unique, usually
                immutable, attributes. The database identifier will change if a transient object is made
                persistent. If the transient instance (usually together with detached instances) is held in a
                <tt class="literal">Set</tt>, changing the hashcode breaks the contract of the <tt class="literal">Set</tt>.
                Attributes for business keys don't have to be as stable as database primary keys, you only
                have to guarantee stability as long as the objects are in the same <tt class="literal">Set</tt>. See
                the Hibernate website for a more thorough discussion of this issue. Also note that this is not
                a Hibernate issue, but simply how Java object identity and equality has to be implemented.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-basics-issues"></a>11.1.4.&nbsp;Common issues</h3></div></div><div></div></div><p>
                 Never use the anti-patterns <span class="emphasis"><em>session-per-user-session</em></span> or
                 <span class="emphasis"><em>session-per-application</em></span> (of course, there are rare exceptions to
                 this rule). Note that some of the following issues might also appear with the recommended
                 patterns, make sure you understand the implications before making a design decision:
             </p><div class="itemizedlist"><ul type="disc"><li><p>
                        A <tt class="literal">Session</tt> is not thread-safe. Things which are supposed to work
                        concurrently, like HTTP requests, session beans, or Swing workers, will cause race
                        conditions if a <tt class="literal">Session</tt> instance would be shared. If you keep your
                        Hibernate <tt class="literal">Session</tt> in your <tt class="literal">HttpSession</tt> (discussed
                        later), you should consider synchronizing access to your Http session. Otherwise,
                        a user that clicks reload fast enough may use the same <tt class="literal">Session</tt> in
                        two concurrently running threads.
                    </p></li><li><p>
                        An exception thrown by Hibernate means you have to rollback your database transaction
                        and close the <tt class="literal">Session</tt> immediately (discussed later in more detail).
                        If your <tt class="literal">Session</tt> is bound to the application, you have to stop
                        the application. Rolling back the database transaction doesn't put your business
                        objects back into the state they were at the start of the transaction. This means the
                        database state and the business objects do get out of sync. Usually this is not a
                        problem, because exceptions are not recoverable and you have to start over after
                        rollback anyway.
                    </p></li><li><p>
                        The <tt class="literal">Session</tt> caches every object that is in persistent state (watched
                        and checked for dirty state by Hibernate). This means it grows endlessly until you
                        get an OutOfMemoryException, if you keep it open for a long time or simply load too
                        much data. One solution for this is to call <tt class="literal">clear()</tt> and <tt class="literal">evict()</tt>
                        to manage the <tt class="literal">Session</tt> cache, but you most likely should consider a
                        Stored Procedure if you need mass data operations. Some solutions are shown in
                        <a href="#batch" title="Chapter&nbsp;13.&nbsp;Batch processing">Chapter&nbsp;13, <i>Batch processing</i></a>. Keeping a <tt class="literal">Session</tt> open for the duration
                        of a user session also means a high probability of stale data.
                    </p></li></ul></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-demarcation"></a>11.2.&nbsp;Database transaction demarcation</h2></div></div><div></div></div><p>
            Datatabase (or system) transaction boundaries are always necessary. No communication with
            the database can occur outside of a database transaction (this seems to confuse many developers
            who are used to the auto-commit mode). Always use clear transaction boundaries, even for
            read-only operations. Depending on your isolation level and database capabilities this might not
            be required but there is no downside if you always demarcate transactions explicitly. Certainly,
            a single database transaction is going to perform better than many small transactions, even
            for reading data.
        </p><p>
            A Hibernate application can run in non-managed (i.e. standalone, simple Web- or Swing applications)
            and managed J2EE environments. In a non-managed environment, Hibernate is usually responsible for
            its own database connection pool. The application developer has to manually set transaction
            boundaries, in other words, begin, commit, or rollback database transactions himself. A managed environment
            usually provides container-managed transactions (CMT), with the transaction assembly defined declaratively
            in deployment descriptors of EJB session beans, for example. Programmatic transaction demarcation is
            then no longer necessary.
        </p><p>
            However, it is often desirable to keep your persistence layer portable between non-managed
            resource-local environments, and systems that can rely on JTA but use BMT instead of CMT.
            In both cases you'd use programmatic transaction demaracation. Hibernate offers a wrapper
            API called <tt class="literal">Transaction</tt> that translates into the native transaction system of
            your deployment environment. This API is actually optional, but we strongly encourage its use
            unless you are in a CMT session bean.
        </p><p>
            Usually, ending a <tt class="literal">Session</tt> involves four distinct phases:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    flush the session
                </p></li><li><p>
                    commit the transaction
                </p></li><li><p>
                    close the session
                </p></li><li><p>
                    handle exceptions
                </p></li></ul></div><p>
            Flushing the session has been discussed earlier, we'll now have a closer look at transaction
            demarcation and exception handling in both managed- and non-managed environments.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-demarcation-nonmanaged"></a>11.2.1.&nbsp;Non-managed environment</h3></div></div><div></div></div><p>
                If a Hibernate persistence layer runs in a non-managed environment, database connections
                are usually handled by simple (i.e. non-DataSource) connection pools from which
	            Hibernate obtains connections as needed. The session/transaction handling idiom looks
	            like this:
            </p><pre class="programlisting">// Non-managed environment idiom
Session sess = factory.openSession();
Transaction tx = null;
try {
    tx = sess.beginTransaction();

    // do some work
    ...

    tx.commit();
}
catch (RuntimeException e) {
    if (tx != null) tx.rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}</pre><p>
                You don't have to <tt class="literal">flush()</tt> the <tt class="literal">Session</tt> explicitly -
                the call to <tt class="literal">commit()</tt> automatically triggers the synchronization (depending
	            upon the <a href="#objectstate-flushing" title="10.10.&nbsp;Flushing the Session">Section&nbsp;10.10, &#8220;Flushing the Session&#8221;</a> for the session.
                A call to <tt class="literal">close()</tt> marks the end of a session. The main implication
                of <tt class="literal">close()</tt> is that the JDBC connection will be relinquished by the
                session. This Java code is portable and runs in both non-managed and JTA environments.
            </p><p>
                A much more flexible solution is Hibernate's built-in "current session" context
                management, as described earlier:
            </p><pre class="programlisting">// Non-managed environment idiom with getCurrentSession()
try {
    factory.getCurrentSession().beginTransaction();

    // do some work
    ...

    factory.getCurrentSession().getTransaction().commit();
}
catch (RuntimeException e) {
    factory.getCurrentSession().getTransaction().rollback();
    throw e; // or display error message
}</pre><p>
                You will very likely never see these code snippets in a regular application;
                fatal (system) exceptions should always be caught at the "top". In other words, the
                code that executes Hibernate calls (in the persistence layer) and the code that handles
                <tt class="literal">RuntimeException</tt> (and usually can only clean up and exit) are in
                different layers. The current context management by Hibernate can significantly
                simplify this design, as all you need is access to a <tt class="literal">SessionFactory</tt>.
                Exception handling is discussed later in this chapter.
            </p><p>
                Note that you should select <tt class="literal">org.hibernate.transaction.JDBCTransactionFactory</tt>
                (which is the default), and for the second example <tt class="literal">"thread"</tt> as your
                <tt class="literal">hibernate.current_session_context_class</tt>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-demarcation-jta"></a>11.2.2.&nbsp;Using JTA</h3></div></div><div></div></div><p>
                If your persistence layer runs in an application server (e.g. behind EJB session beans),
                every datasource connection obtained by Hibernate will automatically be part of the global
                JTA transaction. Hibernate offers two strategies for this integration.
            </p><p>
                If you use bean-managed transactions (BMT) Hibernate will tell the application server to start
                and end a BMT transaction if you use the <tt class="literal">Transaction</tt> API. So, the
                transaction management code is identical to the non-managed environment.
            </p><pre class="programlisting">// BMT idiom
Session sess = factory.openSession();
Transaction tx = null;
try {
    tx = sess.beginTransaction();

    // do some work
    ...

    tx.commit();
}
catch (RuntimeException e) {
    if (tx != null) tx.rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}</pre><p>
                Or with automatic session context management:
            </p><pre class="programlisting">// BMT idiom with getCurrentSession()
try {
    factory.getCurrentSession().beginTransaction();

    // do some work
    ...

    factory.getCurrentSession().getTransaction().commit();
}
catch (RuntimeException e) {
    factory.getCurrentSession().getTransaction().rollback();
    throw e; // or display error message
}</pre><p>
                With CMT, transaction demarcation is done in session bean deployment descriptors, not programatically,
                hence, the code is reduced to:
            </p><pre class="programlisting">// CMT idiom
 Session sess = factory.getCurrentSession();

 // do some work
 ...
</pre><p>
                In a CMT?EJB even rollback happens automatically, since an unhandled <tt class="literal">RuntimeException</tt>
                thrown  by a session bean method tells the container to set the global transaction to rollback.
                <span class="emphasis"><em>This means you do not need to use the Hibernate <tt class="literal">Transaction</tt> API at
                all in CMT.</em></span>
            </p><p>
                Note that you should choose <tt class="literal">org.hibernate.transaction.JTATransactionFactory</tt>
                in a BMT session bean, and <tt class="literal">org.hibernate.transaction.CMTTransactionFactory</tt>
                in a CMT session bean, when you configure Hibernate's transaction factory. Remember to also set
                <tt class="literal">hibernate.transaction.manager_lookup_class</tt>. Furthermore, make sure
                that your <tt class="literal">hibernate.current_session_context_class</tt> is either unset (backwards
                compatiblity), or set to <tt class="literal">"jta"</tt>.
            </p><p>
                The <tt class="literal">getCurrentSession()</tt> operation has one downside in a JTA environment.
                There is one caveat to the use of <tt class="literal">after_statement</tt> connection release
                mode, which is then used by default. Due to a silly limitation of the JTA spec, it is not
                possible for Hibernate to automatically clean up any unclosed <tt class="literal">ScrollableResults</tt> or
                <tt class="literal">Iterator</tt> instances returned by <tt class="literal">scroll()</tt> or 
                <tt class="literal">iterate()</tt>. You <span class="emphasis"><em>must</em></span> release the underlying database 
                cursor by calling <tt class="literal">ScrollableResults.close()</tt> or 
                <tt class="literal">Hibernate.close(Iterator)</tt> explicity from a <tt class="literal">finally</tt> 
                block. (Of course, most applications can easily avoid using <tt class="literal">scroll()</tt> or 
                <tt class="literal">iterate()</tt> at all from the CMT code.)
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-demarcation-exceptions"></a>11.2.3.&nbsp;Exception handling</h3></div></div><div></div></div><p>
                If the <tt class="literal">Session</tt> throws an exception (including any
                <tt class="literal">SQLException</tt>), you should immediately rollback the database
                transaction, call <tt class="literal">Session.close()</tt> and discard the
                <tt class="literal">Session</tt> instance. Certain methods of <tt class="literal">Session</tt>
                will <span class="emphasis"><em>not</em></span> leave the session in a consistent state. No
                exception thrown by Hibernate can be treated as recoverable. Ensure that the
                <tt class="literal">Session</tt> will be closed by calling <tt class="literal">close()</tt>
                in a <tt class="literal">finally</tt> block.
            </p><p>
                The <tt class="literal">HibernateException</tt>, which wraps most of the errors that
                can occur in a Hibernate persistence layer, is an unchecked exception (it wasn't
                in older versions of Hibernate). In our opinion, we shouldn't force the application
                developer to catch an unrecoverable exception at a low layer. In most systems, unchecked
                and fatal exceptions are handled in one of the first frames of the method call
                stack (i.e. in higher layers) and an error message is presented to the application
                user (or some other appropriate action is taken). Note that Hibernate might also throw
                other unchecked exceptions which are not a <tt class="literal">HibernateException</tt>. These 
                are, again, not recoverable and appropriate action should be taken.
            </p><p>
                Hibernate wraps <tt class="literal">SQLException</tt>s thrown while interacting with the database
                in a <tt class="literal">JDBCException</tt>. In fact, Hibernate will attempt to convert the eexception
                into a more meningful subclass of <tt class="literal">JDBCException</tt>.  The underlying
                <tt class="literal">SQLException</tt> is always available via <tt class="literal">JDBCException.getCause()</tt>.
                Hibernate converts the <tt class="literal">SQLException</tt> into an appropriate 
                <tt class="literal">JDBCException</tt> subclass using the <tt class="literal">SQLExceptionConverter</tt> 
                attached to the <tt class="literal">SessionFactory</tt>. By default, the 
                <tt class="literal">SQLExceptionConverter</tt> is defined by the configured dialect; however, it is
                also possible to plug in a custom implementation (see the javadocs for the
                <tt class="literal">SQLExceptionConverterFactory</tt> class for details).  The standard 
                <tt class="literal">JDBCException</tt> subtypes are:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">JDBCConnectionException</tt> - indicates an error
                        with the underlying JDBC communication.
                    </p></li><li><p>
                        <tt class="literal">SQLGrammarException</tt> - indicates a grammar
                        or syntax problem with the issued SQL.
                    </p></li><li><p>
                        <tt class="literal">ConstraintViolationException</tt> - indicates some
                        form of integrity constraint violation.
                    </p></li><li><p>
                        <tt class="literal">LockAcquisitionException</tt> - indicates an error
                        acquiring a lock level necessary to perform the requested operation.
                    </p></li><li><p>
                        <tt class="literal">GenericJDBCException</tt> - a generic exception
                        which did not fall into any of the other categories.
                    </p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-demarcation-timeout"></a>11.2.4.&nbsp;Transaction timeout</h3></div></div><div></div></div><p>
                One extremely important feature provided by a managed environment like EJB
                that is never provided for non-managed code is transaction timeout. Transaction
                timeouts ensure that no misbehaving transaction can indefinitely tie up 
                resources while returning no response to the user. Outside a managed (JTA)
                environment, Hibernate cannot fully provide this functionality. However,
                Hibernate can at least control data access operations, ensuring that database
                level deadlocks and queries with huge result sets are limited by a defined
                timeout. In a managed environment, Hibernate can delegate transaction timeout
                to JTA. This functioanlity is abstracted by the Hibernate 
                <tt class="literal">Transaction</tt> object.
            </p><pre class="programlisting">
Session sess = factory.openSession();
try {
    //set transaction timeout to 3 seconds
    sess.getTransaction().setTimeout(3);
    sess.getTransaction().begin();

    // do some work
    ...

    sess.getTransaction().commit()
}
catch (RuntimeException e) {
    sess.getTransaction().rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}</pre><p>
                Note that <tt class="literal">setTimeout()</tt> may not be called in a CMT bean,
                where transaction timeouts must be defined declaratively.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-optimistic"></a>11.3.&nbsp;Optimistic concurrency control</h2></div></div><div></div></div><p>
            The only approach that is consistent with high concurrency and high
            scalability is optimistic concurrency control with versioning. Version
            checking uses version numbers, or timestamps, to detect conflicting updates
            (and to prevent lost updates). Hibernate provides for three possible approaches
            to writing application code that uses optimistic concurrency. The use cases
            we show are in the context of long conversations, but version checking
            also has the benefit of preventing lost updates in single database transactions.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-manual"></a>11.3.1.&nbsp;Application version checking</h3></div></div><div></div></div><p>
                In an implementation without much help from Hibernate, each interaction with the
                database occurs in a new <tt class="literal">Session</tt> and the developer is responsible
                for reloading all persistent instances from the database before manipulating them.
                This approach forces the application to carry out its own version checking to ensure
                conversation transaction isolation. This approach is the least efficient in terms of
                database access. It is the approach most similar to entity EJBs.
            </p><pre class="programlisting">// foo is an instance loaded by a previous Session
session = factory.openSession();
Transaction t = session.beginTransaction();

int oldVersion = foo.getVersion();
session.load( foo, foo.getKey() ); // load the current state
if ( oldVersion!=foo.getVersion ) throw new StaleObjectStateException();
foo.setProperty("bar");

t.commit();
session.close();</pre><p>
                The <tt class="literal">version</tt> property is mapped using <tt class="literal">&lt;version&gt;</tt>,
                and Hibernate will automatically increment it during flush if the entity is
                dirty.
            </p><p>
                Of course, if you are operating in a low-data-concurrency environment and don't
                require version checking, you may use this approach and just skip the version
                check. In that case, <span class="emphasis"><em>last commit wins</em></span> will be the default
                strategy for your long conversations. Keep in mind that this might
                confuse the users of the application, as they might experience lost updates without
                error messages or a chance to merge conflicting changes.
            </p><p>
                Clearly, manual version checking is only feasible in very trivial circumstances
                and not practical for most applications. Often not only single instances, but
                complete graphs of modified ojects have to be checked. Hibernate offers automatic
                version checking with either an extended <tt class="literal">Session</tt> or detached instances
                as the design paradigm.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-longsession"></a>11.3.2.&nbsp;Extended session and automatic versioning</h3></div></div><div></div></div><p>
                A single <tt class="literal">Session</tt> instance and its persistent instances are
                used for the whole conversation, known as <span class="emphasis"><em>session-per-conversation</em></span>.
                Hibernate checks instance versions at flush time, throwing an exception if concurrent
                modification is detected. It's up to the developer to catch and handle this exception
                (common options are the opportunity for the user to merge changes or to restart the
                business conversation with non-stale data).
            </p><p>
                The <tt class="literal">Session</tt> is disconnected from any underlying JDBC connection
                when waiting for user interaction. This approach is the most efficient in terms
                of database access. The application need not concern itself with version checking or
                with reattaching detached instances, nor does it have to reload instances in every
                database transaction.
            </p><pre class="programlisting">// foo is an instance loaded earlier by the old session
Transaction t = session.beginTransaction(); // Obtain a new JDBC connection, start transaction

foo.setProperty("bar");

session.flush();    // Only for last transaction in conversation
t.commit();         // Also return JDBC connection
session.close();    // Only for last transaction in conversation</pre><p>
                The <tt class="literal">foo</tt> object still knows which <tt class="literal">Session</tt> it was
                loaded in. Beginning a new database transaction on an old session obtains a new connection
                and resumes the session. Committing a database transaction disconnects a session
                from the JDBC connection and returns the connection to the pool. After reconnection, to
                force a version check on data  you aren't updating, you may call <tt class="literal">Session.lock()</tt>
                with <tt class="literal">LockMode.READ</tt> on any objects that might have been updated by another
                transaction. You don't need to lock any data that you <span class="emphasis"><em>are</em></span> updating.
                Usually you would set <tt class="literal">FlushMode.NEVER</tt> on an extended <tt class="literal">Session</tt>,
                so that only the last database transaction cycle is allowed to actually persist all
                modifications made in this conversation. Hence, only this last database transaction
                would include the <tt class="literal">flush()</tt> operation, and then also
                <tt class="literal">close()</tt> the session to end the conversation.
            </p><p>
                This pattern is problematic if the <tt class="literal">Session</tt> is too big to
                be stored during user think time, e.g. an <tt class="literal">HttpSession</tt> should
                be kept as small as possible. As the <tt class="literal">Session</tt> is also the
                (mandatory) first-level cache and contains all loaded objects, we can probably
                use this strategy only for a few request/response cycles. You should use a
                <tt class="literal">Session</tt> only for a single conversation, as it will soon also
                have stale data.
            </p><p>
                (Note that earlier Hibernate versions required explicit disconnection and reconnection
                of a <tt class="literal">Session</tt>. These methods are deprecated, as beginning and
                ending a transaction has the same effect.)
            </p><p>
                Also note that you should keep the disconnected <tt class="literal">Session</tt> close
                to the persistence layer. In other words, use an EJB stateful session bean to
                hold the <tt class="literal">Session</tt> in a three-tier environment, and don't transfer
                it to the web layer (or even serialize it to a separate tier) to store it in the
                <tt class="literal">HttpSession</tt>.
            </p><p>
                The extended session pattern, or <span class="emphasis"><em>session-per-conversation</em></span>, is
                more difficult to implement with automatic current session context management.
                You need to supply your own implementation of the <tt class="literal">CurrentSessionContext</tt>
                for this, see the Hibernate Wiki for examples.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-detached"></a>11.3.3.&nbsp;Detached objects and automatic versioning</h3></div></div><div></div></div><p>
                Each interaction with the persistent store occurs in a new <tt class="literal">Session</tt>.
                However, the same persistent instances are reused for each interaction with the database.
                The application manipulates the state of detached instances originally loaded in another
                <tt class="literal">Session</tt> and then reattaches them using <tt class="literal">Session.update()</tt>,
                <tt class="literal">Session.saveOrUpdate()</tt>, or <tt class="literal">Session.merge()</tt>.
            </p><pre class="programlisting">// foo is an instance loaded by a previous Session
foo.setProperty("bar");
session = factory.openSession();
Transaction t = session.beginTransaction();
session.saveOrUpdate(foo); // Use merge() if "foo" might have been loaded already
t.commit();
session.close();</pre><p>
                Again, Hibernate will check instance versions during flush, throwing an
                exception if conflicting updates occured.
            </p><p>
                You may also call <tt class="literal">lock()</tt> instead of <tt class="literal">update()</tt>
                and use <tt class="literal">LockMode.READ</tt> (performing a version check, bypassing all
                caches) if you are sure that the object has not been modified.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-customizing"></a>11.3.4.&nbsp;Customizing automatic versioning</h3></div></div><div></div></div><p>
                You may disable Hibernate's automatic version increment for particular properties and 
                collections by setting the <tt class="literal">optimistic-lock</tt> mapping attribute to 
                <tt class="literal">false</tt>. Hibernate will then no longer increment versions if the 
                property is dirty.
            </p><p>
                Legacy database schemas are often static and can't be modified. Or, other applications
                might also access the same database and don't know how to handle version numbers or
                even timestamps. In both cases, versioning can't rely on a particular column in a table.
                To force a version check without a version or timestamp property mapping, with a
                comparison of the state of all fields in a row, turn on <tt class="literal">optimistic-lock="all"</tt>
                in the <tt class="literal">&lt;class&gt;</tt> mapping. Note that this concepetually only works
                if Hibernate can compare the old and new state, i.e. if you use a single long
                <tt class="literal">Session</tt> and not session-per-request-with-detached-objects.
            </p><p>
                Sometimes concurrent modification can be permitted as long as the changes that have been
                made don't overlap. If you set <tt class="literal">optimistic-lock="dirty"</tt> when mapping the
                <tt class="literal">&lt;class&gt;</tt>, Hibernate will only compare dirty fields during flush.
            </p><p>
                In both cases, with dedicated version/timestamp columns or with full/dirty field
                comparison, Hibernate uses a single <tt class="literal">UPDATE</tt> statement (with an
                appropriate <tt class="literal">WHERE</tt> clause) per entity to execute the version check
                and update the information. If you use transitive persistence to cascade reattachment
                to associated entities, Hibernate might execute uneccessary updates. This is usually
                not a problem, but <span class="emphasis"><em>on update</em></span> triggers in the database might be
                executed even when no changes have been made to detached instances. You can customize
                this behavior by setting  <tt class="literal">select-before-update="true"</tt> in the
                <tt class="literal">&lt;class&gt;</tt> mapping, forcing Hibernate to <tt class="literal">SELECT</tt>
                the instance to ensure that changes did actually occur, before updating the row.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-locking"></a>11.4.&nbsp;Pessimistic Locking</h2></div></div><div></div></div><p>
            It is not intended that users spend much time worring about locking strategies. Its usually
            enough to specify an isolation level for the JDBC connections and then simply let the
            database do all the work. However, advanced users may sometimes wish to obtain
            exclusive pessimistic locks, or re-obtain locks at the start of a new transaction.
        </p><p>
            Hibernate will always use the locking mechanism of the database, never lock objects
            in memory!
        </p><p>
            The <tt class="literal">LockMode</tt> class defines the different lock levels that may be acquired
            by Hibernate. A lock is obtained by the following mechanisms:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">LockMode.WRITE</tt> is acquired automatically when Hibernate updates or inserts
                    a row.
                </p></li><li><p>
                    <tt class="literal">LockMode.UPGRADE</tt> may be acquired upon explicit user request using
                    <tt class="literal">SELECT ... FOR UPDATE</tt> on databases which support that syntax.
                </p></li><li><p>
                    <tt class="literal">LockMode.UPGRADE_NOWAIT</tt> may be acquired upon explicit user request using a
                    <tt class="literal">SELECT ... FOR UPDATE NOWAIT</tt> under Oracle.
                </p></li><li><p>
                    <tt class="literal">LockMode.READ</tt> is acquired automatically when Hibernate reads data
                    under Repeatable Read or Serializable isolation level. May be re-acquired by explicit user
                    request.
                </p></li><li><p>
            <tt class="literal">LockMode.NONE</tt> represents the absence of a lock. All objects switch to this
            lock mode at the end of a <tt class="literal">Transaction</tt>. Objects associated with the session
            via a call to <tt class="literal">update()</tt> or <tt class="literal">saveOrUpdate()</tt> also start out
            in this lock mode.
        </p></li></ul></div><p>
            The "explicit user request" is expressed in one of the following ways:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    A call to <tt class="literal">Session.load()</tt>, specifying a <tt class="literal">LockMode</tt>.
                </p></li><li><p>
                    A call to <tt class="literal">Session.lock()</tt>.
                </p></li><li><p>
                    A call to <tt class="literal">Query.setLockMode()</tt>.
                </p></li></ul></div><p>
            If <tt class="literal">Session.load()</tt> is called with <tt class="literal">UPGRADE</tt> or
            <tt class="literal">UPGRADE_NOWAIT</tt>, and the requested object was not yet loaded by
            the session, the object is loaded using <tt class="literal">SELECT ... FOR UPDATE</tt>.
            If <tt class="literal">load()</tt> is called for an object that is already loaded with
            a less restrictive lock than the one requested, Hibernate calls
            <tt class="literal">lock()</tt> for that object.
        </p><p>
            <tt class="literal">Session.lock()</tt> performs a version number check if the specified lock
            mode is <tt class="literal">READ</tt>, <tt class="literal">UPGRADE</tt> or
            <tt class="literal">UPGRADE_NOWAIT</tt>. (In the case of <tt class="literal">UPGRADE</tt> or
            <tt class="literal">UPGRADE_NOWAIT</tt>, <tt class="literal">SELECT ... FOR UPDATE</tt> is used.)
        </p><p>
            If the database does not support the requested lock mode, Hibernate will use an appropriate
            alternate mode (instead of throwing an exception). This ensures that applications will
            be portable.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-connection-release"></a>11.5.&nbsp;Connection Release Modes</h2></div></div><div></div></div><p>
            The legacy (2.x) behavior of Hibernate in regards to JDBC connection management
            was that a <tt class="literal">Session</tt> would obtain a connection when it was first
            needed and then hold unto that connection until the session was closed.
            Hibernate 3.x introduced the notion of connection release modes to tell a session
            how to handle its JDBC connections.  Note that the following discussion is pertinent
            only to connections provided through a configured <tt class="literal">ConnectionProvider</tt>;
            user-supplied connections are outside the breadth of this discussion.  The different
            release modes are identified by the enumerated values of
            <tt class="literal">org.hibernate.ConnectionReleaseMode</tt>:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">ON_CLOSE</tt> - is essentially the legacy behavior described above. The
                    Hibernate session obatins a connection when it first needs to perform some JDBC access
                    and holds unto that connection until the session is closed.
                </p></li><li><p>
                    <tt class="literal">AFTER_TRANSACTION</tt> - says to release connections after a
                    <tt class="literal">org.hibernate.Transaction</tt> has completed.
                </p></li><li><p>
                    <tt class="literal">AFTER_STATEMENT</tt> (also referred to as aggressive release) - says to
                    release connections after each and every statement execution. This aggressive releasing
                    is skipped if that statement leaves open resources associated with the given session;
                    currently the only situation where this occurs is through the use of
                    <tt class="literal">org.hibernate.ScrollableResults</tt>.
                </p></li></ul></div><p>
            The configuration parameter <tt class="literal">hibernate.connection.release_mode</tt> is used
            to specify which release mode to use.  The possible values:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">auto</tt> (the default) - this choice delegates to the release mode
                    returned by the <tt class="literal">org.hibernate.transaction.TransactionFactory.getDefaultReleaseMode()</tt>
                    method.  For JTATransactionFactory, this returns ConnectionReleaseMode.AFTER_STATEMENT; for
                    JDBCTransactionFactory, this returns ConnectionReleaseMode.AFTER_TRANSACTION.  It is rarely
                    a good idea to change this default behavior as failures due to the value of this setting
                    tend to indicate bugs and/or invalid assumptions in user code.
                </p></li><li><p>
                    <tt class="literal">on_close</tt> - says to use ConnectionReleaseMode.ON_CLOSE.  This setting
                    is left for backwards compatibility, but its use is highly discouraged.
                </p></li><li><p>
                    <tt class="literal">after_transaction</tt> - says to use ConnectionReleaseMode.AFTER_TRANSACTION.
                    This setting should not be used in JTA environments.  Also note that with
                    ConnectionReleaseMode.AFTER_TRANSACTION, if a session is considered to be in auto-commit
                    mode connections will be released as if the release mode were AFTER_STATEMENT.
                </p></li><li><p>
                    <tt class="literal">after_statement</tt> - says to use ConnectionReleaseMode.AFTER_STATEMENT.  Additionally,
                    the configured <tt class="literal">ConnectionProvider</tt> is consulted to see if it supports this
                    setting (<tt class="literal">supportsAggressiveRelease()</tt>).  If not, the release mode is reset
                    to ConnectionReleaseMode.AFTER_TRANSACTION.  This setting is only safe in environments where
                    we can either re-acquire the same underlying JDBC connection each time we make a call into
                    <tt class="literal">ConnectionProvider.getConnection()</tt> or in auto-commit environments where
                    it does not matter whether we get back the same connection.
                </p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="events"></a>Chapter&nbsp;12.&nbsp;Interceptors and events</h2></div></div><div></div></div><p>
        It is often useful for the application to react to certain events that occur
        inside Hibernate. This allows implementation of certain kinds of generic 
        functionality, and extension of Hibernate functionality.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-interceptors"></a>12.1.&nbsp;Interceptors</h2></div></div><div></div></div><p>
            The <tt class="literal">Interceptor</tt> interface provides callbacks from the session to the 
            application allowing the application to inspect and/or manipulate properties of a
            persistent object before it is saved, updated, deleted or loaded. One 
            possible use for this is to track auditing information. For example, the following 
            <tt class="literal">Interceptor</tt> automatically sets the  <tt class="literal">createTimestamp</tt> 
            when an <tt class="literal">Auditable</tt> is created and updates the 
            <tt class="literal">lastUpdateTimestamp</tt> property when an <tt class="literal">Auditable</tt> is 
            updated.
        </p><p>

            You may either implement <tt class="literal">Interceptor</tt> directly or (better) extend

            <tt class="literal">EmptyInterceptor</tt>.

        </p><pre class="programlisting">package org.hibernate.test;

import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;

import org.hibernate.EmptyInterceptor;

import org.hibernate.Transaction;
import org.hibernate.type.Type;

public class AuditInterceptor extends EmptyInterceptor {

    private int updates;
    private int creates;

    private int loads;

    public void onDelete(Object entity,
                         Serializable id,
                         Object[] state,
                         String[] propertyNames,
                         Type[] types) {
        // do nothing
    }

    public boolean onFlushDirty(Object entity,
                                Serializable id,
                                Object[] currentState,
                                Object[] previousState,
                                String[] propertyNames,
                                Type[] types) {

        if ( entity instanceof Auditable ) {
            updates++;
            for ( int i=0; i &lt; propertyNames.length; i++ ) {
                if ( "lastUpdateTimestamp".equals( propertyNames[i] ) ) {
                    currentState[i] = new Date();
                    return true;
                }
            }
        }
        return false;
    }

    public boolean onLoad(Object entity,
                          Serializable id,
                          Object[] state,
                          String[] propertyNames,
                          Type[] types) {
        if ( entity instanceof Auditable ) {

            loads++;

        }

        return false;
    }

    public boolean onSave(Object entity,
                          Serializable id,
                          Object[] state,
                          String[] propertyNames,
                          Type[] types) {

        if ( entity instanceof Auditable ) {
            creates++;
            for ( int i=0; i&lt;propertyNames.length; i++ ) {
                if ( "createTimestamp".equals( propertyNames[i] ) ) {
                    state[i] = new Date();
                    return true;
                }
            }
        }
        return false;
    }

    public void afterTransactionCompletion(Transaction tx) {

        if ( tx.wasCommitted() ) {
            System.out.println("Creations: " + creates + ", Updates: " + updates, "Loads: " + loads);

        }
        updates=0;

        creates=0;

        loads=0;

    }

}</pre><p>
            The interceptor would be specified when a session is created.
        </p><pre class="programlisting">Session session = sf.openSession( new AuditInterceptor() );</pre><p>
            You may also set an interceptor on a global level, using the <tt class="literal">Configuration</tt>. 

            In this case, the interceptor must be threadsafe.
        </p><pre class="programlisting">new Configuration().setInterceptor( new AuditInterceptor() );</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-events"></a>12.2.&nbsp;Event system</h2></div></div><div></div></div><p>
            If you have to react to particular events in your persistence layer, you may
            also use the Hibernate3 <span class="emphasis"><em>event</em></span> architecture. The event
            system can be used in addition or as a replacement for interceptors.
        </p><p>
            Essentially all of the methods of the <tt class="literal">Session</tt> interface correlate
            to an event. You have a <tt class="literal">LoadEvent</tt>, a <tt class="literal">FlushEvent</tt>, etc
            (consult the XML configuration-file DTD or the <tt class="literal">org.hibernate.event</tt>
            package for the full list of defined event types). When a request is made of one of
            these methods, the Hibernate <tt class="literal">Session</tt> generates an appropriate
            event and passes it to the configured event listener for that type. Out-of-the-box,
            these listeners implement the same processing in which those methods always resulted.
            However, you are free to implement a customization of one of the listener interfaces
            (i.e., the <tt class="literal">LoadEvent</tt> is processed by the registered implemenation
            of the <tt class="literal">LoadEventListener</tt> interface), in which case their
            implementation would be responsible for processing any <tt class="literal">load()</tt> requests
            made of the <tt class="literal">Session</tt>.
        </p><p>
            The listeners should be considered effectively singletons; meaning, they are shared between
            requests, and thus should not save any state as instance variables.
        </p><p>
            A custom listener should implement the appropriate interface for the event it wants to
            process and/or extend one of the convenience base classes (or even the default event
            listeners used by Hibernate out-of-the-box as these are declared non-final for this
            purpose). Custom listeners can either be registered programmatically through the
            <tt class="literal">Configuration</tt> object, or specified in the Hibernate configuration
            XML (declarative configuration through the properties file is not supported). Here's an
            example of a custom load event listener:
        </p><pre class="programlisting">public class MyLoadListener implements LoadEventListener {
    // this is the single method defined by the LoadEventListener interface
    public void onLoad(LoadEvent event, LoadEventListener.LoadType loadType)
            throws HibernateException {
        if ( !MySecurity.isAuthorized( event.getEntityClassName(), event.getEntityId() ) ) {
            throw MySecurityException("Unauthorized access");
        }
    }
}</pre><p>
            You also need a configuration entry telling Hibernate to use the listener in addition
            to the default listener:
        </p><pre class="programlisting">&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
        ...
        &lt;event type="load"&gt;

            &lt;listener class="com.eg.MyLoadListener"/&gt;

            &lt;listener class="org.hibernate.event.def.DefaultLoadEventListener"/&gt;

        &lt;/event&gt;
    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;</pre><p>
            Instead, you may register it programmatically:
        </p><pre class="programlisting">Configuration cfg = new Configuration();
LoadEventListener[] stack = { new MyLoadListener(), new DefaultLoadEventListener() };

cfg.EventListeners().setLoadEventListeners(stack);</pre><p>
            Listeners registered declaratively cannot share instances. If the same class name is
            used in multiple <tt class="literal">&lt;listener/&gt;</tt> elements, each reference will
            result in a separate instance of that class. If you need the capability to share
            listener instances between listener types you must use the programmatic registration
            approach.
        </p><p>
            Why implement an interface and define the specific type during configuration? Well, a
            listener implementation could implement multiple event listener interfaces. Having the
            type additionally defined during registration makes it easier to turn custom listeners on
            or off during configuration.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-decl-security"></a>12.3.&nbsp;Hibernate declarative security</h2></div></div><div></div></div><p>
            Usually, declarative security in Hibernate applications is managed in a session facade
            layer. Now, Hibernate3 allows certain actions to be permissioned via JACC, and authorized 
            via JAAS. This is optional functionality built on top of the event architecture.
        </p><p>
            First, you must configure the appropriate event listeners, to enable the use of JAAS
            authorization.
        </p><pre class="programlisting">&lt;listener type="pre-delete" class="org.hibernate.secure.JACCPreDeleteEventListener"/&gt;
&lt;listener type="pre-update" class="org.hibernate.secure.JACCPreUpdateEventListener"/&gt;
&lt;listener type="pre-insert" class="org.hibernate.secure.JACCPreInsertEventListener"/&gt;
&lt;listener type="pre-load" class="org.hibernate.secure.JACCPreLoadEventListener"/&gt;</pre><p>

            Note that <tt class="literal">&lt;listener type="..." class="..."/&gt;</tt> is just a shorthand

            for <tt class="literal">&lt;event type="..."&gt;&lt;listener class="..."/&gt;&lt;/event&gt;</tt>

            when there is exactly one listener for a particular event type.

        </p><p>
            Next, still in <tt class="literal">hibernate.cfg.xml</tt>, bind the permissions to roles:
        </p><pre class="programlisting">&lt;grant role="admin" entity-name="User" actions="insert,update,read"/&gt;
&lt;grant role="su" entity-name="User" actions="*"/&gt;</pre><p>
            The role names are the roles understood by your JACC provider.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="batch"></a>Chapter&nbsp;13.&nbsp;Batch processing</h2></div></div><div></div></div><p>
        A naive approach to inserting 100 000 rows in the database using Hibernate might 
        look like this:
    </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
for ( int i=0; i&lt;100000; i++ ) {
    Customer customer = new Customer(.....);
    session.save(customer);
}
tx.commit();
session.close();</pre><p>
        This would fall over with an <tt class="literal">OutOfMemoryException</tt> somewhere 
        around the 50 000th row. That's because Hibernate caches all the newly inserted 
        <tt class="literal">Customer</tt> instances in the session-level cache. 
    </p><p>
        In this chapter we'll show you how to avoid this problem. First, however, if you
        are doing batch processing, it is absolutely critical that you enable the use of
        JDBC batching, if you intend to achieve reasonable performance. Set the JDBC batch 
        size to a reasonable number (say, 10-50):
    </p><pre class="programlisting">hibernate.jdbc.batch_size 20</pre><p>
        You also might like to do this kind of work in a process where interaction with 
        the second-level cache is completely disabled:
    </p><pre class="programlisting">hibernate.cache.use_second_level_cache false</pre><p>
        However, this is not absolutely necessary, since we can explicitly set the
        <tt class="literal">CacheMode</tt> to disable interaction with the second-level cache.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="batch-inserts"></a>13.1.&nbsp;Batch inserts</h2></div></div><div></div></div><p>
            When making new objects persistent, you must <tt class="literal">flush()</tt> and 
            then <tt class="literal">clear()</tt> the session regularly, to control the size of
            the first-level cache.
        </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
   
for ( int i=0; i&lt;100000; i++ ) {
    Customer customer = new Customer(.....);
    session.save(customer);
    if ( i % 20 == 0 ) { //20, same as the JDBC batch size
        //flush a batch of inserts and release memory:
        session.flush();
        session.clear();
    }
}
   
tx.commit();
session.close();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="batch-update"></a>13.2.&nbsp;Batch updates</h2></div></div><div></div></div><p>
            For retrieving and updating data the same ideas apply. In addition, you need to 
            use <tt class="literal">scroll()</tt> to take advantage of server-side cursors for 
            queries that return many rows of data.
        </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
   
ScrollableResults customers = session.getNamedQuery("GetCustomers")
    .setCacheMode(CacheMode.IGNORE)
    .scroll(ScrollMode.FORWARD_ONLY);
int count=0;
while ( customers.next() ) {
    Customer customer = (Customer) customers.get(0);
    customer.updateStuff(...);
    if ( ++count % 20 == 0 ) {
        //flush a batch of updates and release memory:
        session.flush();
        session.clear();
    }
}
   
tx.commit();
session.close();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="batch-statelesssession"></a>13.3.&nbsp;The StatelessSession interface</h2></div></div><div></div></div><p>
            Alternatively, Hibernate provides a command-oriented API that may be used for 
            streaming data to and from the database in the form of detached objects. A 
            <tt class="literal">StatelessSession</tt> has no persistence context associated
            with it and does not provide many of the higher-level lifecycle semantics.
            In particular, a stateless session does not implement a first-level cache nor
            interact with any second-level or query cache. It does not implement 
            transactional write-behind or automatic dirty checking. Operations performed
            using a stateless session do not ever cascade to associated instances. Collections 
            are ignored by a stateless session. Operations performed via a stateless session 
            bypass Hibernate's event model and interceptors. Stateless sessions are vulnerable 
            to data aliasing effects, due to the lack of a first-level cache. A stateless
            session is a lower-level abstraction, much closer to the underlying JDBC.
        </p><pre class="programlisting">StatelessSession session = sessionFactory.openStatelessSession();
Transaction tx = session.beginTransaction();
   
ScrollableResults customers = session.getNamedQuery("GetCustomers")
    .scroll(ScrollMode.FORWARD_ONLY);
while ( customers.next() ) {
    Customer customer = (Customer) customers.get(0);
    customer.updateStuff(...);
    session.update(customer);
}
   
tx.commit();
session.close();</pre><p>
            Note that in this code example, the <tt class="literal">Customer</tt> instances returned
            by the query are immediately detached. They are never associated with any persistence
            context.
        </p><p>
            The <tt class="literal">insert(), update()</tt> and <tt class="literal">delete()</tt> operations
            defined by the <tt class="literal">StatelessSession</tt> interface are considered to be
            direct database row-level operations, which result in immediate execution of a SQL
            <tt class="literal">INSERT, UPDATE</tt> or <tt class="literal">DELETE</tt> respectively. Thus,
            they have very different semantics to the <tt class="literal">save(), saveOrUpdate()</tt> 
            and <tt class="literal">delete()</tt> operations defined by the <tt class="literal">Session</tt> 
            interface.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="batch-direct"></a>13.4.&nbsp;DML-style operations</h2></div></div><div></div></div><p>
            As already discussed, automatic and transparent object/relational mapping is concerned
            with the management of object state. This implies that the object state is available
            in memory, hence manipulating (using the SQL <tt class="literal">Data Manipulation Language</tt>
            (DML) statements: <tt class="literal">INSERT</tt>, <tt class="literal">UPDATE</tt>, <tt class="literal">DELETE</tt>)
            data directly in the database will not affect in-memory state. However, Hibernate provides methods
            for bulk SQL-style DML statement execution which are performed through the
            Hibernate Query Language (<a href="#queryhql" title="Chapter&nbsp;14.&nbsp;HQL: The Hibernate Query Language">Chapter&nbsp;14, <i>HQL: The Hibernate Query Language</i></a>).
        </p><p>
            The pseudo-syntax for <tt class="literal">UPDATE</tt> and <tt class="literal">DELETE</tt> statements
            is: <tt class="literal">( UPDATE | DELETE ) FROM? EntityName (WHERE where_conditions)?</tt>.  Some
            points to note:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    In the from-clause, the FROM keyword is optional
                </p></li><li><p>
                    There can only be a single entity named in the from-clause; it can optionally be
                    aliased.  If the entity name is aliased, then any property references must
                    be qualified using that alias; if the entity name is not aliased, then it is
                    illegal for any property references to be qualified.
                </p></li><li><p>
                    No <a href="#queryhql-joins-forms" title="14.4.&nbsp;Forms of join syntax">Section&nbsp;14.4, &#8220;Forms of join syntax&#8221;</a> (either implicit or explicit)
	                can be specified in a bulk HQL query.  Sub-queries may be used in the where-clause;
	                the subqueries, themselves, may contain joins.
                </p></li><li><p>
                    The where-clause is also optional.
                </p></li></ul></div><p>
            As an example, to execute an HQL <tt class="literal">UPDATE</tt>, use the
            <tt class="literal">Query.executeUpdate()</tt> method (the method is named for
            those familiar with JDBC's <tt class="literal">PreparedStatement.executeUpdate()</tt>):
        </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

String hqlUpdate = "update Customer c set c.name = :newName where c.name = :oldName";
// or String hqlUpdate = "update Customer set name = :newName where name = :oldName";
int updatedEntities = s.createQuery( hqlUpdate )
        .setString( "newName", newName )
        .setString( "oldName", oldName )
        .executeUpdate();
tx.commit();
session.close();</pre><p>
            To execute an HQL <tt class="literal">DELETE</tt>, use the same <tt class="literal">Query.executeUpdate()</tt>
            method:
        </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

String hqlDelete = "delete Customer c where c.name = :oldName";
// or String hqlDelete = "delete Customer where name = :oldName";
int deletedEntities = s.createQuery( hqlDelete )
        .setString( "oldName", oldName )
        .executeUpdate();
tx.commit();
session.close();</pre><p>
            The <tt class="literal">int</tt> value returned by the <tt class="literal">Query.executeUpdate()</tt>
            method indicate the number of entities effected by the operation.  Consider this may or may not
            correlate to the number of rows effected in the database.  An HQL bulk operation might result in
            multiple actual SQL statements being executed, for joined-subclass, for example.  The returned
            number indicates the number of actual entities affected by the statement.  Going back to the
            example of joined-subclass, a delete against one of the subclasses may actually result
            in deletes against not just the table to which that subclass is mapped, but also the "root"
            table and potentially joined-subclass tables further down the inheritence hierarchy.
        </p><p>
            The pseudo-syntax for <tt class="literal">INSERT</tt> statements is:
            <tt class="literal">INSERT INTO EntityName properties_list select_statement</tt>.  Some
            points to note:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Only the INSERT INTO ... SELECT ... form is supported; not the INSERT INTO ... VALUES ... form.
                </p><p>
                    The properties_list is analogous to the <tt class="literal">column speficiation</tt>
                    in the SQL <tt class="literal">INSERT</tt> statement.  For entities involved in mapped
                    inheritence, only properties directly defined on that given class-level can be
                    used in the properties_list.  Superclass properties are not allowed; and subclass
                    properties do not make sense.  In other words, <tt class="literal">INSERT</tt>
                    statements are inherently non-polymorphic.
                </p></li><li><p>
                    select_statement can be any valid HQL select query, with the caveat that the return types
                    must match the types expected by the insert.  Currently, this is checked during query
                    compilation rather than allowing the check to relegate to the database.  Note however
                    that this might cause problems between Hibernate <tt class="literal">Type</tt>s which are
                    <span class="emphasis"><em>equivalent</em></span> as opposed to <span class="emphasis"><em>equal</em></span>.  This might cause
                    issues with mismatches between a property defined as a <tt class="literal">org.hibernate.type.DateType</tt>
                    and a property defined as a <tt class="literal">org.hibernate.type.TimestampType</tt>, even though the
                    database might not make a distinction or might be able to handle the conversion.
                </p></li><li><p>
                    For the id property, the insert statement gives you two options.  You can either
                    explicitly specify the id property in the properties_list (in which case its value
                    is taken from the corresponding select expression) or omit it from the properties_list
                    (in which case a generated value is used).  This later option is only available when
                    using id generators that operate in the database; attempting to use this option with
                    any "in memory" type generators will cause an exception during parsing.  Note that
                    for the purposes of this discussion, in-database generators are considered to be
                    <tt class="literal">org.hibernate.id.SequenceGenerator</tt> (and its subclasses) and
                    any implementors of <tt class="literal">org.hibernate.id.PostInsertIdentifierGenerator</tt>.
                    The most notable exception here is <tt class="literal">org.hibernate.id.TableHiLoGenerator</tt>,
                    which cannot be used because it does not expose a selectable way to get its values.
                </p></li><li><p>
                    For properties mapped as either <tt class="literal">version</tt> or <tt class="literal">timestamp</tt>,
                    the insert statement gives you two options.  You can either specify the property in the
                    properties_list (in which case its value is taken from the corresponding select expressions)
                    or omit it from the properties_list (in which case the <tt class="literal">seed value</tt> defined
                    by the <tt class="literal">org.hibernate.type.VersionType</tt> is used).
                </p></li></ul></div><p>
            An example HQL <tt class="literal">INSERT</tt> statement execution:
        </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

String hqlInsert = "insert into DelinquentAccount (id, name) select c.id, c.name from Customer c where ...";
int createdEntities = s.createQuery( hqlInsert )
        .executeUpdate();
tx.commit();
session.close();</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="queryhql"></a>Chapter&nbsp;14.&nbsp;HQL: The Hibernate Query Language</h2></div></div><div></div></div><p>
        Hibernate is equipped with an extremely powerful query language that (quite intentionally)
        looks very much like SQL. But don't be fooled by the syntax; HQL is fully object-oriented,
        understanding notions like inheritence, polymorphism and association.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-casesensitivity"></a>14.1.&nbsp;Case Sensitivity</h2></div></div><div></div></div><p>
            Queries are case-insensitive, except for names of Java classes and properties.
            So <tt class="literal">SeLeCT</tt> is the same as
            <tt class="literal">sELEct</tt> is the same as
            <tt class="literal">SELECT</tt> but
            <tt class="literal">org.hibernate.eg.FOO</tt> is not
            <tt class="literal">org.hibernate.eg.Foo</tt> and
            <tt class="literal">foo.barSet</tt> is not
            <tt class="literal">foo.BARSET</tt>.
        </p><p>
            This manual uses lowercase HQL keywords. Some users find queries with uppercase keywords 
            more readable, but we find this convention ugly when embedded in Java code.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-from"></a>14.2.&nbsp;The from clause</h2></div></div><div></div></div><p>
            The simplest possible Hibernate query is of the form:
        </p><pre class="programlisting">from eg.Cat</pre><p>
            which simply returns all instances of the class <tt class="literal">eg.Cat</tt>.
            We don't usually need to qualify the class name, since <tt class="literal">auto-import</tt>
            is the default. So we almost always just write:
        </p><pre class="programlisting">from Cat</pre><p>
            Most of the time, you will need to assign an <span class="emphasis"><em>alias</em></span>, since
            you will want to refer to the <tt class="literal">Cat</tt> in other parts of the
            query.
        </p><pre class="programlisting">from Cat as cat</pre><p>
            This query assigns the alias <tt class="literal">cat</tt> to <tt class="literal">Cat</tt>
            instances, so we could use that alias later in the query. The <tt class="literal">as</tt>
            keyword is optional; we could also write:
        </p><pre class="programlisting">from Cat cat</pre><p>
            Multiple classes may appear, resulting in a cartesian product or "cross" join.
        </p><pre class="programlisting">from Formula, Parameter</pre><pre class="programlisting">from Formula as form, Parameter as param</pre><p>
            It is considered good practice to name query aliases using an initial lowercase,
            consistent with Java naming standards for local variables
            (eg. <tt class="literal">domesticCat</tt>).
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-joins"></a>14.3.&nbsp;Associations and joins</h2></div></div><div></div></div><p>
            We may also assign aliases to associated entities, or even to elements of a 
            collection of values, using a <tt class="literal">join</tt>.
        </p><pre class="programlisting">from Cat as cat 
    inner join cat.mate as mate
    left outer join cat.kittens as kitten</pre><pre class="programlisting">from Cat as cat left join cat.mate.kittens as kittens</pre><pre class="programlisting">from Formula form full join form.parameter param</pre><p>
            The supported join types are borrowed from ANSI SQL
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">inner join</tt>
                </p></li><li><p>
                    <tt class="literal">left outer join</tt>
                </p></li><li><p>
                    <tt class="literal">right outer join</tt>
                </p></li><li><p>
                    <tt class="literal">full join</tt> (not usually useful)
                </p></li></ul></div><p>
            The <tt class="literal">inner join</tt>, <tt class="literal">left outer join</tt> and 
            <tt class="literal">right outer join</tt> constructs may be abbreviated.
        </p><pre class="programlisting">from Cat as cat 
    join cat.mate as mate
    left join cat.kittens as kitten</pre><p>
            You may supply extra join conditions using the HQL <tt class="literal">with</tt>
            keyword.
        </p><pre class="programlisting">from Cat as cat 
    left join cat.kittens as kitten 
        with kitten.bodyWeight &gt; 10.0</pre><p>
            In addition, a "fetch" join allows associations or collections of values to be 
            initialized along with their parent objects, using a single select. This is particularly 
            useful in the case of a collection. It effectively overrides the outer join and
            lazy declarations of the mapping file for associations and collections. See
            <a href="#performance-fetching" title="19.1.&nbsp;Fetching strategies">Section&nbsp;19.1, &#8220;Fetching strategies&#8221;</a> for more information.
        </p><pre class="programlisting">from Cat as cat 
    inner join fetch cat.mate
    left join fetch cat.kittens</pre><p>
            A fetch join does not usually need to assign an alias, because the associated objects 
            should not be used in the <tt class="literal">where</tt> clause (or any other clause). Also, 
            the associated objects are not returned directly in the query results. Instead, they may 
            be accessed via the parent object. The only reason we might need an alias is if we are
            recursively join fetching a further collection:
        </p><pre class="programlisting">from Cat as cat 
    inner join fetch cat.mate
    left join fetch cat.kittens child
    left join fetch child.kittens</pre><p>
            Note that the <tt class="literal">fetch</tt> construct may not be used in queries called using
            <tt class="literal">scroll()</tt> or <tt class="literal">iterate()</tt>. Nor should <tt class="literal">fetch</tt>
            be used together with <tt class="literal">setMaxResults()</tt> or <tt class="literal">setFirstResult()</tt>.
            Nor may <tt class="literal">fetch</tt> be used together with an ad hoc <tt class="literal">with</tt> condition.
            It is possible to create a cartesian product by join fetching more than one collection in a
            query, so take care in this case. Join fetching multiple collection roles also sometimes gives 
            unexpected results for bag mappings, so be careful about how you formulate your queries in this 
            case. Finally, note that <tt class="literal">full join fetch</tt> and <tt class="literal">right join fetch</tt> 
            are not meaningful.
        </p><p>
            If you are using property-level lazy fetching (with bytecode instrumentation), it is
            possible to force Hibernate to fetch the lazy properties immediately (in the first
            query) using <tt class="literal">fetch all properties</tt>.
        </p><pre class="programlisting">from Document fetch all properties order by name</pre><pre class="programlisting">from Document doc fetch all properties where lower(doc.name) like '%cats%'</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-joins-forms"></a>14.4.&nbsp;Forms of join syntax</h2></div></div><div></div></div><p>
		    HQL supports two forms of association joining: <tt class="literal">implicit</tt> and <tt class="literal">explicit</tt>.
		</p><p>
		    The queries shown in the previous section all use the <tt class="literal">explicit</tt> form where
		    the join keyword is explicitly used in the from clause.  This is the recommended form.
	    </p><p>
		    The <tt class="literal">implicit</tt> form does not use the join keyword.  Instead, the
		    associations are "dereferenced" using dot-notation.  <tt class="literal">implicit</tt> joins
		    can appear in any of the HQL clauses.  <tt class="literal">implicit</tt> join result
		    in inner joins in the resulting SQL statement.
	    </p><pre class="programlisting">from Cat as cat where cat.mate.name like '%s%'</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-select"></a>14.5.&nbsp;The select clause</h2></div></div><div></div></div><p>
            The <tt class="literal">select</tt> clause picks which objects and properties to return in 
            the query result set. Consider:
        </p><pre class="programlisting">select mate 
from Cat as cat 
    inner join cat.mate as mate</pre><p>
            The query will select <tt class="literal">mate</tt>s of other <tt class="literal">Cat</tt>s.
            Actually, you may express this query more compactly as:
        </p><pre class="programlisting">select cat.mate from Cat cat</pre><p>
            Queries may return properties of any value type including properties of component type:
        </p><pre class="programlisting">select cat.name from DomesticCat cat
where cat.name like 'fri%'</pre><pre class="programlisting">select cust.name.firstName from Customer as cust</pre><p>
            Queries may return multiple objects and/or properties as an array of type 
            <tt class="literal">Object[]</tt>,
        </p><pre class="programlisting">select mother, offspr, mate.name 
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>
            or as a <tt class="literal">List</tt>,
        </p><pre class="programlisting">select new list(mother, offspr, mate.name)
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>
            or as an actual typesafe Java object,
        </p><pre class="programlisting">select new Family(mother, mate, offspr)
from DomesticCat as mother
    join mother.mate as mate
    left join mother.kittens as offspr</pre><p>
            assuming that the class <tt class="literal">Family</tt> has an appropriate constructor.
        </p><p>
            You may assign aliases to selected expressions using <tt class="literal">as</tt>:
        </p><pre class="programlisting">select max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n
from Cat cat</pre><p>
            This is most useful when used together with <tt class="literal">select new map</tt>:
        </p><pre class="programlisting">select new map( max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n )
from Cat cat</pre><p>
            This query returns a <tt class="literal">Map</tt> from aliases to selected values.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-aggregation"></a>14.6.&nbsp;Aggregate functions</h2></div></div><div></div></div><p>
            HQL queries may even return the results of aggregate functions on properties:
        </p><pre class="programlisting">select avg(cat.weight), sum(cat.weight), max(cat.weight), count(cat)
from Cat cat</pre><p>
            The supported aggregate functions are
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">avg(...), sum(...), min(...), max(...)</tt>
                </p></li><li><p>
                    <tt class="literal">count(*)</tt>
                </p></li><li><p>
                    <tt class="literal">count(...), count(distinct ...), count(all...)</tt>
                </p></li></ul></div><p>
            You may use arithmetic operators, concatenation, and recognized SQL functions
            in the select clause:
        </p><pre class="programlisting">select cat.weight + sum(kitten.weight) 
from Cat cat 
    join cat.kittens kitten
group by cat.id, cat.weight</pre><pre class="programlisting">select firstName||' '||initial||' '||upper(lastName) from Person</pre><p>
            The <tt class="literal">distinct</tt> and <tt class="literal">all</tt> keywords may be used and 
            have the same semantics as in SQL.
        </p><pre class="programlisting">select distinct cat.name from Cat cat

select count(distinct cat.name), count(cat) from Cat cat</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-polymorphism"></a>14.7.&nbsp;Polymorphic queries</h2></div></div><div></div></div><p>
            A query like:
        </p><pre class="programlisting">from Cat as cat</pre><p>
            returns instances not only of <tt class="literal">Cat</tt>, but also of subclasses like
            <tt class="literal">DomesticCat</tt>. Hibernate queries may name <span class="emphasis"><em>any</em></span> Java 
            class or interface in the <tt class="literal">from</tt> clause. The query will return instances 
            of all persistent classes that extend that class or implement the interface. The following 
            query would return all persistent objects:
        </p><pre class="programlisting">from java.lang.Object o</pre><p>
            The interface <tt class="literal">Named</tt> might be implemented by various persistent
            classes:
        </p><pre class="programlisting">from Named n, Named m where n.name = m.name</pre><p>
            Note that these last two queries will require more than one SQL <tt class="literal">SELECT</tt>. This
            means that the <tt class="literal">order by</tt> clause does not correctly order the whole result set.
            (It also means you can't call these queries using <tt class="literal">Query.scroll()</tt>.)
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-where"></a>14.8.&nbsp;The where clause</h2></div></div><div></div></div><p>
            The <tt class="literal">where</tt> clause allows you to narrow the list of instances returned.
            If no alias exists, you may refer to properties by name:
        </p><pre class="programlisting">from Cat where name='Fritz'</pre><p>
        	If there is an alias, use a qualified property name:
        </p><pre class="programlisting">from Cat as cat where cat.name='Fritz'</pre><p>
            returns instances of <tt class="literal">Cat</tt> named 'Fritz'.
        </p><pre class="programlisting">select foo 
from Foo foo, Bar bar
where foo.startDate = bar.date</pre><p>
            will return all instances of <tt class="literal">Foo</tt> for which
            there exists an instance of <tt class="literal">bar</tt> with a
            <tt class="literal">date</tt> property equal to the
            <tt class="literal">startDate</tt> property of the
            <tt class="literal">Foo</tt>. Compound path expressions make the
            <tt class="literal">where</tt> clause extremely powerful. Consider:
        </p><pre class="programlisting">from Cat cat where cat.mate.name is not null</pre><p>
            This query translates to an SQL query with a table (inner) join. If you were to write
            something like
        </p><pre class="programlisting">from Foo foo  
where foo.bar.baz.customer.address.city is not null</pre><p>
            you would end up with a query that would require four table joins in SQL.
        </p><p>
            The <tt class="literal">=</tt> operator may be used to compare not only properties, but also 
            instances:
        </p><pre class="programlisting">from Cat cat, Cat rival where cat.mate = rival.mate</pre><pre class="programlisting">select cat, mate 
from Cat cat, Cat mate
where cat.mate = mate</pre><p>
            The special property (lowercase) <tt class="literal">id</tt> may be used to reference the 
            unique identifier of an object. (You may also use its property name.)
        </p><pre class="programlisting">from Cat as cat where cat.id = 123

from Cat as cat where cat.mate.id = 69</pre><p>
            The second query is efficient. No table join is required!
        </p><p>
            Properties of composite identifiers may also be used. Suppose <tt class="literal">Person</tt> 
            has a composite identifier consisting of <tt class="literal">country</tt> and 
            <tt class="literal">medicareNumber</tt>.
        </p><pre class="programlisting">from bank.Person person
where person.id.country = 'AU' 
    and person.id.medicareNumber = 123456</pre><pre class="programlisting">from bank.Account account
where account.owner.id.country = 'AU' 
    and account.owner.id.medicareNumber = 123456</pre><p>
            Once again, the second query requires no table join.
        </p><p>
            Likewise, the special property <tt class="literal">class</tt> accesses the discriminator value
            of an instance in the case of polymorphic persistence. A Java class name embedded in the 
            where clause will be translated to its discriminator value.
        </p><pre class="programlisting">from Cat cat where cat.class = DomesticCat</pre><p>
            You may also specify properties of components or composite user types (and of components 
            of components, etc). Never try to use a path-expression that ends in a property of component 
            type (as opposed to a property of a component). For example, if <tt class="literal">store.owner</tt>
            is an entity with a component <tt class="literal">address</tt>
        </p><pre class="programlisting">store.owner.address.city    // okay
store.owner.address         // error!</pre><p>
            An "any" type has the special properties <tt class="literal">id</tt> and <tt class="literal">class</tt>,
            allowing us to express a join in the following way (where <tt class="literal">AuditLog.item</tt>
            is a property mapped with <tt class="literal">&lt;any&gt;</tt>).
        </p><pre class="programlisting">from AuditLog log, Payment payment 
where log.item.class = 'Payment' and log.item.id = payment.id</pre><p>
            Notice that <tt class="literal">log.item.class</tt> and <tt class="literal">payment.class</tt>
            would refer to the values of completely different database columns in the above query.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-expressions"></a>14.9.&nbsp;Expressions</h2></div></div><div></div></div><p>
            Expressions allowed in the <tt class="literal">where</tt> clause include
            most of the kind of things you could write in SQL:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    mathematical operators <tt class="literal">+, -, *, /</tt>
                </p></li><li><p>
                    binary comparison operators <tt class="literal">=, &gt;=, &lt;=, &lt;&gt;, !=, like</tt>
                </p></li><li><p>
                    logical operations <tt class="literal">and, or, not</tt>
                </p></li><li><p>
                    Parentheses <tt class="literal">( )</tt>, indicating grouping
                </p></li><li><p>
                    <tt class="literal">in</tt>,
                    <tt class="literal">not in</tt>,
                    <tt class="literal">between</tt>,
                    <tt class="literal">is null</tt>,
                    <tt class="literal">is not null</tt>,
                    <tt class="literal">is empty</tt>,
                    <tt class="literal">is not empty</tt>,
                    <tt class="literal">member of</tt> and 
                    <tt class="literal">not member of</tt>
                </p></li><li><p>
                	"Simple" case, <tt class="literal">case ... when ... then ... else ... end</tt>, and
                    "searched" case, <tt class="literal">case when ... then ... else ... end</tt> 
                </p></li><li><p>
                    string concatenation <tt class="literal">...||...</tt> or <tt class="literal">concat(...,...)</tt>
                </p></li><li><p>
                    <tt class="literal">current_date()</tt>, <tt class="literal">current_time()</tt>,
                    <tt class="literal">current_timestamp()</tt>
                </p></li><li><p>
					<tt class="literal">second(...)</tt>, <tt class="literal">minute(...)</tt>, 
					<tt class="literal">hour(...)</tt>, <tt class="literal">day(...)</tt>, 
					<tt class="literal">month(...)</tt>, <tt class="literal">year(...)</tt>,
                </p></li><li><p>
                    Any function or operator defined by EJB-QL 3.0: <tt class="literal">substring(), trim(),
                    lower(), upper(), length(), locate(), abs(), sqrt(), bit_length(), mod()</tt>
                </p></li><li><p>
                    <tt class="literal">coalesce()</tt> and <tt class="literal">nullif()</tt>
                </p></li><li><p>
                    <tt class="literal">str()</tt> for converting numeric or temporal values to a
                    readable string 
                </p></li><li><p>
                    <tt class="literal">cast(... as ...)</tt>, where the second argument is the name of
                    a Hibernate type, and <tt class="literal">extract(... from ...)</tt> if ANSI 
                    <tt class="literal">cast()</tt> and <tt class="literal">extract()</tt> is supported by 
                    the underlying database
                </p></li><li><p>
                    the HQL <tt class="literal">index()</tt> function, that applies to aliases of
                    a joined indexed collection
                </p></li><li><p>
                    HQL functions that take collection-valued path expressions: <tt class="literal">size(), 
                    minelement(), maxelement(), minindex(), maxindex()</tt>, along with the 
                    special <tt class="literal">elements()</tt> and <tt class="literal">indices</tt> functions
                    which may be quantified using <tt class="literal">some, all, exists, any, in</tt>.
                </p></li><li><p>
                    Any database-supported SQL scalar function like <tt class="literal">sign()</tt>, 
                    <tt class="literal">trunc()</tt>, <tt class="literal">rtrim()</tt>, <tt class="literal">sin()</tt>
                </p></li><li><p>
                    JDBC-style positional parameters <tt class="literal">?</tt>
                </p></li><li><p>
                    named parameters <tt class="literal">:name</tt>, <tt class="literal">:start_date</tt>, <tt class="literal">:x1</tt>
                </p></li><li><p>
                    SQL literals <tt class="literal">'foo'</tt>, <tt class="literal">69</tt>, <tt class="literal">6.66E+2</tt>,
                    <tt class="literal">'1970-01-01 10:00:01.0'</tt>
                </p></li><li><p>
                    Java <tt class="literal">public static final</tt> constants <tt class="literal">eg.Color.TABBY</tt>
                </p></li></ul></div><p>
            <tt class="literal">in</tt> and <tt class="literal">between</tt> may be used as follows:
        </p><pre class="programlisting">from DomesticCat cat where cat.name between 'A' and 'B'</pre><pre class="programlisting">from DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )</pre><p>
            and the negated forms may be written
        </p><pre class="programlisting">from DomesticCat cat where cat.name not between 'A' and 'B'</pre><pre class="programlisting">from DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )</pre><p>
            Likewise, <tt class="literal">is null</tt> and <tt class="literal">is not null</tt> may be used to test 
            for null values.
        </p><p>
            Booleans may be easily used in expressions by declaring HQL query substitutions in Hibernate
            configuration:
        </p><pre class="programlisting">&lt;property name="hibernate.query.substitutions"&gt;true 1, false 0&lt;/property&gt;</pre><p>
            This will replace the keywords <tt class="literal">true</tt> and <tt class="literal">false</tt> with the
            literals <tt class="literal">1</tt> and <tt class="literal">0</tt> in the translated SQL from this HQL:
        </p><pre class="programlisting">from Cat cat where cat.alive = true</pre><p>
            You may test the size of a collection with the special property <tt class="literal">size</tt>, or
            the special <tt class="literal">size()</tt> function.
        </p><pre class="programlisting">from Cat cat where cat.kittens.size &gt; 0</pre><pre class="programlisting">from Cat cat where size(cat.kittens) &gt; 0</pre><p>
            For indexed collections, you may refer to the minimum and maximum indices using
            <tt class="literal">minindex</tt> and <tt class="literal">maxindex</tt> functions. Similarly, 
            you may refer to the minimum and maximum elements of a collection of basic type 
            using the <tt class="literal">minelement</tt> and <tt class="literal">maxelement</tt>
            functions.
        </p><pre class="programlisting">from Calendar cal where maxelement(cal.holidays) &gt; current_date</pre><pre class="programlisting">from Order order where maxindex(order.items) &gt; 100</pre><pre class="programlisting">from Order order where minelement(order.items) &gt; 10000</pre><p>
            The SQL functions <tt class="literal">any, some, all, exists, in</tt> are supported when passed the element 
            or index set of a collection (<tt class="literal">elements</tt> and <tt class="literal">indices</tt> functions)
            or the result of a subquery (see below).
        </p><pre class="programlisting">select mother from Cat as mother, Cat as kit
where kit in elements(foo.kittens)</pre><pre class="programlisting">select p from NameList list, Person p
where p.name = some elements(list.names)</pre><pre class="programlisting">from Cat cat where exists elements(cat.kittens)</pre><pre class="programlisting">from Player p where 3 &gt; all elements(p.scores)</pre><pre class="programlisting">from Show show where 'fizard' in indices(show.acts)</pre><p>
            Note that these constructs - <tt class="literal">size</tt>, <tt class="literal">elements</tt>,
            <tt class="literal">indices</tt>, <tt class="literal">minindex</tt>, <tt class="literal">maxindex</tt>,
            <tt class="literal">minelement</tt>, <tt class="literal">maxelement</tt> - may only be used in
            the where clause in Hibernate3.
        </p><p>
            Elements of indexed collections (arrays, lists, maps) may be referred to by
            index (in a where clause only):
        </p><pre class="programlisting">from Order order where order.items[0].id = 1234</pre><pre class="programlisting">select person from Person person, Calendar calendar
where calendar.holidays['national day'] = person.birthDay
    and person.nationality.calendar = calendar</pre><pre class="programlisting">select item from Item item, Order order
where order.items[ order.deliveredItemIndices[0] ] = item and order.id = 11</pre><pre class="programlisting">select item from Item item, Order order
where order.items[ maxindex(order.items) ] = item and order.id = 11</pre><p>
            The expression inside <tt class="literal">[]</tt> may even be an arithmetic expression.
        </p><pre class="programlisting">select item from Item item, Order order
where order.items[ size(order.items) - 1 ] = item</pre><p>
            HQL also provides the built-in <tt class="literal">index()</tt> function, for elements 
            of a one-to-many association or collection of values.
        </p><pre class="programlisting">select item, index(item) from Order order 
    join order.items item
where index(item) &lt; 5</pre><p>
            Scalar SQL functions supported by the underlying database may be used
        </p><pre class="programlisting">from DomesticCat cat where upper(cat.name) like 'FRI%'</pre><p>
            If you are not yet convinced by all this, think how much longer and less readable the 
            following query would be in SQL:
        </p><pre class="programlisting">select cust
from Product prod,
    Store store
    inner join store.customers cust
where prod.name = 'widget'
    and store.location.name in ( 'Melbourne', 'Sydney' )
    and prod = all elements(cust.currentOrder.lineItems)</pre><p>
            <span class="emphasis"><em>Hint:</em></span> something like
        </p><pre class="programlisting">SELECT cust.name, cust.address, cust.phone, cust.id, cust.current_order
FROM customers cust,
    stores store,
    locations loc,
    store_customers sc,
    product prod
WHERE prod.name = 'widget'
    AND store.loc_id = loc.id
    AND loc.name IN ( 'Melbourne', 'Sydney' )
    AND sc.store_id = store.id
    AND sc.cust_id = cust.id
    AND prod.id = ALL(
        SELECT item.prod_id
        FROM line_items item, orders o
        WHERE item.order_id = o.id
            AND cust.current_order = o.id
    )</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-ordering"></a>14.10.&nbsp;The order by clause</h2></div></div><div></div></div><p>
            The list returned by a query may be ordered by any property of a returned class or components:
        </p><pre class="programlisting">from DomesticCat cat
order by cat.name asc, cat.weight desc, cat.birthdate</pre><p>
            The optional <tt class="literal">asc</tt> or <tt class="literal">desc</tt> indicate ascending or descending order 
            respectively.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-grouping"></a>14.11.&nbsp;The group by clause</h2></div></div><div></div></div><p>
            A query that returns aggregate values may be grouped by any property of a returned class or components:
        </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat) 
from Cat cat
group by cat.color</pre><pre class="programlisting">select foo.id, avg(name), max(name) 
from Foo foo join foo.names name
group by foo.id</pre><p>
            A <tt class="literal">having</tt> clause is also allowed.
        </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat) 
from Cat cat
group by cat.color 
having cat.color in (eg.Color.TABBY, eg.Color.BLACK)</pre><p>
            SQL functions and aggregate functions are allowed in the <tt class="literal">having</tt>
            and <tt class="literal">order by</tt> clauses, if supported by the underlying database 
            (eg. not in MySQL).
        </p><pre class="programlisting">select cat
from Cat cat
    join cat.kittens kitten
group by cat
having avg(kitten.weight) &gt; 100
order by count(kitten) asc, sum(kitten.weight) desc</pre><p>
            Note that neither the <tt class="literal">group by</tt> clause nor the
            <tt class="literal">order by</tt> clause may contain arithmetic expressions.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-subqueries"></a>14.12.&nbsp;Subqueries</h2></div></div><div></div></div><p>
            For databases that support subselects, Hibernate supports subqueries within queries. A subquery must
            be surrounded by parentheses (often by an SQL aggregate function call). Even correlated subqueries
            (subqueries that refer to an alias in the outer query) are allowed.
        </p><pre class="programlisting">from Cat as fatcat 
where fatcat.weight &gt; ( 
    select avg(cat.weight) from DomesticCat cat 
)</pre><pre class="programlisting">from DomesticCat as cat 
where cat.name = some ( 
    select name.nickName from Name as name 
)</pre><pre class="programlisting">from Cat as cat 
where not exists ( 
    from Cat as mate where mate.mate = cat 
)</pre><pre class="programlisting">from DomesticCat as cat 
where cat.name not in ( 
    select name.nickName from Name as name 
)</pre><pre class="programlisting">select cat.id, (select max(kit.weight) from cat.kitten kit) 
from Cat as cat</pre><p>
            Note that HQL subqueries may occur only in the select or where clauses.
        </p><p>
            For subqueries with more than one expression in the select list, you can use a tuple constructor:
        </p><pre class="programlisting">from Cat as cat 
where not ( cat.name, cat.color ) in ( 
    select cat.name, cat.color from DomesticCat cat 
)</pre><p>
            Note that on some databases (but not Oracle or HSQL), you can use tuple constructors in other
            contexts, for example when querying components or composite user types:
        </p><pre class="programlisting">from Person where name = ('Gavin', 'A', 'King')</pre><p>
            Which is equivalent to the more verbose:
        </p><pre class="programlisting">from Person where name.first = 'Gavin' and name.initial = 'A' and name.last = 'King')</pre><p>
            There are two good reasons you might not want to do this kind of thing: first, it is not 
            completely portable between database platforms; second, the query is now dependent upon
            the ordering of properties in the mapping document.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-examples"></a>14.13.&nbsp;HQL examples</h2></div></div><div></div></div><p>
            Hibernate queries can be quite powerful and complex. In fact, the power of the query language
            is one of Hibernate's main selling points. Here are some example queries very similar to queries
            that I used on a recent project. Note that most queries you will write are much simpler than these!
        </p><p>
            The following query returns the order id, number of items and total value of the order for all 
            unpaid orders for a particular customer and given minimum total value, ordering the results by 
            total value. In determining the prices, it uses the current catalog. The resulting SQL query, 
            against the <tt class="literal">ORDER</tt>, <tt class="literal">ORDER_LINE</tt>, <tt class="literal">PRODUCT</tt>,
            <tt class="literal">CATALOG</tt> and <tt class="literal">PRICE</tt> tables has four inner joins and an
            (uncorrelated) subselect.
        </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog.effectiveDate &lt; sysdate
    and catalog.effectiveDate &gt;= all (
        select cat.effectiveDate 
        from Catalog as cat
        where cat.effectiveDate &lt; sysdate
    )
group by order
having sum(price.amount) &gt; :minAmount
order by sum(price.amount) desc</pre><p>
            What a monster! Actually, in real life, I'm not very keen on subqueries, so my query was 
            really more like this:
        </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog = :currentCatalog
group by order
having sum(price.amount) &gt; :minAmount
order by sum(price.amount) desc</pre><p>
            The next query counts the number of payments in each status, excluding all payments in the
            <tt class="literal">AWAITING_APPROVAL</tt> status where the most recent status change was made by the 
            current user. It translates to an SQL query with two inner joins and a correlated subselect 
            against the <tt class="literal">PAYMENT</tt>, <tt class="literal">PAYMENT_STATUS</tt> and 
            <tt class="literal">PAYMENT_STATUS_CHANGE</tt> tables.
        </p><pre class="programlisting">select count(payment), status.name 
from Payment as payment 
    join payment.currentStatus as status
    join payment.statusChanges as statusChange
where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL
    or (
        statusChange.timeStamp = ( 
            select max(change.timeStamp) 
            from PaymentStatusChange change 
            where change.payment = payment
        )
        and statusChange.user &lt;&gt; :currentUser
    )
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>
            If I would have mapped the <tt class="literal">statusChanges</tt> collection as a list, instead of a set, 
            the query would have been much simpler to write.
        </p><pre class="programlisting">select count(payment), status.name 
from Payment as payment
    join payment.currentStatus as status
where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL
    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user &lt;&gt; :currentUser
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>
            The next query uses the MS SQL Server <tt class="literal">isNull()</tt> function to return all
            the accounts and unpaid payments for the organization to which the current user belongs.
            It translates to an SQL query with three inner joins, an outer join and a subselect against 
            the <tt class="literal">ACCOUNT</tt>, <tt class="literal">PAYMENT</tt>, <tt class="literal">PAYMENT_STATUS</tt>,
            <tt class="literal">ACCOUNT_TYPE</tt>, <tt class="literal">ORGANIZATION</tt> and 
            <tt class="literal">ORG_USER</tt> tables.
        </p><pre class="programlisting">select account, payment
from Account as account
    left outer join account.payments as payment
where :currentUser in elements(account.holder.users)
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre><p>
            For some databases, we would need to do away with the (correlated) subselect.
        </p><pre class="programlisting">select account, payment
from Account as account
    join account.holder.users as user
    left outer join account.payments as payment
where :currentUser = user
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-bulk"></a>14.14.&nbsp;Bulk update and delete</h2></div></div><div></div></div><p>
            HQL now supports <tt class="literal">update</tt>, <tt class="literal">delete</tt> and
            <tt class="literal">insert ... select ...</tt> statements.
            See <a href="#batch-direct" title="13.4.&nbsp;DML-style operations">Section&nbsp;13.4, &#8220;DML-style operations&#8221;</a> for details.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-tipstricks"></a>14.15.&nbsp;Tips &amp; Tricks</h2></div></div><div></div></div><p>
            You can count the number of query results without actually returning them:
        </p><pre class="programlisting">( (Integer) session.iterate("select count(*) from ....").next() ).intValue()</pre><p>
            To order a result by the size of a collection, use the following query:
        </p><pre class="programlisting">select usr.id, usr.name
from User as usr 
    left join usr.messages as msg
group by usr.id, usr.name
order by count(msg)</pre><p>
            If your database supports subselects, you can place a condition upon selection
            size in the where clause of your query:
        </p><pre class="programlisting">from User usr where size(usr.messages) &gt;= 1</pre><p>
            If your database doesn't support subselects, use the following query:
        </p><pre class="programlisting">select usr.id, usr.name
from User usr.name
    join usr.messages msg
group by usr.id, usr.name
having count(msg) &gt;= 1</pre><p>
            As this solution can't return a <tt class="literal">User</tt> with zero messages
            because of the inner join, the following form is also useful:
        </p><pre class="programlisting">select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
having count(msg) = 0</pre><p>
            Properties of a JavaBean can be bound to named query parameters:
        </p><pre class="programlisting">Query q = s.createQuery("from foo Foo as foo where foo.name=:name and foo.size=:size");
q.setProperties(fooBean); // fooBean has getName() and getSize()
List foos = q.list();</pre><p>
            Collections are pageable by using the <tt class="literal">Query</tt> interface with a filter:
        </p><pre class="programlisting">Query q = s.createFilter( collection, "" ); // the trivial filter
q.setMaxResults(PAGE_SIZE);
q.setFirstResult(PAGE_SIZE * pageNumber);
List page = q.list();</pre><p>
            Collection elements may be ordered or grouped using a query filter:
        </p><pre class="programlisting">Collection orderedCollection = s.filter( collection, "order by this.amount" );
Collection counts = s.filter( collection, "select this.type, count(this) group by this.type" );</pre><p>
            You can find the size of a collection without initializing it:
        </p><pre class="programlisting">( (Integer) session.iterate("select count(*) from ....").next() ).intValue();</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="querycriteria"></a>Chapter&nbsp;15.&nbsp;Criteria Queries</h2></div></div><div></div></div><p>
        Hibernate features an intuitive, extensible criteria query API.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-creating"></a>15.1.&nbsp;Creating a <tt class="literal">Criteria</tt> instance</h2></div></div><div></div></div><p>
            The interface <tt class="literal">org.hibernate.Criteria</tt> represents a query against
            a particular persistent class. The <tt class="literal">Session</tt> is a factory for
            <tt class="literal">Criteria</tt> instances.
        </p><pre class="programlisting">Criteria crit = sess.createCriteria(Cat.class);
crit.setMaxResults(50);
List cats = crit.list();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-narrowing"></a>15.2.&nbsp;Narrowing the result set</h2></div></div><div></div></div><p>
            An individual query criterion is an instance of the interface
            <tt class="literal">org.hibernate.criterion.Criterion</tt>. The class
            <tt class="literal">org.hibernate.criterion.Restrictions</tt> defines
            factory methods for obtaining certain built-in
            <tt class="literal">Criterion</tt> types.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "Fritz%") )
    .add( Restrictions.between("weight", minWeight, maxWeight) )
    .list();</pre><p>
            Restrictions may be grouped logically.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "Fritz%") )
    .add( Restrictions.or(
        Restrictions.eq( "age", new Integer(0) ),
        Restrictions.isNull("age")
    ) )
    .list();</pre><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.in( "name", new String[] { "Fritz", "Izi", "Pk" } ) )
    .add( Restrictions.disjunction()
        .add( Restrictions.isNull("age") )
        .add( Restrictions.eq("age", new Integer(0) ) )
        .add( Restrictions.eq("age", new Integer(1) ) )
        .add( Restrictions.eq("age", new Integer(2) ) )
    ) )
    .list();</pre><p>
            There are quite a range of built-in criterion types (<tt class="literal">Restrictions</tt>
            subclasses), but one that is especially useful lets you specify SQL directly.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.sqlRestriction("lower({alias}.name) like lower(?)", "Fritz%", Hibernate.STRING) )
    .list();</pre><p>
            The <tt class="literal">{alias}</tt> placeholder with be replaced by the row alias
            of the queried entity.
        </p><p>
            An alternative approach to obtaining a criterion is to get it from a 
            <tt class="literal">Property</tt> instance. You can create a <tt class="literal">Property</tt>
            by calling <tt class="literal">Property.forName()</tt>.
        </p><pre class="programlisting">
Property age = Property.forName("age");
List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.disjunction()
        .add( age.isNull() )
        .add( age.eq( new Integer(0) ) )
        .add( age.eq( new Integer(1) ) )
        .add( age.eq( new Integer(2) ) )
    ) )
    .add( Property.forName("name").in( new String[] { "Fritz", "Izi", "Pk" } ) )
    .list();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-ordering"></a>15.3.&nbsp;Ordering the results</h2></div></div><div></div></div><p>
            You may order the results using <tt class="literal">org.hibernate.criterion.Order</tt>.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "F%")
    .addOrder( Order.asc("name") )
    .addOrder( Order.desc("age") )
    .setMaxResults(50)
    .list();</pre><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Property.forName("name").like("F%") )
    .addOrder( Property.forName("name").asc() )
    .addOrder( Property.forName("age").desc() )
    .setMaxResults(50)
    .list();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-associations"></a>15.4.&nbsp;Associations</h2></div></div><div></div></div><p>
            You may easily specify constraints upon related entities by navigating
            associations using <tt class="literal">createCriteria()</tt>.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "F%") )
    .createCriteria("kittens")
        .add( Restrictions.like("name", "F%") )
    .list();</pre><p>
            note that the second <tt class="literal">createCriteria()</tt> returns a new
            instance of <tt class="literal">Criteria</tt>, which refers to the elements of
            the <tt class="literal">kittens</tt> collection.
        </p><p>
            The following, alternate form is useful in certain circumstances.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .createAlias("kittens", "kt")
    .createAlias("mate", "mt")
    .add( Restrictions.eqProperty("kt.name", "mt.name") )
    .list();</pre><p>
            (<tt class="literal">createAlias()</tt> does not create a new instance of
            <tt class="literal">Criteria</tt>.)
        </p><p>
            Note that the kittens collections held by the <tt class="literal">Cat</tt> instances
            returned by the previous two queries are <span class="emphasis"><em>not</em></span> pre-filtered
            by the criteria! If you wish to retrieve just the kittens that match the
            criteria, you must use a <tt class="literal">ResultTransformer</tt>.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .createCriteria("kittens", "kt")
        .add( Restrictions.eq("name", "F%") )
    .setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP)
    .list();
Iterator iter = cats.iterator();
while ( iter.hasNext() ) {
    Map map = (Map) iter.next();
    Cat cat = (Cat) map.get(Criteria.ROOT_ALIAS);
    Cat kitten = (Cat) map.get("kt");
}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-dynamicfetching"></a>15.5.&nbsp;Dynamic association fetching</h2></div></div><div></div></div><p>
            You may specify association fetching semantics at runtime using
            <tt class="literal">setFetchMode()</tt>.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "Fritz%") )
    .setFetchMode("mate", FetchMode.EAGER)
    .setFetchMode("kittens", FetchMode.EAGER)
    .list();</pre><p>
            This query will fetch both <tt class="literal">mate</tt> and <tt class="literal">kittens</tt>
            by outer join. See <a href="#performance-fetching" title="19.1.&nbsp;Fetching strategies">Section&nbsp;19.1, &#8220;Fetching strategies&#8221;</a> for more information.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-examples"></a>15.6.&nbsp;Example queries</h2></div></div><div></div></div><p>
            The class <tt class="literal">org.hibernate.criterion.Example</tt> allows
            you to construct a query criterion from a given instance.
        </p><pre class="programlisting">Cat cat = new Cat();
cat.setSex('F');
cat.setColor(Color.BLACK);
List results = session.createCriteria(Cat.class)
    .add( Example.create(cat) )
    .list();</pre><p>
           Version properties, identifiers and associations are ignored. By default,
           null valued properties are excluded.
        </p><p>
           You can adjust how the <tt class="literal">Example</tt> is applied.
        </p><pre class="programlisting">Example example = Example.create(cat)
    .excludeZeroes()           //exclude zero valued properties
    .excludeProperty("color")  //exclude the property named "color"
    .ignoreCase()              //perform case insensitive string comparisons
    .enableLike();             //use like for string comparisons
List results = session.createCriteria(Cat.class)
    .add(example)
    .list();</pre><p>
            You can even use examples to place criteria upon associated objects.
        </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .add( Example.create(cat) )
    .createCriteria("mate")
        .add( Example.create( cat.getMate() ) )
    .list();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-projection"></a>15.7.&nbsp;Projections, aggregation and grouping</h2></div></div><div></div></div><p>
            The class <tt class="literal">org.hibernate.criterion.Projections</tt> is a
            factory for <tt class="literal">Projection</tt> instances. We apply a
            projection to a query by calling <tt class="literal">setProjection()</tt>.
        </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.rowCount() )
    .add( Restrictions.eq("color", Color.BLACK) )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.projectionList()
        .add( Projections.rowCount() )
        .add( Projections.avg("weight") )
        .add( Projections.max("weight") )
        .add( Projections.groupProperty("color") )
    )
    .list();</pre><p>
            There is no explicit "group by" necessary in a criteria query. Certain
            projection types are defined to be <span class="emphasis"><em>grouping projections</em></span>,
            which also appear in the SQL <tt class="literal">group by</tt> clause.
        </p><p>
            An alias may optionally be assigned to a projection, so that the projected value
            may be referred to in restrictions or orderings. Here are two different ways to
            do this:
        </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.alias( Projections.groupProperty("color"), "colr" ) )
    .addOrder( Order.asc("colr") )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.groupProperty("color").as("colr") )
    .addOrder( Order.asc("colr") )
    .list();</pre><p>
            The <tt class="literal">alias()</tt> and <tt class="literal">as()</tt> methods simply wrap a
            projection instance in another, aliased, instance of <tt class="literal">Projection</tt>.
            As a shortcut, you can assign an alias when you add the projection to a 
            projection list:
        </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.projectionList()
        .add( Projections.rowCount(), "catCountByColor" )
        .add( Projections.avg("weight"), "avgWeight" )
        .add( Projections.max("weight"), "maxWeight" )
        .add( Projections.groupProperty("color"), "color" )
    )
    .addOrder( Order.desc("catCountByColor") )
    .addOrder( Order.desc("avgWeight") )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Domestic.class, "cat")
    .createAlias("kittens", "kit")
    .setProjection( Projections.projectionList()
        .add( Projections.property("cat.name"), "catName" )
        .add( Projections.property("kit.name"), "kitName" )
    )
    .addOrder( Order.asc("catName") )
    .addOrder( Order.asc("kitName") )
    .list();</pre><p>
            You can also use <tt class="literal">Property.forName()</tt> to express projections:
        </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Property.forName("name") )
    .add( Property.forName("color").eq(Color.BLACK) )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.projectionList()
        .add( Projections.rowCount().as("catCountByColor") )
        .add( Property.forName("weight").avg().as("avgWeight") )
        .add( Property.forName("weight").max().as("maxWeight") )
        .add( Property.forName("color").group().as("color" )
    )
    .addOrder( Order.desc("catCountByColor") )
    .addOrder( Order.desc("avgWeight") )
    .list();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-detachedqueries"></a>15.8.&nbsp;Detached queries and subqueries</h2></div></div><div></div></div><p>
            The <tt class="literal">DetachedCriteria</tt> class lets you create a query outside the scope 
            of a session, and then later execute it using some arbitrary <tt class="literal">Session</tt>.
        </p><pre class="programlisting">DetachedCriteria query = DetachedCriteria.forClass(Cat.class)
    .add( Property.forName("sex").eq('F') );
    
Session session = ....;
Transaction txn = session.beginTransaction();
List results = query.getExecutableCriteria(session).setMaxResults(100).list();
txn.commit();
session.close();</pre><p>
            A <tt class="literal">DetachedCriteria</tt> may also be used to express a subquery. Criterion
            instances involving subqueries may be obtained via <tt class="literal">Subqueries</tt> or
            <tt class="literal">Property</tt>.            
        </p><pre class="programlisting">DetachedCriteria avgWeight = DetachedCriteria.forClass(Cat.class)
    .setProjection( Property.forName("weight").avg() );
session.createCriteria(Cat.class)
    .add( Property.forName("weight).gt(avgWeight) )
    .list();</pre><pre class="programlisting">DetachedCriteria weights = DetachedCriteria.forClass(Cat.class)
    .setProjection( Property.forName("weight") );
session.createCriteria(Cat.class)
    .add( Subqueries.geAll("weight", weights) )
    .list();</pre><p>
            Even correlated subqueries are possible:
        </p><pre class="programlisting">DetachedCriteria avgWeightForSex = DetachedCriteria.forClass(Cat.class, "cat2")
    .setProjection( Property.forName("weight").avg() )
    .add( Property.forName("cat2.sex").eqProperty("cat.sex") );
session.createCriteria(Cat.class, "cat")
    .add( Property.forName("weight).gt(avgWeightForSex) )
    .list();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="query-criteria-naturalid"></a>15.9.&nbsp;Queries by natural identifier</h2></div></div><div></div></div><p>
            For most queries, including criteria queries, the query cache is not very efficient,
            because query cache invalidation occurs too frequently. However, there is one special
            kind of query where we can optimize the cache invalidation algorithm: lookups by a 
            constant natural key. In some applications, this kind of query occurs frequently.
            The criteria API provides special provision for this use case.
        </p><p>
            First, you should map the natural key of your entity using 
            <tt class="literal">&lt;natural-id&gt;</tt>, and enable use of the second-level cache.
        </p><pre class="programlisting">&lt;class name="User"&gt;
    &lt;cache usage="read-write"/&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;natural-id&gt;
        &lt;property name="name"/&gt;
        &lt;property name="org"/&gt;
    &lt;/natural-id&gt;
    &lt;property name="password"/&gt;
&lt;/class&gt;</pre><p>
            Note that this functionality is not intended for use with entities with 
            <span class="emphasis"><em>mutable</em></span> natural keys.
        </p><p>
            Next, enable the Hibernate query cache.
        </p><p>
            Now, <tt class="literal">Restrictions.naturalId()</tt> allows us to make use of
            the more efficient cache algorithm.
        </p><pre class="programlisting">session.createCriteria(User.class)
    .add( Restrictions.naturalId()
        .set("name", "gavin")
        .set("org", "hb") 
    ).setCacheable(true)
    .uniqueResult();</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="querysql"></a>Chapter&nbsp;16.&nbsp;Native SQL</h2></div></div><div></div></div><p>You may also express queries in the native SQL dialect of your
  database. This is useful if you want to utilize database specific features
  such as query hints or the <tt class="literal">CONNECT</tt> keyword in Oracle. It
  also provides a clean migration path from a direct SQL/JDBC based
  application to Hibernate.</p><p>Hibernate3 allows you to specify handwritten SQL (including stored
  procedures) for all create, update, delete, and load operations.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-creating"></a>16.1.&nbsp;Using a <tt class="literal">SQLQuery</tt></h2></div></div><div></div></div><p>Execution of native SQL queries is controlled via the
    <tt class="literal">SQLQuery</tt> interface, which is obtained by calling
    <tt class="literal">Session.createSQLQuery()</tt>. In extremely simple cases, we
    can use the following form:</p><pre class="programlisting">List cats = sess.createSQLQuery("select * from cats")
    .addEntity(Cat.class)
    .list();</pre><p>This query specified:</p><div class="itemizedlist"><ul type="disc"><li><p>the SQL query string</p></li><li><p>the entity returned by the query</p></li></ul></div><p>Here, the result set column names are assumed to be the same as the
    column names specified in the mapping document. This can be problematic
    for SQL queries which join multiple tables, since the same column names
    may appear in more than one table. The following form is not vulnerable to
    column name duplication:</p><pre class="programlisting">List cats = sess.createSQLQuery("select {cat.*} from cats cat")
    .addEntity("cat", Cat.class)
    .list();</pre><p>This query specified:</p><div class="itemizedlist"><ul type="disc"><li><p>the SQL query string, with a placeholder for Hibernate to inject
        the column aliases</p></li><li><p>the entity returned by the query, and its SQL table alias</p></li></ul></div><p>The <tt class="literal">addEntity()</tt> method associates the SQL table
    alias with the returned entity class, and determines the shape of the
    query result set.</p><p>The <tt class="literal">addJoin()</tt> method may be used to load
    associations to other entities and collections.</p><pre class="programlisting">List cats = sess.createSQLQuery(
        "select {cat.*}, {kitten.*} from cats cat, cats kitten where kitten.mother = cat.id"
    )
    .addEntity("cat", Cat.class)
    .addJoin("kitten", "cat.kittens")
    .list();</pre><p>A native SQL query might return a simple scalar value or a
    combination of scalars and entities.</p><pre class="programlisting">Double max = (Double) sess.createSQLQuery("select max(cat.weight) as maxWeight from cats cat")
        .addScalar("maxWeight", Hibernate.DOUBLE);
        .uniqueResult();</pre><p>You can alternatively describe the resultset mapping informations in
    your hbm files and use them for your queries</p><pre class="programlisting">List cats = sess.createSQLQuery(
        "select {cat.*}, {kitten.*} from cats cat, cats kitten where kitten.mother = cat.id"
    )
    .setResultSetMapping("catAndKitten")
    .list();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-aliasreferences"></a>16.2.&nbsp;Alias and property references</h2></div></div><div></div></div><p>The <tt class="literal">{cat.*}</tt> notation used above is a shorthand
    for "all properties". Alternatively, you may list the columns explicity,
    but even this case we let Hibernate inject the SQL column aliases for each
    property. The placeholder for a column alias is just the property name
    qualified by the table alias. In the following example, we retrieve
    <tt class="literal">Cat</tt>s from a different table
    (<tt class="literal">cat_log</tt>) to the one declared in the mapping metadata.
    Notice that we may even use the property aliases in the where clause if we
    like.</p><p>The <tt class="literal">{}</tt>-syntax is <span class="emphasis"><em>not</em></span>
    required for named queries. See <a href="#querysql-namedqueries" title="16.3.&nbsp;Named SQL queries">Section&nbsp;16.3, &#8220;Named SQL queries&#8221;</a></p><pre class="programlisting">String sql = "select cat.originalId as {cat.id}, " +
    "cat.mateid as {cat.mate}, cat.sex as {cat.sex}, " +
    "cat.weight*10 as {cat.weight}, cat.name as {cat.name} " +
    "from cat_log cat where {cat.mate} = :catId"

List loggedCats = sess.createSQLQuery(sql)
    .addEntity("cat", Cat.class)
    .setLong("catId", catId)
    .list();</pre><p><span class="emphasis"><em>Note:</em></span> if you list each property explicitly, you
    must include all properties of the class <span class="emphasis"><em>and its
    subclasses</em></span>!</p><p>The following table shows the different possibilities of using the
    alias injection. Note: the alias names in the result are examples, each
    alias will have a unique and probably different name when used.</p><div class="table"><a name="aliasinjection-summary"></a><p class="title"><b>Table&nbsp;16.1.&nbsp;Alias injection names</b></p><table summary="Alias injection names" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>Description</th><th>Syntax</th><th>Example</th><td class="auto-generated">&nbsp;</td></tr></thead><tbody><tr><td>A simple property</td><td><tt class="literal">{[aliasname].[propertyname]</tt></td><td><tt class="literal">A_NAME as {item.name}</tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td>A composite property</td><td><tt class="literal">{[aliasname].[componentname].[propertyname]}</tt></td><td><tt class="literal">CURRENCY as {item.amount.currency}, VALUE as {item.amount.value}</tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td>Discriminator of an entity</td><td><tt class="literal">{[aliasname].class}</tt></td><td><tt class="literal">DISC as {item.class}</tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td>All properties of an entity</td><td><tt class="literal">{[aliasname].*}</tt></td><td><tt class="literal">{item.*}</tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td>A collection key</td><td><tt class="literal">{[aliasname].key}</tt></td><td><tt class="literal">ORGID as {coll.key}</tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td>The id of an collection</td><td><tt class="literal">{[aliasname].id}</tt></td><td><tt class="literal">EMPID as {coll.id}</tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td>The element of an collection</td><td><tt class="literal">{[aliasname].element}</tt></td><td><tt class="literal">XID as {coll.element}</tt></td><td>&nbsp;</td></tr><tr><td>Property of the element in the collection</td><td><tt class="literal">{[aliasname].element.[propertyname]}</tt></td><td><tt class="literal">NAME as {coll.element.name}</tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td>All properties of the element in the collection</td><td><tt class="literal">{[aliasname].element.*}</tt></td><td><tt class="literal">{coll.element.*}</tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td>All properties of the the collection</td><td><tt class="literal">{[aliasname].*}</tt></td><td><tt class="literal">{coll.*}</tt></td><td class="auto-generated">&nbsp;</td></tr></tbody></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-namedqueries"></a>16.3.&nbsp;Named SQL queries</h2></div></div><div></div></div><p>Named SQL queries may be defined in the mapping document and called
    in exactly the same way as a named HQL query. In this case, we do
    <span class="emphasis"><em>not</em></span> need to call
    <tt class="literal">addEntity()</tt>.</p><pre class="programlisting">&lt;sql-query name="persons"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex}
    FROM PERSON person
    WHERE person.NAME LIKE :namePattern
&lt;/sql-query&gt;</pre><pre class="programlisting">List people = sess.getNamedQuery("persons")
    .setString("namePattern", namePattern)
    .setMaxResults(50)
    .list();</pre><p>The <tt class="literal">&lt;return-join&gt;</tt> and
    <tt class="literal">&lt;load-collection&gt;</tt> elements are used to join
    associations and define queries which initialize collections,
    respectively.</p><pre class="programlisting">&lt;sql-query name="personsWith"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    &lt;return-join alias="address" property="person.mailingAddress"/&gt;
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex},
           adddress.STREET AS {address.street},
           adddress.CITY AS {address.city},
           adddress.STATE AS {address.state},
           adddress.ZIP AS {address.zip}
    FROM PERSON person
    JOIN ADDRESS adddress
        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'
    WHERE person.NAME LIKE :namePattern
&lt;/sql-query&gt;</pre><p>A named SQL query may return a scalar value. You must declare the
    column alias and Hibernate type using the
    <tt class="literal">&lt;return-scalar&gt;</tt> element:</p><pre class="programlisting">&lt;sql-query name="mySqlQuery"&gt;
    &lt;return-scalar column="name" type="string"/&gt;
    &lt;return-scalar column="age" type="long"/&gt;
    SELECT p.NAME AS name,
           p.AGE AS age,
    FROM PERSON p WHERE p.NAME LIKE 'Hiber%'
&lt;/sql-query&gt;</pre><p>You can externalize the resultset mapping informations in a
    <tt class="literal">&lt;resultset&gt;</tt> element to either reuse them accross
    several named queries or through the
    <tt class="literal">setResultSetMapping()</tt> API.</p><pre class="programlisting">&lt;resultset name="personAddress"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    &lt;return-join alias="address" property="person.mailingAddress"/&gt;
&lt;/resultset&gt;

&lt;sql-query name="personsWith" resultset-ref="personAddress"&gt;
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex},
           adddress.STREET AS {address.street},
           adddress.CITY AS {address.city},
           adddress.STATE AS {address.state},
           adddress.ZIP AS {address.zip}
    FROM PERSON person
    JOIN ADDRESS adddress
        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'
    WHERE person.NAME LIKE :namePattern
&lt;/sql-query&gt;</pre><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="propertyresults"></a>16.3.1.&nbsp;Using return-property to explicitly specify column/alias
      names</h3></div></div><div></div></div><p>With <tt class="literal">&lt;return-property&gt;</tt> you can explicitly
      tell Hibernate what column aliases to use, instead of using the
      <tt class="literal">{}</tt>-syntax to let Hibernate inject its own
      aliases.</p><pre class="programlisting">&lt;sql-query name="mySqlQuery"&gt;
    &lt;return alias="person" class="eg.Person"&gt;
        &lt;return-property name="name" column="myName"/&gt;
        &lt;return-property name="age" column="myAge"/&gt;
        &lt;return-property name="sex" column="mySex"/&gt;
    &lt;/return&gt;
    SELECT person.NAME AS myName,
           person.AGE AS myAge,
           person.SEX AS mySex,
    FROM PERSON person WHERE person.NAME LIKE :name
&lt;/sql-query&gt;
</pre><p><tt class="literal">&lt;return-property&gt;</tt> also works with
      multiple columns. This solves a limitation with the
      <tt class="literal">{}</tt>-syntax which can not allow fine grained control of
      multi-column properties.</p><pre class="programlisting">&lt;sql-query name="organizationCurrentEmployments"&gt;
    &lt;return alias="emp" class="Employment"&gt;
        &lt;return-property name="salary"&gt;
            &lt;return-column name="VALUE"/&gt;
            &lt;return-column name="CURRENCY"/&gt;
        &lt;/return-property&gt;
        &lt;return-property name="endDate" column="myEndDate"/&gt;
    &lt;/return&gt;
        SELECT EMPLOYEE AS {emp.employee}, EMPLOYER AS {emp.employer},
        STARTDATE AS {emp.startDate}, ENDDATE AS {emp.endDate},
        REGIONCODE as {emp.regionCode}, EID AS {emp.id}, VALUE, CURRENCY
        FROM EMPLOYMENT
        WHERE EMPLOYER = :id AND ENDDATE IS NULL
        ORDER BY STARTDATE ASC
&lt;/sql-query&gt;</pre><p>Notice that in this example we used
      <tt class="literal">&lt;return-property&gt;</tt> in combination with the
      <tt class="literal">{}</tt>-syntax for injection. Allowing users to choose how
      they want to refer column and properties.</p><p>
          If your mapping has a discriminator you must use
          <tt class="literal">&lt;return-discriminator&gt;</tt> to specify the
          discriminator column.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sp_query"></a>16.3.2.&nbsp;Using stored procedures for querying</h3></div></div><div></div></div><p>Hibernate 3 introduces support for queries via stored procedures
      and functions. Most of the following documentation is equivalent for both.
      The stored procedure/function must return a resultset as the first out-parameter
      to be able to work with Hibernate. An example of such a stored function
      in Oracle 9 and higher is as follows:</p><pre class="programlisting">CREATE OR REPLACE FUNCTION selectAllEmployments
    RETURN SYS_REFCURSOR
AS
    st_cursor SYS_REFCURSOR;
BEGIN
    OPEN st_cursor FOR
 SELECT EMPLOYEE, EMPLOYER,
 STARTDATE, ENDDATE,
 REGIONCODE, EID, VALUE, CURRENCY
 FROM EMPLOYMENT;
      RETURN  st_cursor;
 END;</pre><p>To use this query in Hibernate you need to map it via a named
      query.</p><pre class="programlisting">&lt;sql-query name="selectAllEmployees_SP" callable="true"&gt;
    &lt;return alias="emp" class="Employment"&gt;
        &lt;return-property name="employee" column="EMPLOYEE"/&gt;
        &lt;return-property name="employer" column="EMPLOYER"/&gt;
        &lt;return-property name="startDate" column="STARTDATE"/&gt;
        &lt;return-property name="endDate" column="ENDDATE"/&gt;
        &lt;return-property name="regionCode" column="REGIONCODE"/&gt;
        &lt;return-property name="id" column="EID"/&gt;
        &lt;return-property name="salary"&gt;
            &lt;return-column name="VALUE"/&gt;
            &lt;return-column name="CURRENCY"/&gt;
        &lt;/return-property&gt;
    &lt;/return&gt;
    { ? = call selectAllEmployments() }
&lt;/sql-query&gt;</pre><p>Notice stored procedures currently only return scalars and
      entities. <tt class="literal">&lt;return-join&gt;</tt> and
      <tt class="literal">&lt;load-collection&gt;</tt> are not supported.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="querysql-limits-storedprocedures"></a>16.3.2.1.&nbsp;Rules/limitations for using stored procedures</h4></div></div><div></div></div><p>To use stored procedures with Hibernate the procedures/functions have to
        follow some rules. If they do not follow those rules they are not
        usable with Hibernate. If you still want to use these procedures you
        have to execute them via <tt class="literal">session.connection()</tt>. The
        rules are different for each database, since database vendors have
        different stored procedure semantics/syntax.</p><p>Stored procedure queries can't be paged with
        <tt class="literal">setFirstResult()/setMaxResults()</tt>.</p><p>Recommended call form is standard SQL92: <tt class="literal">{ ? = call
        functionName(&lt;parameters&gt;) }</tt> or <tt class="literal">{ ? = call
        procedureName(&lt;parameters&gt;}</tt>. Native call syntax is
        not supported.</p><p>For Oracle the following rules apply:</p><div class="itemizedlist"><ul type="disc" compact><li><p>A function must return a result set. The first parameter of
            a procedure must be an <tt class="literal">OUT</tt> that returns a result
            set. This is done by using a <tt class="literal">SYS_REFCURSOR</tt> type
            in Oracle 9 or 10. In Oracle you need to define a
            <tt class="literal">REF CURSOR</tt> type, see Oracle literature.</p></li></ul></div><p>For Sybase or MS SQL server the following rules apply:</p><div class="itemizedlist"><ul type="disc" compact><li><p>The procedure must return a result set. Note that since
            these servers can/will return multiple result sets and update
            counts, Hibernate will iterate the results and take the first
            result that is a result set as its return value. Everything else
            will be discarded.</p></li><li><p>If you can enable <tt class="literal">SET NOCOUNT ON</tt> in your
            procedure it will probably be more efficient, but this is not a
            requirement.</p></li></ul></div></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-cud"></a>16.4.&nbsp;Custom SQL for create, update and delete</h2></div></div><div></div></div><p>Hibernate3 can use custom SQL statements for create, update, and
    delete operations. The class and collection persisters in Hibernate
    already contain a set of configuration time generated strings (insertsql,
    deletesql, updatesql etc.). The mapping tags
    <tt class="literal">&lt;sql-insert&gt;</tt>,
    <tt class="literal">&lt;sql-delete&gt;</tt>, and
    <tt class="literal">&lt;sql-update&gt;</tt> override these strings:</p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true"/&gt;
    &lt;sql-insert&gt;INSERT INTO PERSON (NAME, ID) VALUES ( UPPER(?), ? )&lt;/sql-insert&gt;
    &lt;sql-update&gt;UPDATE PERSON SET NAME=UPPER(?) WHERE ID=?&lt;/sql-update&gt;
    &lt;sql-delete&gt;DELETE FROM PERSON WHERE ID=?&lt;/sql-delete&gt;
&lt;/class&gt;</pre><p>The SQL is directly executed in your database, so you are free to
    use any dialect you like. This will of course reduce the portability of
    your mapping if you use database specific SQL.</p><p>Stored procedures are supported if the <tt class="literal">callable</tt>
    attribute is set:</p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true"/&gt;
    &lt;sql-insert callable="true"&gt;{call createPerson (?, ?)}&lt;/sql-insert&gt;
    &lt;sql-delete callable="true"&gt;{? = call deletePerson (?)}&lt;/sql-delete&gt;
    &lt;sql-update callable="true"&gt;{? = call updatePerson (?, ?)}&lt;/sql-update&gt;
&lt;/class&gt;</pre><p>The order of the positional parameters are currently vital, as they
    must be in the same sequence as Hibernate expects them.</p><p>You can see the expected order by enabling debug logging for the
    <tt class="literal">org.hibernate.persister.entity</tt> level. With this level
    enabled Hibernate will print out the static SQL that is used to create,
    update, delete etc. entities. (To see the expected sequence, remember to
    not include your custom SQL in the mapping files as that will override the
    Hibernate generated static sql.)</p><p>The stored procedures are in most cases (read: better do it than
    not) required to return the number of rows inserted/updated/deleted, as
    Hibernate has some runtime checks for the success of the statement.
    Hibernate always registers the first statement parameter as a numeric
    output parameter for the CUD operations:</p><pre class="programlisting">CREATE OR REPLACE FUNCTION updatePerson (uid IN NUMBER, uname IN VARCHAR2)
    RETURN NUMBER IS
BEGIN

    update PERSON
    set
        NAME = uname,
    where
        ID = uid;

    return SQL%ROWCOUNT;

END updatePerson;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-load"></a>16.5.&nbsp;Custom SQL for loading</h2></div></div><div></div></div><p>You may also declare your own SQL (or HQL) queries for entity
    loading:</p><pre class="programlisting">&lt;sql-query name="person"&gt;
    &lt;return alias="pers" class="Person" lock-mode="upgrade"/&gt;
    SELECT NAME AS {pers.name}, ID AS {pers.id}
    FROM PERSON
    WHERE ID=?
    FOR UPDATE
&lt;/sql-query&gt;</pre><p>This is just a named query declaration, as discussed earlier. You
    may reference this named query in a class mapping:</p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true"/&gt;
    &lt;loader query-ref="person"/&gt;
&lt;/class&gt;</pre><p>This even works with stored procedures.</p><p>You may even define a query for collection loading:</p><pre class="programlisting">&lt;set name="employments" inverse="true"&gt;
    &lt;key/&gt;
    &lt;one-to-many class="Employment"/&gt;
    &lt;loader query-ref="employments"/&gt;
&lt;/set&gt;</pre><pre class="programlisting">&lt;sql-query name="employments"&gt;
    &lt;load-collection alias="emp" role="Person.employments"/&gt;
    SELECT {emp.*}
    FROM EMPLOYMENT emp
    WHERE EMPLOYER = :id
    ORDER BY STARTDATE ASC, EMPLOYEE ASC
&lt;/sql-query&gt;</pre><p>You could even define an entity loader that loads a collection by
    join fetching:</p><pre class="programlisting">&lt;sql-query name="person"&gt;
    &lt;return alias="pers" class="Person"/&gt;
    &lt;return-join alias="emp" property="pers.employments"/&gt;
    SELECT NAME AS {pers.*}, {emp.*}
    FROM PERSON pers
    LEFT OUTER JOIN EMPLOYMENT emp
        ON pers.ID = emp.PERSON_ID
    WHERE ID=?
&lt;/sql-query&gt;</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="filters"></a>Chapter&nbsp;17.&nbsp;Filtering data</h2></div></div><div></div></div><p>
        Hibernate3 provides an innovative new approach to handling data with "visibility" rules.
        A <span class="emphasis"><em>Hibernate filter</em></span> is a global, named, parameterized filter that may be 
        enabled or disabled for a particular Hibernate session.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-filters"></a>17.1.&nbsp;Hibernate filters</h2></div></div><div></div></div><p>
            Hibernate3 adds the ability to pre-define filter criteria and attach those filters at both
            a class and a collection level. A filter criteria is the ability to define a restriction clause
            very similiar to the existing "where" attribute available on the class and various collection
            elements. Except these filter conditions can be parameterized. The application can then make
            the decision at runtime whether given filters should be enabled and what their parameter
            values should be. Filters can be used like database views, but parameterized inside the
            application.
        </p><p>
            In order to use filters, they must first be defined and then attached to the appropriate
            mapping elements. To define a filter, use the <tt class="literal">&lt;filter-def/&gt;</tt> element
            within a <tt class="literal">&lt;hibernate-mapping/&gt;</tt> element:
        </p><pre class="programlisting">&lt;filter-def name="myFilter"&gt;
    &lt;filter-param name="myFilterParam" type="string"/&gt;
&lt;/filter-def&gt;</pre><p>
            Then, this filter can be attached to a class:
        </p><pre class="programlisting">&lt;class name="myClass" ...&gt;
    ...
    &lt;filter name="myFilter" condition=":myFilterParam = MY_FILTERED_COLUMN"/&gt;
&lt;/class&gt;</pre><p>
            or, to a collection:
        </p><pre class="programlisting">&lt;set ...&gt;
    &lt;filter name="myFilter" condition=":myFilterParam = MY_FILTERED_COLUMN"/&gt;
&lt;/set&gt;</pre><p>
            or, even to both (or multiples of each) at the same time.
        </p><p>
            The methods on <tt class="literal">Session</tt> are: <tt class="literal">enableFilter(String filterName)</tt>,
            <tt class="literal">getEnabledFilter(String filterName)</tt>, and <tt class="literal">disableFilter(String filterName)</tt>.
            By default, filters are <span class="emphasis"><em>not</em></span> enabled for a given session; they must be explcitly
            enabled through use of the <tt class="literal">Session.enabledFilter()</tt> method, which returns an
            instance of the <tt class="literal">Filter</tt> interface. Using the simple filter defined above, this
            would look like:
        </p><pre class="programlisting">session.enableFilter("myFilter").setParameter("myFilterParam", "some-value");</pre><p>
            Note that methods on the org.hibernate.Filter interface do allow the method-chaining common to much of Hibernate.
        </p><p>
            A full example, using temporal data with an effective record date pattern:
        </p><pre class="programlisting">&lt;filter-def name="effectiveDate"&gt;
    &lt;filter-param name="asOfDate" type="date"/&gt;
&lt;/filter-def&gt;

&lt;class name="Employee" ...&gt;
...
    &lt;many-to-one name="department" column="dept_id" class="Department"/&gt;
    &lt;property name="effectiveStartDate" type="date" column="eff_start_dt"/&gt;
    &lt;property name="effectiveEndDate" type="date" column="eff_end_dt"/&gt;
...
    &lt;!--
        Note that this assumes non-terminal records have an eff_end_dt set to
        a max db date for simplicity-sake
    --&gt;
    &lt;filter name="effectiveDate"
            condition=":asOfDate BETWEEN eff_start_dt and eff_end_dt"/&gt;
&lt;/class&gt;

&lt;class name="Department" ...&gt;
...
    &lt;set name="employees" lazy="true"&gt;
        &lt;key column="dept_id"/&gt;
        &lt;one-to-many class="Employee"/&gt;
        &lt;filter name="effectiveDate"
                condition=":asOfDate BETWEEN eff_start_dt and eff_end_dt"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
            Then, in order to ensure that you always get back currently effective records, simply
            enable the filter on the session prior to retrieving employee data:
        </p><pre class="programlisting">Session session = ...;
session.enabledFilter("effectiveDate").setParameter("asOfDate", new Date());
List results = session.createQuery("from Employee as e where e.salary &gt; :targetSalary")
         .setLong("targetSalary", new Long(1000000))
         .list();
</pre><p>
            In the HQL above, even though we only explicitly mentioned a salary constraint on the results,
            because of the enabled filter the query will return only currently active employees who have
            a salary greater than a million dollars.
        </p><p>
            Note: if you plan on using filters with outer joining (either through HQL or load fetching) be
            careful of the direction of the condition expression.  Its safest to set this up for left
            outer joining; in general, place the parameter first followed by the column name(s) after
            the operator.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="xml"></a>Chapter&nbsp;18.&nbsp;XML Mapping</h2></div></div><div></div></div><p><span class="emphasis"><em>
        Note that this is an experimental feature in Hibernate 3.0 and is under
        extremely active development.
    </em></span></p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml-intro"></a>18.1.&nbsp;Working with XML data</h2></div></div><div></div></div><p>
            Hibernate lets you work with persistent XML data in much the same way
            you work with persistent POJOs. A parsed XML tree can be thought of
            as just another way to represent the relational data at the object level,
            instead of POJOs.
        </p><p>
            Hibernate supports dom4j as API for manipulating XML trees. You can write 
            queries that retrieve dom4j trees from the database and have any 
            modification you make to the tree automatically synchronized to the 
            database. You can even take an XML document, parse it using dom4j, and
            write it to the database with any of Hibernate's basic operations: 
            <tt class="literal">persist(), saveOrUpdate(), merge(), delete(), replicate()</tt> 
            (merging is not yet supported).
        </p><p>
            This feature has many applications including data import/export, 
            externalization of entity data via JMS or SOAP and XSLT-based reporting.
        </p><p>
            A single mapping may be used to simultaneously map properties of a class
            and nodes of an XML document to the database, or, if there is no class to map, 
            it may be used to map just the XML.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml-intro-mapping"></a>18.1.1.&nbsp;Specifying XML and class mapping together</h3></div></div><div></div></div><p>
                Here is an example of mapping a POJO and XML simultaneously:
            </p><pre class="programlisting">&lt;class name="Account" 
        table="ACCOUNTS" 
        node="account"&gt;
        
    &lt;id name="accountId" 
            column="ACCOUNT_ID" 
            node="@id"/&gt;
            
    &lt;many-to-one name="customer" 
            column="CUSTOMER_ID" 
            node="customer/@id" 
            embed-xml="false"/&gt;
            
    &lt;property name="balance" 
            column="BALANCE" 
            node="balance"/&gt;
            
    ...
    
&lt;/class&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml-onlyxml"></a>18.1.2.&nbsp;Specifying only an XML mapping</h3></div></div><div></div></div><p>
                Here is an example where there is no POJO class:
            </p><pre class="programlisting">&lt;class entity-name="Account" 
        table="ACCOUNTS" 
        node="account"&gt;
        
    &lt;id name="id" 
            column="ACCOUNT_ID" 
            node="@id" 
            type="string"/&gt;
            
    &lt;many-to-one name="customerId" 
            column="CUSTOMER_ID" 
            node="customer/@id" 
            embed-xml="false" 
            entity-name="Customer"/&gt;
            
    &lt;property name="balance" 
            column="BALANCE" 
            node="balance" 
            type="big_decimal"/&gt;
            
    ...
    
&lt;/class&gt;</pre><p>
                This mapping allows you to access the data as a dom4j tree, or as a graph of
                property name/value pairs (java <tt class="literal">Map</tt>s). The property names
                are purely logical constructs that may be referred to in HQL queries.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml-mapping"></a>18.2.&nbsp;XML mapping metadata</h2></div></div><div></div></div><p>
            Many Hibernate mapping elements accept the <tt class="literal">node</tt> attribute.
            This let's you specify the name of an XML attribute or element that holds the
            property or entity data. The format of the <tt class="literal">node</tt> attribute
            must be one of the following:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p><tt class="literal">"element-name"</tt> - map to the named XML element</p></li><li><p><tt class="literal">"@attribute-name"</tt> - map to the named XML attribute</p></li><li><p><tt class="literal">"."</tt> - map to the parent element</p></li><li><p>
                <tt class="literal">"element-name/@attribute-name"</tt> - 
                map to the named attribute of the named element
            </p></li></ul></div><p>
            For collections and single valued associations, there is an additional 
            <tt class="literal">embed-xml</tt> attribute. If <tt class="literal">embed-xml="true"</tt>,
            the default, the XML tree for the associated entity (or collection of value type) 
            will be embedded directly in the XML tree for the entity that owns the association.
            Otherwise, if <tt class="literal">embed-xml="false"</tt>, then only the referenced 
            identifier value will appear in the XML for single point associations and 
            collections will simply not appear at all.
        </p><p>
            You should be careful not to leave <tt class="literal">embed-xml="true"</tt> for
            too many associations, since XML does not deal well with circularity!
        </p><pre class="programlisting">&lt;class name="Customer" 
        table="CUSTOMER" 
        node="customer"&gt;
        
    &lt;id name="id" 
            column="CUST_ID" 
            node="@id"/&gt;
            
    &lt;map name="accounts" 
            node="." 
            embed-xml="true"&gt;
        &lt;key column="CUSTOMER_ID" 
                not-null="true"/&gt;
        &lt;map-key column="SHORT_DESC" 
                node="@short-desc" 
                type="string"/&gt;
        &lt;one-to-many entity-name="Account"
                embed-xml="false" 
                node="account"/&gt;
    &lt;/map&gt;
    
    &lt;component name="name" 
            node="name"&gt;
        &lt;property name="firstName" 
                node="first-name"/&gt;
        &lt;property name="initial" 
                node="initial"/&gt;
        &lt;property name="lastName" 
                node="last-name"/&gt;
    &lt;/component&gt;
    
    ...
    
&lt;/class&gt;</pre><p>
            in this case, we have decided to embed the collection of account ids, but not
            the actual account data. The following HQL query:
        </p><pre class="programlisting">from Customer c left join fetch c.accounts where c.lastName like :lastName</pre><p>
            Would return datasets such as this:
        </p><pre class="programlisting">&lt;customer id="123456789"&gt;
    &lt;account short-desc="Savings"&gt;987632567&lt;/account&gt;
    &lt;account short-desc="Credit Card"&gt;985612323&lt;/account&gt;
    &lt;name&gt;
        &lt;first-name&gt;Gavin&lt;/first-name&gt;
        &lt;initial&gt;A&lt;/initial&gt;
        &lt;last-name&gt;King&lt;/last-name&gt;
    &lt;/name&gt;
    ...
&lt;/customer&gt;</pre><p>
            If you set <tt class="literal">embed-xml="true"</tt> on the <tt class="literal">&lt;one-to-many&gt;</tt>
            mapping, the data might look more like this:
        </p><pre class="programlisting">&lt;customer id="123456789"&gt;
    &lt;account id="987632567" short-desc="Savings"&gt;
        &lt;customer id="123456789"/&gt;
        &lt;balance&gt;100.29&lt;/balance&gt;
    &lt;/account&gt;
    &lt;account id="985612323" short-desc="Credit Card"&gt;
        &lt;customer id="123456789"/&gt;
        &lt;balance&gt;-2370.34&lt;/balance&gt;
    &lt;/account&gt;
    &lt;name&gt;
        &lt;first-name&gt;Gavin&lt;/first-name&gt;
        &lt;initial&gt;A&lt;/initial&gt;
        &lt;last-name&gt;King&lt;/last-name&gt;
    &lt;/name&gt;
    ...
&lt;/customer&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml-manipulation"></a>18.3.&nbsp;Manipulating XML data</h2></div></div><div></div></div><p>
            Let's rearead and update XML documents in the application. We do this by
            obtaining a dom4j session:
        </p><pre class="programlisting">Document doc = ....;
       
Session session = factory.openSession();
Session dom4jSession = session.getSession(EntityMode.DOM4J);
Transaction tx = session.beginTransaction();

List results = dom4jSession
    .createQuery("from Customer c left join fetch c.accounts where c.lastName like :lastName")
    .list();
for ( int i=0; i&lt;results.size(); i++ ) {
    //add the customer data to the XML document
    Element customer = (Element) results.get(i);
    doc.add(customer);
}

tx.commit();
session.close();</pre><pre class="programlisting">Session session = factory.openSession();
Session dom4jSession = session.getSession(EntityMode.DOM4J);
Transaction tx = session.beginTransaction();

Element cust = (Element) dom4jSession.get("Customer", customerId);
for ( int i=0; i&lt;results.size(); i++ ) {
    Element customer = (Element) results.get(i);
    //change the customer name in the XML and database
    Element name = customer.element("name");
    name.element("first-name").setText(firstName);
    name.element("initial").setText(initial);
    name.element("last-name").setText(lastName);
}

tx.commit();
session.close();</pre><p>
            It is extremely useful to combine this feature with Hibernate's <tt class="literal">replicate()</tt>
            operation to implement XML-based data import/export.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="performance"></a>Chapter&nbsp;19.&nbsp;Improving performance</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-fetching"></a>19.1.&nbsp;Fetching strategies</h2></div></div><div></div></div><p>
            A <span class="emphasis"><em>fetching strategy</em></span> is the strategy Hibernate will use for 
            retrieving associated objects if the application needs to navigate the association. 
            Fetch strategies may be declared in the O/R mapping metadata, or over-ridden by a 
            particular HQL or <tt class="literal">Criteria</tt> query.
        </p><p>
            Hibernate3 defines the following fetching strategies:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <span class="emphasis"><em>Join fetching</em></span> - Hibernate retrieves the
                    associated instance or collection in the same <tt class="literal">SELECT</tt>,
                    using an <tt class="literal">OUTER JOIN</tt>.
                </p></li><li><p>
                    <span class="emphasis"><em>Select fetching</em></span> - a second <tt class="literal">SELECT</tt>
                    is used to retrieve the associated entity or collection. Unless
                    you explicitly disable lazy fetching by specifying <tt class="literal">lazy="false"</tt>, 
                    this second select will only be executed when you actually access the
                    association.
                </p></li><li><p>
                    <span class="emphasis"><em>Subselect fetching</em></span> - a second <tt class="literal">SELECT</tt>
                    is used to retrieve the associated collections for all entities retrieved in a
                    previous query or fetch. Unless you explicitly disable lazy fetching by specifying 
                    <tt class="literal">lazy="false"</tt>, this second select will only be executed when you 
                    actually access the association.
                </p></li><li><p>
                    <span class="emphasis"><em>Batch fetching</em></span> - an optimization strategy
                    for select fetching - Hibernate retrieves a batch of entity instances 
                    or collections in a single <tt class="literal">SELECT</tt>, by specifying 
                    a list of primary keys or foreign keys.
                </p></li></ul></div><p>
            Hibernate also distinguishes between:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <span class="emphasis"><em>Immediate fetching</em></span> - an association, collection or
                    attribute is fetched immediately, when the owner is loaded.
                </p></li><li><p>
                    <span class="emphasis"><em>Lazy collection fetching</em></span> - a collection is fetched 
                    when the application invokes an operation upon that collection. (This
                    is the default for collections.)
                </p></li><li><p>
                    <span class="emphasis"><em>"Extra-lazy" collection fetching</em></span> - individual
                    elements of the collection are accessed from the database as needed.
                    Hibernate tries not to fetch the whole collection into memory unless
                    absolutely needed (suitable for very large collections)
                </p></li><li><p>
                    <span class="emphasis"><em>Proxy fetching</em></span> - a single-valued association is 
                    fetched when a method other than the identifier getter is invoked
                    upon the associated object.
                </p></li><li><p>
                    <span class="emphasis"><em>"No-proxy" fetching</em></span> - a single-valued association is 
                    fetched when the instance variable is accessed. Compared to proxy fetching, 
                    this approach is less lazy (the association is fetched even when only the 
                    identifier is accessed) but more transparent, since no proxy is visible to 
                    the application. This approach requires buildtime bytecode instrumentation 
                    and is rarely necessary.
                </p></li><li><p>
                    <span class="emphasis"><em>Lazy attribute fetching</em></span> - an attribute or single
                    valued association is fetched when the instance variable is accessed. 
                    This approach requires buildtime bytecode instrumentation and is rarely 
                    necessary.
                </p></li></ul></div><p>
            We have two orthogonal notions here: <span class="emphasis"><em>when</em></span> is the association
            fetched, and <span class="emphasis"><em>how</em></span> is it fetched (what SQL is used). Don't
            confuse them! We use <tt class="literal">fetch</tt> to tune performance. We may use 
            <tt class="literal">lazy</tt> to define a contract for what data is always available 
            in any detached instance of a particular class.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-lazy"></a>19.1.1.&nbsp;Working with lazy associations</h3></div></div><div></div></div><p>
                By default, Hibernate3 uses lazy select fetching for collections and lazy proxy
                fetching for single-valued associations. These defaults make sense for almost
                all associations in almost all applications. 
            </p><p>
                <span class="emphasis"><em>Note:</em></span> if you set 
                <tt class="literal">hibernate.default_batch_fetch_size</tt>, Hibernate will use the 
                batch fetch optimization for lazy fetching (this optimization may also be enabled 
                at a more granular level).
            </p><p>
                However, lazy fetching poses one problem that you must be aware of. Access to a 
                lazy association outside of the context of an open Hibernate session will result 
                in an exception. For example:
            </p><pre class="programlisting">s = sessions.openSession();
Transaction tx = s.beginTransaction();
            
User u = (User) s.createQuery("from User u where u.name=:userName")
    .setString("userName", userName).uniqueResult();
Map permissions = u.getPermissions();

tx.commit();
s.close();

Integer accessLevel = (Integer) permissions.get("accounts");  // Error!</pre><p>
                Since the permissions collection was not initialized when the 
                <tt class="literal">Session</tt> was closed, the collection will not be able to 
                load its state. <span class="emphasis"><em>Hibernate does not support lazy initialization 
                for detached objects</em></span>. The fix is to move the code that reads 
                from the collection to just before the transaction is committed.
            </p><p>
                Alternatively, we could use a non-lazy collection or association, 
                by specifying <tt class="literal">lazy="false"</tt> for the association mapping.
                However, it is intended that lazy initialization be used for almost all 
                collections and associations. If you define too many non-lazy associations 
                in your object model, Hibernate will end up needing to fetch the entire 
                database into memory in every transaction!
            </p><p>
                On the other hand, we often want to choose join fetching (which is non-lazy by 
                nature) instead of select fetching in a particular transaction. We'll now see
                how to customize the fetching strategy. In Hibernate3, the mechanisms for
                choosing a fetch strategy are identical for single-valued associations and
                collections.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-custom"></a>19.1.2.&nbsp;Tuning fetch strategies</h3></div></div><div></div></div><p>
                Select fetching (the default) is extremely vulnerable to N+1 selects problems, 
                so we might want to enable join fetching in the mapping document:
            </p><pre class="programlisting">&lt;set name="permissions" 
            fetch="join"&gt;
    &lt;key column="userId"/&gt;
    &lt;one-to-many class="Permission"/&gt;
&lt;/set</pre><pre class="programlisting">&lt;many-to-one name="mother" class="Cat" fetch="join"/&gt;</pre><p>
                The <tt class="literal">fetch</tt> strategy defined in the mapping document affects:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                    retrieval via <tt class="literal">get()</tt> or <tt class="literal">load()</tt>
                </p></li><li><p>
                    retrieval that happens implicitly when an association is navigated
                </p></li><li><p>
                    <tt class="literal">Criteria</tt> queries
                </p></li><li><p>
                    HQL queries if <tt class="literal">subselect</tt> fetching is used
                </p></li></ul></div><p>
                No matter what fetching strategy you use, the defined non-lazy graph is guaranteed
                to be loaded into memory. Note that this might result in several immediate selects
                being used to execute a particular HQL query.
            </p><p>
                Usually, we don't use the mapping document to customize fetching. Instead, we
                keep the default behavior, and override it for a particular transaction, using 
                <tt class="literal">left join fetch</tt> in HQL. This tells Hibernate to fetch 
                the association eagerly in the first select, using an outer join. In the
                <tt class="literal">Criteria</tt> query API, you would use
                <tt class="literal">setFetchMode(FetchMode.JOIN)</tt>.
            </p><p>
                If you ever feel like you wish you could change the fetching strategy used by
                <tt class="literal">get()</tt> or <tt class="literal">load()</tt>, simply use a 
                <tt class="literal">Criteria</tt> query, for example:
            </p><pre class="programlisting">User user = (User) session.createCriteria(User.class)
                .setFetchMode("permissions", FetchMode.JOIN)
                .add( Restrictions.idEq(userId) )
                .uniqueResult();</pre><p>
                (This is Hibernate's equivalent of what some ORM solutions call a "fetch plan".)
            </p><p>
                A completely different way to avoid problems with N+1 selects is to use the 
                second-level cache.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-proxies"></a>19.1.3.&nbsp;Single-ended association proxies</h3></div></div><div></div></div><p>
                Lazy fetching for collections is implemented using Hibernate's own implementation
                of persistent collections. However, a different mechanism is needed for lazy
                behavior in single-ended associations. The target entity of the association must
                be proxied. Hibernate implements lazy initializing proxies for persistent objects
                using runtime bytecode enhancement (via the excellent CGLIB library).
            </p><p>
                By default, Hibernate3 generates proxies (at startup) for all persistent classes
                and uses them to enable lazy fetching of <tt class="literal">many-to-one</tt> and
                <tt class="literal">one-to-one</tt> associations.
            </p><p>
                The mapping file may declare an interface to use as the proxy interface for that
                class, with the <tt class="literal">proxy</tt> attribute. By default, Hibernate uses a subclass
                of the class. <span class="emphasis"><em>Note that the proxied class must implement a default constructor
                with at least package visibility. We recommend this constructor for all persistent classes!</em></span>
            </p><p>
                There are some gotchas to be aware of when extending this approach to polymorphic
                classes, eg.
            </p><pre class="programlisting">&lt;class name="Cat" proxy="Cat"&gt;
    ......
    &lt;subclass name="DomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
                Firstly, instances of <tt class="literal">Cat</tt> will never be castable to
                <tt class="literal">DomesticCat</tt>, even if the underlying instance is an
                instance of <tt class="literal">DomesticCat</tt>:
            </p><pre class="programlisting">Cat cat = (Cat) session.load(Cat.class, id);  // instantiate a proxy (does not hit the db)
if ( cat.isDomesticCat() ) {                  // hit the db to initialize the proxy
    DomesticCat dc = (DomesticCat) cat;       // Error!
    ....
}</pre><p>
                Secondly, it is possible to break proxy <tt class="literal">==</tt>.
            </p><pre class="programlisting">Cat cat = (Cat) session.load(Cat.class, id);            // instantiate a Cat proxy
DomesticCat dc = 
        (DomesticCat) session.load(DomesticCat.class, id);  // acquire new DomesticCat proxy!
System.out.println(cat==dc);                            // false</pre><p>
                However, the situation is not quite as bad as it looks. Even though we now have two references
                to different proxy objects, the underlying instance will still be the same object:
            </p><pre class="programlisting">cat.setWeight(11.0);  // hit the db to initialize the proxy
System.out.println( dc.getWeight() );  // 11.0</pre><p>
                Third, you may not use a CGLIB proxy for a <tt class="literal">final</tt> class or a class
                with any <tt class="literal">final</tt> methods.
            </p><p>
                Finally, if your persistent object acquires any resources upon instantiation (eg. in
                initializers or default constructor), then those resources will also be acquired by
                the proxy. The proxy class is an actual subclass of the persistent class.
            </p><p>
                These problems are all due to fundamental limitations in Java's single inheritance model.
                If you wish to avoid these problems your persistent classes must each implement an interface
                that declares its business methods. You should specify these interfaces in the mapping file. eg.
            </p><pre class="programlisting">&lt;class name="CatImpl" proxy="Cat"&gt;
    ......
    &lt;subclass name="DomesticCatImpl" proxy="DomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
                where <tt class="literal">CatImpl</tt> implements the interface <tt class="literal">Cat</tt> and
                <tt class="literal">DomesticCatImpl</tt> implements the interface <tt class="literal">DomesticCat</tt>. Then
                proxies for instances of <tt class="literal">Cat</tt> and <tt class="literal">DomesticCat</tt> may be returned
                by <tt class="literal">load()</tt> or <tt class="literal">iterate()</tt>. (Note that <tt class="literal">list()</tt>
                does not usually return proxies.)
            </p><pre class="programlisting">Cat cat = (Cat) session.load(CatImpl.class, catid);
Iterator iter = session.iterate("from CatImpl as cat where cat.name='fritz'");
Cat fritz = (Cat) iter.next();</pre><p>
                Relationships are also lazily initialized. This means you must declare any properties to be of
                type <tt class="literal">Cat</tt>, not <tt class="literal">CatImpl</tt>.
            </p><p>
                Certain operations do <span class="emphasis"><em>not</em></span> require proxy initialization
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">equals()</tt>, if the persistent class does not override
                        <tt class="literal">equals()</tt>
                    </p></li><li><p>
                        <tt class="literal">hashCode()</tt>, if the persistent class does not override
                        <tt class="literal">hashCode()</tt>
                    </p></li><li><p>
                        The identifier getter method
                    </p></li></ul></div><p>
                Hibernate will detect persistent classes that override <tt class="literal">equals()</tt> or
                <tt class="literal">hashCode()</tt>.
            </p><p>
                By choosing <tt class="literal">lazy="no-proxy"</tt> instead of the default 
                <tt class="literal">lazy="proxy"</tt>, we can avoid the problems associated with typecasting.
                However, we will require buildtime bytecode instrumentation, and all operations
                will result in immediate proxy initialization.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-initialization"></a>19.1.4.&nbsp;Initializing collections and proxies</h3></div></div><div></div></div><p>
                A <tt class="literal">LazyInitializationException</tt> will be thrown by Hibernate if an uninitialized 
                collection or proxy is accessed outside of the scope of the <tt class="literal">Session</tt>, ie. when 
                the entity owning the collection or having the reference to the proxy is in the detached state.
            </p><p>
                Sometimes we need to ensure that a proxy or collection is initialized before closing the
                <tt class="literal">Session</tt>. Of course, we can alway force initialization by calling
                <tt class="literal">cat.getSex()</tt> or <tt class="literal">cat.getKittens().size()</tt>, for example.
                But that is confusing to readers of the code and is not convenient for generic code.
            </p><p>
                The static methods <tt class="literal">Hibernate.initialize()</tt> and <tt class="literal">Hibernate.isInitialized()</tt>
                provide the application with a convenient way of working with lazily initialized collections or
                proxies. <tt class="literal">Hibernate.initialize(cat)</tt> will force the initialization of a proxy,
                <tt class="literal">cat</tt>, as long as its <tt class="literal">Session</tt> is still open.
                <tt class="literal">Hibernate.initialize( cat.getKittens() )</tt> has a similar effect for the collection
                of kittens.
            </p><p>
                Another option is to keep the <tt class="literal">Session</tt> open until all needed
                collections and proxies have been loaded. In some application architectures,
                particularly where the code that accesses data using Hibernate, and the code that
                uses it are in different application layers or different physical processes, it 
                can be a problem to ensure that the <tt class="literal">Session</tt> is open when a 
                collection is initialized. There are two basic ways to deal with this issue:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        In a web-based application, a servlet filter can be used to close the
                        <tt class="literal">Session</tt> only at the very end of a user request, once
                        the rendering of the view is complete (the <span class="emphasis"><em>Open Session in
                        View</em></span> pattern).  Of course, this places heavy demands on the 
                        correctness of the exception handling of your application infrastructure. 
                        It is vitally important that the <tt class="literal">Session</tt> is closed and the 
                        transaction ended before returning to the user, even when an exception occurs 
                        during rendering of the view. See the Hibernate Wiki for examples of this
                        "Open Session in View" pattern.
                    </p></li><li><p>
                        In an application with a separate business tier, the business logic must
                        "prepare" all collections that will be needed by the web tier before
                        returning. This means that the business tier should load all the data and
                        return all the data already initialized to the presentation/web tier that
                        is required for a particular use case. Usually, the application calls
                        <tt class="literal">Hibernate.initialize()</tt> for each collection that will
                        be needed in the web tier (this call must occur before the session is closed)
                        or retrieves the collection eagerly using a Hibernate query with a
                        <tt class="literal">FETCH</tt> clause or a <tt class="literal">FetchMode.JOIN</tt> in
                        <tt class="literal">Criteria</tt>. This is usually easier if you adopt the
                        <span class="emphasis"><em>Command</em></span> pattern instead of a <span class="emphasis"><em>Session Facade</em></span>.
                    </p></li><li><p>
                        You may also attach a previously loaded object to a new <tt class="literal">Session</tt>
                        with <tt class="literal">merge()</tt> or <tt class="literal">lock()</tt> before
                        accessing uninitialized collections (or other proxies). No, Hibernate does not,
                        and certainly <span class="emphasis"><em>should</em></span> not do this automatically, since it 
                        would introduce ad hoc transaction semantics!
                    </p></li></ul></div><p>
                Sometimes you don't want to initialize a large collection, but still need some
                information about it (like its size) or a subset of the data.
            </p><p>
                You can use a collection filter to get the size of a collection without initializing it:
            </p><pre class="programlisting">( (Integer) s.createFilter( collection, "select count(*)" ).list().get(0) ).intValue()</pre><p>
                The <tt class="literal">createFilter()</tt> method is also used to efficiently retrieve subsets
                of a collection without needing to initialize the whole collection:
            </p><pre class="programlisting">s.createFilter( lazyCollection, "").setFirstResult(0).setMaxResults(10).list();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-batch"></a>19.1.5.&nbsp;Using batch fetching</h3></div></div><div></div></div><p>
                Hibernate can make efficient use of batch fetching, that is, Hibernate can load several uninitialized
                proxies if one proxy is accessed (or collections. Batch fetching is an optimization of the lazy select
                fetching strategy. There are two ways you can tune batch fetching: on the class and the collection level.
            </p><p>
                Batch fetching for classes/entities is easier to understand. Imagine you have the following situation
                at runtime: You have 25 <tt class="literal">Cat</tt> instances loaded in a <tt class="literal">Session</tt>, each
                <tt class="literal">Cat</tt> has a reference to its <tt class="literal">owner</tt>, a <tt class="literal">Person</tt>.
                The <tt class="literal">Person</tt> class is mapped with a proxy, <tt class="literal">lazy="true"</tt>. If you now
                iterate through all cats and call <tt class="literal">getOwner()</tt> on each, Hibernate will by default
                execute 25 <tt class="literal">SELECT</tt> statements, to retrieve the proxied owners. You can tune this
                behavior by specifying a <tt class="literal">batch-size</tt> in the mapping of <tt class="literal">Person</tt>:
            </p><pre class="programlisting">&lt;class name="Person" batch-size="10"&gt;...&lt;/class&gt;</pre><p>
                Hibernate will now execute only three queries, the pattern is 10, 10, 5.
            </p><p>
                You may also enable batch fetching of collections. For example, if each <tt class="literal">Person</tt> has
                a lazy collection of <tt class="literal">Cat</tt>s, and 10 persons are currently loaded in the
                <tt class="literal">Sesssion</tt>, iterating through all persons will generate 10 <tt class="literal">SELECT</tt>s,
                one for every call to <tt class="literal">getCats()</tt>. If you enable batch fetching for the
                <tt class="literal">cats</tt> collection in the mapping of <tt class="literal">Person</tt>, Hibernate can pre-fetch
                collections:
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;set name="cats" batch-size="3"&gt;
        ...
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
                With a <tt class="literal">batch-size</tt> of 8, Hibernate will load 3, 3, 3, 1 collections in four
                <tt class="literal">SELECT</tt>s. Again, the value of the attribute depends on the expected number of
                uninitialized collections in a particular <tt class="literal">Session</tt>.
            </p><p>
                Batch fetching of collections is particularly useful if you have a nested tree of items, ie.
                the typical bill-of-materials pattern. (Although a <span class="emphasis"><em>nested set</em></span> or a
                <span class="emphasis"><em>materialized path</em></span> might be a better option for read-mostly trees.)
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-subselect"></a>19.1.6.&nbsp;Using subselect fetching</h3></div></div><div></div></div><p>
                If one lazy collection or single-valued proxy has to be fetched, Hibernate loads all of
                them, re-running the original query in a subselect. This works in the same way as
                batch-fetching, without the piecemeal loading.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-lazyproperties"></a>19.1.7.&nbsp;Using lazy property fetching</h3></div></div><div></div></div><p>
                Hibernate3 supports the lazy fetching of individual properties. This optimization technique
                is also known as <span class="emphasis"><em>fetch groups</em></span>. Please note that this is mostly a
                marketing feature, as in practice, optimizing row reads is much more important than
                optimization of column reads. However, only loading some properties of a class might
                be useful in extreme cases, when legacy tables have hundreds of columns and the data model
                can not be improved.
            </p><p>
                To enable lazy property loading, set the <tt class="literal">lazy</tt> attribute on your
                particular property mappings:
            </p><pre class="programlisting">&lt;class name="Document"&gt;
       &lt;id name="id"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true" length="50"/&gt;
    &lt;property name="summary" not-null="true" length="200" lazy="true"/&gt;
    &lt;property name="text" not-null="true" length="2000" lazy="true"/&gt;
&lt;/class&gt;</pre><p>
                Lazy property loading requires buildtime bytecode instrumentation! If your persistent
                classes are not enhanced, Hibernate will silently ignore lazy property settings and
                fall back to immediate fetching.
            </p><p>
                For bytecode instrumentation, use the following Ant task:
            </p><pre class="programlisting">&lt;target name="instrument" depends="compile"&gt;
    &lt;taskdef name="instrument" classname="org.hibernate.tool.instrument.InstrumentTask"&gt;
        &lt;classpath path="${jar.path}"/&gt;
        &lt;classpath path="${classes.dir}"/&gt;
        &lt;classpath refid="lib.class.path"/&gt;
    &lt;/taskdef&gt;

    &lt;instrument verbose="true"&gt;
        &lt;fileset dir="${testclasses.dir}/org/hibernate/auction/model"&gt;
            &lt;include name="*.class"/&gt;
        &lt;/fileset&gt;
    &lt;/instrument&gt;
&lt;/target&gt;</pre><p>
                A different (better?) way to avoid unnecessary column reads, at least for
                read-only transactions is to use the projection features of HQL or Criteria
                queries. This avoids the need for buildtime bytecode processing and is
                certainly a prefered solution.
            </p><p>
                You may force the usual eager fetching of properties using <tt class="literal">fetch all
                properties</tt> in HQL.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-cache"></a>19.2.&nbsp;The Second Level Cache</h2></div></div><div></div></div><p>
            A Hibernate <tt class="literal">Session</tt> is a transaction-level cache of persistent data. It is
            possible to configure a cluster or JVM-level (<tt class="literal">SessionFactory</tt>-level) cache on 
            a class-by-class and collection-by-collection basis. You may even plug in a clustered cache. Be 
            careful. Caches are never aware of changes made to the persistent store by another application 
            (though they may be configured to regularly expire cached data).
        </p><p>
            By default, Hibernate uses EHCache for JVM-level caching. (JCS support is now deprecated and will 
            be removed in a future version of Hibernate.) You may choose a different implementation by 
            specifying the name of a class that implements <tt class="literal">org.hibernate.cache.CacheProvider</tt>
            using the property <tt class="literal">hibernate.cache.provider_class</tt>.
        </p><div class="table"><a name="cacheproviders"></a><p class="title"><b>Table&nbsp;19.1.&nbsp;Cache Providers</b></p><table summary="Cache Providers" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Cache</th><th align="left">Provider class</th><th align="left">Type</th><th align="left">Cluster Safe</th><th align="left">Query Cache Supported</th></tr></thead><tbody><tr><td align="left">Hashtable (not intended for production use)</td><td align="left"><tt class="literal">org.hibernate.cache.HashtableCacheProvider</tt></td><td align="left">memory</td><td align="left">&nbsp;</td><td align="left">yes</td></tr><tr><td align="left">EHCache</td><td align="left"><tt class="literal">org.hibernate.cache.EhCacheProvider</tt></td><td align="left">memory, disk</td><td align="left">&nbsp;</td><td align="left">yes</td></tr><tr><td align="left">OSCache</td><td align="left"><tt class="literal">org.hibernate.cache.OSCacheProvider</tt></td><td align="left">memory, disk</td><td align="left">&nbsp;</td><td align="left">yes</td></tr><tr><td align="left">SwarmCache</td><td align="left"><tt class="literal">org.hibernate.cache.SwarmCacheProvider</tt></td><td align="left">clustered (ip multicast)</td><td align="left">yes (clustered invalidation)</td><td align="left">&nbsp;</td></tr><tr><td align="left">JBoss TreeCache</td><td align="left"><tt class="literal">org.hibernate.cache.TreeCacheProvider</tt></td><td align="left">clustered (ip multicast), transactional</td><td align="left">yes (replication)</td><td align="left">yes (clock sync req.)</td></tr></tbody></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-mapping"></a>19.2.1.&nbsp;Cache mappings</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;cache&gt;</tt> element of a class or collection mapping has the
                following form:
            </p><div class="programlistingco"><pre class="programlisting">&lt;cache 
    usage="transactional|read-write|nonstrict-read-write|read-only"  <span class="co">(1)</span>
    region="RegionName"                                              <span class="co">(2)</span>
    include="all|non-lazy"                                           <span class="co">(3)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">usage</tt> (required) specifies the caching strategy:
                            <tt class="literal">transactional</tt>,
                            <tt class="literal">read-write</tt>,
                            <tt class="literal">nonstrict-read-write</tt> or
                            <tt class="literal">read-only</tt>
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">region</tt> (optional, defaults to the class or
                            collection role name) specifies the name of the second level cache 
                            region
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">include</tt> (optional, defaults to <tt class="literal">all</tt>) 
                            <tt class="literal">non-lazy</tt> specifies that properties of the entity mapped
                            with <tt class="literal">lazy="true"</tt> may not be cached when attribute-level
                            lazy fetching is enabled
                        </p></td></tr></table></div></div><p>
                Alternatively (preferrably?), you may specify <tt class="literal">&lt;class-cache&gt;</tt> and 
                <tt class="literal">&lt;collection-cache&gt;</tt> elements in <tt class="literal">hibernate.cfg.xml</tt>.
            </p><p>
                The <tt class="literal">usage</tt> attribute specifies a <span class="emphasis"><em>cache concurrency strategy</em></span>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-readonly"></a>19.2.2.&nbsp;Strategy: read only</h3></div></div><div></div></div><p>
                If your application needs to read but never modify instances of a persistent class, a 
                <tt class="literal">read-only</tt> cache may be used. This is the simplest and best performing
                strategy. It's even perfectly safe for use in a cluster.
            </p><pre class="programlisting">&lt;class name="eg.Immutable" mutable="false"&gt;
    &lt;cache usage="read-only"/&gt;
    ....
&lt;/class&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-readwrite"></a>19.2.3.&nbsp;Strategy: read/write</h3></div></div><div></div></div><p>
                If the application needs to update data, a <tt class="literal">read-write</tt> cache might be appropriate. 
                This cache strategy should never be used if serializable transaction isolation level is required. 
                If the cache is used in a JTA environment, you must specify the property 
                <tt class="literal">hibernate.transaction.manager_lookup_class</tt>, naming a strategy for obtaining the 
                JTA <tt class="literal">TransactionManager</tt>. In other environments, you should ensure that the transaction 
                is completed when <tt class="literal">Session.close()</tt> or <tt class="literal">Session.disconnect()</tt> is called. 
                If you wish to use this strategy in a cluster, you should ensure that the underlying cache implementation 
                supports locking. The built-in cache providers do <span class="emphasis"><em>not</em></span>.
            </p><pre class="programlisting">&lt;class name="eg.Cat" .... &gt;
    &lt;cache usage="read-write"/&gt;
    ....
    &lt;set name="kittens" ... &gt;
        &lt;cache usage="read-write"/&gt;
        ....
    &lt;/set&gt;
&lt;/class&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-nonstrict"></a>19.2.4.&nbsp;Strategy: nonstrict read/write</h3></div></div><div></div></div><p>
                If the application only occasionally needs to update data (ie. if it is extremely unlikely that two 
                transactions would try to update the same item simultaneously) and strict transaction isolation is
                not required, a <tt class="literal">nonstrict-read-write</tt> cache might be appropriate. If the cache is 
                used in a JTA environment, you must specify <tt class="literal">hibernate.transaction.manager_lookup_class</tt>. 
                In other environments, you should ensure that the transaction is completed when 
                <tt class="literal">Session.close()</tt> or <tt class="literal">Session.disconnect()</tt> is called.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-transactional"></a>19.2.5.&nbsp;Strategy: transactional</h3></div></div><div></div></div><p>
                The <tt class="literal">transactional</tt> cache strategy provides support for fully transactional cache
                providers such as JBoss TreeCache. Such a cache may only be used in a JTA environment and you must 
                specify <tt class="literal">hibernate.transaction.manager_lookup_class</tt>. 
            </p></div><p>
            None of the cache providers support all of the cache concurrency strategies. The following table shows
            which providers are compatible with which concurrency strategies.
        </p><div class="table"><a name="d0e14110"></a><p class="title"><b>Table&nbsp;19.2.&nbsp;Cache Concurrency Strategy Support</b></p><table summary="Cache Concurrency Strategy Support" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Cache</th><th align="left">read-only</th><th align="left">nonstrict-read-write</th><th align="left">read-write</th><th align="left">transactional</th></tr></thead><tbody><tr><td align="left">Hashtable (not intended for production use)</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left">&nbsp;</td></tr><tr><td align="left">EHCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left">&nbsp;</td></tr><tr><td align="left">OSCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left">&nbsp;</td></tr><tr><td align="left">SwarmCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">&nbsp;</td><td align="left">&nbsp;</td></tr><tr><td align="left">JBoss TreeCache</td><td align="left">yes</td><td align="left">&nbsp;</td><td align="left">&nbsp;</td><td align="left">yes</td></tr></tbody></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-sessioncache"></a>19.3.&nbsp;Managing the caches</h2></div></div><div></div></div><p>
            Whenever you pass an object to <tt class="literal">save()</tt>, <tt class="literal">update()</tt>
            or <tt class="literal">saveOrUpdate()</tt> and whenever you retrieve an object using 
            <tt class="literal">load()</tt>, <tt class="literal">get()</tt>, <tt class="literal">list()</tt>, 
            <tt class="literal">iterate()</tt> or <tt class="literal">scroll()</tt>, that object is added 
            to the internal cache of the <tt class="literal">Session</tt>. 
        </p><p>
            When <tt class="literal">flush()</tt> is subsequently called, the state of that object will 
            be synchronized with the database. If you do not want this synchronization to occur or 
            if you are processing a huge number of objects and need to manage memory efficiently, 
            the <tt class="literal">evict()</tt> method may be used to remove the object and its collections 
            from the first-level cache.
        </p><pre class="programlisting">ScrollableResult cats = sess.createQuery("from Cat as cat").scroll(); //a huge result set
while ( cats.next() ) {
    Cat cat = (Cat) cats.get(0);
    doSomethingWithACat(cat);
    sess.evict(cat);
}</pre><p>
            The <tt class="literal">Session</tt> also provides a <tt class="literal">contains()</tt> method to determine 
            if an instance belongs to the session cache.
        </p><p>
            To completely evict all objects from the session cache, call <tt class="literal">Session.clear()</tt>
        </p><p>
            For the second-level cache, there are methods defined on <tt class="literal">SessionFactory</tt> for 
            evicting the cached state of an instance, entire class, collection instance or entire collection 
            role.
        </p><pre class="programlisting">sessionFactory.evict(Cat.class, catId); //evict a particular Cat
sessionFactory.evict(Cat.class);  //evict all Cats
sessionFactory.evictCollection("Cat.kittens", catId); //evict a particular collection of kittens
sessionFactory.evictCollection("Cat.kittens"); //evict all kitten collections</pre><p>
            The <tt class="literal">CacheMode</tt> controls how a particular session interacts with the second-level
            cache.
        </p><div class="itemizedlist"><ul type="disc"><li><p>
            <tt class="literal">CacheMode.NORMAL</tt> - read items from and write items to the second-level cache
        </p></li><li><p>
            <tt class="literal">CacheMode.GET</tt> - read items from the second-level cache, but don't write to
            the second-level cache except when updating data
        </p></li><li><p>
            <tt class="literal">CacheMode.PUT</tt> - write items to the second-level cache, but don't read from
            the second-level cache
        </p></li><li><p>
            <tt class="literal">CacheMode.REFRESH</tt> - write items to the second-level cache, but don't read from
            the second-level cache, bypass the effect of <tt class="literal">hibernate.cache.use_minimal_puts</tt>, forcing
            a refresh of the second-level cache for all items read from the database
        </p></li></ul></div><p>
            To browse the contents of a second-level or query cache region, use the <tt class="literal">Statistics</tt>
            API:
        </p><pre class="programlisting">Map cacheEntries = sessionFactory.getStatistics()
        .getSecondLevelCacheStatistics(regionName)
        .getEntries();</pre><p>
            You'll need to enable statistics, and, optionally, force Hibernate to keep the cache entries in a
            more human-understandable format:
        </p><pre class="programlisting">hibernate.generate_statistics true
hibernate.cache.use_structured_entries true</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-querycache"></a>19.4.&nbsp;The Query Cache</h2></div></div><div></div></div><p>
            Query result sets may also be cached. This is only useful for queries that are run
            frequently with the same parameters. To use the query cache you must first enable it:
        </p><pre class="programlisting">hibernate.cache.use_query_cache true</pre><p>
            This setting causes the creation of two new cache regions - one holding cached query 
            result sets (<tt class="literal">org.hibernate.cache.StandardQueryCache</tt>), the other 
            holding timestamps of the most recent updates to queryable tables 
            (<tt class="literal">org.hibernate.cache.UpdateTimestampsCache</tt>). Note that the query
            cache does not cache the state of the actual entities in the result set; it caches 
            only identifier values and results of value type. So the query cache should always be
            used in conjunction with the second-level cache.
        </p><p>
            Most queries do not benefit from caching, so by default queries are not cached. To
            enable caching, call <tt class="literal">Query.setCacheable(true)</tt>. This call allows
            the query to look for existing cache results or add its results to the cache when
            it is executed.
        </p><p>
            If you require fine-grained control over query cache expiration policies, you may
            specify a named cache region for a particular query by calling 
            <tt class="literal">Query.setCacheRegion()</tt>.
        </p><pre class="programlisting">List blogs = sess.createQuery("from Blog blog where blog.blogger = :blogger")
    .setEntity("blogger", blogger)
    .setMaxResults(15)
    .setCacheable(true)
    .setCacheRegion("frontpages")
    .list();</pre><p>
            If the query should force a refresh of its query cache region, you should call
            <tt class="literal">Query.setCacheMode(CacheMode.REFRESH)</tt>. This is particularly useful 
            in cases where underlying data may have been updated via a separate process (i.e., 
            not modified through Hibernate) and allows the application to selectively refresh 
            particular query result sets. This is a more efficient alternative to eviction of 
            a query cache region via <tt class="literal">SessionFactory.evictQueries()</tt>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-collections"></a>19.5.&nbsp;Understanding Collection performance</h2></div></div><div></div></div><p>
            We've already spent quite some time talking about collections.
            In this section we will highlight a couple more issues about
            how collections behave at runtime.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-taxonomy"></a>19.5.1.&nbsp;Taxonomy</h3></div></div><div></div></div><p>Hibernate defines three basic kinds of collections:</p><div class="itemizedlist"><ul type="disc"><li><p>collections of values</p></li><li><p>one to many associations</p></li><li><p>many to many associations</p></li></ul></div><p>
                This classification distinguishes the various table and foreign key
                relationships but does not tell us quite everything we need to know
                about the relational model. To fully understand the relational structure
                and performance characteristics, we must also consider the structure of
                the primary key that is used by Hibernate to update or delete collection
                rows. This suggests the following classification:
            </p><div class="itemizedlist"><ul type="disc"><li><p>indexed collections</p></li><li><p>sets</p></li><li><p>bags</p></li></ul></div><p>
                All indexed collections (maps, lists, arrays) have a primary key consisting
                of the <tt class="literal">&lt;key&gt;</tt> and <tt class="literal">&lt;index&gt;</tt>
                columns. In this case collection updates are usually extremely efficient -
                the primary key may be efficiently indexed and a particular row may be efficiently
                located when Hibernate tries to update or delete it.
            </p><p>
                Sets have a primary key consisting of <tt class="literal">&lt;key&gt;</tt> and element
                columns. This may be less efficient for some types of collection element, particularly
                composite elements or large text or binary fields; the database may not be able to index
                a complex primary key as efficently.  On the other hand, for one to many or many to many
                associations, particularly in the case of synthetic identifiers, it is likely to be just
                as efficient. (Side-note: if you want <tt class="literal">SchemaExport</tt> to actually create
                the primary key of a <tt class="literal">&lt;set&gt;</tt> for you, you must declare all columns
                as <tt class="literal">not-null="true"</tt>.)
            </p><p>
                <tt class="literal">&lt;idbag&gt;</tt> mappings define a surrogate key, so they are
                always very efficient to update. In fact, they are the best case.
            </p><p>
                Bags are the worst case. Since a bag permits duplicate element values and has no
                index column, no primary key may be defined. Hibernate has no way of distinguishing
                between duplicate rows. Hibernate resolves this problem by completely removing
                (in a single <tt class="literal">DELETE</tt>) and recreating the collection whenever it
                changes. This might be very inefficient.
            </p><p>
                Note that for a one-to-many association, the "primary key" may not be the physical
                primary key of the database table - but even in this case, the above classification
                is still useful. (It still reflects how Hibernate "locates" individual rows of the
                collection.)
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-mostefficientupdate"></a>19.5.2.&nbsp;Lists, maps, idbags and sets are the most efficient collections to update</h3></div></div><div></div></div><p>
                From the discussion above, it should be clear that indexed collections
                and (usually) sets allow the most efficient operation in terms of adding,
                removing and updating elements.
            </p><p>
                There is, arguably, one more advantage that indexed collections have over sets for
                many to many associations or collections of values. Because of the structure of a
                <tt class="literal">Set</tt>, Hibernate doesn't ever <tt class="literal">UPDATE</tt> a row when
                an element is "changed". Changes to a <tt class="literal">Set</tt> always work via
                <tt class="literal">INSERT</tt> and <tt class="literal">DELETE</tt> (of individual rows). Once
                again, this consideration does not apply to one to many associations.
            </p><p>
                After observing that arrays cannot be lazy, we would conclude that lists, maps and 
                idbags are the most performant (non-inverse) collection types, with sets not far 
                behind. Sets are expected to be the most common kind of collection in Hibernate 
                applications. This is because the "set" semantics are most natural in the relational
                model.
            </p><p>
                However, in well-designed Hibernate domain models, we usually see that most collections
                are in fact one-to-many associations with <tt class="literal">inverse="true"</tt>. For these
                associations, the update is handled by the many-to-one end of the association, and so
                considerations of collection update performance simply do not apply.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-mostefficentinverse"></a>19.5.3.&nbsp;Bags and lists are the most efficient inverse collections</h3></div></div><div></div></div><p>
                Just before you ditch bags forever, there is a particular case in which bags (and also lists)
                are much more performant than sets. For a collection with <tt class="literal">inverse="true"</tt>
                (the standard bidirectional one-to-many relationship idiom, for example) we can add elements
                to a bag or list without needing to initialize (fetch) the bag elements! This is because
                <tt class="literal">Collection.add()</tt> or <tt class="literal">Collection.addAll()</tt> must always
                return true for a bag or <tt class="literal">List</tt> (unlike a <tt class="literal">Set</tt>). This can
                make the following common code much faster.
            </p><pre class="programlisting">Parent p = (Parent) sess.load(Parent.class, id);
Child c = new Child();
c.setParent(p);
p.getChildren().add(c);  //no need to fetch the collection!
sess.flush();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-oneshotdelete"></a>19.5.4.&nbsp;One shot delete</h3></div></div><div></div></div><p>
                Occasionally, deleting collection elements one by one can be extremely inefficient. Hibernate
                isn't completely stupid, so it knows not to do that in the case of an newly-empty collection
                (if you called <tt class="literal">list.clear()</tt>, for example). In this case, Hibernate will
                issue a single <tt class="literal">DELETE</tt> and we are done!
            </p><p>
                Suppose we add a single element to a collection of size twenty and then remove two elements.
                Hibernate will issue one <tt class="literal">INSERT</tt> statement and two <tt class="literal">DELETE</tt>
                statements (unless the collection is a bag). This is certainly desirable.
            </p><p>
                However, suppose that we remove eighteen elements, leaving two and then add thee new elements.
                There are two possible ways to proceed
            </p><div class="itemizedlist"><ul type="disc"><li><p>delete eighteen rows one by one and then insert three rows</p></li><li><p>remove the whole collection (in one SQL <tt class="literal">DELETE</tt>) and insert
                all five current elements (one by one)</p></li></ul></div><p>
                Hibernate isn't smart enough to know that the second option is probably quicker in this case.
                (And it would probably be undesirable for Hibernate to be that smart; such behaviour might
                confuse database triggers, etc.)
            </p><p>
                Fortunately, you can force this behaviour (ie. the second strategy) at any time by discarding
                (ie. dereferencing) the original collection and returning a newly instantiated collection with
                all the current elements. This can be very useful and powerful from time to time.
            </p><p>
                Of course, one-shot-delete does not apply to collections mapped <tt class="literal">inverse="true"</tt>.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-monitoring"></a>19.6.&nbsp;Monitoring performance</h2></div></div><div></div></div><p>
            Optimization is not much use without monitoring and access to performance numbers.
            Hibernate provides a full range of figures about its internal operations.
            Statistics in Hibernate are available per <tt class="literal">SessionFactory</tt>.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-monitoring-sf"></a>19.6.1.&nbsp;Monitoring a SessionFactory</h3></div></div><div></div></div><p>
                You can access <tt class="literal">SessionFactory</tt> metrics in two ways.
                Your first option is to call <tt class="literal">sessionFactory.getStatistics()</tt> and
                read or display the <tt class="literal">Statistics</tt> yourself.
            </p><p>
                Hibernate can also use JMX to publish metrics if you enable the
                <tt class="literal">StatisticsService</tt> MBean. You may enable a single MBean for all your
                <tt class="literal">SessionFactory</tt> or one per factory. See the following code for
                minimalistic configuration examples:
            </p><pre class="programlisting">// MBean service registration for a specific SessionFactory
Hashtable tb = new Hashtable();
tb.put("type", "statistics");
tb.put("sessionFactory", "myFinancialApp");
ObjectName on = new ObjectName("hibernate", tb); // MBean object name

StatisticsService stats = new StatisticsService(); // MBean implementation
stats.setSessionFactory(sessionFactory); // Bind the stats to a SessionFactory
server.registerMBean(stats, on); // Register the Mbean on the server</pre><pre class="programlisting">// MBean service registration for all SessionFactory's
Hashtable tb = new Hashtable();
tb.put("type", "statistics");
tb.put("sessionFactory", "all");
ObjectName on = new ObjectName("hibernate", tb); // MBean object name

StatisticsService stats = new StatisticsService(); // MBean implementation
server.registerMBean(stats, on); // Register the MBean on the server</pre><p>
                TODO: This doesn't make sense: In the first case, we retrieve and use the MBean directly. In the second one, we must give
                the JNDI name in which the session factory is held before using it. Use
                <tt class="literal">hibernateStatsBean.setSessionFactoryJNDIName("my/JNDI/Name")</tt>
            </p><p>
                You can (de)activate the monitoring for a <tt class="literal">SessionFactory</tt>
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        at configuration time, set <tt class="literal">hibernate.generate_statistics</tt> to <tt class="literal">false</tt>
                    </p></li></ul></div><div class="itemizedlist"><ul type="disc"><li><p>
                        at runtime: <tt class="literal">sf.getStatistics().setStatisticsEnabled(true)</tt>
                        or <tt class="literal">hibernateStatsBean.setStatisticsEnabled(true)</tt>
                    </p></li></ul></div><p>
                Statistics can be reset programatically using the <tt class="literal">clear()</tt> method.
                A summary can be sent to a logger (info level) using the <tt class="literal">logSummary()</tt>
                method.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-monitoring-metrics"></a>19.6.2.&nbsp;Metrics</h3></div></div><div></div></div><p>
                Hibernate provides a number of metrics, from very basic to the specialized information
                only relevant in certain scenarios. All available counters are described in the
                <tt class="literal">Statistics</tt> interface API, in three categories:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        Metrics related to the general <tt class="literal">Session</tt> usage, such as
                        number of open sessions, retrieved JDBC connections, etc.
                    </p></li><li><p>
                        Metrics related to he entities, collections, queries, and caches as a
                        whole (aka global metrics),
                    </p></li><li><p>
                        Detailed metrics related to a particular entity, collection, query or
                        cache region.
                    </p></li></ul></div><p>
                For exampl,e you can check the cache hit, miss, and put ratio of entities, collections
                and queries, and the average time a query needs. Beware that the number of milliseconds
                is subject to approximation in Java. Hibernate is tied to the JVM precision, on some
                platforms this might even only be accurate to 10 seconds.
            </p><p>
                Simple getters are used to access the global metrics (i.e. not tied to a particular entity,
                collection, cache region, etc.). You can access the metrics of a particular entity, collection
                or cache region through its name, and through its HQL or SQL representation for queries. Please
                refer to the <tt class="literal">Statistics</tt>, <tt class="literal">EntityStatistics</tt>,
                <tt class="literal">CollectionStatistics</tt>, <tt class="literal">SecondLevelCacheStatistics</tt>,
                and <tt class="literal">QueryStatistics</tt> API Javadoc for more information. The following
                code shows a simple example:
            </p><pre class="programlisting">Statistics stats = HibernateUtil.sessionFactory.getStatistics();

double queryCacheHitCount  = stats.getQueryCacheHitCount();
double queryCacheMissCount = stats.getQueryCacheMissCount();
double queryCacheHitRatio =
  queryCacheHitCount / (queryCacheHitCount + queryCacheMissCount);

log.info("Query Hit ratio:" + queryCacheHitRatio);

EntityStatistics entityStats =
  stats.getEntityStatistics( Cat.class.getName() );
long changes =
        entityStats.getInsertCount()
        + entityStats.getUpdateCount()
        + entityStats.getDeleteCount();
log.info(Cat.class.getName() + " changed " + changes + "times"  );</pre><p>
                To work on all entities, collections, queries and region caches, you can retrieve
                the list of names of entities, collections, queries and region caches with the
                following methods: <tt class="literal">getQueries()</tt>, <tt class="literal">getEntityNames()</tt>,
                <tt class="literal">getCollectionRoleNames()</tt>, and
                <tt class="literal">getSecondLevelCacheRegionNames()</tt>.
            </p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="toolsetguide"></a>Chapter&nbsp;20.&nbsp;Toolset Guide</h2></div></div><div></div></div><p>
        Roundtrip engineering with Hibernate is possible using a set of Eclipse plugins,
        commandline tools, as well as Ant tasks.
    </p><p>
        The <span class="emphasis"><em>Hibernate Tools</em></span> currently include plugins for the Eclipse
        IDE as well as Ant tasks for reverse engineering of existing databases:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
            <span class="emphasis"><em>Mapping Editor:</em></span> An editor for Hibernate XML mapping files,
            supporting auto-completion and syntax highlighting. It also supports semantic
            auto-completion for class names and property/field names, making it much more versatile than a normal XML editor.
        </p></li><li><p>
            <span class="emphasis"><em>Console:</em></span> The console is a new view in Eclipse. In addition to
            a tree overview of your console configurations, you also get an interactive view
            of your persistent classes and their relationships. The console allows you to
            execute HQL queries against your database and browse the result directly in
            Eclipse.
        </p></li><li><p>
            <span class="emphasis"><em>Development Wizards:</em></span> Several wizards are provided with the
            Hibernate Eclipse tools; you can use a wizard to quickly generate Hibernate configuration
            (cfg.xml) files, or you may even completely reverse engineer an existing database schema
            into POJO source files and Hibernate mapping files. The reverse engineering wizard
            supports customizable templates.
        </p></li><li><p>
            <span class="emphasis"><em>Ant Tasks:</em></span>
        </p></li></ul></div><p>
        Please refer to the <span class="emphasis"><em>Hibernate Tools</em></span> package and it's documentation
        for more information.
    </p><p>
        However, the Hibernate main package comes bundled with an integrated tool (it can even
        be used from "inside" Hibernate on-the-fly): <span class="emphasis"><em>SchemaExport</em></span> aka
        <tt class="literal">hbm2ddl</tt>.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="toolsetguide-s1"></a>20.1.&nbsp;Automatic schema generation</h2></div></div><div></div></div><p>
            DDL may be generated from your mapping files by a Hibernate utility. The generated
            schema includes referential integrity constraints (primary and foreign keys) for
            entity and collection tables. Tables and sequences are also created for mapped
            identifier generators.
        </p><p>
            You <span class="emphasis"><em>must</em></span> specify a SQL <tt class="literal">Dialect</tt> via the 
            <tt class="literal">hibernate.dialect</tt> property when using this tool, as DDL
            is highly vendor specific.
        </p><p>
            First, customize your mapping files to improve the generated schema.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-2"></a>20.1.1.&nbsp;Customizing the schema</h3></div></div><div></div></div><p>
                Many Hibernate mapping elements define optional attributes named <tt class="literal">length</tt>,

                <tt class="literal">precision</tt> and <tt class="literal">scale</tt>. You may set the length, precision 

                and scale of a column with this attribute. 

                
            </p><pre class="programlisting">&lt;property name="zip" length="5"/&gt;</pre><pre class="programlisting">&lt;property name="balance" precision="12" scale="2"/&gt;</pre><p>
                Some tags also accept a <tt class="literal">not-null</tt> attribute (for generating a 

                <tt class="literal">NOT NULL</tt> constraint on table columns) and a <tt class="literal">unique</tt> 

                attribute (for generating <tt class="literal">UNIQUE</tt> constraint on table columns).
            </p><pre class="programlisting">&lt;many-to-one name="bar" column="barId" not-null="true"/&gt;</pre><pre class="programlisting">&lt;element column="serialNumber" type="long" not-null="true" unique="true"/&gt;</pre><p>
                A <tt class="literal">unique-key</tt> attribute may be used to group columns in

                a single unique key constraint. Currently, the specified value of the 

                <tt class="literal">unique-key</tt> attribute is <span class="emphasis"><em>not</em></span> used 

                to name the constraint in the generated DDL, only to group the columns in 

                the mapping file.
            </p><pre class="programlisting">&lt;many-to-one name="org" column="orgId" unique-key="OrgEmployeeId"/&gt;

&lt;property name="employeeId" unique-key="OrgEmployee"/&gt;</pre><p>

                An <tt class="literal">index</tt> attribute specifies the name of an index that

                will be created using the mapped column or columns. Multiple columns may be 

                grouped into the same index, simply by specifying the same index name. 

            </p><pre class="programlisting">&lt;property name="lastName" index="CustName"/&gt;

&lt;property name="firstName" index="CustName"/&gt;</pre><p>

                A <tt class="literal">foreign-key</tt> attribute may be used to override the name 

                of any generated foreign key constraint.

            </p><pre class="programlisting">&lt;many-to-one name="bar" column="barId" foreign-key="FKFooBar"/&gt;</pre><p>
                Many mapping elements also accept a child <tt class="literal">&lt;column&gt;</tt> element. 

                This is particularly useful for mapping multi-column types:
            </p><pre class="programlisting">&lt;property name="name" type="my.customtypes.Name"/&gt;
    &lt;column name="last" not-null="true" index="bar_idx" length="30"/&gt;
    &lt;column name="first" not-null="true" index="bar_idx" length="20"/&gt;
    &lt;column name="initial"/&gt;
&lt;/property&gt;</pre><p>

                The <tt class="literal">default</tt> attribute lets you specify a default value for

                a column (you should assign the same value to the mapped property before

                saving a new instance of the mapped class).

            </p><pre class="programlisting">&lt;property name="credits" type="integer" insert="false"&gt;

    &lt;column name="credits" default="10"/&gt;

&lt;/property&gt;</pre><pre class="programlisting">&lt;version name="version" type="integer" insert="false"&gt;

    &lt;column name="version" default="0"/&gt;

&lt;/property&gt;</pre><p>
                The <tt class="literal">sql-type</tt> attribute allows the user to override the default 

                mapping of a Hibernate type to SQL datatype.
            </p><pre class="programlisting">&lt;property name="balance" type="float"&gt;

    &lt;column name="balance" sql-type="decimal(13,3)"/&gt;

&lt;/property&gt;</pre><p>
                The <tt class="literal">check</tt> attribute allows you to specify a check constraint.
            </p><pre class="programlisting">&lt;property name="foo" type="integer"&gt;
    &lt;column name="foo" check="foo &gt; 10"/&gt;
&lt;/property&gt;</pre><pre class="programlisting">&lt;class name="Foo" table="foos" check="bar &lt; 100.0"&gt;
    ...
    &lt;property name="bar" type="float"/&gt;
&lt;/class&gt;</pre><div class="table"><a name="schemattributes-summary"></a><p class="title"><b>Table&nbsp;20.1.&nbsp;Summary</b></p><table summary="Summary" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Attribute</th><th>Values</th><th>Interpretation</th></tr></thead><tbody><tr><td><tt class="literal">length</tt></td><td>number</td><td>column length</td></tr><tr><td><tt class="literal">precision</tt></td><td>number</td><td>column decimal precision</td></tr><tr><td><tt class="literal">scale</tt></td><td>number</td><td>column decimal scale</td></tr><tr><td><tt class="literal">not-null</tt></td><td><tt class="literal">true|false</tt></td><td>specfies that the column should be non-nullable</td></tr><tr><td><tt class="literal">unique</tt></td><td><tt class="literal">true|false</tt></td><td>specifies that the column should have a unique constraint</td></tr><tr><td><tt class="literal">index</tt></td><td><tt class="literal">index_name</tt></td><td>specifies the name of a (multi-column) index</td></tr><tr><td><tt class="literal">unique-key</tt></td><td><tt class="literal">unique_key_name</tt></td><td>specifies the name of a multi-column unique constraint</td></tr><tr><td><tt class="literal">foreign-key</tt></td><td><tt class="literal">foreign_key_name</tt></td><td>
                                specifies the name of the foreign key constraint generated
                                for an association, for a <tt class="literal">&lt;one-to-one&gt;</tt>, 

                                <tt class="literal">&lt;many-to-one&gt;</tt>, <tt class="literal">&lt;key&gt;</tt>, 

                                or <tt class="literal">&lt;many-to-many&gt;</tt> mapping element. Note that
                                <tt class="literal">inverse="true"</tt> sides will not be considered
                                by <tt class="literal">SchemaExport</tt>.
                            </td></tr><tr><td><tt class="literal">sql-type</tt></td><td><tt class="literal">SQL column type</tt></td><td>
                                overrides the default column type (attribute of 
                                <tt class="literal">&lt;column&gt;</tt> element only)
                            </td></tr><tr><td><tt class="literal">default</tt></td><td>SQL expression</td><td>

                                specify a default value for the column

                            </td></tr><tr><td><tt class="literal">check</tt></td><td>SQL expression</td><td>
                                create an SQL check constraint on either column or table
                            </td></tr></tbody></table></div><p>
                The <tt class="literal">&lt;comment&gt;</tt> element allows you to specify comments
                for the generated schema.
            </p><pre class="programlisting">&lt;class name="Customer" table="CurCust"&gt;
    &lt;comment&gt;Current customers only&lt;/comment&gt;
    ...
&lt;/class&gt;</pre><pre class="programlisting">&lt;property name="balance"&gt;
    &lt;column name="bal"&gt;
        &lt;comment&gt;Balance in USD&lt;/comment&gt;
    &lt;/column&gt;
&lt;/property&gt;</pre><p>
                This results in a <tt class="literal">comment on table</tt> or 
                <tt class="literal">comment on column</tt> statement in the generated
                DDL (where supported).
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-3"></a>20.1.2.&nbsp;Running the tool</h3></div></div><div></div></div><p>
                The <tt class="literal">SchemaExport</tt> tool writes a DDL script to standard out and/or
                executes the DDL statements.
            </p><p>
                <tt class="literal">java -cp </tt><span class="emphasis"><em>hibernate_classpaths</em></span>
                <tt class="literal">org.hibernate.tool.hbm2ddl.SchemaExport</tt> <span class="emphasis"><em>options mapping_files</em></span>
            </p><div class="table"><a name="d0e14936"></a><p class="title"><b>Table&nbsp;20.2.&nbsp;<tt class="literal">SchemaExport</tt> Command Line Options</b></p><table summary="SchemaExport Command Line Options" border="1"><colgroup><col><col></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">--quiet</tt></td><td>don't output the script to stdout</td></tr><tr><td><tt class="literal">--drop</tt></td><td>only drop the tables</td></tr><tr><td><tt class="literal">--create</tt></td><td>only create the tables</td></tr><tr><td><tt class="literal">--text</tt></td><td>don't export to the database</td></tr><tr><td><tt class="literal">--output=my_schema.ddl</tt></td><td>output the ddl script to a file</td></tr><tr><td><tt class="literal">--naming=eg.MyNamingStrategy</tt></td><td>select a <tt class="literal">NamingStrategy</tt></td></tr><tr><td><tt class="literal">--config=hibernate.cfg.xml</tt></td><td>read Hibernate configuration from an XML file</td></tr><tr><td><tt class="literal">--properties=hibernate.properties</tt></td><td>read database properties from a file</td></tr><tr><td><tt class="literal">--format</tt></td><td>format the generated SQL nicely in the script</td></tr><tr><td><tt class="literal">--delimiter=;</tt></td><td>set an end of line delimiter for the script</td></tr></tbody></table></div><p>
                You may even embed <tt class="literal">SchemaExport</tt> in your application:
            </p><pre class="programlisting">Configuration cfg = ....;
new SchemaExport(cfg).create(false, true);</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-4"></a>20.1.3.&nbsp;Properties</h3></div></div><div></div></div><p>
                Database properties may be specified
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>as system properties with <tt class="literal">-D</tt><span class="emphasis"><em>&lt;property&gt;</em></span></p></li><li><p>in <tt class="literal">hibernate.properties</tt></p></li><li><p>in a named properties file with <tt class="literal">--properties</tt></p></li></ul></div><p>
                The needed properties are:
            </p><div class="table"><a name="d0e15045"></a><p class="title"><b>Table&nbsp;20.3.&nbsp;SchemaExport Connection Properties</b></p><table summary="SchemaExport Connection Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property Name</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.connection.driver_class</tt></td><td>jdbc driver class</td></tr><tr><td><tt class="literal">hibernate.connection.url</tt></td><td>jdbc url</td></tr><tr><td><tt class="literal">hibernate.connection.username</tt></td><td>database user</td></tr><tr><td><tt class="literal">hibernate.connection.password</tt></td><td>user password</td></tr><tr><td><tt class="literal">hibernate.dialect</tt></td><td>dialect</td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-5"></a>20.1.4.&nbsp;Using Ant</h3></div></div><div></div></div><p>
                You can call <tt class="literal">SchemaExport</tt> from your Ant build script:
            </p><pre class="programlisting">&lt;target name="schemaexport"&gt;
    &lt;taskdef name="schemaexport"
        classname="org.hibernate.tool.hbm2ddl.SchemaExportTask"
        classpathref="class.path"/&gt;
    
    &lt;schemaexport
        properties="hibernate.properties"
        quiet="no"
        text="no"
        drop="no"
        delimiter=";"
        output="schema-export.sql"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemaexport&gt;
&lt;/target&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-6"></a>20.1.5.&nbsp;Incremental schema updates</h3></div></div><div></div></div><p>
                The <tt class="literal">SchemaUpdate</tt> tool will update an existing schema with "incremental" changes.
                Note that <tt class="literal">SchemaUpdate</tt> depends heavily upon the JDBC metadata API, so it will
                not work with all JDBC drivers.
            </p><p>
                <tt class="literal">java -cp </tt><span class="emphasis"><em>hibernate_classpaths</em></span>
                <tt class="literal">org.hibernate.tool.hbm2ddl.SchemaUpdate</tt> <span class="emphasis"><em>options mapping_files</em></span>
            </p><div class="table"><a name="d0e15122"></a><p class="title"><b>Table&nbsp;20.4.&nbsp;<tt class="literal">SchemaUpdate</tt> Command Line Options</b></p><table summary="SchemaUpdate Command Line Options" border="1"><colgroup><col><col></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">--quiet</tt></td><td>don't output the script to stdout</td></tr><tr><td><tt class="literal">--text</tt></td><td>don't export the script to the database</td></tr><tr><td><tt class="literal">--naming=eg.MyNamingStrategy</tt></td><td>select a <tt class="literal">NamingStrategy</tt></td></tr><tr><td><tt class="literal">--properties=hibernate.properties</tt></td><td>read database properties from a file</td></tr><tr><td><tt class="literal">--config=hibernate.cfg.xml</tt></td><td>specify a <tt class="literal">.cfg.xml</tt> file</td></tr></tbody></table></div><p>
                You may embed <tt class="literal">SchemaUpdate</tt> in your application:
            </p><pre class="programlisting">Configuration cfg = ....;
new SchemaUpdate(cfg).execute(false);</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-7"></a>20.1.6.&nbsp;Using Ant for incremental schema updates</h3></div></div><div></div></div><p>
                You can call <tt class="literal">SchemaUpdate</tt> from the Ant script:
            </p><pre class="programlisting">&lt;target name="schemaupdate"&gt;
    &lt;taskdef name="schemaupdate"
        classname="org.hibernate.tool.hbm2ddl.SchemaUpdateTask"
        classpathref="class.path"/&gt;
    
    &lt;schemaupdate
        properties="hibernate.properties"
        quiet="no"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemaupdate&gt;
&lt;/target&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-8"></a>20.1.7.&nbsp;Schema validation</h3></div></div><div></div></div><p>

                The <tt class="literal">SchemaValidator</tt> tool will validate that the existing database schema "matches"

                your mapping documents. Note that <tt class="literal">SchemaValidator</tt> depends heavily upon the JDBC 

                metadata API, so it will not work with all JDBC drivers. This tool is extremely useful for testing.

            </p><p>

                <tt class="literal">java -cp </tt><span class="emphasis"><em>hibernate_classpaths</em></span>

                <tt class="literal">org.hibernate.tool.hbm2ddl.SchemaValidator</tt> <span class="emphasis"><em>options mapping_files</em></span>

            </p><div class="table"><a name="d0e15213"></a><p class="title"><b>Table&nbsp;20.5.&nbsp;<tt class="literal">SchemaValidator</tt> Command Line Options</b></p><table summary="SchemaValidator Command Line Options" border="1"><colgroup><col><col></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">--naming=eg.MyNamingStrategy</tt></td><td>select a <tt class="literal">NamingStrategy</tt></td></tr><tr><td><tt class="literal">--properties=hibernate.properties</tt></td><td>read database properties from a file</td></tr><tr><td><tt class="literal">--config=hibernate.cfg.xml</tt></td><td>specify a <tt class="literal">.cfg.xml</tt> file</td></tr></tbody></table></div><p>

                You may embed <tt class="literal">SchemaValidator</tt> in your application:

            </p><pre class="programlisting">Configuration cfg = ....;

new SchemaValidator(cfg).validate();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-9"></a>20.1.8.&nbsp;Using Ant for schema validation</h3></div></div><div></div></div><p>

                You can call <tt class="literal">SchemaValidator</tt> from the Ant script:

            </p><pre class="programlisting">&lt;target name="schemavalidate"&gt;

    &lt;taskdef name="schemavalidator"

        classname="org.hibernate.tool.hbm2ddl.SchemaValidatorTask"

        classpathref="class.path"/&gt;

    

    &lt;schemavalidator

        properties="hibernate.properties"&gt;

        &lt;fileset dir="src"&gt;

            &lt;include name="**/*.hbm.xml"/&gt;

        &lt;/fileset&gt;

    &lt;/schemaupdate&gt;

&lt;/target&gt;</pre></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="example-parentchild"></a>Chapter&nbsp;21.&nbsp;Example: Parent/Child</h2></div></div><div></div></div><p>
        One of the very first things that new users try to do with Hibernate is to model a parent / child type 
        relationship. There are two different approaches to this. For various reasons the most convenient 
        approach, especially for new users, is to model both <tt class="literal">Parent</tt> and <tt class="literal">Child</tt> 
        as entity classes with a <tt class="literal">&lt;one-to-many&gt;</tt> association from <tt class="literal">Parent</tt> 
        to <tt class="literal">Child</tt>. (The alternative approach is to declare the <tt class="literal">Child</tt> as a 
        <tt class="literal">&lt;composite-element&gt;</tt>.) Now, it turns out that default semantics of a one to many 
        association (in Hibernate) are much less close to the usual semantics of a parent / child relationship than 
        those of a composite element mapping. We will explain how to use a <span class="emphasis"><em>bidirectional one to many 
        association with cascades</em></span> to model a parent / child relationship efficiently and elegantly. 
        It's not at all difficult!
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-collections"></a>21.1.&nbsp;A note about collections</h2></div></div><div></div></div><p>
            Hibernate collections are considered to be a logical part of their owning entity; never of the
            contained entities. This is a crucial distinction! It has the following consequences:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                When we remove / add an object from / to a collection, the version number of the collection owner
                is incremented.
            </p></li><li><p>
                If an object that was removed from a collection is an instance of a value type (eg, a composite
                element), that object will cease to be persistent and its state will be completely removed from
                the database. Likewise, adding a value type instance to the collection will cause its state to be
                immediately persistent.
            </p></li><li><p>
                On the other hand, if an entity is removed from a collection (a one-to-many or many-to-many
                association), it will not be deleted, by default. This behaviour is completely consistent - a
                change to the internal state of another entity should not cause the associated entity to vanish!
                Likewise, adding an entity to a collection does not cause that entity to become persistent, by
                default.
            </p></li></ul></div><p>
            Instead, the default behaviour is that adding an entity to a collection merely creates a link between
            the two entities, while removing it removes the link. This is very appropriate for all sorts of cases.
            Where it is not appropriate at all is the case of a parent / child relationship, where the life of the
            child is bound to the lifecycle of the parent.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-bidir"></a>21.2.&nbsp;Bidirectional one-to-many</h2></div></div><div></div></div><p>
            Suppose we start with a simple <tt class="literal">&lt;one-to-many&gt;</tt> association from
            <tt class="literal">Parent</tt> to <tt class="literal">Child</tt>.
        </p><pre class="programlisting">&lt;set name="children"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
            If we were to execute the following code
        </p><pre class="programlisting">Parent p = .....;
Child c = new Child();
p.getChildren().add(c);
session.save(c);
session.flush();</pre><p>
            Hibernate would issue two SQL statements:
        </p><div class="itemizedlist"><ul type="disc"><li><p>an <tt class="literal">INSERT</tt> to create the record for <tt class="literal">c</tt></p></li><li><p>
                an <tt class="literal">UPDATE</tt> to create the link from <tt class="literal">p</tt> to
                <tt class="literal">c</tt>
            </p></li></ul></div><p>
            This is not only inefficient, but also violates any <tt class="literal">NOT NULL</tt> constraint on the
            <tt class="literal">parent_id</tt> column. We can fix the nullability constraint violation by specifying
            <tt class="literal">not-null="true"</tt> in the collection mapping:
        </p><pre class="programlisting">&lt;set name="children"&gt;
    &lt;key column="parent_id" not-null="true"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
        	However, this is not the recommended solution.
       	</p><p>
            The underlying cause of this behaviour is that the link (the foreign key <tt class="literal">parent_id</tt>) 
            from <tt class="literal">p</tt> to <tt class="literal">c</tt> is not considered part of the state of the 
            <tt class="literal">Child</tt> object and is therefore not created in the <tt class="literal">INSERT</tt>. So the 
            solution is to make the link part of the <tt class="literal">Child</tt> mapping.
        </p><pre class="programlisting">&lt;many-to-one name="parent" column="parent_id" not-null="true"/&gt;</pre><p>
            (We also need to add the <tt class="literal">parent</tt> property to the <tt class="literal">Child</tt> class.)
        </p><p>
            Now that the <tt class="literal">Child</tt> entity is managing the state of the link, we tell the collection 
            not to update the link. We use the <tt class="literal">inverse</tt> attribute.
        </p><pre class="programlisting">&lt;set name="children" inverse="true"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
            The following code would be used to add a new <tt class="literal">Child</tt>
        </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
c.setParent(p);
p.getChildren().add(c);
session.save(c);
session.flush();</pre><p>
            And now, only one SQL <tt class="literal">INSERT</tt> would be issued!
        </p><p>
            To tighten things up a bit, we could create an <tt class="literal">addChild()</tt> method of
            <tt class="literal">Parent</tt>.
        </p><pre class="programlisting">public void addChild(Child c) {
    c.setParent(this);
    children.add(c);
}</pre><p>
            Now, the code to add a <tt class="literal">Child</tt> looks like
        </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
p.addChild(c);
session.save(c);
session.flush();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-cascades"></a>21.3.&nbsp;Cascading lifecycle</h2></div></div><div></div></div><p>
             The explicit call to <tt class="literal">save()</tt> is still annoying. We will address this by
             using cascades.
         </p><pre class="programlisting">&lt;set name="children" inverse="true" cascade="all"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
             This simplifies the code above to
         </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
p.addChild(c);
session.flush();</pre><p>
             Similarly, we don't need to iterate over the children when saving or deleting a <tt class="literal">Parent</tt>.
             The following removes <tt class="literal">p</tt> and all its children from the database.
         </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
session.delete(p);
session.flush();</pre><p>
             However, this code
         </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = (Child) p.getChildren().iterator().next();
p.getChildren().remove(c);
c.setParent(null);
session.flush();</pre><p>
             will not remove <tt class="literal">c</tt> from the database; it will ony remove the link to <tt class="literal">p</tt>
             (and cause a <tt class="literal">NOT NULL</tt> constraint violation, in this case). You need to explicitly
             <tt class="literal">delete()</tt> the <tt class="literal">Child</tt>.
         </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = (Child) p.getChildren().iterator().next();
p.getChildren().remove(c);
session.delete(c);
session.flush();</pre><p>
             Now, in our case, a <tt class="literal">Child</tt> can't really exist without its parent. So if we remove
             a <tt class="literal">Child</tt> from the collection, we really do want it to be deleted. For this, we must
             use <tt class="literal">cascade="all-delete-orphan"</tt>.
         </p><pre class="programlisting">&lt;set name="children" inverse="true" cascade="all-delete-orphan"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
             Note: even though the collection mapping specifies <tt class="literal">inverse="true"</tt>, cascades are 
             still processed by iterating the collection elements. So if you require that an object be saved, 
             deleted or updated by cascade, you must add it to the collection. It is not enough to simply call
             <tt class="literal">setParent()</tt>.
         </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-update"></a>21.4.&nbsp;Cascades and <tt class="literal">unsaved-value</tt></h2></div></div><div></div></div><p>
             Suppose we loaded up a <tt class="literal">Parent</tt> in one <tt class="literal">Session</tt>, made some changes 
             in a UI action and wish to persist these changes in a new session by calling <tt class="literal">update()</tt>. 
             The <tt class="literal">Parent</tt> will contain a collection of childen and, since cascading update is enabled, 
             Hibernate needs to know which children are newly instantiated and which represent existing rows in the 
             database. Lets assume that both <tt class="literal">Parent</tt> and <tt class="literal">Child</tt> have genenerated
             identifier properties of type <tt class="literal">Long</tt>. Hibernate will use the identifier and 
             version/timestamp property value to determine which of the children are new. (See
             <a href="#objectstate-saveorupdate" title="10.7.&nbsp;Automatic state detection">Section&nbsp;10.7, &#8220;Automatic state detection&#8221;</a>.) <span class="emphasis"><em>In Hibernate3, it is no longer necessary to specify
             an <tt class="literal">unsaved-value</tt> explicitly.</em></span>
         </p><p>
             The following code will update <tt class="literal">parent</tt> and <tt class="literal">child</tt> and insert 
             <tt class="literal">newChild</tt>.
         </p><pre class="programlisting">//parent and child were both loaded in a previous session
parent.addChild(child);
Child newChild = new Child();
parent.addChild(newChild);
session.update(parent);
session.flush();</pre><p>
             Well, that's all very well for the case of a generated identifier, but what about assigned identifiers
             and composite identifiers? This is more difficult, since Hibernate can't use the identifier property to
             distinguish between a newly instantiated object (with an identifier assigned by the user) and an 
             object loaded in a previous session. In this case, Hibernate will either use the timestamp or version 
             property, or will actually query the second-level cache or, worst case, the database, to see if the 
             row exists.
         </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-conclusion"></a>21.5.&nbsp;Conclusion</h2></div></div><div></div></div><p>
             There is quite a bit to digest here and it might look confusing first time around. However, in practice, 
             it all works out very nicely. Most Hibernate applications use the parent / child pattern in many places.
         </p><p>
             We mentioned an alternative in the first paragraph. None of the above issues exist in the case of
             <tt class="literal">&lt;composite-element&gt;</tt> mappings, which have exactly the semantics of a parent / child
             relationship. Unfortunately, there are two big limitations to composite element classes: composite elements 
             may not own collections, and they should not be the child of any entity other than the unique parent.
         </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="example-weblog"></a>Chapter&nbsp;22.&nbsp;Example: Weblog Application</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-weblog-classes"></a>22.1.&nbsp;Persistent Classes</h2></div></div><div></div></div><p>
            The persistent classes represent a weblog, and an item posted
            in a weblog. They are to be modelled as a standard parent/child
            relationship, but we will use an ordered bag, instead of a set.
        </p><pre class="programlisting">package eg;

import java.util.List;

public class Blog {
    private Long _id;
    private String _name;
    private List _items;

    public Long getId() {
        return _id;
    }
    public List getItems() {
        return _items;
    }
    public String getName() {
        return _name;
    }
    public void setId(Long long1) {
        _id = long1;
    }
    public void setItems(List list) {
        _items = list;
    }
    public void setName(String string) {
        _name = string;
    }
}</pre><pre class="programlisting">package eg;

import java.text.DateFormat;
import java.util.Calendar;

public class BlogItem {
    private Long _id;
    private Calendar _datetime;
    private String _text;
    private String _title;
    private Blog _blog;

    public Blog getBlog() {
        return _blog;
    }
    public Calendar getDatetime() {
        return _datetime;
    }
    public Long getId() {
        return _id;
    }
    public String getText() {
        return _text;
    }
    public String getTitle() {
        return _title;
    }
    public void setBlog(Blog blog) {
        _blog = blog;
    }
    public void setDatetime(Calendar calendar) {
        _datetime = calendar;
    }
    public void setId(Long long1) {
        _id = long1;
    }
    public void setText(String string) {
        _text = string;
    }
    public void setTitle(String string) {
        _title = string;
    }
}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-weblog-mappings"></a>22.2.&nbsp;Hibernate Mappings</h2></div></div><div></div></div><p>
            The XML mappings should now be quite straightforward.
        </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

    &lt;class
        name="Blog"
        table="BLOGS"&gt;

        &lt;id
            name="id"
            column="BLOG_ID"&gt;

            &lt;generator class="native"/&gt;

        &lt;/id&gt;

        &lt;property
            name="name"
            column="NAME"
            not-null="true"
            unique="true"/&gt;

        &lt;bag
            name="items"
            inverse="true"
            order-by="DATE_TIME"
            cascade="all"&gt;

            &lt;key column="BLOG_ID"/&gt;
            &lt;one-to-many class="BlogItem"/&gt;

        &lt;/bag&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

    &lt;class
        name="BlogItem"
        table="BLOG_ITEMS"
        dynamic-update="true"&gt;

        &lt;id
            name="id"
            column="BLOG_ITEM_ID"&gt;

            &lt;generator class="native"/&gt;

        &lt;/id&gt;

        &lt;property
            name="title"
            column="TITLE"
            not-null="true"/&gt;

        &lt;property
            name="text"
            column="TEXT"
            not-null="true"/&gt;

        &lt;property
            name="datetime"
            column="DATE_TIME"
            not-null="true"/&gt;

        &lt;many-to-one
            name="blog"
            column="BLOG_ID"
            not-null="true"/&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-weblog-code"></a>22.3.&nbsp;Hibernate Code</h2></div></div><div></div></div><p>
            The following class demonstrates some of the kinds of things
            we can do with these classes, using Hibernate.
        </p><pre class="programlisting">package eg;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Iterator;
import java.util.List;

import org.hibernate.HibernateException;
import org.hibernate.Query;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;
import org.hibernate.tool.hbm2ddl.SchemaExport;

public class BlogMain {
    
    private SessionFactory _sessions;
    
    public void configure() throws HibernateException {
        _sessions = new Configuration()
            .addClass(Blog.class)
            .addClass(BlogItem.class)
            .buildSessionFactory();
    }
    
    public void exportTables() throws HibernateException {
        Configuration cfg = new Configuration()
            .addClass(Blog.class)
            .addClass(BlogItem.class);
        new SchemaExport(cfg).create(true, true);
    }
    
    public Blog createBlog(String name) throws HibernateException {
        
        Blog blog = new Blog();
        blog.setName(name);
        blog.setItems( new ArrayList() );
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.persist(blog);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return blog;
    }
    
    public BlogItem createBlogItem(Blog blog, String title, String text)
                        throws HibernateException {
        
        BlogItem item = new BlogItem();
        item.setTitle(title);
        item.setText(text);
        item.setBlog(blog);
        item.setDatetime( Calendar.getInstance() );
        blog.getItems().add(item);
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.update(blog);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return item;
    }
    
    public BlogItem createBlogItem(Long blogid, String title, String text)
                        throws HibernateException {
        
        BlogItem item = new BlogItem();
        item.setTitle(title);
        item.setText(text);
        item.setDatetime( Calendar.getInstance() );
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            Blog blog = (Blog) session.load(Blog.class, blogid);
            item.setBlog(blog);
            blog.getItems().add(item);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return item;
    }
    
    public void updateBlogItem(BlogItem item, String text)
                    throws HibernateException {
        
        item.setText(text);
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.update(item);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
    }
    
    public void updateBlogItem(Long itemid, String text)
                    throws HibernateException {
    
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            BlogItem item = (BlogItem) session.load(BlogItem.class, itemid);
            item.setText(text);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
    }
    
    public List listAllBlogNamesAndItemCounts(int max)
                    throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        List result = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "select blog.id, blog.name, count(blogItem) " +
                "from Blog as blog " +
                "left outer join blog.items as blogItem " +
                "group by blog.name, blog.id " +
                "order by max(blogItem.datetime)"
            );
            q.setMaxResults(max);
            result = q.list();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return result;
    }
    
    public Blog getBlogAndAllItems(Long blogid)
                    throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        Blog blog = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "from Blog as blog " +
                "left outer join fetch blog.items " +
                "where blog.id = :blogid"
            );
            q.setParameter("blogid", blogid);
            blog  = (Blog) q.uniqueResult();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return blog;
    }
    
    public List listBlogsAndRecentItems() throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        List result = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "from Blog as blog " +
                "inner join blog.items as blogItem " +
                "where blogItem.datetime &gt; :minDate"
            );

            Calendar cal = Calendar.getInstance();
            cal.roll(Calendar.MONTH, false);
            q.setCalendar("minDate", cal);
            
            result = q.list();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return result;
    }
}</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="example-mappings"></a>Chapter&nbsp;23.&nbsp;Example: Various Mappings</h2></div></div><div></div></div><p>
        This chapters shows off some more complex association mappings.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-mappings-emp"></a>23.1.&nbsp;Employer/Employee</h2></div></div><div></div></div><p>
            The following model of the relationship between <tt class="literal">Employer</tt> and 
            <tt class="literal">Employee</tt> uses an actual entity class (<tt class="literal">Employment</tt>) 
            to represent the association. This is done because there might be more than one
            period of employment for the same two parties. Components are used to model monetary 
            values and employee names.
        </p><div class="mediaobject" align="center"><img src="../shared/images/EmployerEmployee.gif" align="middle"></div><p>
            Heres a possible mapping document:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;
        
    &lt;class name="Employer" table="employers"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employer_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

    &lt;class name="Employment" table="employment_periods"&gt;

        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employment_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="startDate" column="start_date"/&gt;
        &lt;property name="endDate" column="end_date"/&gt;

        &lt;component name="hourlyRate" class="MonetaryAmount"&gt;
            &lt;property name="amount"&gt;
                &lt;column name="hourly_rate" sql-type="NUMERIC(12, 2)"/&gt;
            &lt;/property&gt;
            &lt;property name="currency" length="12"/&gt;
        &lt;/component&gt;

        &lt;many-to-one name="employer" column="employer_id" not-null="true"/&gt;
        &lt;many-to-one name="employee" column="employee_id" not-null="true"/&gt;

    &lt;/class&gt;

    &lt;class name="Employee" table="employees"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employee_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="taxfileNumber"/&gt;
        &lt;component name="name" class="Name"&gt;
            &lt;property name="firstName"/&gt;
            &lt;property name="initial"/&gt;
            &lt;property name="lastName"/&gt;
        &lt;/component&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
        And heres the table schema generated by <tt class="literal">SchemaExport</tt>.
    </p><pre class="programlisting">create table employers (
    id BIGINT not null, 
    name VARCHAR(255), 
    primary key (id)
)

create table employment_periods (
    id BIGINT not null,
    hourly_rate NUMERIC(12, 2),
    currency VARCHAR(12), 
    employee_id BIGINT not null, 
    employer_id BIGINT not null, 
    end_date TIMESTAMP, 
    start_date TIMESTAMP, 
    primary key (id)
)

create table employees (
    id BIGINT not null, 
    firstName VARCHAR(255), 
    initial CHAR(1), 
    lastName VARCHAR(255), 
    taxfileNumber VARCHAR(255), 
    primary key (id)
)

alter table employment_periods 
    add constraint employment_periodsFK0 foreign key (employer_id) references employers
alter table employment_periods 
    add constraint employment_periodsFK1 foreign key (employee_id) references employees
create sequence employee_id_seq
create sequence employment_id_seq
create sequence employer_id_seq</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-mappings-authorwork"></a>23.2.&nbsp;Author/Work</h2></div></div><div></div></div><p>
            Consider the following model of the relationships between <tt class="literal">Work</tt>,
            <tt class="literal">Author</tt> and <tt class="literal">Person</tt>. We represent the relationship
            between <tt class="literal">Work</tt> and <tt class="literal">Author</tt> as a many-to-many
            association. We choose to represent the relationship between <tt class="literal">Author</tt> 
            and <tt class="literal">Person</tt> as one-to-one association. Another possibility would be to 
            have <tt class="literal">Author</tt> extend <tt class="literal">Person</tt>.  
        </p><div class="mediaobject" align="center"><img src="../shared/images/AuthorWork.gif" align="middle"></div><p>
            The following mapping document correctly represents these relationships:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Work" table="works" discriminator-value="W"&gt;

        &lt;id name="id" column="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;discriminator column="type" type="character"/&gt;

        &lt;property name="title"/&gt;
        &lt;set name="authors" table="author_work"&gt;
            &lt;key column name="work_id"/&gt;
            &lt;many-to-many class="Author" column name="author_id"/&gt;
        &lt;/set&gt;

        &lt;subclass name="Book" discriminator-value="B"&gt;
            &lt;property name="text"/&gt;
        &lt;/subclass&gt;

        &lt;subclass name="Song" discriminator-value="S"&gt;
            &lt;property name="tempo"/&gt;
            &lt;property name="genre"/&gt;
        &lt;/subclass&gt;

    &lt;/class&gt;

    &lt;class name="Author" table="authors"&gt;

        &lt;id name="id" column="id"&gt;
            &lt;!-- The Author must have the same identifier as the Person --&gt;
            &lt;generator class="assigned"/&gt; 
        &lt;/id&gt;

        &lt;property name="alias"/&gt;
        &lt;one-to-one name="person" constrained="true"/&gt;

        &lt;set name="works" table="author_work" inverse="true"&gt;
            &lt;key column="author_id"/&gt;
            &lt;many-to-many class="Work" column="work_id"/&gt;
        &lt;/set&gt;

    &lt;/class&gt;

    &lt;class name="Person" table="persons"&gt;
        &lt;id name="id" column="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
        There are four tables in this mapping. <tt class="literal">works</tt>, 
        <tt class="literal">authors</tt> and <tt class="literal">persons</tt> hold work, author
        and person data respectively. <tt class="literal">author_work</tt> is an association
        table linking authors to works. Heres the table schema, as generated by
        <tt class="literal">SchemaExport</tt>.
    </p><pre class="programlisting">create table works (
    id BIGINT not null generated by default as identity, 
    tempo FLOAT, 
    genre VARCHAR(255), 
    text INTEGER, 
    title VARCHAR(255), 
    type CHAR(1) not null, 
    primary key (id)
)

create table author_work (
    author_id BIGINT not null, 
    work_id BIGINT not null, 
    primary key (work_id, author_id)
)

create table authors (
    id BIGINT not null generated by default as identity, 
    alias VARCHAR(255), 
    primary key (id)
)

create table persons (
    id BIGINT not null generated by default as identity, 
    name VARCHAR(255), 
    primary key (id)
)

alter table authors 
    add constraint authorsFK0 foreign key (id) references persons
alter table author_work 
    add constraint author_workFK0 foreign key (author_id) references authors
alter table author_work
    add constraint author_workFK1 foreign key (work_id) references works</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-mappings-customerorderproduct"></a>23.3.&nbsp;Customer/Order/Product</h2></div></div><div></div></div><p>
            Now consider a model of the relationships between <tt class="literal">Customer</tt>,
            <tt class="literal">Order</tt> and <tt class="literal">LineItem</tt> and <tt class="literal">Product</tt>.
            There is a one-to-many association between <tt class="literal">Customer</tt> and
            <tt class="literal">Order</tt>, but how should we represent <tt class="literal">Order</tt> / 
            <tt class="literal">LineItem</tt> / <tt class="literal">Product</tt>? I've chosen to map
            <tt class="literal">LineItem</tt> as an association class representing the many-to-many
            association between <tt class="literal">Order</tt> and <tt class="literal">Product</tt>. In
            Hibernate, this is called a composite element.
        </p><div class="mediaobject" align="center"><img src="../shared/images/CustomerOrderProduct.gif" align="middle"></div><p>
            The mapping document:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Customer" table="customers"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
        &lt;set name="orders" inverse="true"&gt;
            &lt;key column="customer_id"/&gt;
            &lt;one-to-many class="Order"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Order" table="orders"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="date"/&gt;
        &lt;many-to-one name="customer" column="customer_id"/&gt;
        &lt;list name="lineItems" table="line_items"&gt;
            &lt;key column="order_id"/&gt;
            &lt;list-index column="line_number"/&gt;
            &lt;composite-element class="LineItem"&gt;
                &lt;property name="quantity"/&gt;
                &lt;many-to-one name="product" column="product_id"/&gt;
            &lt;/composite-element&gt;
        &lt;/list&gt;
    &lt;/class&gt;

    &lt;class name="Product" table="products"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="serialNumber"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
        <tt class="literal">customers</tt>, <tt class="literal">orders</tt>, <tt class="literal">line_items</tt> and 
        <tt class="literal">products</tt> hold customer, order, order line item and product data
        respectively. <tt class="literal">line_items</tt> also acts as an association table linking
        orders with products.
    </p><pre class="programlisting">create table customers (
    id BIGINT not null generated by default as identity, 
    name VARCHAR(255), 
    primary key (id)
)

create table orders (
    id BIGINT not null generated by default as identity, 
    customer_id BIGINT, 
    date TIMESTAMP, 
    primary key (id)
)

create table line_items (
    line_number INTEGER not null, 
    order_id BIGINT not null, 
    product_id BIGINT, 
    quantity INTEGER, 
    primary key (order_id, line_number)
)

create table products (
    id BIGINT not null generated by default as identity, 
    serialNumber VARCHAR(255), 
    primary key (id)
)

alter table orders 
    add constraint ordersFK0 foreign key (customer_id) references customers
alter table line_items
    add constraint line_itemsFK0 foreign key (product_id) references products
alter table line_items
    add constraint line_itemsFK1 foreign key (order_id) references orders</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="misc"></a>23.4.&nbsp;Miscellaneous example mappings</h2></div></div><div></div></div><p>
            These examples are all taken from the Hibernate test suite. You
            will find many other useful example mappings there. Look in the
            <tt class="literal">test</tt> folder of the Hibernate distribution.
        </p><p>TODO: put words around this stuff</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="example-mappings-typed-onetone"></a>23.4.1.&nbsp;"Typed" one-to-one association</h3></div></div><div></div></div><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="name"/&gt;
    &lt;one-to-one name="address" 
            cascade="all"&gt;
        &lt;formula&gt;name&lt;/formula&gt;
        &lt;formula&gt;'HOME'&lt;/formula&gt;
    &lt;/one-to-one&gt;
    &lt;one-to-one name="mailingAddress" 
            cascade="all"&gt;
        &lt;formula&gt;name&lt;/formula&gt;
        &lt;formula&gt;'MAILING'&lt;/formula&gt;
    &lt;/one-to-one&gt;
&lt;/class&gt;

&lt;class name="Address" batch-size="2" 
        check="addressType in ('MAILING', 'HOME', 'BUSINESS')"&gt;
    &lt;composite-id&gt;
        &lt;key-many-to-one name="person" 
                column="personName"/&gt;
        &lt;key-property name="type" 
                column="addressType"/&gt;
    &lt;/composite-id&gt;
    &lt;property name="street" type="text"/&gt;
    &lt;property name="state"/&gt;
    &lt;property name="zip"/&gt;
&lt;/class&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="example-mappings-composite-key"></a>23.4.2.&nbsp;Composite key example</h3></div></div><div></div></div><pre class="programlisting">&lt;class name="Customer"&gt;

    &lt;id name="customerId"
        length="10"&gt;
        &lt;generator class="assigned"/&gt;
    &lt;/id&gt;

    &lt;property name="name" not-null="true" length="100"/&gt;
    &lt;property name="address" not-null="true" length="200"/&gt;

    &lt;list name="orders"
            inverse="true"
            cascade="save-update"&gt;
        &lt;key column="customerId"/&gt;
        &lt;index column="orderNumber"/&gt;
        &lt;one-to-many class="Order"/&gt;
    &lt;/list&gt;

&lt;/class&gt;

&lt;class name="Order" table="CustomerOrder" lazy="true"&gt;
    &lt;synchronize table="LineItem"/&gt;
    &lt;synchronize table="Product"/&gt;
    
    &lt;composite-id name="id" 
            class="Order$Id"&gt;
        &lt;key-property name="customerId" length="10"/&gt;
        &lt;key-property name="orderNumber"/&gt;
    &lt;/composite-id&gt;
    
    &lt;property name="orderDate" 
            type="calendar_date"
            not-null="true"/&gt;
    
    &lt;property name="total"&gt;
        &lt;formula&gt;
            ( select sum(li.quantity*p.price) 
            from LineItem li, Product p 
            where li.productId = p.productId 
                and li.customerId = customerId 
                and li.orderNumber = orderNumber )
        &lt;/formula&gt;
    &lt;/property&gt;
    
    &lt;many-to-one name="customer"
            column="customerId"
            insert="false"
            update="false" 
            not-null="true"/&gt;
        
    &lt;bag name="lineItems"
            fetch="join" 
            inverse="true"
            cascade="save-update"&gt;
        &lt;key&gt;
            &lt;column name="customerId"/&gt;
            &lt;column name="orderNumber"/&gt;
        &lt;/key&gt;
        &lt;one-to-many class="LineItem"/&gt;
    &lt;/bag&gt;
    
&lt;/class&gt;
    
&lt;class name="LineItem"&gt;
    
    &lt;composite-id name="id" 
            class="LineItem$Id"&gt;
        &lt;key-property name="customerId" length="10"/&gt;
        &lt;key-property name="orderNumber"/&gt;
        &lt;key-property name="productId" length="10"/&gt;
    &lt;/composite-id&gt;
    
    &lt;property name="quantity"/&gt;
    
    &lt;many-to-one name="order"
            insert="false"
            update="false" 
            not-null="true"&gt;
        &lt;column name="customerId"/&gt;
        &lt;column name="orderNumber"/&gt;
    &lt;/many-to-one&gt;
    
    &lt;many-to-one name="product"
            insert="false"
            update="false" 
            not-null="true"
            column="productId"/&gt;
        
&lt;/class&gt;

&lt;class name="Product"&gt;
    &lt;synchronize table="LineItem"/&gt;

    &lt;id name="productId"
        length="10"&gt;
        &lt;generator class="assigned"/&gt;
    &lt;/id&gt;
    
    &lt;property name="description" 
        not-null="true" 
        length="200"/&gt;
    &lt;property name="price" length="3"/&gt;
    &lt;property name="numberAvailable"/&gt;
    
    &lt;property name="numberOrdered"&gt;
        &lt;formula&gt;
            ( select sum(li.quantity) 
            from LineItem li 
            where li.productId = productId )
        &lt;/formula&gt;
    &lt;/property&gt;
    
&lt;/class&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="example-mappings-composite-key-manytomany"></a>23.4.3.&nbsp;Many-to-many with shared composite key attribute</h3></div></div><div></div></div><pre class="programlisting">&lt;class name="User" table="`User`"&gt;
    &lt;composite-id&gt;
        &lt;key-property name="name"/&gt;
        &lt;key-property name="org"/&gt;
    &lt;/composite-id&gt;
    &lt;set name="groups" table="UserGroup"&gt;
        &lt;key&gt;
            &lt;column name="userName"/&gt;
            &lt;column name="org"/&gt;
        &lt;/key&gt;
        &lt;many-to-many class="Group"&gt;
            &lt;column name="groupName"/&gt;
            &lt;formula&gt;org&lt;/formula&gt;
        &lt;/many-to-many&gt;
    &lt;/set&gt;
&lt;/class&gt;
    
&lt;class name="Group" table="`Group`"&gt;
    &lt;composite-id&gt;
        &lt;key-property name="name"/&gt;
        &lt;key-property name="org"/&gt;
    &lt;/composite-id&gt;
    &lt;property name="description"/&gt;
    &lt;set name="users" table="UserGroup" inverse="true"&gt;
        &lt;key&gt;
            &lt;column name="groupName"/&gt;
            &lt;column name="org"/&gt;
        &lt;/key&gt;
        &lt;many-to-many class="User"&gt;
            &lt;column name="userName"/&gt;
            &lt;formula&gt;org&lt;/formula&gt;
        &lt;/many-to-many&gt;
    &lt;/set&gt;
&lt;/class&gt;
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="example-mappings-content-discrimination"></a>23.4.4.&nbsp;Content based discrimination</h3></div></div><div></div></div><pre class="programlisting">&lt;class name="Person"
    discriminator-value="P"&gt;
    
    &lt;id name="id" 
        column="person_id" 
        unsaved-value="0"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    
            
    &lt;discriminator 
        type="character"&gt;
        &lt;formula&gt;
            case 
                when title is not null then 'E' 
                when salesperson is not null then 'C' 
                else 'P' 
            end
        &lt;/formula&gt;
    &lt;/discriminator&gt;

    &lt;property name="name" 
        not-null="true"
        length="80"/&gt;
        
    &lt;property name="sex" 
        not-null="true"
        update="false"/&gt;
    
    &lt;component name="address"&gt;
        &lt;property name="address"/&gt;
        &lt;property name="zip"/&gt;
        &lt;property name="country"/&gt;
    &lt;/component&gt;
    
    &lt;subclass name="Employee" 
        discriminator-value="E"&gt;
            &lt;property name="title"
                length="20"/&gt;
            &lt;property name="salary"/&gt;
            &lt;many-to-one name="manager"/&gt;
    &lt;/subclass&gt;
    
    &lt;subclass name="Customer" 
        discriminator-value="C"&gt;
            &lt;property name="comments"/&gt;
            &lt;many-to-one name="salesperson"/&gt;
    &lt;/subclass&gt;
    
&lt;/class&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="example-mappings-association-alternatekeys"></a>23.4.5.&nbsp;Associations on alternate keys</h3></div></div><div></div></div><pre class="programlisting">&lt;class name="Person"&gt;
    
    &lt;id name="id"&gt;
        &lt;generator class="hilo"/&gt;
    &lt;/id&gt;
    
    &lt;property name="name" length="100"/&gt;
    
    &lt;one-to-one name="address" 
        property-ref="person"
        cascade="all"
        fetch="join"/&gt;
    
    &lt;set name="accounts" 
        inverse="true"&gt;
        &lt;key column="userId"
            property-ref="userId"/&gt;
        &lt;one-to-many class="Account"/&gt;
    &lt;/set&gt;
    
    &lt;property name="userId" length="8"/&gt;

&lt;/class&gt;

&lt;class name="Address"&gt;

    &lt;id name="id"&gt;
        &lt;generator class="hilo"/&gt;
    &lt;/id&gt;

    &lt;property name="address" length="300"/&gt;
    &lt;property name="zip" length="5"/&gt;
    &lt;property name="country" length="25"/&gt;
    &lt;many-to-one name="person" unique="true" not-null="true"/&gt;

&lt;/class&gt;

&lt;class name="Account"&gt;
    &lt;id name="accountId" length="32"&gt;
        &lt;generator class="uuid"/&gt;
    &lt;/id&gt;
    
    &lt;many-to-one name="user"
        column="userId"
        property-ref="userId"/&gt;
    
    &lt;property name="type" not-null="true"/&gt;
    
&lt;/class&gt;</pre></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="best-practices"></a>Chapter&nbsp;24.&nbsp;Best Practices</h2></div></div><div></div></div><div class="variablelist"><dl><dt><span class="term">Write fine-grained classes and map them using <tt class="literal">&lt;component&gt;</tt>.</span></dt><dd><p>
                    Use an <tt class="literal">Address</tt> class to encapsulate <tt class="literal">street</tt>,
                    <tt class="literal">suburb</tt>, <tt class="literal">state</tt>, <tt class="literal">postcode</tt>.
                    This encourages code reuse and simplifies refactoring.
                </p></dd><dt><span class="term">Declare identifier properties on persistent classes.</span></dt><dd><p>
                    Hibernate makes identifier properties optional. There are all sorts of reasons why
                    you should use them. We recommend that identifiers be 'synthetic' (generated, with
                    no business meaning).
                </p></dd><dt><span class="term">Identify natural keys.</span></dt><dd><p>
                    Identify natural keys for all entities, and map them using 
                    <tt class="literal">&lt;natural-id&gt;</tt>. Implement <tt class="literal">equals()</tt> and 
                    <tt class="literal">hashCode()</tt> to compare the properties that make up the natural key.
                </p></dd><dt><span class="term">Place each class mapping in its own file.</span></dt><dd><p>
                     Don't use a single monolithic mapping document. Map <tt class="literal">com.eg.Foo</tt> in 
                     the file <tt class="literal">com/eg/Foo.hbm.xml</tt>. This makes particularly good sense in 
                     a team environment.
                </p></dd><dt><span class="term">Load mappings as resources.</span></dt><dd><p>
                    Deploy the mappings along with the classes they map.
                </p></dd><dt><span class="term">Consider externalising query strings.</span></dt><dd><p>
                    This is a good practice if your queries call non-ANSI-standard SQL functions. 
                    Externalising the query strings to mapping files will make the application more 
                    portable.
                </p></dd><dt><span class="term">Use bind variables.</span></dt><dd><p>
                     As in JDBC, always replace non-constant values by "?". Never use string manipulation to 
                     bind a non-constant value in a query! Even better, consider using named parameters in
                     queries.
                </p></dd><dt><span class="term">Don't manage your own JDBC connections.</span></dt><dd><p>
                    Hibernate lets the application manage JDBC connections. This approach should be considered 
                    a last-resort. If you can't use the built-in connections providers, consider providing your 
                    own implementation of <tt class="literal">org.hibernate.connection.ConnectionProvider</tt>.
                </p></dd><dt><span class="term">Consider using a custom type.</span></dt><dd><p>
                    Suppose you have a Java type, say from some library, that needs to be persisted but doesn't 
                    provide the accessors needed to map it as a component. You should consider implementing
                    <tt class="literal">org.hibernate.UserType</tt>. This approach frees the application
                    code from implementing transformations to / from a Hibernate type.
                </p></dd><dt><span class="term">Use hand-coded JDBC in bottlenecks.</span></dt><dd><p>
                    In performance-critical areas of the system, some kinds of operations might benefit from 
                    direct JDBC. But please, wait until you <span class="emphasis"><em>know</em></span> something is a bottleneck. 
                    And don't assume that direct JDBC is necessarily faster. If you need to use direct JDBC, it might 
                    be worth opening a Hibernate <tt class="literal">Session</tt> and using that JDBC connection. That 
                    way you can still use the same transaction strategy and underlying connection provider.
                </p></dd><dt><span class="term">Understand <tt class="literal">Session</tt> flushing.</span></dt><dd><p>
                    From time to time the Session synchronizes its persistent state with the database. Performance will
                    be affected if this process occurs too often. You may sometimes minimize unnecessary flushing by 
                    disabling automatic flushing or even by changing the order of queries and other operations within a 
                    particular transaction.      
                </p></dd><dt><span class="term">In a three tiered architecture, consider using detached objects.</span></dt><dd><p>
                    When using a servlet / session bean architecture, you could pass persistent objects loaded in
                    the session bean to and from the servlet / JSP layer. Use a new session to service each request. 
                    Use <tt class="literal">Session.merge()</tt> or <tt class="literal">Session.saveOrUpdate()</tt> to 
                    synchronize objects with the database.
                </p></dd><dt><span class="term">In a two tiered architecture, consider using long persistence contexts.</span></dt><dd><p>
                    Database Transactions have to be as short as possible for best scalability. However, it is often
                    neccessary to implement long running <span class="emphasis"><em>application transactions</em></span>, a single 
                    unit-of-work from the point of view of a user. An application transaction might span several 
                    client request/response cycles. It is common to use detached objects to implement application
                    transactions. An alternative, extremely appropriate in two tiered architecture, is to maintain
                    a single open persistence contact (session) for the whole lifecycle of the application transaction 
                    and simply disconnect from the JDBC connection at the end of each request and reconnect at the 
                    beginning of the subsequent request. Never share a single session across more than one application 
                    transaction, or you will be working with stale data.
                </p></dd><dt><span class="term">Don't treat exceptions as recoverable.</span></dt><dd><p>
                    This is more of a necessary practice than a "best" practice. When an exception occurs, roll back
                    the <tt class="literal">Transaction</tt> and close the <tt class="literal">Session</tt>. If you don't, Hibernate
                    can't guarantee that in-memory state accurately represents persistent state. As a special case of this,
                    do not use <tt class="literal">Session.load()</tt> to determine if an instance with the given identifier 
                    exists on the database; use <tt class="literal">Session.get()</tt> or a query instead.
                </p></dd><dt><span class="term">Prefer lazy fetching for associations.</span></dt><dd><p>
                    Use eager fetching sparingly. Use proxies and lazy collections for most associations to classes that 
                    are not likely to be completely held in the second-level cache. For associations to cached classes, 
                    where there is an a extremely high probability of a cache hit, explicitly disable eager fetching using 
                    <tt class="literal">lazy="false"</tt>. When an join fetching is appropriate to a particular use
                    case, use a query with a <tt class="literal">left join fetch</tt>.
                </p></dd><dt><span class="term">
                Use the <span class="emphasis"><em>open session in view</em></span> pattern, or a disciplined 
                <span class="emphasis"><em>assembly phase</em></span> to avoid problems with unfetched data.
            </span></dt><dd><p>
                    Hibernate frees the developer from writing tedious <span class="emphasis"><em>Data Transfer Objects</em></span> (DTO). 
                    In a traditional EJB architecture, DTOs serve dual purposes: first, they work around the problem
                    that entity beans are not serializable; second, they implicitly define an assembly phase where
                    all data to be used by the view is fetched and marshalled into the DTOs before returning control 
                    to the presentation tier. Hibernate eliminates the first purpose. However, you will still need
                    an assembly phase (think of your business methods as having a strict contract with the presentation
                    tier about what data is available in the detached objects) unless you are prepared to hold the
                    persistence context (the session) open across the view rendering process. This is not a limitation
                    of Hibernate! It is a fundamental requirement of safe transactional data access.
                </p></dd><dt><span class="term">Consider abstracting your business logic from Hibernate.</span></dt><dd><p>
                    Hide (Hibernate) data-access code behind an interface. Combine the <span class="emphasis"><em>DAO</em></span> and 
                    <span class="emphasis"><em>Thread Local Session</em></span> patterns. You can even have some classes persisted by
                    handcoded JDBC, associated to Hibernate via a <tt class="literal">UserType</tt>. (This advice is 
                    intended for "sufficiently large" applications; it is not appropriate for an application with
                    five tables!)
                </p></dd><dt><span class="term">Don't use exotic association mappings.</span></dt><dd><p>
                    Good usecases for a real many-to-many associations are rare. Most of the time you need
                    additional information stored in the "link table". In this case, it is much better to
                    use two one-to-many associations to an intermediate link class. In fact, we think that
                    most associations are one-to-many and many-to-one, you should be careful when using any
                    other association style and ask yourself if it is really neccessary.
                </p></dd><dt><span class="term">Prefer bidirectional associations.</span></dt><dd><p>
                    Unidirectional associations are more difficult to query. In a large application, almost
                    all associations must be navigable in both directions in queries.
                </p></dd></dl></div></div></div></body></html>