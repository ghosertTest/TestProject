<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HIBERNATE - Persistance relationnelle en Java standard</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="fr"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>HIBERNATE - Persistance relationnelle en Java standard</h1></div><div><h2 class="subtitle">Documentation de r&eacute;f&eacute;rence d'Hibernate</h2></div><div><p class="releaseinfo">3.1final</p></div></div><div></div><hr></div><div class="toc"><p><b>Table des mati&egrave;res</b></p><dl><dt><span class="preface"><a href="#preface">Pr&eacute;face</a></span></dt><dt><span class="chapter"><a href="#tutorial">1. Introduction &agrave; Hibernate</a></span></dt><dd><dl><dt><span class="sect1"><a href="#tutorial-intro">1.1. Pr&eacute;face</a></span></dt><dt><span class="sect1"><a href="#tutorial-firstapp">1.2. Partie 1 - Premi&egrave;re application Hibernate</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-firstapp-firstclass">1.2.1. La premi&egrave;re classe</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-mapping">1.2.2. Le fichier de mapping</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-configuration">1.2.3. Configuration d'Hibernate</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-ant">1.2.4. Construction avec Ant</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-helpers">1.2.5. D&eacute;marrage et aides</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-workingpersistence">1.2.6. Charger et stocker des objets</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-associations">1.3. Partie 2 - Mapper des associations</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-associations-mappinguser">1.3.1. Mapper la classe Person</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-unidirset">1.3.2. Une association unidirectionnelle bas&eacute;e sur Set</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-working">1.3.3. Travailler avec l'association</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-valuecollections">1.3.4. Collection de valeurs</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-bidirectional">1.3.5. Associations bidirectionnelles</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-usingbidir">1.3.6. Travailler avec des liens bidirectionnels</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-webapp">1.4. Part 3 - L'application web EventManager</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-webapp-servlet">1.4.1. Ecrire la servlet de base</a></span></dt><dt><span class="sect2"><a href="#tutorial-webapp-processing">1.4.2. Proc&eacute;der et rendre</a></span></dt><dt><span class="sect2"><a href="#tutorial-webapp-deploy">1.4.3. D&eacute;ployer et tester</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-summary">1.5. R&eacute;sum&eacute;</a></span></dt></dl></dd><dt><span class="chapter"><a href="#architecture">2. Architecture</a></span></dt><dd><dl><dt><span class="sect1"><a href="#architecture-overview">2.1. G&eacute;n&eacute;ralit&eacute;s</a></span></dt><dt><span class="sect1"><a href="#architecture-states">2.2. Etats des instances</a></span></dt><dt><span class="sect1"><a href="#architecture-jmx">2.3. Int&eacute;gration JMX</a></span></dt><dt><span class="sect1"><a href="#architecture-jca">2.4. Support JCA</a></span></dt><dt><span class="sect1"><a href="#architecture-current-session">2.5. Sessions Contextuelles</a></span></dt></dl></dd><dt><span class="chapter"><a href="#session-configuration">3. Configuration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#configuration-programmatic">3.1. Configuration par programmation</a></span></dt><dt><span class="sect1"><a href="#configuration-sessionfactory">3.2. Obtenir une SessionFactory</a></span></dt><dt><span class="sect1"><a href="#configuration-hibernatejdbc">3.3. Connexions JDBC</a></span></dt><dt><span class="sect1"><a href="#configuration-optional">3.4. Propri&eacute;t&eacute;s de configuration optionnelles</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuration-optional-dialects">3.4.1. Dialectes SQL</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-outerjoin">3.4.2. Chargement par Jointure Ouverte</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-binarystreams">3.4.3. Flux binaires</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-cacheprovider">3.4.4. Cache de second niveau et cache de requ&ecirc;tes</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-querysubstitution">3.4.5. Substitution dans le langage de requ&ecirc;tage</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-statistics">3.4.6. Statistiques Hibernate</a></span></dt></dl></dd><dt><span class="sect1"><a href="#configuration-logging">3.5. Tracer</a></span></dt><dt><span class="sect1"><a href="#configuration-namingstrategy">3.6. Impl&eacute;menter une NamingStrategy</a></span></dt><dt><span class="sect1"><a href="#configuration-xmlconfig">3.7. Fichier de configuration XML</a></span></dt><dt><span class="sect1"><a href="#configuration-j2ee">3.8. Int&eacute;gration &agrave; un serveur d'application J2EE</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuration-optional-transactionstrategy">3.8.1. Configuration de la strat&eacute;gie transactionnelle</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-jndi">3.8.2. SessionFactory associ&eacute;e au JNDI</a></span></dt><dt><span class="sect2"><a href="#configuration-j2ee-currentsession">3.8.3. Association automatique de la Session &agrave; JTA</a></span></dt><dt><span class="sect2"><a href="#configuration-j2ee-jmx">3.8.4. D&eacute;ploiement JMX</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#persistent-classes">4. Classes persistantes</a></span></dt><dd><dl><dt><span class="sect1"><a href="#persistent-classes-pojo">4.1. Un exemple simple de POJO</a></span></dt><dd><dl><dt><span class="sect2"><a href="#persistent-classes-pojo-constructor">4.1.1. Impl&eacute;menter un constructeur sans argument</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-identifier">4.1.2. Fournir une propri&eacute;t&eacute; d'indentifiant (optionnel)</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-final">4.1.3. Favoriser les classes non finales (optionnel)</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-accessors">4.1.4. D&eacute;clarer les accesseurs et mutateurs des attributs persistants (optionnel)</a></span></dt></dl></dd><dt><span class="sect1"><a href="#persistent-classes-inheritance">4.2. Impl&eacute;menter l'h&eacute;ritage</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-equalshashcode">4.3. Impl&eacute;menter equals() et hashCode()</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-dynamicmodels">4.4. Mod&egrave;les dynamiques</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-tuplizers">4.5. Tuplizers</a></span></dt></dl></dd><dt><span class="chapter"><a href="#mapping">5. Mapping O/R basique</a></span></dt><dd><dl><dt><span class="sect1"><a href="#mapping-declaration">5.1. D&eacute;claration de Mapping</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-declaration-doctype">5.1.1. Doctype</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-mapping">5.1.2. hibernate-mapping</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-class">5.1.3. class</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id">5.1.4. id</a></span></dt><dd><dl><dt><span class="sect3"><a href="#mapping-declaration-id-generator">5.1.4.1. Generator</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-hilo">5.1.4.2. algorithme Hi/lo</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-uuid">5.1.4.3. UUID algorithm</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-sequences">5.1.4.4. Colonnes identifiantes et s&eacute;quences</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-assigned">5.1.4.5. Identifiants assign&eacute;s</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-select">5.1.4.6. Clefs primaires assign&eacute;es par trigger</a></span></dt></dl></dd><dt><span class="sect2"><a href="#mapping-declaration-compositeid">5.1.5. composite-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-discriminator">5.1.6. discriminator</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-version">5.1.7. version (optionnel)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-timestamp">5.1.8. timestamp (optionnel)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-property">5.1.9. property</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-manytoone">5.1.10. many-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-onetoone">5.1.11. one-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-naturalid">5.1.12. natural-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-component">5.1.13. component, dynamic-component</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-properties">5.1.14. properties</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-subclass">5.1.15. subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-joinedsubclass">5.1.16. joined-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-unionsubclass">5.1.17. union-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-join">5.1.18. join</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-key">5.1.19. key</a></span></dt><dt><span class="sect2"><a href="#mapping-column">5.1.20. &eacute;l&eacute;ments column et formula</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-import">5.1.21. import</a></span></dt><dt><span class="sect2"><a href="#mapping-types-anymapping">5.1.22. any</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-types">5.2. Hibernate Types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-types-entitiesvalues">5.2.1. Entit&eacute;s et valeurs</a></span></dt><dt><span class="sect2"><a href="#mapping-types-basictypes">5.2.2. Basic value types</a></span></dt><dt><span class="sect2"><a href="#mapping-types-custom">5.2.3. Types de valeur d&eacute;finis par l'utilisateur</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-entityname">5.3. Mapper une classe plus d'une fois</a></span></dt><dt><span class="sect1"><a href="#mapping-quotedidentifiers">5.4. SQL quoted identifiers</a></span></dt><dt><span class="sect1"><a href="#mapping-alternatives">5.5. alternatives Metadata</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-xdoclet">5.5.1. utilisation de XDoclet</a></span></dt><dt><span class="sect2"><a href="#mapping-annotations">5.5.2. Utilisation des annotations JDK 5.0</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-generated">5.6. Propri&eacute;t&eacute;s g&eacute;n&eacute;r&eacute;es</a></span></dt><dt><span class="sect1"><a href="#mapping-database-object">5.7. Objets auxiliaires de la base de donn&eacute;es</a></span></dt></dl></dd><dt><span class="chapter"><a href="#collections">6. Mapping des collections</a></span></dt><dd><dl><dt><span class="sect1"><a href="#collections-persistent">6.1. Collections persistantes</a></span></dt><dt><span class="sect1"><a href="#collections-mapping">6.2. Mapper une collection</a></span></dt><dd><dl><dt><span class="sect2"><a href="#collections-foreignkeys">6.2.1. Les clefs &eacute;trang&egrave;res d'une collection</a></span></dt><dt><span class="sect2"><a href="#collections-elements">6.2.2. Les &eacute;l&eacute;ments d'une collection</a></span></dt><dt><span class="sect2"><a href="#collections-indexed">6.2.3. Collections index&eacute;es</a></span></dt><dt><span class="sect2"><a href="#collections-ofvalues">6.2.4. Collections de valeurs et associations plusieurs-vers-plusieurs</a></span></dt><dt><span class="sect2"><a href="#collections-onetomany">6.2.5. Association un-vers-plusieurs</a></span></dt></dl></dd><dt><span class="sect1"><a href="#collections-advancedmappings">6.3. Mappings de collection avanc&eacute;s</a></span></dt><dd><dl><dt><span class="sect2"><a href="#collections-sorted">6.3.1. Collections tri&eacute;es</a></span></dt><dt><span class="sect2"><a href="#collections-bidirectional">6.3.2. Associations bidirectionnelles</a></span></dt><dt><span class="sect2"><a href="#collections-indexedbidirectional">6.3.3. Associations bidirectionnelles avec des collections index&eacute;es</a></span></dt><dt><span class="sect2"><a href="#collections-ternary">6.3.4. Associations ternaires</a></span></dt><dt><span class="sect2"><a href="#collections-idbag">6.3.5. Utiliser un &lt;idbag&gt;</a></span></dt></dl></dd><dt><span class="sect1"><a href="#collections-example">6.4. Exemples de collections</a></span></dt></dl></dd><dt><span class="chapter"><a href="#associations">7. Mapper les associations</a></span></dt><dd><dl><dt><span class="sect1"><a href="#assoc-intro">7.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#assoc-unidirectional">7.2. Association unidirectionnelle</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-unidirectional-m21">7.2.1. plusieurs &agrave; un</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-121">7.2.2. un &agrave; un</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-12m">7.2.3. un &agrave; plusieurs</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-unidirectional-join">7.3. Associations unidirectionnelles avec tables de jointure</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-unidirectional-join-12m">7.3.1. un &agrave; plusieurs</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-m21">7.3.2. plusieurs &agrave; un</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-121">7.3.3. un &agrave; un</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-m2m">7.3.4. plusieurs &agrave; plusieurs</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-bidirectional">7.4. Associations bidirectionnelles</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-bidirectional-m21">7.4.1. un &agrave; plusieurs / plusieurs &agrave; un</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-121">7.4.2. Un &agrave; un</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-bidirectional-join">7.5. Associations bidirectionnelles avec table de jointure</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-bidirectional-join-12m">7.5.1. un &agrave; plusieurs / plusieurs &agrave; un</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-join-121">7.5.2. Un &agrave; un</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-join-m2m">7.5.3. plusieurs &agrave; plusieurs</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-complex">7.6. Des mappings plus complexes</a></span></dt></dl></dd><dt><span class="chapter"><a href="#components">8. Mapping de composants</a></span></dt><dd><dl><dt><span class="sect1"><a href="#components-dependentobjects">8.1. Objects d&eacute;pendants</a></span></dt><dt><span class="sect1"><a href="#components-incollections">8.2. Collection d'objets d&eacute;pendants</a></span></dt><dt><span class="sect1"><a href="#components-asmapindex">8.3. Utiliser les composants comme index de map</a></span></dt><dt><span class="sect1"><a href="#components-compositeid">8.4. Utiliser un composant comme identifiant</a></span></dt><dt><span class="sect1"><a href="#components-dynamic">8.5. Composant Dynamique</a></span></dt></dl></dd><dt><span class="chapter"><a href="#inheritance">9. Mapping d'h&eacute;ritage de classe</a></span></dt><dd><dl><dt><span class="sect1"><a href="#inheritance-strategies">9.1. Les trois strat&eacute;gies</a></span></dt><dd><dl><dt><span class="sect2"><a href="#inheritance-tableperclass">9.1.1. Une table par hi&eacute;rarchie de classe</a></span></dt><dt><span class="sect2"><a href="#inheritance-tablepersubclass">9.1.2. Une table par classe fille</a></span></dt><dt><span class="sect2"><a href="#inheritance-tablepersubclass-discriminator">9.1.3. Une table par classe fille, en utilisant un discriminant</a></span></dt><dt><span class="sect2"><a href="#inheritance-mixing-tableperclass-tablepersubclass">9.1.4. M&eacute;lange d'une table par hi&eacute;rarchie de classe avec une table par classe fille</a></span></dt><dt><span class="sect2"><a href="#inheritance-tableperconcrete">9.1.5. Une table par classe concr&egrave;te</a></span></dt><dt><span class="sect2"><a href="#inheritance-tableperconcreate-polymorphism">9.1.6. Une table par classe concr&egrave;te, en utilisant le polymorphisme implicite</a></span></dt><dt><span class="sect2"><a href="#inheritace-mixingpolymorphism">9.1.7. M&eacute;lange du polymorphisme implicite avec d'autres mappings d'h&eacute;ritage</a></span></dt></dl></dd><dt><span class="sect1"><a href="#inheritance-limitations">9.2. Limitations</a></span></dt></dl></dd><dt><span class="chapter"><a href="#objectstate">10. Travailler avec des objets</a></span></dt><dd><dl><dt><span class="sect1"><a href="#objectstate-overview">10.1. &Eacute;tats des objets Hibernate</a></span></dt><dt><span class="sect1"><a href="#objectstate-makingpersistent">10.2. Rendre des objets persistants</a></span></dt><dt><span class="sect1"><a href="#objectstate-loading">10.3. Chargement d'un objet</a></span></dt><dt><span class="sect1"><a href="#objectstate-querying">10.4. Requ&ecirc;tage</a></span></dt><dd><dl><dt><span class="sect2"><a href="#objectstate-querying-executing">10.4.1. Ex&eacute;cution de requ&ecirc;tes</a></span></dt><dd><dl><dt><span class="sect3"><a href="#objectstate-querying-executing-iterate">10.4.1.1. It&eacute;ration de r&eacute;sultats</a></span></dt><dt><span class="sect3"><a href="#objectstate-querying-executing-tuples">10.4.1.2. Requ&ecirc;tes qui retournent des tuples</a></span></dt><dt><span class="sect3"><a href="#objectstate-querying-executing-scalar">10.4.1.3. R&eacute;sultats scalaires</a></span></dt><dt><span class="sect3"><a href="#objectstate-querying-executing-parameters">10.4.1.4. Lier des param&egrave;tres</a></span></dt><dt><span class="sect3"><a href="#objectstate-querying-executing-pagination">10.4.1.5. Pagination</a></span></dt><dt><span class="sect3"><a href="#objectstate-querying-executing-scrolling">10.4.1.6. It&eacute;ration "scrollable"</a></span></dt><dt><span class="sect3"><a href="#objectstate-querying-executing-named">10.4.1.7. Externaliser des requ&ecirc;tes nomm&eacute;es</a></span></dt></dl></dd><dt><span class="sect2"><a href="#objectstate-filtering">10.4.2. Filtrer des collections</a></span></dt><dt><span class="sect2"><a href="#objecstate-querying-criteria">10.4.3. Requ&ecirc;tes Criteria</a></span></dt><dt><span class="sect2"><a href="#objectstate-querying-nativesql">10.4.4. Requ&ecirc;tes en SQL natif</a></span></dt></dl></dd><dt><span class="sect1"><a href="#objectstate-modifying">10.5. Modifier des objets persistants</a></span></dt><dt><span class="sect1"><a href="#objectstate-detached">10.6. Modifier des objets d&eacute;tach&eacute;s</a></span></dt><dt><span class="sect1"><a href="#objectstate-saveorupdate">10.7. D&eacute;tection automatique d'un &eacute;tat</a></span></dt><dt><span class="sect1"><a href="#objectstate-deleting">10.8. Suppression d'objets persistants</a></span></dt><dt><span class="sect1"><a href="#objectstate-replicating">10.9. R&eacute;plication d'objets entre deux entrep&ocirc;ts de donn&eacute;es</a></span></dt><dt><span class="sect1"><a href="#objectstate-flushing">10.10. Flush de la session</a></span></dt><dt><span class="sect1"><a href="#objectstate-transitive">10.11. Persistance transitive</a></span></dt><dt><span class="sect1"><a href="#objectstate-metadata">10.12. Utilisation des m&eacute;ta-donn&eacute;es</a></span></dt></dl></dd><dt><span class="chapter"><a href="#transactions">11. Transactions et acc&egrave;s concurrents</a></span></dt><dd><dl><dt><span class="sect1"><a href="#transactions-basics">11.1. Gestion de session et d&eacute;limitation de transactions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-basics-uow">11.1.1. Unit&eacute; de travail</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-apptx">11.1.2. Longue conversation</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-identity">11.1.3. L'identit&eacute; des objets</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-issues">11.1.4. Probl&egrave;mes communs</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-demarcation">11.2. D&eacute;marcation des transactions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-demarcation-nonmanaged">11.2.1. Environnement non manag&eacute;</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-jta">11.2.2. Utilisation de JTA</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-exceptions">11.2.3. Gestion des exceptions</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-timeout">11.2.4. Timeout de transaction</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-optimistic">11.3. Contr&ocirc;le de consurrence optimiste</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-optimistic-manual">11.3.1. Gestion du versionnage au niveau applicatif</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-longsession">11.3.2. Les sessions longues et le versionnage automatique.</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-detached">11.3.3. Les objets d&eacute;tach&eacute;s et le versionnage automatique</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-customizing">11.3.4. Personnaliser le versionnage automatique</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-locking">11.4. Verouillage pessimiste</a></span></dt><dt><span class="sect1"><a href="#transactions-connection-release">11.5. Mode de lib&eacute;ration de Connection</a></span></dt></dl></dd><dt><span class="chapter"><a href="#events">12. Les intercepteurs et les &eacute;v&eacute;nements</a></span></dt><dd><dl><dt><span class="sect1"><a href="#objectstate-interceptors">12.1. Intercepteurs</a></span></dt><dt><span class="sect1"><a href="#objectstate-events">12.2. Syst&egrave;me d'&eacute;v&eacute;nements</a></span></dt><dt><span class="sect1"><a href="#objectstate-decl-security">12.3. S&eacute;curit&eacute; d&eacute;clarative d'Hibernate</a></span></dt></dl></dd><dt><span class="chapter"><a href="#batch">13. Traitement par paquet</a></span></dt><dd><dl><dt><span class="sect1"><a href="#batch-inserts">13.1. Insertions en paquet</a></span></dt><dt><span class="sect1"><a href="#batch-update">13.2. Paquet de mises &agrave; jour</a></span></dt><dt><span class="sect1"><a href="#batch-statelesssession">13.3. L'interface StatelessSession</a></span></dt><dt><span class="sect1"><a href="#batch-direct">13.4. Op&eacute;rations de style DML</a></span></dt></dl></dd><dt><span class="chapter"><a href="#queryhql">14. HQL: Langage de requ&ecirc;tage d'Hibernate</a></span></dt><dd><dl><dt><span class="sect1"><a href="#queryhql-casesensitivity">14.1. Sensibilit&eacute; &agrave; la casse</a></span></dt><dt><span class="sect1"><a href="#queryhql-from">14.2. La clause from</a></span></dt><dt><span class="sect1"><a href="#queryhql-joins">14.3. Associations et jointures</a></span></dt><dt><span class="sect1"><a href="#queryhql-joins-forms">14.4. Formes de syntaxes pour les jointures</a></span></dt><dt><span class="sect1"><a href="#queryhql-select">14.5. La clause select</a></span></dt><dt><span class="sect1"><a href="#queryhql-aggregation">14.6. Fonctions d'aggr&eacute;gation</a></span></dt><dt><span class="sect1"><a href="#queryhql-polymorphism">14.7. Requ&ecirc;tes polymorphiques</a></span></dt><dt><span class="sect1"><a href="#queryhql-where">14.8. La clause where</a></span></dt><dt><span class="sect1"><a href="#queryhql-expressions">14.9. Expressions</a></span></dt><dt><span class="sect1"><a href="#queryhql-ordering">14.10. La clause order by</a></span></dt><dt><span class="sect1"><a href="#queryhql-grouping">14.11. La clause group by</a></span></dt><dt><span class="sect1"><a href="#queryhql-subqueries">14.12. Sous-requ&ecirc;tes</a></span></dt><dt><span class="sect1"><a href="#queryhql-examples">14.13. Exemples HQL</a></span></dt><dt><span class="sect1"><a href="#queryhql-bulk">14.14. Mise &agrave; jour et suppression</a></span></dt><dt><span class="sect1"><a href="#queryhql-tipstricks">14.15. Trucs &amp; Astuces</a></span></dt></dl></dd><dt><span class="chapter"><a href="#querycriteria">15. Requ&ecirc;tes par crit&egrave;res</a></span></dt><dd><dl><dt><span class="sect1"><a href="#querycriteria-creating">15.1. Cr&eacute;er une instance de Criteria</a></span></dt><dt><span class="sect1"><a href="#querycriteria-narrowing">15.2. Restriction du r&eacute;sultat</a></span></dt><dt><span class="sect1"><a href="#querycriteria-ordering">15.3. Trier les r&eacute;sultats</a></span></dt><dt><span class="sect1"><a href="#querycriteria-associations">15.4. Associations</a></span></dt><dt><span class="sect1"><a href="#querycriteria-dynamicfetching">15.5. Peuplement d'associations de mani&egrave;re dynamique</a></span></dt><dt><span class="sect1"><a href="#querycriteria-examples">15.6. Requ&ecirc;tes par l'exemple</a></span></dt><dt><span class="sect1"><a href="#querycriteria-projection">15.7. Projections, agr&eacute;gation et regroupement</a></span></dt><dt><span class="sect1"><a href="#querycriteria-detachedqueries">15.8. Requ&ecirc;tes et sous-requ&ecirc;tes d&eacute;tach&eacute;es</a></span></dt><dt><span class="sect1"><a href="#query-criteria-naturalid">15.9. Requ&ecirc;tes par identifiant naturel</a></span></dt></dl></dd><dt><span class="chapter"><a href="#querysql">16. SQL natif</a></span></dt><dd><dl><dt><span class="sect1"><a href="#querysql-creating">16.1. Utiliser une SQLQuery</a></span></dt><dt><span class="sect1"><a href="#querysql-aliasreferences">16.2. Alias et r&eacute;f&eacute;rences de propri&eacute;t&eacute;</a></span></dt><dt><span class="sect1"><a href="#querysql-namedqueries">16.3. Requ&ecirc;tes SQL nomm&eacute;es</a></span></dt><dd><dl><dt><span class="sect2"><a href="#propertyresults">16.3.1. Utilisation de return-property pour sp&eacute;cifier explicitement les noms des colonnes/alias</a></span></dt><dt><span class="sect2"><a href="#sp_query">16.3.2. Utilisation de proc&eacute;dures stock&eacute;es pour les requ&ecirc;tes</a></span></dt><dd><dl><dt><span class="sect3"><a href="#querysql-limits-storedprocedures">16.3.2.1. R&egrave;gles/limitations lors de l'utilisation des proc&eacute;dures stock&eacute;es</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#querysql-cud">16.4. SQL personnalis&eacute; pour cr&eacute;er, mettre &agrave; jour et effacer</a></span></dt><dt><span class="sect1"><a href="#querysql-load">16.5. SQL personnalis&eacute; pour le chargement</a></span></dt></dl></dd><dt><span class="chapter"><a href="#filters">17. Filtrer les donn&eacute;es</a></span></dt><dd><dl><dt><span class="sect1"><a href="#objectstate-filters">17.1. Filtres Hibernate</a></span></dt></dl></dd><dt><span class="chapter"><a href="#xml">18. Mapping XML</a></span></dt><dd><dl><dt><span class="sect1"><a href="#xml-intro">18.1. Travailler avec des donn&eacute;es XML</a></span></dt><dd><dl><dt><span class="sect2"><a href="#xml-intro-mapping">18.1.1. Sp&eacute;cifier le mapping XML et le mapping d'une classe ensemble</a></span></dt><dt><span class="sect2"><a href="#xml-onlyxml">18.1.2. Sp&eacute;cifier seulement un mapping XML</a></span></dt></dl></dd><dt><span class="sect1"><a href="#xml-mapping">18.2. M&eacute;tadonn&eacute;es du mapping XML</a></span></dt><dt><span class="sect1"><a href="#xml-manipulation">18.3. Manipuler des donn&eacute;es XML</a></span></dt></dl></dd><dt><span class="chapter"><a href="#performance">19. Am&eacute;liorer les performances</a></span></dt><dd><dl><dt><span class="sect1"><a href="#performance-fetching">19.1. Strat&eacute;gies de chargement</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-fetching-lazy">19.1.1. Travailler avec des associations charg&eacute;es tardivement</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-custom">19.1.2. Personnalisation des strat&eacute;gies de chargement</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-proxies">19.1.3. Proxys pour des associations vers un seul objet</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-initialization">19.1.4. Initialisation des collections et des proxys</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-batch">19.1.5. Utiliser le chargement par lot</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-subselect">19.1.6. Utilisation du chargement par sous select</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-lazyproperties">19.1.7. Utiliser le chargement tardif des propri&eacute;t&eacute;s</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-cache">19.2. Le cache de second niveau</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-cache-mapping">19.2.1. Mapping de Cache</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readonly">19.2.2. Strategie : lecture seule</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readwrite">19.2.3. Strat&eacute;gie : lecture/&eacute;criture</a></span></dt><dt><span class="sect2"><a href="#performance-cache-nonstrict">19.2.4. Strat&eacute;gie : lecture/&eacute;criture non stricte</a></span></dt><dt><span class="sect2"><a href="#performance-cache-transactional">19.2.5. Strat&eacute;gie : transactionelle</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-sessioncache">19.3. G&eacute;rer les caches</a></span></dt><dt><span class="sect1"><a href="#performance-querycache">19.4. Le cache de requ&ecirc;tes</a></span></dt><dt><span class="sect1"><a href="#performance-collections">19.5. Comprendre les performances des Collections</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-collections-taxonomy">19.5.1. Classification</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficientupdate">19.5.2. Les lists, les maps, les idbags et les sets sont les collections les plus efficaces pour la mise &agrave; jour</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficentinverse">19.5.3. Les Bags et les lists sont les plus efficaces pour les collections inverse</a></span></dt><dt><span class="sect2"><a href="#performance-collections-oneshotdelete">19.5.4. Suppression en un coup</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-monitoring">19.6. Moniteur de performance</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-monitoring-sf">19.6.1. Suivi d'une SessionFactory</a></span></dt><dt><span class="sect2"><a href="#performance-monitoring-metrics">19.6.2. M&eacute;triques</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#toolsetguide">20. Guide des outils</a></span></dt><dd><dl><dt><span class="sect1"><a href="#toolsetguide-s1">20.1. G&eacute;n&eacute;ration automatique du sch&eacute;ma</a></span></dt><dd><dl><dt><span class="sect2"><a href="#toolsetguide-s1-2">20.1.1. Personnaliser le sch&eacute;ma</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-3">20.1.2. Ex&eacute;cuter l'outil</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-4">20.1.3. Propri&eacute;t&eacute;s</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-5">20.1.4. Utiliser Ant</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-6">20.1.5. Mises &agrave; jour incr&eacute;mentales du sch&eacute;ma</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-7">20.1.6. Utiliser Ant pour des mises &agrave; jour de sch&eacute;ma par incr&eacute;ment</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-9">20.1.7. Utiliser Ant pour la validation du Sch&eacute;ma</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#example-parentchild">21. Exemple : P&egrave;re/Fils</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-parentchild-collections">21.1. Une note &agrave; propos des collections</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-bidir">21.2. un-vers-plusieurs bidirectionnel</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-cascades">21.3. Cycle de vie en cascade</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-update">21.4. Cascades et unsaved-value</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-conclusion">21.5. Conclusion</a></span></dt></dl></dd><dt><span class="chapter"><a href="#example-weblog">22. Exemple : application Weblog</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-weblog-classes">22.1. Classes persistantes</a></span></dt><dt><span class="sect1"><a href="#example-weblog-mappings">22.2. Mappings Hibernate</a></span></dt><dt><span class="sect1"><a href="#example-weblog-code">22.3. Code Hibernate</a></span></dt></dl></dd><dt><span class="chapter"><a href="#example-mappings">23. Exemple : quelques mappings</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-mappings-emp">23.1. Employeur/Employ&eacute; (Employer/Employee)</a></span></dt><dt><span class="sect1"><a href="#example-mappings-authorwork">23.2. Auteur/Travail (Author/Work)</a></span></dt><dt><span class="sect1"><a href="#example-mappings-customerorderproduct">23.3. Client/Commande/Produit (Customer/Order/Product)</a></span></dt><dt><span class="sect1"><a href="#misc">23.4. Divers mappings d'exemple</a></span></dt><dd><dl><dt><span class="sect2"><a href="#example-mappings-typed-onetone">23.4.1. "Typed" one-to-one association</a></span></dt><dt><span class="sect2"><a href="#example-mappings-composite-key">23.4.2. Exemple de clef compos&eacute;e</a></span></dt><dt><span class="sect2"><a href="#example-mappings-composite-key-manytomany">23.4.3. Many-to-many avec une clef compos&eacute;e partag&eacute;e</a></span></dt><dt><span class="sect2"><a href="#example-mappings-content-discrimination">23.4.4. Contenu bas&eacute; sur une discrimination</a></span></dt><dt><span class="sect2"><a href="#example-mappings-association-alternatekeys">23.4.5. Associations sur des clefs altern&eacute;es</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#best-practices">24. Meilleures pratiques</a></span></dt></dl></div><div class="preface" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>Pr&eacute;face</h2></div></div><div></div></div><p>
            Traducteur(s): Vincent Ricard, Sebastien Cesbron, Michael Courcy, Vincent Gigu&egrave;re, Baptiste Mathus, Emmanuel Bernard, Anthony Patricio
        </p><p>
            Travailler dans les deux univers que sont l'orient&eacute; objet et la base de donn&eacute;es
            relationnelle peut &ecirc;tre lourd et consommateur en temps dans le monde de
            l'entreprise d'aujourd'hui. Hibernate est un outil de  mapping objet/relationnel
            pour le monde Java. Le terme mapping objet/relationnel (ORM) d&eacute;crit la technique
            consistant &agrave; faire le lien entre la repr&eacute;sentation objet des donn&eacute;es
            et sa repr&eacute;sentation relationnelle bas&eacute;e sur un sch&eacute;ma SQL.
        </p><p>
            Non seulement, Hibernate s'occupe du transfert des classes Java dans les tables
            de la base de donn&eacute;es (et des types de donn&eacute;es Java dans les types de donn&eacute;es SQL),
            mais il permet de requ&ecirc;ter les donn&eacute;es et propose des moyens de les r&eacute;cup&eacute;rer.
            Il peut donc r&eacute;duire de mani&egrave;re significative le temps de d&eacute;veloppement qui
            aurait &eacute;t&eacute; autrement perdu dans une manipulation manuelle des donn&eacute;es via SQL
            et JDBC.
        </p><p>
            Le but d'Hibernate est de lib&eacute;rer le d&eacute;veloppeur de 95 pourcent des t&acirc;ches de
            programmation li&eacute;es &agrave; la persistence des donn&eacute;es communes. Hibernate n'est
            probablement pas la meilleure solution pour les applications centr&eacute;es sur les
            donn&eacute;es qui n'utilisent que les proc&eacute;dures stock&eacute;es pour impl&eacute;menter la logique
            m&eacute;tier dans la base de donn&eacute;es, il est le plus utile dans les mod&egrave;les m&eacute;tier orient&eacute;s
            objets dont la logique m&eacute;tier est impl&eacute;ment&eacute;e dans la couche Java dite interm&eacute;diaire.
            Cependant, Hibernate vous aidera &agrave; supprimer ou &agrave; encapsuler le code SQL
            sp&eacute;cifique &agrave; votre base de donn&eacute;es et vous aidera sur la t&acirc;che commune qu'est
            la transformation des donn&eacute;es d'une repr&eacute;sentation tabulaire &agrave; une
            repr&eacute;sentation sous forme de graphe d'objets.
        </p><p>
            Si vous &ecirc;tes nouveau dans Hibernate et le mapping Objet/Relationnel voire m&ecirc;me en Java,
            suivez ces quelques &eacute;tapes :
        </p><div class="orderedlist"><ol type="1"><li><p>
                    Lisez <a href="#tutorial" title="Chapitre&nbsp;1.&nbsp;Introduction &agrave; Hibernate">Chapitre&nbsp;1, <i>Introduction &agrave; Hibernate</i></a> pour un didacticiel plus long avec plus d'instructions &eacute;tape par &eacute;tape.
                </p></li><li><p>
                    Lisez <a href="#architecture" title="Chapitre&nbsp;2.&nbsp;Architecture">Chapitre&nbsp;2, <i>Architecture</i></a> pour comprendre les environnements dans lesquels
                    Hibernate peut &ecirc;tre utilis&eacute;.
                </p></li><li><p>
                    Regardez le r&eacute;pertoire <tt class="literal">eg</tt> de la distribution Hibernate, il contient
                    une application simple et autonome. Copiez votre pilote JDBC dans le r&eacute;pertoire
                    <tt class="literal">lib/</tt> et &eacute;ditez <tt class="literal">src/hibernate.properties</tt>, en
                    positionnant correctement les valeurs pour votre base de donn&eacute;es. A partir d'une
                    invite de commande dans le r&eacute;pertoire de la distribution, tapez <tt class="literal">ant eg</tt>
                    (cela utilise Ant), ou sous Windows tapez <tt class="literal">build eg</tt>.
                </p></li><li><p>
                    Fa&icirc;tes de cette documentation de r&eacute;f&eacute;rence votre principale source d'information.
                    Pensez &agrave; lire <span class="emphasis"><em>Hibernate in Action</em></span>
                    (http://www.manning.com/bauer) si vous avez besoin de plus d'aide avec le design
                    d'applications ou si vous pr&eacute;f&eacute;rez un tutoriel pas &agrave; pas. Visitez aussi
                    http://caveatemptor.hibernate.org et t&eacute;l&eacute;chargez l'application exemple
                    pour Hibernate in Action.
                </p></li><li><p>
                    Les questions les plus fr&eacute;quemment pos&eacute;es (FAQs) trouvent leur r&eacute;ponse sur le
                    site web Hibernate.
                </p></li><li><p>
                    Des d&eacute;mos, exemples et tutoriaux de tierces personnes sont r&eacute;f&eacute;renc&eacute;s sur
                    le site web Hibernate.
                </p></li><li><p>
                    La zone communautaire (Community Area) du site web Hibernate est une
                    bonne source d'information sur les design patterns et sur diff&eacute;rentes
                    solutions d'int&eacute;gration d'Hibernate (Tomcat, JBoss, Spring Framework, Struts,
                    EJB, etc).
                </p></li></ol></div><p>
             Si vous avez des questions, utilisez le forum utilisateurs du site web Hibernate.
             Nous utilisons &eacute;galement l'outil de gestion des incidents JIRA pour tout ce qui
             est rapports de bogue et demandes d'&eacute;volution. Si vous &ecirc;tes int&eacute;ress&eacute; par le
             d&eacute;veloppement d'Hibernate, joignez-vous &agrave; la liste de diffusion de d&eacute;veloppement.
         </p><p>
             Le d&eacute;veloppement commercial, le support de production et les formations &agrave; Hibernate
             sont propos&eacute;s par JBoss Inc (voir http://www.hibernate.org/SupportTraining/). Hibernate
             est un projet Open Source professionnel et un composant critique de la suite de produits
             JBoss Enterprise Middleware System (JEMS).
         </p></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="tutorial"></a>Chapitre&nbsp;1.&nbsp;Introduction &agrave; Hibernate</h2></div></div><div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tutorial-intro"></a>1.1.&nbsp;Pr&eacute;face</h2></div></div><div></div></div><p>
            Ce chapitre est un didacticiel introductif destin&eacute; aux nouveaux utilisateurs
            d'Hibernate. Nous commen&ccedil;ons avec une simple application en ligne de commande
            utilisant une base de donn&eacute;es en m&eacute;moire, et la d&eacute;veloppons en &eacute;tapes faciles
            &agrave; comprendre.
        </p><p>
            Ce didacticiel est destin&eacute; aux nouveaux utilisateurs d'Hibernate mais requiert
            des connaissances Java et SQL. Il est bas&eacute; sur un didacticiel de Michael Gloegl,
            les biblioth&egrave;ques tierces que nous nommons sont pour les JDK 1.4 et 5.0. Vous
            pourriez avoir besoin d'autres biblioth&egrave;ques pour le JDK 1.3.
        </p><p>
            Le code source de ce tutoriel est inclus dans la distribution dans le r&eacute;pertoire
            <tt class="literal">doc/reference/tutorial/</tt>.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tutorial-firstapp"></a>1.2.&nbsp;Partie 1 - Premi&egrave;re application Hibernate</h2></div></div><div></div></div><p>
            D'abord, nous cr&eacute;erons une simple application Hibernate en console. Nous utilisons
            une base de donn&eacute;es en m&eacute;moire (HSQL DB), donc nous n'avons pas &agrave; installer de
            serveur de base de donn&eacute;es.
        </p><p>
            Supposons que nous ayons besoin d'une petite application de base de donn&eacute;es qui
            puisse stocker des &eacute;v&eacute;nements que nous voulons suivre, et des informations &agrave; propos
            des h&ocirc;tes de ces &eacute;v&eacute;nements.
        </p><p>
            La premi&egrave;re chose que nous faisons est de configurer notre r&eacute;pertoire de
            d&eacute;veloppement et de mettre toutes les biblioth&egrave;ques dont nous avons besoin dedans.
            T&eacute;l&eacute;chargez la distribution Hibernate &agrave; partir du site web d'Hibernate.
            Extrayez le paquet et placez toutes les biblioth&egrave;ques requises trouv&eacute;es dans
            <tt class="literal">/lib</tt> dans le r&eacute;pertoire <tt class="literal">/lib</tt> de votre
            nouveau r&eacute;pertoire de travail. Il devrait ressembler &agrave; &ccedil;a :
        </p><pre class="programlisting">.
+lib
  antlr.jar
  cglib-full.jar
  asm.jar
  asm-attrs.jars
  commons-collections.jar
  commons-logging.jar
  ehcache.jar
  hibernate3.jar
  jta.jar
  dom4j.jar
  log4j.jar </pre><p>
            Ceci est l'ensemble minimum de biblioth&egrave;ques requises (notez que nous avons aussi
            copi&eacute; hibernate3.jar, l'archive principale) pour Hibernate. Lisez le fichier
            <tt class="literal">README.txt</tt> dans le r&eacute;pertoire <tt class="literal">lib/</tt> de la
            distribution Hibernate pour plus d'informations &agrave; propos des bilioth&egrave;ques tierces
            requises et optionnelles. (En fait, log4j n'est pas requis mais pr&eacute;f&eacute;r&eacute; par beaucoup
            de d&eacute;veloppeurs.)
        </p><p>
            Ensuite, nous cr&eacute;ons une classe qui r&eacute;pr&eacute;sente l'&eacute;v&eacute;nement que nous voulons
            stocker dans notre base de donn&eacute;es.
        </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-firstapp-firstclass"></a>1.2.1.&nbsp;La premi&egrave;re classe</h3></div></div><div></div></div><p>
                Notre premi&egrave;re classe persistante est une simple classe JavaBean avec
                quelques propri&eacute;t&eacute;s :
            </p><pre class="programlisting">package events;

import java.util.Date;

public class Event {
    private Long id;

    private String title;
    private Date date;

    public Event() {}

    public Long getId() {
        return id;
    }

    private void setId(Long id) {
        this.id = id;
    }

    public Date getDate() {
        return date;
    }

    public void setDate(Date date) {
        this.date = date;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }
}</pre><p>
                Vous pouvez voir que cette classe utilise les conventions de nommage standard JavaBean
                pour les m&eacute;thodes getter/setter des propri&eacute;t&eacute;s, ainsi qu'une visibilit&eacute; priv&eacute;e
                pour les champs. Ceci est la conception recommand&eacute;e - mais pas obligatoire. Hibernate peut
                aussi acc&eacute;der aux champs directement, le b&eacute;n&eacute;fice des m&eacute;thodes d'acc&egrave;s est la robustesse
                pour la refonte de code. Le constructeur sans argument est requis pour instancier
                un objet de cette classe via reflexion.
            </p><p>
                La propri&eacute;t&eacute; <tt class="literal">id</tt> contient la valeur d'un identifiant unique pour un
                &eacute;v&eacute;nement particulier. Toutes les classes d'entit&eacute;s persistantes (ainsi que les classes
                d&eacute;pendantes de moindre importance) auront besoin d'une telle propri&eacute;t&eacute; identifiante si nous
                voulons utiliser l'ensemble complet des fonctionnalit&eacute;s d'Hibernate. En fait, la plupart des
                applications (surtout les applications web) ont besoin de distinguer des objets par des
                identifiants, donc vous devriez consid&eacute;rer &ccedil;a comme une fonctionnalit&eacute; plut&ocirc;t que comme une
                limitation. Cependant, nous ne manipulons g&eacute;n&eacute;ralement pas l'identit&eacute; d'un objet, dor&eacute;navant
                la m&eacute;thode setter devrait &ecirc;tre priv&eacute;e. Seul Hibernate assignera les identifiants lorsqu'un
                objet est sauvegard&eacute;. Vous pouvez voir qu'Hibernate peut acc&eacute;der aux m&eacute;thodes publiques,
                priv&eacute;es et prot&eacute;g&eacute;es, ainsi qu'aux champs (publics, priv&eacute;s, prot&eacute;g&eacute;s) directement. Le choix
                vous est laiss&eacute;, et vous pouvez l'ajuster &agrave; la conception de votre application.
            </p><p>
                Le constructeur sans argument est requis pour toutes les classes persistantes ;
                Hibernate doit cr&eacute;er des objets pour vous en utilisant la r&eacute;flexion Java. Le
                constructeur peut &ecirc;tre priv&eacute;, cependant, la visibilit&eacute; du paquet est requise
                pour la g&eacute;n&eacute;ration de proxy &agrave; l'ex&eacute;cution et une r&eacute;cup&eacute;ration des donn&eacute;es efficaces
                sans instrumentation du bytecode.
            </p><p>
                Placez ce fichier source Java dans un r&eacute;pertoire appel&eacute; <tt class="literal">src</tt>
                dans le dossier de d&eacute;veloppement. Ce r&eacute;pertoire devrait maintenant ressembler
                &agrave; &ccedil;a :
            </p><pre class="programlisting">.
+lib
  &lt;Hibernate et biblioth&egrave;ques tierces&gt;
+src
  +events
    Event.java</pre><p>
                Dans la prochaine &eacute;tape, nous informons Hibernate de cette classe persistante.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-firstapp-mapping"></a>1.2.2.&nbsp;Le fichier de mapping</h3></div></div><div></div></div><p>
                Hibernate a besoin de savoir comment charger et stocker des objets d'une classe
                persistante. C'est l&agrave; qu'intervient le fichier de mapping Hibernate. Le fichier
                de mapping indique &agrave; Hibernate &agrave; quelle table dans la base de donn&eacute;es il doit
                acc&eacute;der, et quelles colonnes de cette table il devra utiliser.
            </p><p>
                La structure basique de ce fichier de mapping ressemble &agrave; &ccedil;a :
            </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping&gt;
[...]
&lt;/hibernate-mapping&gt;</pre><p>
                Notez que la DTD Hibernate est tr&egrave;s sophistiqu&eacute;e. Vous pouvez l'utiliser
                pour l'auto-compl&eacute;tement des &eacute;l&eacute;ments et des attributs de mapping XML dans
                votre &eacute;diteur ou votre IDE. Vous devriez aussi ouvrir le fichier DTD dans
                votre &eacute;diteur de texte - c'est le moyen le plus facile d'obtenir une vue
                d'ensemble de tous les &eacute;l&eacute;ments et attributs, et de voir les valeurs par
                d&eacute;faut, ainsi que quelques commentaires. Notez qu'Hibernate ne chargera
                pas le fichier DTD &agrave; partir du web, mais regardera d'abord dans le classpath
                de l'application. Le fichier DTD est inclus dans <tt class="literal">hibernate3.jar</tt>
                ainsi que dans le r&eacute;pertoire <tt class="literal">src</tt> de la distribution
                Hibernate.
            </p><p>
                Nous omettrons la d&eacute;claration de la DTD dans les exemples futurs pour
                raccourcir le code. Bien s&ucirc;r il n'est pas optionnel.
            </p><p>
                Entre les deux balises <tt class="literal">hibernate-mapping</tt>, incluez un
                &eacute;l&eacute;ment <tt class="literal">class</tt>. Toutes les classes d'entit&eacute;s persistantes
                (encore une fois, il pourrait y avoir des classes d&eacute;pendantes plus tard,
                qui ne sont pas des entit&eacute;s m&egrave;re) ont besoin d'un mapping vers une table
                de la base de donn&eacute;es SQL :
            </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Event" table="EVENTS"&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
                Plus loin, nous disons &agrave; Hibernate comment persister et charger un objet de la classe
                <tt class="literal">Event</tt> dans la table <tt class="literal">EVENTS</tt>, chaque instance est
                repr&eacute;sent&eacute;e par une ligne dans cette table. Maintenant nous continuons avec le mapping de
                la propri&eacute;t&eacute; de l'identifiant unique vers la clef primaire de la table. De plus, comme
                nous ne voulons pas nous occuper de la gestion de cet identifiant, nous utilisons une
                strat&eacute;gie de g&eacute;n&eacute;ration d'identifiant d'Hibernate pour la colonne de la clef primaire
                subrog&eacute;e :
            </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Event" table="EVENTS"&gt;
        &lt;id name="id" column="EVENT_ID"&gt;
            &lt;generator class="increment"/&gt;
        &lt;/id&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
                L'&eacute;l&eacute;ment <tt class="literal">id</tt> est la d&eacute;claration de la propri&eacute;t&eacute; de l'identifiant,
                <tt class="literal">name="id"</tt> d&eacute;clare le nom de la propri&eacute;t&eacute; Java - Hibernate
                utilisera les m&eacute;thodes getter et setter pour acc&eacute;der &agrave; la propri&eacute;t&eacute;. L'attribut
                <tt class="literal">column</tt> indique &agrave; Hibernate quelle colonne de la table
                <tt class="literal">EVENTS</tt> nous utilisons pour cette clef primaire. L'&eacute;l&eacute;ment
                <tt class="literal">generator</tt> imbriqu&eacute; sp&eacute;cifie la strat&eacute;gie de g&eacute;n&eacute;ration de
                l'identifiant, dans ce cas nous avons utilis&eacute; <tt class="literal">increment</tt>,
                laquelle est une m&eacute;thode tr&egrave;s simple utile surtout pour les tests
                (et didacticiels). Hibernate supporte aussi les identifiants g&eacute;n&eacute;r&eacute;s par les
                bases de donn&eacute;es, globalement uniques, ainsi que les identifiants assign&eacute;s par
                l'application (ou n'importe quelle strat&eacute;gie que vous avez &eacute;crit en extension).
            </p><p>
                Finalement nous incluons des d&eacute;clarations pour les propri&eacute;t&eacute;s persistantes de la classe
                dans le fichier de mapping. Par d&eacute;faut, aucune propri&eacute;t&eacute; de la classe n'est consid&eacute;r&eacute;e
                comme persistante :
            </p><pre class="programlisting">
&lt;hibernate-mapping&gt;

    &lt;class name="Event" table="EVENTS"&gt;
        &lt;id name="id" column="EVENT_ID"&gt;
            &lt;generator class="increment"/&gt;
        &lt;/id&gt;
        &lt;property name="date" type="timestamp" column="EVENT_DATE"/&gt;
        &lt;property name="title"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
                Comme avec l'&eacute;l&eacute;ment <tt class="literal">id</tt>, l'attribut <tt class="literal">name</tt>
                de l'&eacute;l&eacute;ment <tt class="literal">property</tt> indique &agrave; Hibernate quels getters/setters
                utiliser.
            </p><p>
                Pourquoi le mapping de la propri&eacute;t&eacute; <tt class="literal">date</tt> inclut
                l'attribut <tt class="literal">column</tt>, mais pas <tt class="literal">title</tt> ?
                Sans l'attribut <tt class="literal">column</tt> Hibernate utilise par d&eacute;faut
                le nom de la propri&eacute;t&eacute; comme nom de colonne. Ca fonctionne bien pour
                <tt class="literal">title</tt>. Cependant, <tt class="literal">date</tt> est un mot clef
                r&eacute;serv&eacute; dans la plupart des bases de donn&eacute;es, donc nous utilisons un nom
                diff&eacute;rent pour le mapping.
            </p><p>
                La prochaine chose int&eacute;ressante est que le mapping de <tt class="literal">title</tt>
                manque aussi d'un attribut <tt class="literal">type</tt>. Les types que nous d&eacute;clarons
                et utilisons dans les fichiers de mapping ne sont pas, comme vous pourriez vous
                y attendre, des types de donn&eacute;es Java. Ce ne sont pas, non plus, des types de
                base de donn&eacute;es SQL. Ces types sont donc appel&eacute;s des <span class="emphasis"><em>types de mapping
                Hibernate</em></span>, des convertisseurs qui peuvent traduire des types Java en
                types SQL et vice versa. De plus, Hibernate tentera de d&eacute;terminer la bonne conversion
                et le type de mapping lui-m&ecirc;me si l'attribut <tt class="literal">type</tt> n'est pas
                pr&eacute;sent dans le mapping. Dans certains cas, cette d&eacute;tection automatique (utilisant
                la r&eacute;flexion sur la classe Java) pourrait ne pas donner la valeur attendue ou
                dont vous avez besoin. C'est le cas avec la propri&eacute;t&eacute; <tt class="literal">date</tt>.
                Hibernate ne peut pas savoir si la propri&eacute;t&eacute; "mappera" une colonne SQL de type
                <tt class="literal">date</tt>, <tt class="literal">timestamp</tt> ou <tt class="literal">time</tt>.
                Nous d&eacute;clarons que nous voulons conserver des informations avec une date compl&egrave;te
                et l'heure en mappant la propri&eacute;t&eacute; avec un <tt class="literal">timestamp</tt>.
            </p><p>
                Ce fichier de mapping devrait &ecirc;tre sauvegard&eacute; en tant que <tt class="literal">Event.hbm.xml</tt>,
                juste dans le r&eacute;pertoire &agrave; c&ocirc;t&eacute; du fichier source de la classe Java <tt class="literal">Event</tt>.
                Le nommage des fichiers de mapping peut &ecirc;tre arbitraire, cependant le suffixe
                <tt class="literal">hbm.xml</tt> est devenu une convention dans la communaut&eacute; des
                d&eacute;veloppeurs Hibernate. La structure du r&eacute;pertoire devrait ressembler &agrave; &ccedil;a :
            </p><pre class="programlisting">.
+lib
  &lt;Hibernate et biblioth&egrave;ques tierces&gt;
+src
  Event.java
  Event.hbm.xml</pre><p>
                 Nous poursuivons avec la configuration principale d'Hibernate.
             </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-firstapp-configuration"></a>1.2.3.&nbsp;Configuration d'Hibernate</h3></div></div><div></div></div><p>
                Nous avons maintenant une classe persistante et son fichier de mapping. Il est temps de
                configurer Hibernate. Avant &ccedil;a, nous avons besoin d'une base de donn&eacute;es. HSQL DB, un
                SGBD SQL bas&eacute; sur Java et travaillant en m&eacute;moire, peut &ecirc;tre t&eacute;l&eacute;charg&eacute; &agrave; partir du site
                web de HSQL. En fait, vous avez seulement besoin de <tt class="literal">hsqldb.jar</tt>. Placez
                ce fichier dans le r&eacute;pertoire <tt class="literal">lib/</tt> du dossier de d&eacute;veloppement.
            </p><p>
                Cr&eacute;ez un r&eacute;pertoire appel&eacute; <tt class="literal">data</tt> &agrave; la racine du r&eacute;pertoire de d&eacute;veloppement - 
                c'est l&agrave; que HSQL DB stockera ses fichiers de donn&eacute;es. D&eacute;marrez maintenant votre base de donn&eacute;es
                en ex&eacute;cutant <tt class="literal">java -classpath lib/hsqldb.jar org.hsqldb.Server</tt> dans votre r&eacute;pertoire de travail.
                Vous observez qu'elle d&eacute;marre et ouvre une socket TCP/IP, c'est l&agrave; que notre application
                se connectera plus tard. Si vous souhaitez d&eacute;marrez &agrave; partir d'une nouvelle base de donn&eacute;es
                pour ce tutoriel (faites <tt class="literal">CTRL + C</tt> dans la fen&ecirc;tre the window), effacez
                le r&eacute;pertoire <tt class="literal">data/</tt> et red&eacute;marrez HSQL DB &agrave; nouveau.
                
            </p><p>
                Hibernate est la couche de votre application qui se connecte &agrave; cette base de donn&eacute;es,
                donc il a besoin des informations de connexion. Les connexions sont &eacute;tablies &agrave; travers
                un pool de connexions JDBC, que nous devons aussi configurer. La distribution Hibernate
                contient diff&eacute;rents outils de gestion de pools de connexions JDBC open source, mais
                pour ce didacticiel nous utiliserons le pool de connexions int&eacute;gr&eacute; &agrave; Hibernate. Notez
                que vous devez copier les biblioth&egrave;ques requises dans votre classpath et utiliser
                une configuration de pool de connexions diff&eacute;rente si vous voulez utiliser
                un logiciel de gestion de pools JDBC tiers avec une qualit&eacute; de production.
            </p><p>
                Pour la configuration d'Hibernate, nous pouvons utiliser un simple fichier
                <tt class="literal">hibernate.properties</tt>, un fichier <tt class="literal">hibernate.cfg.xml</tt>
                l&eacute;g&egrave;rement plus sophistiqu&eacute;, ou m&ecirc;me une configuration compl&egrave;te par programmation. La
                plupart des utilisateurs pr&eacute;f&egrave;rent le fichier de configuration XML :
            </p><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;

&lt;hibernate-configuration&gt;

    &lt;session-factory&gt;

        &lt;!-- Database connection settings --&gt;
        &lt;property name="connection.driver_class"&gt;org.hsqldb.jdbcDriver&lt;/property&gt;
        &lt;property name="connection.url"&gt;jdbc:hsqldb:hsql://localhost&lt;/property&gt;
        &lt;property name="connection.username"&gt;sa&lt;/property&gt;
        &lt;property name="connection.password"&gt;&lt;/property&gt;

        &lt;!-- JDBC connection pool (use the built-in) --&gt;
        &lt;property name="connection.pool_size"&gt;1&lt;/property&gt;

        &lt;!-- SQL dialect --&gt;
        &lt;property name="dialect"&gt;org.hibernate.dialect.HSQLDialect&lt;/property&gt;

        &lt;!-- Enable Hibernate's automatic session context management --&gt;
        &lt;property name="current_session_context_class"&gt;thread&lt;/property&gt;

        &lt;!-- Disable the second-level cache  --&gt;
        &lt;property name="cache.provider_class"&gt;org.hibernate.cache.NoCacheProvider&lt;/property&gt;

        &lt;!-- Echo all executed SQL to stdout --&gt;
        &lt;property name="show_sql"&gt;true&lt;/property&gt;

        &lt;!-- Drop and re-create the database schema on startup --&gt;
        &lt;property name="hbm2ddl.auto"&gt;create&lt;/property&gt;

        &lt;mapping resource="events/Event.hbm.xml"/&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre><p>
                Notez que cette configuration XML utilise une DTD diff&eacute;rente. Nous configurons
                une <tt class="literal">SessionFactory</tt> d'Hibernate - une fabrique globale responsable
                d'une base de donn&eacute;es particuli&egrave;re. Si vous avez plusieurs base de donn&eacute;es, utilisez
                plusieurs configurations <tt class="literal">&lt;session-factory&gt;</tt>, g&eacute;n&eacute;ralement
                dans des fichiers de configuration diff&eacute;rents (pour un d&eacute;marrage plus facile).
            </p><p>
                Les quatre premiers &eacute;l&eacute;ments <tt class="literal">property</tt> contiennent la configuration
                n&eacute;cessaire pour la connexion JDBC. L'&eacute;l&eacute;ment <tt class="literal">property</tt> du dialecte
                sp&eacute;cifie quelle variante du SQL Hibernate va g&eacute;n&eacute;rer.  La gestion automatique des sessions
                d'Hibernate pour les contextes de persistance sera d&eacute;taill&eacute;e tr&egrave;s vite.
                L'option <tt class="literal">hbm2ddl.auto</tt> active la g&eacute;n&eacute;ration automatique des sch&eacute;mas de
                base de donn&eacute;es - directement dans la base de donn&eacute;es. Cela peut bien s&ucirc;r aussi &ecirc;tre
                d&eacute;sactiv&eacute; (en supprimant l'option de configuration) ou redirig&eacute; vers un fichier avec
                l'aide de la t&acirc;che Ant <tt class="literal">SchemaExport</tt>. Finalement, nous ajoutons
                le(s) fichier(s) de mapping pour les classes persistantes.
            </p><p>
                Copiez ce fichier dans le r&eacute;pertoire source, il terminera dans la racine
                du classpath. Hibernate cherchera automatiquement, au d&eacute;marrage, un fichier appel&eacute;
                <tt class="literal">hibernate.cfg.xml</tt> dans la racine du classpath.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-firstapp-ant"></a>1.2.4.&nbsp;Construction avec Ant</h3></div></div><div></div></div><p>
                Nous allons maintenant construire le didacticiel avec Ant. Vous aurez besoin d'avoir Ant
                d'install&eacute; - r&eacute;cup&eacute;rez-le &agrave; partir de <a href="http://ant.apache.org/bindownload.cgi" target="_top"> la page
                de t&eacute;l&eacute;chargement de Ant</a>. Comment installer Ant ne sera pas couvert ici. R&eacute;f&eacute;rez-vous
                au <a href="http://ant.apache.org/manual/index.html" target="_top">manuel d'Ant</a>. Apr&egrave;s que
                vous aurez install&eacute; Ant, nous pourrons commencer &agrave; cr&eacute;er le fichier de construction. Il
                s'appellera <tt class="literal">build.xml</tt> et sera plac&eacute; directement dans le r&eacute;pertoire de
                d&eacute;veloppement.
            </p><p>
                Un fichier de construction basique ressemble &agrave; &ccedil;a :
            </p><pre class="programlisting">&lt;project name="hibernate-tutorial" default="compile"&gt;

    &lt;property name="sourcedir" value="${basedir}/src"/&gt;
    &lt;property name="targetdir" value="${basedir}/bin"/&gt;
    &lt;property name="librarydir" value="${basedir}/lib"/&gt;

    &lt;path id="libraries"&gt;
        &lt;fileset dir="${librarydir}"&gt;
            &lt;include name="*.jar"/&gt;
        &lt;/fileset&gt;
    &lt;/path&gt;

    &lt;target name="clean"&gt;
        &lt;delete dir="${targetdir}"/&gt;
        &lt;mkdir dir="${targetdir}"/&gt;
    &lt;/target&gt;

    &lt;target name="compile" depends="clean, copy-resources"&gt;
      &lt;javac srcdir="${sourcedir}"
             destdir="${targetdir}"
             classpathref="libraries"/&gt;
    &lt;/target&gt;

    &lt;target name="copy-resources"&gt;
        &lt;copy todir="${targetdir}"&gt;
            &lt;fileset dir="${sourcedir}"&gt;
                &lt;exclude name="**/*.java"/&gt;
            &lt;/fileset&gt;
        &lt;/copy&gt;
    &lt;/target&gt;

&lt;/project&gt;</pre><p>
                Cela dira &agrave; Ant d'ajouter tous les fichiers du r&eacute;pertoire lib finissant par
                <tt class="literal">.jar</tt> dans le classpath utilis&eacute; pour la compilation. Cela copiera aussi
                tous les fichiers source non Java dans le r&eacute;pertoire cible, par exemple les fichiers de
                configuration et de mapping d'Hibernate. Si vous lancez Ant maintenant, vous devriez
                obtenir cette sortie :
            </p><pre class="programlisting">C:\hibernateTutorial\&gt;ant
Buildfile: build.xml

copy-resources:
     [copy] Copying 2 files to C:\hibernateTutorial\bin

compile:
    [javac] Compiling 1 source file to C:\hibernateTutorial\bin

BUILD SUCCESSFUL
Total time: 1 second </pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-firstapp-helpers"></a>1.2.5.&nbsp;D&eacute;marrage et aides</h3></div></div><div></div></div><p>
                Il est temps de charger et de stocker quelques objets <tt class="literal">Event</tt>,
                mais d'abord nous devons compl&eacute;ter la configuration avec du code
                d'infrastructure. Nous devons d&eacute;marrer Hibernate. Ce d&eacute;marrage inclut la construction
                d'un objet <tt class="literal">SessionFactory</tt> global et le stocker quelque part
                facile d'acc&egrave;s dans le code de l'application. Une <tt class="literal">SessionFactory</tt>
                peut ouvrir des nouvelles <tt class="literal">Session</tt>s. Une <tt class="literal">Session</tt>
                repr&eacute;sente une unit&eacute; de travail simplement "thread&eacute;e", la <tt class="literal">SessionFactory</tt>
                est un objet global "thread-safe", instanci&eacute; une seule fois.
            </p><p>
                Nous cr&eacute;erons une classe d'aide <tt class="literal">HibernateUtil</tt> qui s'occupe du
                d&eacute;marrage et rend la gestion des <tt class="literal">Session</tt>s plus facile. 
                Regardons l'impl&eacute;mentation :
            </p><pre class="programlisting">package util;

import org.hibernate.*;
import org.hibernate.cfg.*;

public class HibernateUtil {
    public static final SessionFactory sessionFactory;

    static {
        try {
            // Cr&eacute;ation de la SessionFactory &agrave; partir de hibernate.cfg.xml
            sessionFactory = new Configuration().configure().buildSessionFactory();
        } catch (Throwable ex) {
            // Make sure you log the exception, as it might be swallowed
            System.err.println("Initial SessionFactory creation failed." + ex);
            throw new ExceptionInInitializerError(ex);
        }
    }

    public static final ThreadLocal session = new ThreadLocal();

    public static SessionFactory getSessionFactory() {
        return sessionFactory;
    }
}</pre><p>
                Cette classe ne produit pas seulement la <tt class="literal">SessionFactory</tt> globale
                dans un initialiseur statique (appel&eacute; une seule fois par la JVM lorsque la classe
                est charg&eacute;e), elle masque le fait qu'elle exploite un singleton. Elle pourrait aussi
                obtenir la <tt class="literal">SessionFactory</tt> depuis JNDI dans un serveur d'applications.
            </p><p>
                Si vous nommez la <tt class="literal">SessionFactory</tt> dans votre fichier de configuration,
                Hibernate tentera la r&eacute;cup&eacute;ration depuis JNDI. Pour &eacute;viter ce code, vous pouvez aussi
                utiliser un d&eacute;ploiement JMX et laisser le conteneur (compatible JMX) instancier et lier
                un <tt class="literal">HibernateService</tt> &agrave; JNDI. Ces options avanc&eacute;es sont d&eacute;taill&eacute;es dans
                la documentation de r&eacute;f&eacute;rence Hibernate.
            </p><p>
                Placez <tt class="literal">HibernateUtil.java</tt> dans le r&eacute;pertoire source de d&eacute;veloppement,
                et ensuite <tt class="literal">Event.java</tt> :
            </p><pre class="programlisting">.
+lib
  &lt;Hibernate and third-party libraries&gt;
+src
  +events
    Event.java
    Event.hbm.xml
  +util
    HibernateUtil.java
  hibernate.cfg.xml
+data
build.xml</pre><p>
                Cela devrait encore compiler sans probl&egrave;me. Nous avons finalement besoin de configurer
                le syst&egrave;me de "logs" - Hibernate utilise commons-logging et vous laisse le choix entre
                log4j et le syst&egrave;me de logs du JDK 1.4. La plupart des d&eacute;veloppeurs pr&eacute;f&egrave;rent log4j :
                copiez <tt class="literal">log4j.properties</tt> de la distribution d'Hibernate (il est dans
                le r&eacute;pertoire <tt class="literal">etc/</tt>) dans votre r&eacute;pertoire <tt class="literal">src</tt>,
                puis faites de m&ecirc;me avec <tt class="literal">hibernate.cfg.xml</tt>. Regardez la configuration
                d'exemple et changez les param&egrave;tres si vous voulez une sortie plus verbeuse. Par d&eacute;faut,
                seul le message de d&eacute;marrage d'Hibernate est affich&eacute; sur la sortie standard.
            </p><p>
                L'infrastructure de ce didacticiel est compl&egrave;te - et nous sommes pr&ecirc;ts &agrave; effectuer un
                travail r&eacute;el avec Hibernate.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-firstapp-workingpersistence"></a>1.2.6.&nbsp;Charger et stocker des objets</h3></div></div><div></div></div><p>
                Finalement nous pouvons utiliser Hibernate pour charger et stocker des objets.
                Nous &eacute;crivons une classe <tt class="literal">EventManager</tt> avec une m&eacute;thode
                <tt class="literal">main()</tt> :
            </p><pre class="programlisting">package events;
import org.hibernate.Session;

import java.util.Date;

import util.HibernateUtil;

public class EventManager {

    public static void main(String[] args) {
        EventManager mgr = new EventManager();

        if (args[0].equals("store")) {
            mgr.createAndStoreEvent("My Event", new Date());
        }

        HibernateUtil.getSessionFactory().close();
    }

    private void createAndStoreEvent(String title, Date theDate) {

        Session session = HibernateUtil.getSessionFactory().getCurrentSession();

        session.beginTransaction();

        Event theEvent = new Event();
        theEvent.setTitle(title);
        theEvent.setDate(theDate);

        session.save(theEvent);

        session.getTransaction().commit();
    }</pre><p>
                Nous cr&eacute;ons un nouvel objet <tt class="literal">Event</tt>, et le remettons &agrave; Hibernate.
                Hibernate s'occupe maintenant du SQL et ex&eacute;cute les <tt class="literal">INSERT</tt>s
                dans la base de donn&eacute;es. Regardons le code de gestion de la <tt class="literal">Session</tt>
                et de la <tt class="literal">Transaction</tt> avant de lancer &ccedil;a.
            </p><p>
                Une <tt class="literal">Session</tt> est une unit&eacute; de travail. Pour le moment, nous allons faire
                les choses simplement et assumer une granularit&eacute; un-un entre une <tt class="literal">Session</tt>
                hibernate et une transaction &agrave; la base de donn&eacute;es. Pour isoler notre code du syst&egrave;me de transaction
                sous-jacent (dans notre cas, du pure JDBC, mais cela pourrait &ecirc;tre JTA), nous utilisons l'API
                <tt class="literal">Transaction</tt> qui est disponible depuis la <tt class="literal">Session</tt> Hibernate.
            </p><p>
                Que fait <tt class="literal">sessionFactory.getCurrentSession()</tt> ? Premi&egrave;rement, vous pouvez
                l'invoquer autant de fois que vous le voulez et n'importe o&ugrave; du moment que vous avez votre
                <tt class="literal">SessionFactory</tt> (facile gr&acirc;ce &agrave; <tt class="literal">HibernateUtil</tt>). 
                La m&eacute;thode <tt class="literal">getCurrentSession()</tt> renvoie toujours l'unit&eacute; de travail courante.
                Souvenez vous que nous avons bascul&eacute; notre option de configuration au m&eacute;canisme bas&eacute; sur le "thread"
                dans <tt class="literal">hibernate.cfg.xml</tt>. Par cons&eacute;quent, le scope de l'unit&eacute; de travail
                courante est le thread java courant d'ex&eacute;cution. Ceci n'est pas totalement vrai. Une
                <tt class="literal">Session</tt> commence lorsqu'elle est vraiment utilis&eacute;e la premi&egrave;re fois,
                Lorsque nous appelons pour la premi&egrave;re fois <tt class="literal">getCurrentSession()</tt>.
                Ensuite, elle est li&eacute;e, par Hibernate, au thread courant. Lorsque la transaction s'ach&egrave;ve
                (commit ou rollback), Hibernate d&eacute;lie la <tt class="literal">Session</tt> du thread et la ferme
                pour vous. Si vous invoquez <tt class="literal">getCurrentSession()</tt> une autre fois, vous obtenez
                une nouvelle <tt class="literal">Session</tt> et pouvez entamer une nouvelle unit&eacute; de travail.
                Ce mod&egrave;le de programmation "<span class="emphasis"><em>thread-bound</em></span>" est le moyen le plus 
                populaire d'utiliser Hibernate.
            </p><p>
                Lisez <a href="#transactions" title="Chapitre&nbsp;11.&nbsp;Transactions et acc&egrave;s concurrents">Chapitre&nbsp;11, <i>Transactions et acc&egrave;s concurrents</i></a> pour plus d'informations sur la gestion des transactions et leur d&eacute;marcations.
                Nous n'avons pas g&eacute;r&eacute; les erreurs et rollback sur l'exemple pr&eacute;c&eacute;dent.
            </p><p>
                Pour lancer cette premi&egrave;re routine, nous devons ajouter une cible appelable dans
                le fichier de construction de Ant :
            </p><pre class="programlisting">&lt;target name="run" depends="compile"&gt;
    &lt;java fork="true" classname="events.EventManager" classpathref="libraries"&gt;
        &lt;classpath path="${targetdir}"/&gt;
        &lt;arg value="${action}"/&gt;
    &lt;/java&gt;
&lt;/target&gt;</pre><p>
                La valeur de l'argument <tt class="literal">action</tt> correspond &agrave; la ligne de commande
                qui appelle la cible :
            </p><pre class="programlisting">C:\hibernateTutorial\&gt;ant run -Daction=store</pre><p>
                Vous devriez voir, apr&egrave;s la compilation, Hibernate d&eacute;marrer et, en fonction de votre
                configuration, beaucoup de traces sur la sortie. &Agrave; la fin vous trouverez la ligne suivante :
            </p><pre class="programlisting">[java] Hibernate: insert into EVENTS (EVENT_DATE, title, EVENT_ID) values (?, ?, ?)</pre><p>
                C'est l'<tt class="literal">INSERT</tt> ex&eacute;cut&eacute; par Hibernate, les points d'interrogation
                repr&eacute;sentent les param&egrave;tres JDBC li&eacute;s. Pour voir les valeurs li&eacute;es aux arguments, ou
                pour r&eacute;duire la verbosit&eacute; des traces, v&eacute;rifier votre <tt class="literal">log4j.properties</tt>.
            </p><p>
                Maintenant nous aimerions aussi lister les &eacute;v&eacute;nements stock&eacute;s, donc nous ajoutons une
                option &agrave; la m&eacute;thode principale :
            </p><pre class="programlisting">if (args[0].equals("store")) {
    mgr.createAndStoreEvent("My Event", new Date());
}
else if (args[0].equals("list")) {
    List events = mgr.listEvents();
    for (int i = 0; i &lt; events.size(); i++) {
        Event theEvent = (Event) events.get(i);
        System.out.println("Event: " + theEvent.getTitle() +
                           " Time: " + theEvent.getDate());
    }
}</pre><p>
                Nous ajoutons aussi une nouvelle m&eacute;thode <tt class="literal">listEvents()</tt> :
            </p><pre class="programlisting">private List listEvents() {

    Session session = HibernateUtil.getSessionFactory().getCurrentSession();

    session.beginTransaction();

    List result = session.createQuery("from Event").list();

    session.getTransaction().commit();

    return result;
}</pre><p>
                Ce que nous faisons ici c'est utiliser une requ&ecirc;te HQL (Hibernate Query Language) pour
                charger tous les objets <tt class="literal">Event</tt> existants de la base de donn&eacute;es.
                Hibernate g&eacute;n&eacute;rera le SQL appropri&eacute;, l'enverra &agrave; la base de donn&eacute;es et peuplera des
                objets <tt class="literal">Event</tt> avec les donn&eacute;es. Vous pouvez cr&eacute;er des requ&ecirc;tes plus
                complexes avec HQL, bien s&ucirc;r.
            </p><p>
                Maintenant, pour ex&eacute;cuter et tester tout &ccedil;a, suivez ces &eacute;tapes :
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        Ex&eacute;cutez <tt class="literal">ant run -Daction=store</tt> pour stocker quelque
                        chose dans la base de donn&eacute;es et, bien s&ucirc;r, pour g&eacute;n&eacute;rer, avant, le sch&eacute;ma
                        de la base de donn&eacute;es gr&acirc;ce &agrave; hbm2ddl.
                    </p></li><li><p>
                        Maintenant d&eacute;sactivez hbm2ddl en commentant la propri&eacute;t&eacute; dans votre fichier
                        <tt class="literal">hibernate.cfg.xml</tt>. G&eacute;n&eacute;ralement vous la laissez seulement
                        activ&eacute;e dans des tests unitaires en continu, mais une autre ex&eacute;cution de hbm2ddl
                        <span class="emphasis"><em>effacerait</em></span> tout ce que vous avez stock&eacute; - le param&egrave;tre de
                        configuration <tt class="literal">create</tt> se traduit en fait par "supprimer toutes les
                        tables du sch&eacute;ma, puis re-cr&eacute;er toutes les tables, lorsque la SessionFactory est
                        construite".
                    </p></li></ul></div><p>
                Si maintenant vous appelez Ant avec <tt class="literal">-Daction=list</tt>, vous devriez voir
                les &eacute;v&eacute;nements que vous avez stock&eacute;s jusque l&agrave;. Vous pouvez bien s&ucirc;r aussi appeler l'action
                <tt class="literal">store</tt> plusieurs fois.
            </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tutorial-associations"></a>1.3.&nbsp;Partie 2 - Mapper des associations</h2></div></div><div></div></div><p>
            Nous avons mapp&eacute; une classe d'une entit&eacute; persistante vers une table. Partons de l&agrave; et
            ajoutons quelques associations de classe. D'abord nous ajouterons des gens &agrave; notre
            application, et stockerons une liste d'&eacute;v&eacute;nements auxquels ils participent.
        </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-associations-mappinguser"></a>1.3.1.&nbsp;Mapper la classe Person</h3></div></div><div></div></div><p>
                La premi&egrave;re version de la classe <tt class="literal">Person</tt> est simple :
            </p><pre class="programlisting">package events;

public class Person {

    private Long id;
    private int age;
    private String firstname;
    private String lastname;

    public Person() {}

    // Accessor methods for all properties, private setter for 'id'

}</pre><p>
                Cr&eacute;ez un nouveau fichier de mapping appel&eacute; <tt class="literal">Person.hbm.xml</tt> 
                (n'oubliez pas la r&eacute;f&eacute;rence &agrave; la DTD)
            </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="events.Person" table="PERSON"&gt;
        &lt;id name="id" column="PERSON_ID"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="age"/&gt;
        &lt;property name="firstname"/&gt;
        &lt;property name="lastname"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
                Finalement, ajoutez la nouveau mapping &agrave; la configuration d'Hibernate :
            </p><pre class="programlisting">&lt;mapping resource="events/Event.hbm.xml"/&gt;
&lt;mapping resource="events/Person.hbm.xml"/&gt;</pre><p>
                Nous allons maintenant cr&eacute;er une association entre ces deux entit&eacute;s. &Eacute;videmment,
                des personnes peuvent participer aux &eacute;v&eacute;nements, et des &eacute;v&eacute;nements ont des participants.
                Les questions de conception que nous devons traiter sont : direction, cardinalit&eacute; et comportement
                de la collection.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-associations-unidirset"></a>1.3.2.&nbsp;Une association unidirectionnelle bas&eacute;e sur Set</h3></div></div><div></div></div><p>
                Nous allons ajouter une collection d'&eacute;v&eacute;nements &agrave; la classe <tt class="literal">Person</tt>. De
                cette mani&egrave;re nous pouvons facilement naviguer dans les &eacute;v&eacute;nements d'une personne
                particuli&egrave;re, sans ex&eacute;cuter une requ&ecirc;te explicite - en appelant
                <tt class="literal">aPerson.getEvents()</tt>. Nous utilisons une collection Java, un
                <tt class="literal">Set</tt>, parce que la collection ne contiendra pas d'&eacute;l&eacute;ments dupliqu&eacute;s et
                l'ordre ne nous importe pas.
            </p><p>
                Nous avons besoin d'une association unidirectionnelle, pluri-valu&eacute;e, impl&eacute;ment&eacute;e avec
                un <tt class="literal">Set</tt>. &Eacute;crivons le code pour &ccedil;a dans les classes Java et mappons les :
            </p><pre class="programlisting">public class Person {

    private Set events = new HashSet();

    public Set getEvents() {
        return events;
    }

    public void setEvents(Set events) {
        this.events = events;
    }
}</pre><p>
                D'abord nous mappons cette association, mais pensez &agrave; l'autre c&ocirc;t&eacute;. Clairement, nous pouvons
                la laisser unidirectionnelle. Ou alors, nous pourrions cr&eacute;er une autre collection sur
                <tt class="literal">Event</tt>, si nous voulons &ecirc;tre capable de la parcourir de mani&egrave;re
                bidirectionnelle, c'est-&agrave;-dire avoir <tt class="literal">anEvent.getParticipants()</tt>.
                Ce n'est pas n&eacute;cessaire d'un point de vue fonctionnel. Vous pourrez toujours ex&eacute;cuter une requ&ecirc;te
                explicite pour r&eacute;cup&eacute;rer les participants d'un "event" particulier. Ce choix de conception
                vous est laiss&eacute;, mais ce qui reste certains est la cardinalit&eacute; de l'association: "plusieurs"
                des deux c&ocirc;t&eacute;s, nous appelons cela une association <span class="emphasis"><em>many-to-many</em></span>. 
                Par cons&eacute;quent nous utilisons un mapping Hibernate many-to-many:
            </p><pre class="programlisting">&lt;class name="events.Person" table="PERSON"&gt;
    &lt;id name="id" column="PERSON_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="age"/&gt;
    &lt;property name="firstname"/&gt;
    &lt;property name="lastname"/&gt;

    &lt;set name="events" table="PERSON_EVENT"&gt;
        &lt;key column="PERSON_ID"/&gt;
        &lt;many-to-many column="EVENT_ID" class="Event"/&gt;
    &lt;/set&gt;

&lt;/class&gt;</pre><p>
                Hibernate supporte toutes sortes de mapping de collection, un <tt class="literal">&lt;set&gt;</tt>
                &eacute;tant le plus commun. Pour une association many-to-many (ou une relation
                d'entit&eacute; <span class="emphasis"><em>n:m</em></span>), une table d'association est requise. Chaque ligne dans cette table repr&eacute;sente un lien entre une personne et un &eacute;v&eacute;nement. Le nom de la table est
                configur&eacute; avec l'attribut <tt class="literal">table</tt> de l'&eacute;l&eacute;ment <tt class="literal">set</tt>. Le
                nom de la colonne identifiant dans l'association, du c&ocirc;t&eacute; de la personne, est d&eacute;fini avec
                l'&eacute;l&eacute;ment <tt class="literal">&lt;key&gt;</tt>, et le nom de la colonne pour l'&eacute;v&eacute;nement dans
                l'attribut <tt class="literal">column</tt> de <tt class="literal">&lt;many-to-many&gt;</tt>. Vous
                devez aussi donner &agrave; Hibernate la classe des objets de votre collection (c'est-&agrave;-dire : la
                classe de l'autre c&ocirc;t&eacute; de la collection).
            </p><p>
                Le sch&eacute;ma de base de donn&eacute;es pour ce mapping est donc :
            </p><pre class="programlisting">
    _____________        __________________
   |             |      |                  |       _____________
   |   EVENTS    |      |   PERSON_EVENT   |      |             |
   |_____________|      |__________________|      |    PERSON   |
   |             |      |                  |      |_____________|
   | *EVENT_ID   | &lt;--&gt; | *EVENT_ID        |      |             |
   |  EVENT_DATE |      | *PERSON_ID       | &lt;--&gt; | *PERSON_ID  |
   |  TITLE      |      |__________________|      |  AGE        |
   |_____________|                                |  FIRSTNAME  |
                                                  |  LASTNAME   |
                                                  |_____________|
 </pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-associations-working"></a>1.3.3.&nbsp;Travailler avec l'association</h3></div></div><div></div></div><p>
                R&eacute;unissons quelques personnes et quelques &eacute;v&eacute;nements dans une nouvelle m&eacute;thode dans
                <tt class="literal">EventManager</tt> :
            </p><pre class="programlisting">private void addPersonToEvent(Long personId, Long eventId) {

    Session session = HibernateUtil.getSessionFactory().getCurrentSession();
    session.beginTransaction();

    Person aPerson = (Person) session.load(Person.class, personId);
    Event anEvent = (Event) session.load(Event.class, eventId);

    aPerson.getEvents().add(anEvent);

    session.getTransaction().commit();
}</pre><p>
                Apr&egrave;s le chargement d'une <tt class="literal">Person</tt> et d'un <tt class="literal">Event</tt>, modifiez
                simplement la collection en utilisant les m&eacute;thodes normales de la collection. Comme vous
                pouvez le voir, il n'y a pas d'appel explicite &agrave; <tt class="literal">update()</tt> ou
                <tt class="literal">save()</tt>, Hibernate d&eacute;tecte automatiquement que la collection a &eacute;t&eacute;
                modifi&eacute;e et a besoin d'&ecirc;tre mise &agrave; jour. Ceci est appel&eacute; <span class="emphasis"><em>la v&eacute;rification sale
                automatique</em></span> (NdT : "automatic dirty checking"), et vous pouvez aussi l'essayer en
                modifiant le nom ou la propri&eacute;t&eacute; date de n'importe lequel de vos objets. Tant qu'ils sont dans
                un &eacute;tat <span class="emphasis"><em>persistant</em></span>, c'est-&agrave;-dire, li&eacute;s &agrave; une <tt class="literal">Session</tt> Hibernate
                particuli&egrave;re (c-&agrave;-d qu'ils ont juste &eacute;t&eacute; charg&eacute;s ou sauvegard&eacute;s dans une unit&eacute; de travail),
                Hibernate surveille les changements et ex&eacute;cute le SQL correspondant. Le processus de
                synchronisation de l'&eacute;tat de la m&eacute;moire avec la base de donn&eacute;es, g&eacute;n&eacute;ralement seulement &agrave; la fin
                d'une unit&eacute; de travail, est appel&eacute; <span class="emphasis"><em>flushing</em></span>. Dans notre code, l'unit&eacute; de travail
                s'ach&egrave;ve par un commit (ou rollback) de la transaction avec la base de donn&eacute;es - comme d&eacute;fini 
                par notre option <tt class="literal">thread</tt> de configuration pour la classe <tt class="literal">CurrentSessionContext</tt>.
            </p><p>
                Vous pourriez bien s&ucirc;r charger une personne et un &eacute;v&eacute;nement dans diff&eacute;rentes unit&eacute;s de travail. Ou
                vous modifiez un objet &agrave; l'ext&eacute;rieur d'une <tt class="literal">Session</tt>, s'il n'est pas dans un &eacute;tat
                persistant (s'il &eacute;tait persistant avant, nous appelons cet &eacute;tat <span class="emphasis"><em>d&eacute;tach&eacute;</em></span>). 
                Vous pouvez m&ecirc;me modifier une collection lorsqu'elle est d&eacute;tach&eacute;e:
            </p><pre class="programlisting">private void addPersonToEvent(Long personId, Long eventId) {

    Session session = HibernateUtil.getSessionFactory().getCurrentSession();
    session.beginTransaction();

    Person aPerson = (Person) session
            .createQuery("select p from Person p left join fetch p.events where p.id = :pid")
            .setParameter("pid", personId)
            .uniqueResult(); // Eager fetch the collection so we can use it detached

    Event anEvent = (Event) session.load(Event.class, eventId);

    session.getTransaction().commit();

    // End of first unit of work

    aPerson.getEvents().add(anEvent); // aPerson (and its collection) is detached

    // Begin second unit of work

    Session session2 = HibernateUtil.getSessionFactory().getCurrentSession();
    session2.beginTransaction();

    session2.update(aPerson); // Reattachment of aPerson

    session2.getTransaction().commit();
}</pre><p>
                L'appel &agrave; <tt class="literal">update</tt> rend un objet d&eacute;tach&eacute; &agrave; nouveau persistant, vous pourriez
                dire qu'il le lie &agrave; une unit&eacute; de travail, ainsi toutes les modifications (ajout, suppression) que vous avez faites
                pendant qu'il &eacute;tait d&eacute;tach&eacute; peuvent &ecirc;tre sauvegard&eacute;es dans la base de donn&eacute;es
                (il se peut que vous ayez besoin de modifier quelques unes des m&eacute;thodes pr&eacute;c&eacute;dentes
                pour retourner cet identifiant).
            </p><pre class="programlisting">else if (args[0].equals("addpersontoevent")) {
    Long eventId = mgr.createAndStoreEvent("My Event", new Date());
    Long personId = mgr.createAndStorePerson("Foo", "Bar");
    mgr.addPersonToEvent(personId, eventId);
    System.out.println("Added person " + personId + " to event " + eventId);</pre><p>
                Ce n'est pas tr&egrave;s utile dans notre situation actuelle, mais c'est un concept important
                que vous pouvez mettre dans votre propre application.
                Pour le moment, compl&eacute;tez cet exercice en ajoutant une nouvelle action &agrave; la m&eacute;thode
                principale des <tt class="literal">EventManager</tt>s et appelez la &agrave; partir de la ligne de
                commande. Si vous avez besoin des identifiants d'une personne et d'un &eacute;v&eacute;nement - la
                m&eacute;thode <tt class="literal">save()</tt> les retourne.
            </p><p>
                C'&eacute;tait un exemple d'une association entre deux classes de m&ecirc;me importance, deux entit&eacute;s.
                Comme mentionn&eacute; plus t&ocirc;t, il y a d'autres classes et d'autres types dans un mod&egrave;le typique,
                g&eacute;n&eacute;ralement "moins importants". Vous en avez d&eacute;j&agrave; vu certains, comme un <tt class="literal">int</tt>
                ou une <tt class="literal">String</tt>. Nous appelons ces classes des <span class="emphasis"><em>types de valeur</em></span>,
                et leurs instances <span class="emphasis"><em>d&eacute;pendent</em></span> d'une entit&eacute; particuli&egrave;re. Des instances de ces
                types n'ont pas leur propre identit&eacute;, elles ne sont pas non plus partag&eacute;es entre des entit&eacute;s (deux
                personnes ne r&eacute;f&eacute;rencent pas le m&ecirc;me objet <tt class="literal">firstname</tt>, m&ecirc;me si elles ont le
                m&ecirc;me pr&eacute;nom). Bien s&ucirc;r, des types de valeur ne peuvent pas seulement &ecirc;tre trouv&eacute;s dans
                le JDK (en fait, dans une application Hibernate toutes les classes du JDK sont consid&eacute;r&eacute;es
                comme des types de valeur), vous pouvez aussi &eacute;crire vous-m&ecirc;me des classes d&eacute;pendantes,
                <tt class="literal">Address</tt> ou <tt class="literal">MonetaryAmount</tt>, par exemple.
            </p><p>
                Vous pouvez aussi concevoir une collection de types de valeur. C'est conceptuellement tr&egrave;s
                diff&eacute;rent d'une collection de r&eacute;f&eacute;rences vers d'autres entit&eacute;s, mais tr&egrave;s ressemblant en Java.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-associations-valuecollections"></a>1.3.4.&nbsp;Collection de valeurs</h3></div></div><div></div></div><p>
                Nous ajoutons une collection d'objets de type de valeur &agrave; l'entit&eacute; <tt class="literal">Person</tt>.
                Nous voulons stocker des adresses email, donc le type que nous utilisons est <tt class="literal">String</tt>,
                et la collection est encore un <tt class="literal">Set</tt> :
            </p><pre class="programlisting">private Set emailAddresses = new HashSet();

public Set getEmailAddresses() {
    return emailAddresses;
}

public void setEmailAddresses(Set emailAddresses) {
    this.emailAddresses = emailAddresses;
}</pre><p>
                Le mapping de ce <tt class="literal">Set</tt> :
            </p><pre class="programlisting">&lt;set name="emailAddresses" table="PERSON_EMAIL_ADDR"&gt;
    &lt;key column="PERSON_ID"/&gt;
    &lt;element type="string" column="EMAIL_ADDR"/&gt;
&lt;/set&gt;</pre><p>
                La diff&eacute;rence compar&eacute;e au mapping vu plus t&ocirc;t est la partie <tt class="literal">element</tt>,
                laquelle dit &agrave; Hibernate que la collection ne contient pas de r&eacute;f&eacute;rences vers une autre entit&eacute;,
                mais une collection d'&eacute;l&eacute;ments de type <tt class="literal">String</tt> (le nom en minuscule vous
                indique que c'est un type/convertisseur du mapping Hibernate). Une fois encore, l'attribut
                <tt class="literal">table</tt> de l'&eacute;l&eacute;ment <tt class="literal">set</tt> d&eacute;termine le nom de la table pour la
                collection. L'&eacute;l&eacute;ment <tt class="literal">key</tt> d&eacute;finit le nom de la colonne de la clef &eacute;trang&egrave;re
                dans la table de la collection. L'attribut <tt class="literal">column</tt> dans l'&eacute;l&eacute;ment
                <tt class="literal">element</tt> d&eacute;finit le nom de la colonne o&ugrave; les valeurs de <tt class="literal">String</tt>
                seront r&eacute;ellement stock&eacute;es.
            </p><p>
                Regardons le sch&eacute;ma mis &agrave; jour :
            </p><pre class="programlisting">
  _____________        __________________
 |             |      |                  |       _____________
 |   EVENTS    |      |   PERSON_EVENT   |      |             |       ___________________
 |_____________|      |__________________|      |    PERSON   |      |                   |
 |             |      |                  |      |_____________|      | PERSON_EMAIL_ADDR |
 | *EVENT_ID   | &lt;--&gt; | *EVENT_ID        |      |             |      |___________________|
 |  EVENT_DATE |      | *PERSON_ID       | &lt;--&gt; | *PERSON_ID  | &lt;--&gt; |  *PERSON_ID       |
 |  TITLE      |      |__________________|      |  AGE        |      |  *EMAIL_ADDR      |
 |_____________|                                |  FIRSTNAME  |      |___________________|
                                                |  LASTNAME   |
                                                |_____________|
 </pre><p>
                Vous pouvez voir que la clef primaire de la table de la collection est en fait une
                clef compos&eacute;e, utilisant deux colonnes. Ceci implique aussi qu'il ne peut pas y avoir
                d'adresses email dupliqu&eacute;es par personne, ce qui est exactement la s&eacute;mantique dont
                nous avons besoin pour un ensemble en Java.
            </p><p>
                Vous pouvez maintenant tester et ajouter des &eacute;l&eacute;ments &agrave; cette collection, juste comme
                nous l'avons fait avant en liant des personnes et des &eacute;v&eacute;nements. C'est le m&ecirc;me code
                en Java.
            </p><pre class="programlisting">private void addEmailToPerson(Long personId, String emailAddress) {

    Session session = HibernateUtil.getSessionFactory().getCurrentSession();
    session.beginTransaction();

    Person aPerson = (Person) session.load(Person.class, personId);

    // The getEmailAddresses() might trigger a lazy load of the collection
    aPerson.getEmailAddresses().add(emailAddress);

    session.getTransaction().commit();
}</pre><p>
                Cette fois ci, nous n'avons pas utilis&eacute; une requ&ecirc;te de chargement agressif (<span class="emphasis"><em>fetch</em></span>)
                pour initialiser la collection. Par cons&eacute;quent, l'invocation du getter d&eacute;clenchera un
                select suppl&eacute;mentaire pour l'initialiser. Traquez les logs SQL et tentez d'optimiser
                ce cas avec un chargement aggressif.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-associations-bidirectional"></a>1.3.5.&nbsp;Associations bidirectionnelles</h3></div></div><div></div></div><p>
                Ensuite nous allons mapper une association bidirectionnelle - faire fonctionner
                l'association entre une personne et un &eacute;v&eacute;nement &agrave; partir des deux c&ocirc;t&eacute;s en Java.
                Bien s&ucirc;r, le sch&eacute;ma de la base de donn&eacute;es ne change pas, nous avons toujours une pluralit&eacute;
                many-to-many. Une base de donn&eacute;es relationnelle est plus flexible qu'un langage de
                programmation r&eacute;seau, donc elle n'a pas besoin de direction de navigation - les donn&eacute;es
                peuvent &ecirc;tre vues et r&eacute;cup&eacute;r&eacute;es de toutes les mani&egrave;res possibles.
            </p><p>
                D'abord, ajouter une collection de participants &agrave; la classe <tt class="literal">Event</tt> :
            </p><pre class="programlisting">private Set participants = new HashSet();

public Set getParticipants() {
    return participants;
}

public void setParticipants(Set participants) {
    this.participants = participants;
}</pre><p>
                Maintenant mapper ce c&ocirc;t&eacute; de l'association aussi, dans <tt class="literal">Event.hbm.xml</tt>.
            </p><pre class="programlisting">&lt;set name="participants" table="PERSON_EVENT" inverse="true"&gt;
    &lt;key column="EVENT_ID"/&gt;
    &lt;many-to-many column="PERSON_ID" class="events.Person"/&gt;
&lt;/set&gt;</pre><p>
                Comme vous le voyez, ce sont des mappings de <tt class="literal">set</tt>s normaux dans les
                deux documents de mapping. Notez que les noms de colonne dans <tt class="literal">key</tt> et
                <tt class="literal">many-to-many</tt> sont invers&eacute;s dans les 2 documents de mapping. L'ajout
                le plus important ici est l'attribut <tt class="literal">inverse="true"</tt> dans l'&eacute;l&eacute;ment
                <tt class="literal">set</tt> du mapping de la collection des <tt class="literal">Event</tt>s.
            </p><p>
                Ce que signifie qu'Hibernate devrait prendre l'autre c&ocirc;t&eacute; - la classe <tt class="literal">Person</tt> -
                s'il a besoin de renseigner des informations &agrave; propos du lien entre les deux. Ce sera
                beaucoup plus facile &agrave; comprendre une fois que vous verrez comment le lien bidirectionnel
                entre les deux entit&eacute;s est cr&eacute;&eacute;.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-associations-usingbidir"></a>1.3.6.&nbsp;Travailler avec des liens bidirectionnels</h3></div></div><div></div></div><p>
                Premi&egrave;rement, gardez &agrave; l'esprit qu'Hibernate n'affecte pas la s&eacute;mantique normale de Java.
                Comment avons-nous cr&eacute;&eacute; un lien entre une <tt class="literal">Person</tt> et un <tt class="literal">Event</tt>
                dans l'exemple unidirectionnel ? Nous avons ajout&eacute; une instance de <tt class="literal">Event</tt>
                &agrave; la collection des r&eacute;f&eacute;rences d'&eacute;v&eacute;nement d'une instance de <tt class="literal">Person</tt>. Donc,
                &eacute;videmment, si vous voulons rendre ce lien bidirectionnel, nous devons faire la m&ecirc;me chose de
                l'autre c&ocirc;t&eacute; - ajouter une r&eacute;f&eacute;rence de <tt class="literal">Person</tt> &agrave; la collection d'un
                <tt class="literal">Event</tt>. Cette "configuration du lien des deux c&ocirc;t&eacute;s" est absolument
                n&eacute;cessaire et vous ne devriez jamais oublier de le faire.
            </p><p>
                Beaucoup de d&eacute;veloppeurs programment de mani&egrave;re d&eacute;fensive et cr&eacute;ent des
                m&eacute;thodes de gestion de lien pour affecter correctement les deux c&ocirc;t&eacute;s,
                par exemple dans <tt class="literal">Person</tt> :
            </p><pre class="programlisting">protected Set getEvents() {
    return events;
}

protected void setEvents(Set events) {
    this.events = events;
}

public void addToEvent(Event event) {
    this.getEvents().add(event);
    event.getParticipants().add(this);
}

public void removeFromEvent(Event event) {
    this.getEvents().remove(event);
    event.getParticipants().remove(this);
}</pre><p>
                Notez que les m&eacute;thodes get et set pour la collection sont maintenant prot&eacute;g&eacute;es - ceci permet &agrave; des
                classes du m&ecirc;me paquet et aux sous-classes d'acc&eacute;der encore aux m&eacute;thodes, mais emp&ecirc;che n'importe qui
                d'autre de mettre le d&eacute;sordre directement dans les collections (enfin, presque). Vous devriez
                probablement faire de m&ecirc;me avec la collection de l'autre c&ocirc;t&eacute;.
            </p><p>
                Et &agrave; propos de l'attribut de mapping <tt class="literal">inverse</tt> ? Pour vous, et pour Java, un lien
                bidirectionnel est simplement une mani&egrave;re de configurer correctement les r&eacute;f&eacute;rences des deux c&ocirc;t&eacute;s.
                Hibernate n'a cependant pas assez d'informations pour ordonner correctement les expressions SQL
                <tt class="literal">INSERT</tt> et <tt class="literal">UPDATE</tt> (pour &eacute;viter les violations de contrainte), et
                a besoin d'aide pour g&eacute;rer proprement les associations bidirectionnelles. Rendre
                <tt class="literal">inverse</tt> un c&ocirc;t&eacute; d'une assocation dit &agrave; Hibernate de l'ignorer essentiellement, pour
                le consid&eacute;rer comme un <span class="emphasis"><em>miroir</em></span> de l'autre c&ocirc;t&eacute;. C'est tout ce qui est n&eacute;cessaire &agrave;
                Hibernate pour d&eacute;couvrir tout des probl&egrave;mes de transformation d'un mod&egrave;le de navigation
                directionnelle vers un sch&eacute;ma SQL de base de donn&eacute;es. Les r&egrave;gles dont vous devez vous souvenir sont :
                toutes les associations bidirectionnelles ont besoin d'un c&ocirc;t&eacute; marqu&eacute; <tt class="literal">inverse</tt>.
                Dans une association un-vers-plusieurs vous pouvez choisir n'importe quel c&ocirc;t&eacute;, il n'y a pas de
                diff&eacute;rence.
            </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tutorial-webapp"></a>1.4.&nbsp;Part 3 - L'application web EventManager</h2></div></div><div></div></div><p>
            Une application web Hibernate utilise la <tt class="literal">Session</tt> et <tt class="literal">Transaction</tt>
            comme une application standalone. Cependant, quelques patterns sont utiles. Nous allons coder une
            <tt class="literal">EventManagerServlet</tt>. Cette servlet peut lister tous les &eacute;v&egrave;nements stock&eacute;s dans
            la base de donn&eacute;es, et fournir une formulaire HTML pour saisir d'autres &eacute;v&egrave;nements.
        </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-webapp-servlet"></a>1.4.1.&nbsp;Ecrire la servlet de base</h3></div></div><div></div></div><p>
                Cr&eacute;ons une nouvelle classe dans notre r&eacute;pertoire source, dans le package <tt class="literal">events</tt>:
            </p><pre class="programlisting">package events;

// Imports

public class EventManagerServlet extends HttpServlet {

    private final SimpleDateFormat dateFormatter =
                            new SimpleDateFormat("dd.MM.yyyy");

    // Servlet code
}</pre><p>
                Le <tt class="literal">dateFormatter</tt> est un outil que nous utiliserons plus tard pour convertir les objets
                <tt class="literal">Date</tt> depuis et vers des chaines de caract&egrave;res. Il est propice de n'avoir qu'un
                formatter comme membre de la servlet.
            </p><p>
                La servlet n'accepte que les requ&ecirc;tes HTTP <tt class="literal">GET</tt>, la m&eacute;thode &agrave; impl&eacute;menter est donc
				<tt class="literal">doGet()</tt>:
            </p><pre class="programlisting">protected void doGet(HttpServletRequest request,
                     HttpServletResponse response)
        throws ServletException, IOException {

    try {
        // Begin unit of work
        HibernateUtil.getSessionFactory()
                .getCurrentSession().beginTransaction();

        // Process request and render page...

        // End unit of work
        HibernateUtil.getSessionFactory()
                .getCurrentSession().getTransaction().commit();

    } catch (Exception ex) {
        HibernateUtil.getSessionFactory()
                .getCurrentSession().getTransaction().rollback();
        throw new ServletException(ex);
    }

}</pre><p>
                La pattern que nous utilisons ici est appel&eacute; <span class="emphasis"><em>session-per-request</em></span>.
                Lorsqu'une requ&ecirc;te touche la servlet, une nouvelle <tt class="literal">Session</tt> hibernate est
                ouverte &agrave; l'invocationde <tt class="literal">getCurrentSession()</tt> sur la
                <tt class="literal">SessionFactory</tt>. Ensuite, une transaction avec la base de donn&eacute;es est d&eacute;marr&eacute;e&#8212;
                tous les acc&egrave;s &agrave; la base de donn&eacute;es interviennent au sein de la transactiton, peu importe que les donn&eacute;es
                soient lues ou &eacute;crites (nous n'utilisons pas le mode auto-commit dans les applications).
            </p><p>
                Ensuite, les actions possibles de la requ&ecirc;tes sont ex&eacute;cut&eacute;es et la r&eacute;ponse HTML
                est rendue. Nous en parlerons plus tard.
            </p><p>
                Enfin, l'unit&eacute; de travail s'ach&egrave;ve lorsque l'ex&eacute;cution et le rendu sont achev&eacute;s.
                Si un probl&egrave;me survient lors de ces deux phases, une exception est soulev&eacute;e et la
                transaction avec la base de donn&eacute;es subit un rollback. Voila pour le pattern
                <tt class="literal">session-per-request</tt>. Au lieu d'un code de d&eacute;marcation de transaction
                au sein de chaque servlet, vous pouvez &eacute;crire un filtre de servlet.
                Voir le site Hibernate et le Wiki pour plus d'information sur ce pattern, appel&eacute;
				<span class="emphasis"><em>Open Session in View</em></span>&#8212; vous en aurez besoin d&egrave;s que vous
				utiliserez des JSPs et non plus des servlets pour le rendu de vos vues.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-webapp-processing"></a>1.4.2.&nbsp;Proc&eacute;der et rendre</h3></div></div><div></div></div><p>
                Impl&eacute;mentons l'ex&eacute;cution de la requ&ecirc;te et le rendu de la page.                
            </p><pre class="programlisting">// Write HTML header
PrintWriter out = response.getWriter();
out.println("&lt;html&gt;&lt;head&gt;&lt;title&gt;Event Manager&lt;/title&gt;&lt;/head&gt;&lt;body&gt;");

// Handle actions
if ( "store".equals(request.getParameter("action")) ) {

    String eventTitle = request.getParameter("eventTitle");
    String eventDate = request.getParameter("eventDate");

    if ( "".equals(eventTitle) || "".equals(eventDate) ) {
        out.println("&lt;b&gt;&lt;i&gt;Please enter event title and date.&lt;/i&gt;&lt;/b&gt;");
    } else {
        createAndStoreEvent(eventTitle, dateFormatter.parse(eventDate));
        out.println("&lt;b&gt;&lt;i&gt;Added event.&lt;/i&gt;&lt;/b&gt;");
    }
}

// Print page
printEventForm(out);
listEvents(out);

// Write HTML footer
out.println("&lt;/body&gt;&lt;/html&gt;");
out.flush();
out.close();</pre><p>
                Ce style de code avec un mix de Java et d'HTML ne serait pas scalable 
                dans une application plus complexe&#8212;gardez &agrave; l'esprit que nous ne faisons qu'illustrer
                les concepts basiques d'Hibernate dans ce tutoriel. Ce code affiche une en t&ecirc;te et un pied de page
                HTML. Dans cette page, sont affich&eacute;s un formulaire pour la saisie d'&eacute;v&egrave;nements ainsi
                qu'une liste de tous les &eacute;v&egrave;nements de la base de donn&eacute;es. La premi&egrave;re m&eacute;thode
                est triviale est ne fait que sortir de l'HTML:
            </p><pre class="programlisting">private void printEventForm(PrintWriter out) {
    out.println("&lt;h2&gt;Add new event:&lt;/h2&gt;");
    out.println("&lt;form&gt;");
    out.println("Title: &lt;input name='eventTitle' length='50'/&gt;&lt;br/&gt;");
    out.println("Date (e.g. 24.12.2009): &lt;input name='eventDate' length='10'/&gt;&lt;br/&gt;");
    out.println("&lt;input type='submit' name='action' value='store'/&gt;");
    out.println("&lt;/form&gt;");
}</pre><p>
                La m&eacute;thode <tt class="literal">listEvents()</tt> utilise la
                <tt class="literal">Session</tt> Hibernate li&eacute;e au thread courant pour ex&eacute;cuter la
                requ&ecirc;te:
            </p><pre class="programlisting">private void listEvents(PrintWriter out) {
    List result = HibernateUtil.getSessionFactory()
                    .getCurrentSession().createCriteria(Event.class).list();
    if (result.size() &gt; 0) {
        out.println("&lt;h2&gt;Events in database:&lt;/h2&gt;");
        out.println("&lt;table border='1'&gt;");
        out.println("&lt;tr&gt;");
        out.println("&lt;th&gt;Event title&lt;/th&gt;");
        out.println("&lt;th&gt;Event date&lt;/th&gt;");
        out.println("&lt;/tr&gt;");
        for (Iterator it = result.iterator(); it.hasNext();) {
            Event event = (Event) it.next();
            out.println("&lt;tr&gt;");
            out.println("&lt;td&gt;" + event.getTitle() + "&lt;/td&gt;");
            out.println("&lt;td&gt;" + dateFormatter.format(event.getDate()) + "&lt;/td&gt;");
            out.println("&lt;/tr&gt;");
        }
        out.println("&lt;/table&gt;");
    }
}</pre><p>
                FEnfin, l'action <tt class="literal">store</tt> renvoie &agrave; la m&eacute;thode
                <tt class="literal">createAndStoreEvent()</tt>, qui utilise aussi la
                <tt class="literal">Session</tt> du thread courant:
            </p><pre class="programlisting">protected void createAndStoreEvent(String title, Date theDate) {
    Event theEvent = new Event();
    theEvent.setTitle(title);
    theEvent.setDate(theDate);

    HibernateUtil.getSessionFactory()
                    .getCurrentSession().save(theEvent);
}</pre><p>
                La servlet est faite. Une requ&ecirc;te &agrave; la servlet sera ex&eacute;cut&eacute;e par une seule
                <tt class="literal">Session</tt> et <tt class="literal">Transaction</tt>. Comme pour une application
                standalone, Hibernate peut automatiquement lier ces objets au thread courant d'ex&eacute;cution.
                Cela vous laisse la libert&eacute; de s&eacute;parer votre code en couches et d'acc&eacute;der &agrave; la
				<tt class="literal">SessionFactory</tt> par le moyen que vous voulez.
				G&eacute;n&eacute;ralement, vous utiliserez des conceptions plus sophistiqu&eacute;es et d&eacute;placerez
				le code d'acc&egrave;s aux donn&eacute;es dans une couche DAO. Voir le wiki Hibernate pour plus
				d'exemples.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="tutorial-webapp-deploy"></a>1.4.3.&nbsp;D&eacute;ployer et tester</h3></div></div><div></div></div><p>
                Pour d&eacute;ployer cette application, vous devez cr&eacute;er une archive Web, un War. Ajoutez
                la cible Ant suivante dans votre <tt class="literal">build.xml</tt>:
            </p><pre class="programlisting">&lt;target name="war" depends="compile"&gt;
    &lt;war destfile="hibernate-tutorial.war" webxml="web.xml"&gt;
        &lt;lib dir="${librarydir}"&gt;
          &lt;exclude name="jsdk*.jar"/&gt;
        &lt;/lib&gt;

        &lt;classes dir="${targetdir}"/&gt;
    &lt;/war&gt;
&lt;/target&gt;</pre><p>
                Cette cible cr&eacute;&eacute; un fichier nomm&eacute; <tt class="literal">hibernate-tutorial.war</tt>
                dans le r&eacute;pertoire de votre projet. Elle package les biblioth&egrave;ques et le descripteur <tt class="literal">web.xml</tt>
                qui est attendu dans le r&eacute;pertoire racine de votre projet:
            </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="2.4"
    xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;Event Manager&lt;/servlet-name&gt;
        &lt;servlet-class&gt;events.EventManagerServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Event Manager&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/eventmanager&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre><p>
                Avant de compiler et d&eacute;ployer l'application web, notez qu'une biblioth&egrave;que suppl&eacute;mentaire
                est requise: <tt class="literal">jsdk.jar</tt>. C'est le kit de d&eacute;veloppement de Servlet Java,
                si vous ne disposez pas de cette biblioth&egrave;que, prenez la sur le site de Sun et copiez la
                dans votre r&eacute;pertoire des biblioth&egrave;ques. Cependant, elle ne sera utilis&eacute;e uniquement pour la
                compilation et sera exclue du paackage WAR.
            </p><p>
                Pour construire et d&eacute;ployer, appelez <tt class="literal">ant war</tt> dans votre projet et
                copier le fichier <tt class="literal">hibernate-tutorial.war</tt> dans le r&eacute;pertoire <tt class="literal">webapp</tt> de tomcat
                Si vous n'avez pas install&eacute; Tomcat, t&eacute;l&eacute;chargez le et suivez la notice d'installation. 
                Vous n'avez pas &agrave; modifier la configuration Tomcat pour d&eacute;ployer cette application.
            </p><p>
                Une fois l'application d&eacute;ploy&eacute;e et Tomcat lanc&eacute;, acc&eacute;dez &agrave; l'application via
                <tt class="literal">http://localhost:8080/hibernate-tutorial/eventmanager</tt>. 
                Assurez vous de consulter les traces tomcat pour observer l'initialisation
                d'Hibernate &agrave; la premi&egrave;re requ&ecirc;te touchant votre servlet (l'initialisation statique dans <tt class="literal">HibernateUtil</tt>
                est invoqu&eacute;e) et pour v&eacute;rifier qu'aucune exception ne survienne.
            </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tutorial-summary"></a>1.5.&nbsp;R&eacute;sum&eacute;</h2></div></div><div></div></div><p>
            Ce didacticiel a couvert les bases de l'&eacute;criture d'une simple application Hibernate ainsi qu'une petite application web.
        </p><p>
            Si vous &ecirc;tes d&eacute;j&agrave; confiants avec Hibernate, continuez &agrave; parcourir les sujets que vous trouvez
            int&eacute;ressants &agrave; travers la table des mati&egrave;res de la documentation de r&eacute;f&eacute;rence - les plus
            demand&eacute;s sont le traitement transactionnel (<a href="#transactions" title="Chapitre&nbsp;11.&nbsp;Transactions et acc&egrave;s concurrents">Chapitre&nbsp;11, <i>Transactions et acc&egrave;s concurrents</i></a>), la performance
            des r&eacute;cup&eacute;rations d'information (<a href="#performance" title="Chapitre&nbsp;19.&nbsp;Am&eacute;liorer les performances">Chapitre&nbsp;19, <i>Am&eacute;liorer les performances</i></a>), ou l'utilisation de l'API
            (<a href="#objectstate" title="Chapitre&nbsp;10.&nbsp;Travailler avec des objets">Chapitre&nbsp;10, <i>Travailler avec des objets</i></a>) et les fonctionnalit&eacute;s des requ&ecirc;tes (<a href="#objectstate-querying" title="10.4.&nbsp;Requ&ecirc;tage">Section&nbsp;10.4, &laquo;&nbsp;Requ&ecirc;tage&nbsp;&raquo;</a>).
        </p><p>
            N'oubliez pas de v&eacute;rifier le site web d'Hibernate pour d'autres didacticiels (plus sp&eacute;cialis&eacute;s).
        </p></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="architecture"></a>Chapitre&nbsp;2.&nbsp;Architecture</h2></div></div><div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-overview"></a>2.1.&nbsp;G&eacute;n&eacute;ralit&eacute;s</h2></div></div><div></div></div><p>
            Voici une vue (tr&egrave;s) haut niveau de l'architecture d'Hibernate :
        </p><div class="mediaobject" align="center"><img src="../shared/images/overview.gif" align="middle"></div><p>
            Ce diagramme montre Hibernate utilisant une base de donn&eacute;es et des donn&eacute;es
            de configuration pour fournir un service de persistance (et des objets
            persistants) &agrave; l'application.
        </p><p>
            Nous aimerions d&eacute;crire une vue plus d&eacute;taill&eacute;e de l'architecture. Malheureusement,
            Hibernate est flexible et supporte diff&eacute;rentes approches. Nous allons en
            montrer les deux extr&ecirc;mes. L'architecture l&eacute;g&egrave;re laisse l'application fournir
            ses propres connexions JDBC et g&eacute;rer ses propres transactions. Cette approche
            utilise le minimum des APIs Hibernate :
        </p><div class="mediaobject" align="center"><img src="../shared/images/lite.gif" align="middle"></div><p>
            L'architecture la plus compl&egrave;te abstrait l'application des APIs JDBC/JTA 
            sous-jacentes et laisse Hibernate s'occuper des d&eacute;tails.
        </p><div class="mediaobject" align="center"><img src="../shared/images/full_cream.gif" align="middle"></div><p>
            Voici quelques d&eacute;finitions des objets des diagrammes :

            </p><div class="variablelist"><dl><dt><span class="term">SessionFactory (<tt class="literal">org.hibernate.SessionFactory</tt>)</span></dt><dd><p>
                            Un cache threadsafe (immuable) des mappings vers une (et une seule) base 
                            de donn&eacute;es. Une factory (fabrique) de <tt class="literal">Session</tt> et un client
                            de <tt class="literal">ConnectionProvider</tt>. Peut contenir un cache optionnel de
                            donn&eacute;es (de second niveau) qui est r&eacute;utilisable entre les diff&eacute;rentes transactions
                            que cela soit au sein du m&ecirc;me processus (JVLM) ou par plusieurs n&frac12;uds d'un cluster.
                        </p></dd><dt><span class="term">Session (<tt class="literal">org.hibernate.Session</tt>)</span></dt><dd><p>
                            Un objet mono-thread&eacute;, &agrave; dur&eacute;e de vie courte, qui repr&eacute;sente une conversation
                            entre l'application et l'entrep&ocirc;t de persistance. Encapsule une connexion JDBC.
                            Factory (fabrique) des objets <tt class="literal">Transaction</tt>. Contient un cache
                            (de premier niveau) des objets persistants, ce cache est obligatoire. Il est 
                            utilis&eacute; lors de la navigation dans le graphe d'objets ou lors de la r&eacute;cup&eacute;ration
                            d'objets par leur identifiant.
                        </p></dd><dt><span class="term">Objets et Collections persistants</span></dt><dd><p>
                            Objets mono-thread&eacute;s &agrave; vie courte contenant l'&eacute;tat de persistance
                            et la fonction m&eacute;tier. Ceux-ci sont en g&eacute;n&eacute;ral les objets de type JavaBean
                            (ou POJOs) ; la seule particularit&eacute; est qu'ils sont associ&eacute;s avec une (et
                            une seule) <tt class="literal">Session</tt>. D&egrave;s que la <tt class="literal">Session</tt>
                            est ferm&eacute;e, ils seront d&eacute;tach&eacute;s et libres d'&ecirc;tre utilis&eacute;s par n'importe laquelle
                            des couches de l'application (ie. de et vers la pr&eacute;sentation en tant que Data 
                            Transfer Objects - DTO : objet de transfert de donn&eacute;es).
                        </p></dd><dt><span class="term">Objets et collections transients</span></dt><dd><p>
                            Instances de classes persistantes qui ne sont actuellement pas associ&eacute;es &agrave;
                            une <tt class="literal">Session</tt>. Elles ont pu &ecirc;tre instanci&eacute;es par l'application
                            et ne pas avoir (encore) &eacute;t&eacute; persist&eacute;es ou elle ont pu &ecirc;tre instanci&eacute;es par
                            une <tt class="literal">Session</tt> ferm&eacute;e.
                        </p></dd><dt><span class="term">Transaction (<tt class="literal">org.hibernate.Transaction</tt>)</span></dt><dd><p>
                            (Optionnel) Un objet mono-thread&eacute; &agrave; vie courte utilis&eacute; par l'application
                            pour d&eacute;finir une unit&eacute; de travail atomique. Abstrait l'application des
                            transactions sous-jacentes qu'elles soient JDBC, JTA ou CORBA. Une
                            <tt class="literal">Session</tt> peut fournir plusieurs <tt class="literal">Transaction</tt>s
                            dans certains cas. Toutefois, la d&eacute;limitation des transactions, via l'API d'Hibernate
                            ou par la <tt class="literal">Transaction</tt> sous-jacente, n'est jamais optionnelle!
                        </p></dd><dt><span class="term">ConnectionProvider (<tt class="literal">org.hibernate.connection.ConnectionProvider</tt>)</span></dt><dd><p>
                            (Optionnel) Une fabrique de (pool de) connexions JDBC. Abstrait l'application
                            de la <tt class="literal">Datasource</tt> ou du <tt class="literal">DriverManager</tt> sous-jacent.
                            Non expos&eacute; &agrave; l'application, mais peut &ecirc;tre &eacute;tendu/impl&eacute;ment&eacute; par le d&eacute;veloppeur.
                        </p></dd><dt><span class="term">TransactionFactory (<tt class="literal">org.hibernate.TransactionFactory</tt>)</span></dt><dd><p>
                            (Optionnel) Une fabrique d'instances de <tt class="literal">Transaction</tt>. Non
                            expos&eacute; &agrave; l'application, mais peut &ecirc;tre &eacute;tendu/impl&eacute;ment&eacute; par le d&eacute;veloppeur.
                        </p></dd><dt><span class="term"><span class="emphasis"><em>Interfaces d'extension</em></span></span></dt><dd><p>
                            Hibernate fournit de nombreuses interfaces d'extensions optionnelles que 
                            vous pouvez impl&eacute;menter pour personnaliser le comportement de votre couche de persistance.
                            Reportez vous &agrave; la documentation de l'API pour plus de d&eacute;tails.
                        </p></dd></dl></div><p>
        </p><p>
            Dans une architecture l&eacute;g&egrave;re, l'application n'aura pas &agrave; utiliser les APIs
            <tt class="literal">Transaction</tt>/<tt class="literal">TransactionFactory</tt>
            et/ou n'utilisera pas les APIs <tt class="literal">ConnectionProvider</tt>
            pour utiliser JTA ou JDBC.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-states"></a>2.2.&nbsp;Etats des instances</h2></div></div><div></div></div><p>
            Une instance d'une classe persistante peut &ecirc;tre dans l'un des trois &eacute;tats suivants,
            d&eacute;finis par rapport &agrave; un <span class="emphasis"><em>contexte de persistance</em></span>.
            L'objet <tt class="literal">Session</tt> d'hibernate correspond &agrave; ce concept de 
            contexte de persistance :
        </p><div class="variablelist"><dl><dt><span class="term">passager (transient)</span></dt><dd><p>
                        L'instance n'est pas et n'a jamais &eacute;t&eacute; associ&eacute;e &agrave; un contexte
                        de persistance. Elle ne poss&egrave;de pas d'identit&eacute; persistante (valeur de cl&eacute; primaire)
                    </p></dd><dt><span class="term">persistant</span></dt><dd><p>
                        L'instance est associ&eacute;e au contexte de persistance.
                        Elle poss&egrave;de une identit&eacute; persistante (valeur de cl&eacute; primaire)
                        et, peut-&ecirc;tre, un enregistrement correspondant dans la base.
                        Pour un contexte de persistance particulier, Hibernate
                        <span class="emphasis"><em>garantit</em></span> que l'identit&eacute; persistante
                        est &eacute;quivalente &agrave; l'identit&eacute; Java (emplacement m&eacute;moire de l'objet)
                    </p></dd><dt><span class="term">d&eacute;tach&eacute;</span></dt><dd><p>
                        L'instance a &eacute;t&eacute; associ&eacute;e au contexte de persistance mais ce
                        contexte a &eacute;t&eacute; ferm&eacute;, ou l'instance a &eacute;t&eacute; s&eacute;rialis&eacute;e vers un
                        autre processus. Elle poss&egrave;de une identit&eacute; persistante et
                        peut-&ecirc;tre un enregistrement correspondant dans la base.
                        Pour des instances d&eacute;tach&eacute;es, Hibernate ne donne aucune
                        garantie sur la relation entre l'identit&eacute; persistante et
                        l'identit&eacute; Java.
                    </p></dd></dl></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-jmx"></a>2.3.&nbsp;Int&eacute;gration JMX</h2></div></div><div></div></div><p>
            JMX est le standard J2EE de gestion des composants Java. 
            Hibernate peut &ecirc;tre g&eacute;r&eacute; via un service JMX standard. Nous fournissons une impl&eacute;mentation
            d'un MBean dans la distribution : <tt class="literal">org.hibernate.jmx.HibernateService</tt>.
        </p><p>
            Pour avoir un exemple sur la mani&egrave;re de d&eacute;ployer Hibernate en tant que service JMX dans le
            serveur d'application JBoss Application Server, r&eacute;f&eacute;rez vous au guide utilisateur JBoss (JBoss User Guide).
            Si vous d&eacute;ployez Hibernate via JMX sur JBoss AS, vous aurez &eacute;galement les b&eacute;n&eacute;fices suivants :
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <span class="emphasis"><em>Gestion de la session :</em></span> Le cycle de vie de la <tt class="literal">Session</tt>
                    Hibernate peut &ecirc;tre automatiquement limit&eacute;e &agrave; la port&eacute;e d'une transaction JTA.
                    Cela signifie que vous n'avez plus besoin d'ouvrir et de fermer la <tt class="literal">Session</tt>
                    manuellement, cela devient le travail de l'intercepteur EJB de JBoss. Vous n'avez
                    pas non plus &agrave; vous occuper des d&eacute;marcations des transactions dans votre code (sauf
                    si vous voulez &eacute;crire une couche de persistance qui soit portable, dans ce cas vous
                    pouvez utiliser l'API optionnelle <tt class="literal">Transaction</tt> d'Hibernate).
                    Vous appelez l'<tt class="literal">HibernateContext</tt> pour acc&eacute;der &agrave; la <tt class="literal">Session</tt>.
                </p></li><li><p>
                    <span class="emphasis"><em>D&eacute;ploiement HAR :</em></span> Habituellement vous d&eacute;ployez le service JMX
                    Hibernate en utilisant le descripteur de d&eacute;ploiement de JBoss (dans un fichier EAR et/ou un SAR),
                    il supporte toutes les options de configuration usuelles d'une <tt class="literal">SessionFactory</tt>
                    Hibernate. Cependant, vous devez toujours nommer tous vos fichiers de mapping dans le
                    descripteur de d&eacute;ploiement. Si vous d&eacute;cidez d'utiliser le d&eacute;ploiement optionnel sous forme
                    de HAR, JBoss d&eacute;tectera automatiquement tous vos fichiers de mapping dans votre fichier HAR.
                </p></li></ul></div><p>
            Consultez le guide d'utilisation de JBoss AS pour plus d'informations sur ces options.
        </p><p>
            Les statistiques pendant l'ex&eacute;cution d'Hibernate (au runtime) sont une 
            autre fonctionnalit&eacute; disponible en tant que service JMX. Voyez pour cela
            <a href="#configuration-optional-statistics" title="3.4.6.&nbsp;Statistiques Hibernate">Section&nbsp;3.4.6, &laquo;&nbsp;Statistiques Hibernate&nbsp;&raquo;</a>.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-jca"></a>2.4.&nbsp;Support JCA</h2></div></div><div></div></div><p>
            Hibernate peut aussi &ecirc;tre configur&eacute; en tant que connecteur JCA. R&eacute;f&eacute;rez-vous au site
            web pour de plus amples d&eacute;tails. Il est important de noter que le support JCA d'Hibernate
            est encore consid&eacute;r&eacute; comme exp&eacute;rimental.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-current-session"></a>2.5.&nbsp;Sessions Contextuelles</h2></div></div><div></div></div><p>
            Certaines applications utilisant Hibernate ont besoin d'une sorte de session "contextuelle", o&ugrave;
            une session est li&eacute;e &agrave; la port&eacute;e d'un contexte particulier. Cependant, les applications ne d&eacute;finissent
            pas toutes la notion de contexte de la m&ecirc;me mani&egrave;re, et diff&eacute;rents contextes d&eacute;finissent diff&eacute;rentes
            port&eacute;es &agrave; la notion de "courant". Les applications &agrave; base d'Hibernate, versions pr&eacute;c&eacute;dentes &agrave; la 3.0
            utilisaient g&eacute;n&eacute;ralement un principe maison de sessions contextuelles bas&eacute;es sur le <tt class="literal">ThreadLocal</tt>,
            ainsi que sur des classes utilitaires comme <tt class="literal">HibernateUtil</tt>, ou utilisaient des
            framework tiers (comme Spring ou Pico) qui fournissaient des sessions contextuelles bas&eacute;es sur 
            l'utilisation de proxy/interception.
        </p><p>
        	A partir de la version 3.0.1, Hibernate a ajout&eacute; la m&eacute;thode <tt class="literal">SessionFactory.getCurrentSession()</tt>.
        	Initialement, cela demandait l'usage de transactions <tt class="literal">JTA</tt>, o&ugrave; la
        	transaction <tt class="literal">JTA</tt> d&eacute;finissait la port&eacute;e et le contexte de la session courante.
        	L'&eacute;quipe Hibernate pense que, &eacute;tant donn&eacute;e la maturit&eacute; des impl&eacute;mentations de <tt class="literal">JTA TransactionManager</tt> ,
        	la plupart (sinon toutes) des applications devraient utiliser la gestion des transactions par <tt class="literal">JTA</tt> 
        	qu'elles soient ou non d&eacute;ploy&eacute;es dans un conteneur <tt class="literal">J2EE</tt>. Par cons&eacute;quent,
        	vous devriez toujours contextualiser vos sessions, si vous en avez besoin, via la m&eacute;thode bas&eacute;e sur JTA.
        </p><p>
            Cependant, depuis la version 3.1, la logique derri&egrave;re
            <tt class="literal">SessionFactory.getCurrentSession()</tt> est d&eacute;sormais branchable.  
            A cette fin, une nouvelle interface d'extension (<tt class="literal">org.hibernate.context.CurrentSessionContext</tt>)
            et un nouveau param&egrave;tre de configuration (<tt class="literal">hibernate.current_session_context_class</tt>)
            ont &eacute;t&eacute; ajout&eacute;s pour permettre de configurer d'autres moyens de d&eacute;finir la port&eacute;e et le contexte des
            sessions courantes.
        </p><p>
            Allez voir les Javadocs de l'interface <tt class="literal">org.hibernate.context.CurrentSessionContext</tt>
            pour une description d&eacute;taill&eacute;e de son contrat. Elle d&eacute;finit une seule m&eacute;thode,
            <tt class="literal">currentSession()</tt>, depuis laquelle l'impl&eacute;mentation est responsable
            de traquer la session courante du contexte. Hibernate fournit deux impl&eacute;mentation 
            de cette interface.
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <tt class="literal">org.hibernate.context.JTASessionContext</tt> - les sessions courantes sont
                    associ&eacute;es &agrave; une transaction <tt class="literal">JTA</tt>.  La logique est la m&ecirc;me que
                    l'ancienne approche bas&eacute;e sur JTA. Voir les javadocs pour les d&eacute;tails.
                </p></li><li><p>
                    <tt class="literal">org.hibernate.context.ThreadLocalSessionContext</tt> - les sessions
                    courantes sont associ&eacute;es au thread d'ex&eacute;cution. Voir les javadocs pour les d&eacute;tails.
                </p></li></ul></div><p>
            Les deux impl&eacute;mentations fournissent un mod&egrave;le de programmation de type "une session - une transaction
            &agrave; la base de donn&eacute;es", aussi connu sous le nom de <span class="emphasis"><em>session-per-request</em></span>. 
            Le d&eacute;but et la fin d'une session Hibernate sont d&eacute;finis par la dur&eacute;e d'une transaction de base de donn&eacute;es.
            Si vous utilisez une d&eacute;marcation programmatique de la transaction (par exemple sous J2SE ou JTA/UserTransaction/BMT),
            nous vous conseillons d'utiliser l'API Hibernate <tt class="literal">Transaction</tt> pour masquer le syst&egrave;me
            de transaction utilis&eacute;. Si vous ex&eacute;cutez sous un conteneur EJB qui supporte CMT, vous n'avez besoin d'aucune
            op&eacute;rations de d&eacute;marcations de session ou transaction dans votre code puisque tout
            est g&eacute;r&eacute; de mani&egrave;re d&eacute;clarative. R&eacute;f&eacute;rez vous &agrave; <a href="#transactions" title="Chapitre&nbsp;11.&nbsp;Transactions et acc&egrave;s concurrents">Chapitre&nbsp;11, <i>Transactions et acc&egrave;s concurrents</i></a> pour plus d'informations
            et des exemples de code.
        </p><p>
            Le param&egrave;tre de configuration <tt class="literal">hibernate.current_session_context_class</tt> 
            d&eacute;finit quelle impl&eacute;mentation de <tt class="literal">org.hibernate.context.CurrentSessionContext</tt> 
            doit &ecirc;tre utilis&eacute;e. Notez que pour assurer la compatibilit&eacute; avec les versions pr&eacute;c&eacute;dentes, si
            ce param&egrave;tre n'est pas d&eacute;fini mais qu'un <tt class="literal">org.hibernate.transaction.TransactionManagerLookup</tt> 
            est configur&eacute;, Hibernate utilisera le <tt class="literal">org.hibernate.context.JTASessionContext</tt>.
            La valeur de ce param&egrave;tre devrait juste nommer la classe d'impl&eacute;mentation &agrave; utiliser, 
            pour les deux impl&eacute;mentations fournies, il y a cependant deux alias correspondant: "jta" et "thread".
        </p></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="session-configuration"></a>Chapitre&nbsp;3.&nbsp;Configuration</h2></div></div><div></div></div><p>
        Parce qu'Hibernate est con&ccedil;u pour fonctionner dans diff&eacute;rents environnements,
        il existe beaucoup de param&egrave;tres de configuration. Heureusement, la plupart
        ont des valeurs par d&eacute;faut appropri&eacute;es et la distribution d'Hibernate contient
        un exemple de fichier <tt class="literal">hibernate.properties</tt> dans le r&eacute;pertoire
        <tt class="literal">etc/</tt> qui montre les diff&eacute;rentes options. Vous n'avez qu'&agrave; 
        placer ce fichier dans votre classpath et &agrave; l'adapter.
    </p><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-programmatic"></a>3.1.&nbsp;Configuration par programmation</h2></div></div><div></div></div><p>
            Une instance de <tt class="literal">org.hibernate.cfg.Configuration</tt>
            repr&eacute;sente un ensemble de mappings des classes Java d'une application vers
            la base de donn&eacute;es SQL. La <tt class="literal">Configuration</tt> est utilis&eacute;e
            pour construire un objet (immuable) <tt class="literal">SessionFactory</tt>.
            Les mappings sont constitu&eacute;s d'un ensemble de fichiers de mapping XML.
        </p><p>
            Vous pouvez obtenir une instance de <tt class="literal">Configuration</tt>
            en l'instanciant directement et en sp&eacute;cifiant la liste des documents 
            XML de mapping. Si les fichiers de mapping sont dans le classpath, vous
            pouvez le faire &agrave; l'aide de la m&eacute;thode <tt class="literal">addResource()</tt> :
        </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addResource("Item.hbm.xml")
    .addResource("Bid.hbm.xml");</pre><p>
            Une alternative (parfois meilleure)  est de sp&eacute;cifier les classes mapp&eacute;es
            et de laisser Hibernate trouver les documents de mapping pour vous :
        </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class);</pre><p>
            Hibernate va rechercher les fichiers de mappings 
            <tt class="literal">/org/hibernate/auction/Item.hbm.xml</tt> et
            <tt class="literal">/org/hibernate/auction/Bid.hbm.xml</tt> dans le classpath.
            Cette approche &eacute;limine les noms de fichiers en dur.
        </p><p>
            Une <tt class="literal">Configuration</tt> vous permet &eacute;galement de pr&eacute;ciser des
            propri&eacute;t&eacute;s de configuration :
        </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class)
    .setProperty("hibernate.dialect", "org.hibernate.dialect.MySQLInnoDBDialect")
    .setProperty("hibernate.connection.datasource", "java:comp/env/jdbc/test")
    .setProperty("hibernate.order_updates", "true");</pre><p>
            Ce n'est pas le seul moyen de passer des propri&eacute;t&eacute;s de configuration &agrave; Hibernate.
            Les diff&eacute;rentes options sont :
        </p><div class="orderedlist"><ol type="1" compact><li><p>
                    Passer une instance de <tt class="literal">java.util.Properties</tt>
                    &agrave; <tt class="literal">Configuration.setProperties()</tt>.
                </p></li><li><p>
                    Placer <tt class="literal">hibernate.properties</tt> dans un r&eacute;pertoire racine
                    du classpath
                </p></li><li><p>
                    Positionner les propri&eacute;t&eacute;s <tt class="literal">System</tt> en utilisant
                    <tt class="literal">java -Dproperty=value</tt>.
                </p></li><li><p>
                    Inclure des &eacute;l&eacute;ments <tt class="literal">&lt;property&gt;</tt> dans le
                    fichier <tt class="literal">hibernate.cfg.xml</tt> (voir plus loin).
                </p></li></ol></div><p>
            L'utilisation d'<tt class="literal">hibernate.properties</tt> est l'approche la plus
            simple si vous voulez d&eacute;marrer rapidement
        </p><p>
            La <tt class="literal">Configuration</tt> est un objet de d&eacute;marrage qui sera supprim&eacute;
            une fois qu'une <tt class="literal">SessionFactory</tt> aura &eacute;t&eacute; cr&eacute;&eacute;e.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-sessionfactory"></a>3.2.&nbsp;Obtenir une SessionFactory</h2></div></div><div></div></div><p>
            Une fois que tous les mappings ont &eacute;t&eacute; pars&eacute;s par la <tt class="literal">Configuration</tt>, 
            l'application doit obtenir une fabrique d'instances de <tt class="literal">Session</tt>. 
            Cette fabrique sera partag&eacute;e entre tous les threads de l'application :
        </p><pre class="programlisting">SessionFactory sessions = cfg.buildSessionFactory();</pre><p>
            Hibernate permet &agrave; votre application d'instancier plus d'une <tt class="literal">SessionFactory</tt>.
            Cela est pratique lorsque vous utilisez plus d'une base de donn&eacute;es.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-hibernatejdbc"></a>3.3.&nbsp;Connexions JDBC</h2></div></div><div></div></div><p>
            Habituellement, vous voulez que la <tt class="literal">SessionFactory</tt> cr&eacute;e les connexions JDBC et
            les mette dans un pool pour vous. Si vous suivez cette approche, ouvrir une <tt class="literal">Session</tt> 
            est aussi simple que :
        </p><pre class="programlisting">Session session = sessions.openSession(); // open a new Session</pre><p>
            D&egrave;s que vous ferez quelquechose qui requiert un acc&egrave;s &agrave; la base de donn&eacute;es, une connexion
            JDBC sera r&eacute;cup&eacute;r&eacute;e dans le pool.
        </p><p>
            Pour faire cela, il faut passer les propri&eacute;t&eacute;s de la connexion JDBC &agrave; Hibernate.
            Tous les noms des propri&eacute;t&eacute;s Hibernate et leur signification sont d&eacute;finies dans
            la classe <tt class="literal">org.hibernate.cfg.Environment</tt>. Nous allons maintenant
            d&eacute;crire les param&egrave;tres de configuration des connexions JDBC les plus importants.
        </p><p>
            Hibernate obtiendra des connexions (et les mettra dans un pool) en utilisant 
            <tt class="literal">java.sql.DriverManager</tt> si vous positionnez les param&egrave;tres de la mani&egrave;re
            suivante :
        </p><div class="table"><a name="d0e1573"></a><p class="title"><b>Tableau&nbsp;3.1.&nbsp;Propri&eacute;t&eacute;s JDBC d'Hibernate</b></p><table summary="Propri&eacute;t&eacute;s JDBC d'Hibernate" border="1"><colgroup><col><col></colgroup><thead><tr><th>Nom de la propri&eacute;t&eacute;</th><th>Fonction</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.connection.driver_class</tt></td><td><span class="emphasis"><em>Classe du driver jdbc</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.url</tt></td><td><span class="emphasis"><em>URL jdbc</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.username</tt></td><td><span class="emphasis"><em>utilisateur de la base de donn&eacute;es</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.password</tt></td><td><span class="emphasis"><em>mot de passe de la base de donn&eacute;es</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.pool_size</tt></td><td><span class="emphasis"><em>nombre maximum de connexions dans le pool</em></span></td></tr></tbody></table></div><p>
            L'algorithme natif de pool de connexions d'Hibernate est plut&ocirc;t rudimentaire. Il a &eacute;t&eacute; fait 
            dans le but de vous aider &agrave; d&eacute;marrer et <span class="emphasis"><em>n'est pas pr&eacute;vu pour un syst&egrave;me en production</em></span>
            ou m&ecirc;me pour un test de peformance. Utilisez plut&ocirc;t un pool tiers pour de meilleures performances et une
            meilleure stabilit&eacute; : pour cela, remplacez la propri&eacute;t&eacute; <tt class="literal">hibernate.connection.pool_size</tt> avec les propri&eacute;t&eacute;s
            sp&eacute;cifique au pool de connexions que vous avez choisi. Cela d&eacute;sactivera le pool de connexions interne
            d'Hibernate. Vous pouvez par exemple utiliser C3P0.
        </p><p>
            C3P0 est un pool de connexions JDBC open source distribu&eacute; avec Hibernate dans le r&eacute;pertoire
            <tt class="literal">lib</tt>. Hibernate utilisera son provider <tt class="literal">C3P0ConnectionProvider</tt>
            pour le pool de connexions si vous positionnez les propri&eacute;t&eacute;s <tt class="literal">hibernate.c3p0.*</tt>.
            Si vous voulez utiliser Proxool, r&eacute;f&eacute;rez vous au groupe de propri&eacute;t&eacute;s d'<tt class="literal">hibernate.properties</tt>
            correspondant et regardez sur le site web d'Hibernate pour plus d'informations.
        </p><p>
            Voici un exemple de fichier <tt class="literal">hibernate.properties</tt> pour C3P0:
        </p><a name="c3p0-configuration"></a><pre class="programlisting">hibernate.connection.driver_class = org.postgresql.Driver
hibernate.connection.url = jdbc:postgresql://localhost/mydatabase
hibernate.connection.username = myuser
hibernate.connection.password = secret
hibernate.c3p0.min_size=5
hibernate.c3p0.max_size=20
hibernate.c3p0.timeout=1800
hibernate.c3p0.max_statement=50
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect</pre><p>
            Dans le cadre de l'utilisation au sein d'un serveur d'applications,
            vous devriez quasiment toujours configurer Hibernate pour qu'il obtienne
            ses connexions de la <tt class="literal">DataSource</tt> du serveur d'application
            enregistr&eacute;e dans le JNDI. Pour cela vous devrez d&eacute;finir au moins une des
            propri&eacute;t&eacute;s suivantes :
        </p><div class="table"><a name="d0e1655"></a><p class="title"><b>Tableau&nbsp;3.2.&nbsp;Propri&eacute;t&eacute; d'une Datasource Hibernate</b></p><table summary="Propri&eacute;t&eacute; d'une Datasource Hibernate" border="1"><colgroup><col><col></colgroup><thead><tr><th>Nom d'une propri&eacute;t&eacute;</th><th>fonction</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.connection.datasource</tt></td><td><span class="emphasis"><em>Nom JNDI de la datasource</em></span></td></tr><tr><td><tt class="literal">hibernate.jndi.url</tt></td><td><span class="emphasis"><em>URL du fournisseur JNDI</em></span> (optionnelle)
                </td></tr><tr><td><tt class="literal">hibernate.jndi.class</tt></td><td><span class="emphasis"><em>Classe de l'<tt class="literal">InitialContextFactory</tt> du JNDI</em></span> (optionnelle)
                </td></tr><tr><td><tt class="literal">hibernate.connection.username</tt></td><td><span class="emphasis"><em>utilisateur de la base de donn&eacute;es</em></span> (optionnelle)
                </td></tr><tr><td><tt class="literal">hibernate.connection.password</tt></td><td><span class="emphasis"><em>mot de passe de la base de donn&eacute;es</em></span> (optionnelle)
                </td></tr></tbody></table></div><p>
            Voici un exemple de fichier <tt class="literal">hibernate.properties</tt>
            pour l'utilisation d'une datasource JNDI fournie par un serveur d'applications :
        </p><pre class="programlisting">hibernate.connection.datasource = java:/comp/env/jdbc/test
hibernate.transaction.factory_class = \
    org.hibernate.transaction.JTATransactionFactory
hibernate.transaction.manager_lookup_class = \
    org.hibernate.transaction.JBossTransactionManagerLookup
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect</pre><p>
            Les connexions JDBC obtenues &agrave; partir d'une datasource JNDI participeront automatiquement
            aux transactions g&eacute;r&eacute;es par le conteneur du serveur d'applications.
        </p><p>
            Des propri&eacute;t&eacute;s suppl&eacute;mentaires de connexion peuvent &ecirc;tre pass&eacute;es en pr&eacute;fixant
            le nom de la propri&eacute;t&eacute; par "<tt class="literal">hibernate.connnection</tt>". Par exemple,
            vous pouvez sp&eacute;cifier un jeu de caract&egrave;res en utilisant 
            <tt class="literal">hibernate.connection.charSet</tt>.
        </p><p>
            Vous pouvez fournir votre propre strat&eacute;gie d'obtention des connexions JDBC en impl&eacute;mentant l'interface
            <tt class="literal">org.hibernate.connection.ConnectionProvider</tt>. Vous pouvez s&eacute;lectionner
            une impl&eacute;mentation sp&eacute;cifique en positionnant <tt class="literal">hibernate.connection.provider_class</tt>.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-optional"></a>3.4.&nbsp;Propri&eacute;t&eacute;s de configuration optionnelles</h2></div></div><div></div></div><p>
            Il y a un certain nombre d'autres propri&eacute;t&eacute;s qui contr&ocirc;lent le fonctionnement 
            d'Hibernate &agrave; l'ex&eacute;cution. Toutes sont optionnelles et ont comme valeurs par d&eacute;faut
            des valeurs "raisonnables" pour un fonctionnement nominal.
        </p><p>
            <span class="emphasis"><em>Attention : Certaines de ces propri&eacute;t&eacute;s sont uniquement de niveau System.</em></span>
            Les propri&eacute;t&eacute;s de niveau System ne peuvent &ecirc;tre positionn&eacute;es que via la ligne de commande
            (<tt class="literal">java -Dproperty=value</tt>) ou &ecirc;tre d&eacute;finies dans <tt class="literal">hibernate.properties</tt>.
            Elle <span class="emphasis"><em>ne peuvent pas</em></span> l'&ecirc;tre via une des autres techniques d&eacute;crites ci-dessus.
        </p><div class="table"><a name="configuration-optional-properties"></a><p class="title"><b>Tableau&nbsp;3.3.&nbsp;Propri&eacute;t&eacute;s de configuration d'Hibernate</b></p><table summary="Propri&eacute;t&eacute;s de configuration d'Hibernate" border="1"><colgroup><col><col></colgroup><thead><tr><th>Nom de la propri&eacute;t&eacute;</th><th>Fonction</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.dialect</tt></td><td>
                            Le nom de la classe du <tt class="literal">Dialect</tt> Hibernate.
                            qui permet &agrave; Hibernate de g&eacute;n&eacute;rer du SQL optimis&eacute; pour une
                            base de donn&eacute;es relationnelle particuli&egrave;re.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">nom.complet.de.ma.classe.de.Dialect</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.show_sql</tt></td><td>
                            Ecrit toutes les requ&ecirc;tes SQL sur la console. Il s'agit d'une
                            alternative au positionnement de la cat&eacute;gorie de log
                            <tt class="literal">org.hibernate.SQL</tt> au niveau <tt class="literal">debug</tt>.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.format_sql</tt></td><td>
                            Formate et indente le sql dans la console et dans le log
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.default_schema</tt></td><td>
                            Positionne dans le SQL g&eacute;n&eacute;r&eacute; un sch&eacute;ma/tablespace par d&eacute;faut pour les noms de
                            table ne l'ayant pas surcharg&eacute;.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">MON_SCHEMA</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.default_catalog</tt></td><td>
                            Qualifie les noms de tables non qualifi&eacute;es avec ce catalogue
                            dans le SQL g&eacute;n&eacute;r&eacute;.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">CATALOG_NAME</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.session_factory_name</tt></td><td>
                            La <tt class="literal">SessionFactory</tt> sera automatiquement
                            li&eacute;e &agrave; ce nom dans le JNDI apr&egrave;s sa cr&eacute;ation.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">jndi/nom/hierarchique</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.max_fetch_depth</tt></td><td>
                            D&eacute;finit la profondeur maximale d'un arbre de chargement par
                            jointures ouvertes pour les associations &agrave; cardinalit&eacute; unitaire
                            (un-&agrave;-un, plusieurs-&agrave;-un).
                            Un <tt class="literal">0</tt> d&eacute;sactive le chargement par jointure
                            ouverte.
                            <p>
                                <span class="strong">ex.</span> 
                                valeurs recommand&eacute;es entre <tt class="literal">0</tt> et <tt class="literal">3</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.default_batch_fetch_size</tt></td><td>
                            D&eacute;finit une taille par d&eacute;faut pour le chargement par lot des associations
                            <p>
                                <span class="strong">ex.</span> 
                                Valeurs recommand&eacute;es : <tt class="literal">4</tt>, <tt class="literal">8</tt>, 
                                <tt class="literal">16</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.default_entity_mode</tt></td><td>
                            D&eacute;finit un mode de repr&eacute;sentation par d&eacute;faut des entit&eacute;s pour
                            toutes les sessions ouvertes depuis cette <tt class="literal">SessionFactory</tt><p>
                                <tt class="literal">dynamic-map</tt>, <tt class="literal">dom4j</tt>,
                                <tt class="literal">pojo</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.order_updates</tt></td><td>
                            Force Hibernate &agrave; trier les updates SQL par la valeur de la cl&eacute;
                            primaire des &eacute;l&eacute;ments qui sont mis &agrave; jour. Cela permet de limiter
                            les deadlocks de transaction dans les syst&egrave;mes hautement concurents.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.generate_statistics</tt></td><td>
                            Si activ&eacute;, Hibernate va collecter des statistiques utiles
                            pour le r&eacute;glage des performances.
                            <p>
                                <span class="strong">ex.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.use_identifer_rollback</tt></td><td>
                            Si activ&eacute;, les propri&eacute;t&eacute;s correspondant &agrave; l'identifiant
                            des objets vont &ecirc;tre remises aux valeurs par d&eacute;faut lorsque
                            les objets seront supprim&eacute;s.
                            <p>
                                <span class="strong">ex.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.use_sql_comments</tt></td><td>
                            Si activ&eacute;, Hibernate va g&eacute;n&eacute;rer des commentaires &agrave; l'int&eacute;rieur
                            des requ&ecirc;tes SQL pour faciliter le debogage., par d&eacute;faut &agrave; <tt class="literal">false</tt>.
                            <p>
                                <span class="strong">ex.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr></tbody></table></div><div class="table"><a name="configuration-jdbc-properties"></a><p class="title"><b>Tableau&nbsp;3.4.&nbsp;Propri&eacute;t&eacute;s Hibernate li&eacute;es &agrave; JDBC et aux connexions</b></p><table summary="Propri&eacute;t&eacute;s Hibernate li&eacute;es &agrave; JDBC et aux connexions" border="1"><colgroup><col><col></colgroup><thead><tr><th>Nom de la propri&eacute;t&eacute;</th><th>Fonction</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.jdbc.fetch_size</tt></td><td>
                            Une valeur non nulle d&eacute;termine la taille de chargement
                            des statements JDBC (appelle 
                            <tt class="literal">Statement.setFetchSize()</tt>).
                        </td></tr><tr><td><tt class="literal">hibernate.jdbc.batch_size</tt></td><td>
                            Une valeur non nulle active l'utilisation par Hibernate des mises 
                            &agrave; jour par batch de JDBC2.
                            <p>
                                <span class="strong">ex.</span> 
                                les valeurs recommand&eacute;es entre <tt class="literal">5</tt> et <tt class="literal">30</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.batch_versioned_data</tt></td><td>
                            Param&eacute;trez cette propri&eacute;t&eacute; &agrave; <tt class="literal">true</tt> si votre pilote JDBC
                            retourne des row counts corrects depuis <tt class="literal">executeBatch()</tt> (il est 
                            souvent appropri&eacute; d'activer cette option). Hibernate utilisera alors le "batched DML" pour
                            versionner automatiquement les donn&eacute;es. Par d&eacute;faut = <tt class="literal">false</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.factory_class</tt></td><td>
                           S&eacute;lectionne un <tt class="literal">Batcher</tt> personnalis&eacute;. La
                           plupart des applications n'auront pas besoin de cette propri&eacute;t&eacute;
                           de configuration
                            <p>
                                <span class="strong">ex.</span>
                                <tt class="literal">classname.of.Batcher</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.use_scrollable_resultset</tt></td><td>
                            Active l'utilisation par Hibernate des resultsets scrollables 
                            de JDBC2. Cette propri&eacute;t&eacute; est seulement n&eacute;cessaire lorsque l'on
                            utilise une connexion JDBC fournie par l'utilisateur. Autrement,
                            Hibernate utilise les m&eacute;tadonn&eacute;es de la connexion.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.use_streams_for_binary</tt></td><td>
                            Utilise des flux lorsque l'on &eacute;crit/lit des types
                            <tt class="literal">binary</tt> ou <tt class="literal">serializable</tt>
                            vers et &agrave; partir de JDBC (propri&eacute;t&eacute; de niveau syst&egrave;me).
                            <p>
                                <span class="strong">ex.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.use_get_generated_keys</tt></td><td>
                            Active l'utilisation de <tt class="literal">PreparedStatement.getGeneratedKeys()</tt> de JDBC3
                            pour r&eacute;cup&eacute;rer nativement les cl&eacute;s g&eacute;n&eacute;r&eacute;es apr&egrave;s insertion. N&eacute;cessite un pilote
                            JDBC3+, le mettre &agrave; false si votre pilote a des probl&egrave;mes avec les g&eacute;n&eacute;rateurs
                            d'identifiant Hibernate. Par d&eacute;faut, essaie de d&eacute;terminer les possibilit&eacute;s du
                            pilote en utilisant les meta donn&eacute;es de connexion.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.connection.provider_class</tt></td><td>
                            Le nom de la classe d'un <tt class="literal">ConnectionProvider</tt> personnalis&eacute;
                            qui fournit des connexions JDBC &agrave; Hibernate
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">classname.of.ConnectionProvider</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.connection.isolation</tt></td><td>
                        D&eacute;finit le niveau d'isolation des transactions JDBC. Regardez
                        <tt class="literal">java.sql.Connection</tt> pour conna&icirc;tre le
                        sens des diff&eacute;rentes valeurs mais notez &eacute;galement que la plupart
                        des bases de donn&eacute;es ne supportent pas tous les niveaux d'isolation.
                        <p>
                            <span class="strong">ex.</span> 
                            <tt class="literal">1, 2, 4, 8</tt>
                        </p></td></tr><tr><td><tt class="literal">hibernate.connection.autocommit</tt></td><td>
                            Active le mode de commit automatique (autocommit) pour les connexions
                            JDBC du pool (non recommand&eacute;).
                            <p>
                                <span class="strong">ex.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.connection.release_mode</tt></td><td>
                            Sp&eacute;cifie &agrave; quel moment Hibernate doit relacher les connexion JDBC.
                            Par d&eacute;faut une connexion JDBC est conserv&eacute;e jusqu'&agrave; ce que la session
                            soit explicitement ferm&eacute;e ou d&eacute;connect&eacute;e. Pour une source de donn&eacute;es
                            JTA d'un serveur d'application, vous devriez utiliser <tt class="literal">after_statement</tt>
                            pour lib&eacute;rer les connexions de mani&egrave;re plus agressive apr&egrave;s chaque appel
                            JDBC. Pour une connexion non JTA, il est souvent pr&eacute;f&eacute;rable de lib&eacute;rer
                            la connexion &agrave; la fin de chaque transaction en utilisant <tt class="literal">after_transaction</tt>.
                            <tt class="literal">auto</tt> choisira <tt class="literal">after_statement</tt> pour
                            des transactions JTA et CMT et <tt class="literal">after_transaction</tt> pour
                            des transactions JDBC.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">on_close</tt> (default) | <tt class="literal">after_transaction</tt> |
                                <tt class="literal">after_statement</tt> | <tt class="literal">auto</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.connection.<span class="emphasis"><em>&lt;propertyName&gt;</em></span></tt></td><td>
                        Passe la propri&eacute;t&eacute; JDBC<tt class="literal">propertyName</tt>
                        &agrave; <tt class="literal">DriverManager.getConnection()</tt>.
                    </td></tr><tr><td><tt class="literal">hibernate.jndi.<span class="emphasis"><em>&lt;propertyName&gt;</em></span></tt></td><td>
                           Passe la propri&eacute;t&eacute; <tt class="literal">propertyName</tt> &agrave; l'<tt class="literal">InitialContextFactory</tt>
                           de JNDI.
                        </td></tr></tbody></table></div><div class="table"><a name="configuration-cache-properties"></a><p class="title"><b>Tableau&nbsp;3.5.&nbsp;Propri&eacute;t&eacute;s du Cache d'Hibernate</b></p><table summary="Propri&eacute;t&eacute;s du Cache d'Hibernate" border="1"><colgroup><col><col></colgroup><thead><tr><th>Nom de la propri&eacute;t&eacute;</th><th>Fonction</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.cache.provider_class</tt></td><td>
                            Le nom de classe d'un <tt class="literal">CacheProvider</tt> 
                            sp&eacute;cifique.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">nom.de.classe.du.CacheProvider</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.use_minimal_puts</tt></td><td>
                            Optimise le cache de second niveau en minimisant les &eacute;critures,
                            au prix de plus de lectures. Ce param&egrave;tre est surtout utile pour
                            les caches en cluster et est activ&eacute; par d&eacute;faut dans hibernate3
                            pour les impl&eacute;mentations de cache en cluster.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.use_query_cache</tt></td><td>
                            Activer le cache de requ&ecirc;te, les requ&ecirc;tes individuelles doivent tout
                            de m&ecirc;me &ecirc;tre d&eacute;clar&eacute;es comme pouvant &ecirc;tre mise en cache.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.use_second_level_cache</tt></td><td>
                            Peut &ecirc;tre utilis&eacute; pour d&eacute;sactiver compl&egrave;tement le cache de second niveau
                            qui est activ&eacute; par d&eacute;faut pour les classes qui sp&eacute;cifient un &eacute;l&eacute;ment
                            <tt class="literal">&lt;cache&gt;</tt> dans leur mapping.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.query_cache_factory</tt></td><td>
                            Le nom de classe d'une interface <tt class="literal">QueryCacheFactory</tt> ,
                            par d&eacute;faut = built-in <tt class="literal">StandardQueryCacheFactory</tt>.
                            <p>
                                <span class="strong">ex.</span>
                                <tt class="literal">nom.de.la.classe.de.QueryCacheFactory</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.region_prefix</tt></td><td>
                            Un pr&eacute;fixe &agrave; utiliser pour le nom des r&eacute;gions du 
                            cache de second niveau.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">prefix</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.use_structured_entries</tt></td><td>
                            Force Hibernate &agrave; stocker les donn&eacute;es dans le cache de
                            second niveau dans un format plus adapt&eacute; &agrave; la visualisation
                            par un humain.
                            <p>
                                <span class="strong">ex.</span>
                                <tt class="literal">true|false</tt>
                            </p></td></tr></tbody></table></div><div class="table"><a name="configuration-transaction-properties"></a><p class="title"><b>Tableau&nbsp;3.6.&nbsp;Propri&eacute;t&eacute;s des transactions Hibernate</b></p><table summary="Propri&eacute;t&eacute;s des transactions Hibernate" border="1"><colgroup><col><col></colgroup><thead><tr><th>Nom de la propri&eacute;t&eacute;</th><th>Fonction</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.transaction.factory_class</tt></td><td>
                            Le nom de classe d'une <tt class="literal">TransactionFactory</tt>
                            qui sera utilis&eacute;e par l'API <tt class="literal">Transaction</tt>
                            d'Hibernate (la valeur par d&eacute;faut est 
                            <tt class="literal">JDBCTransactionFactory</tt>).
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">nom.de.classe.d.une.TransactionFactory</tt>
                            </p></td></tr><tr><td><tt class="literal">jta.UserTransaction</tt></td><td>
                            Le nom JNDI utilis&eacute; par la <tt class="literal">JTATransactionFactory</tt>
                            pour obtenir la <tt class="literal">UserTransaction</tt> JTA du serveur 
                            d'applications.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">jndi/nom/compose</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.transaction.manager_lookup_class</tt></td><td>
                            Le nom de la classe du <tt class="literal">TransactionManagerLookup</tt>
                            - requis lorsque le cache de niveau JVM est activ&eacute; ou lorsque l'on
                            utilise un g&eacute;n&eacute;rateur hilo dans un environnement JTA.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">nom.de.classe.du.TransactionManagerLookup</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.transaction.flush_before_completion</tt></td><td>
                            Si activ&eacute;, la session sera automatiquement vid&eacute;e durant la phase
                            qui pr&eacute;c&egrave;de la fin de la transaction (before completion). 
                            La gestion automatique de contexte fourni par Hibernate est
                            recommand&eacute;e, voir
                            <a href="#architecture-current-session" title="2.5.&nbsp;Sessions Contextuelles">Section&nbsp;2.5, &laquo;&nbsp;Sessions Contextuelles&nbsp;&raquo;</a>.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.transaction.auto_close_session</tt></td><td>
                            Si activ&eacute;, la session sera automatiquement ferm&eacute; pendant la phase 
                            qui suit la fin de la transaction (after completion). 
                            La gestion automatique de contexte fourni par Hibernate est
                            recommand&eacute;e, voir
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr></tbody></table></div><div class="table"><a name="configuration-misc-properties"></a><p class="title"><b>Tableau&nbsp;3.7.&nbsp;Propri&eacute;t&eacute;s diverses</b></p><table summary="Propri&eacute;t&eacute;s diverses" border="1"><colgroup><col><col></colgroup><thead><tr><th>Nom de la propri&eacute;t&eacute;</th><th>Fonction</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.current_session_context_class</tt></td><td>
                            Fournit une strat&eacute;gie particuli&egrave;re pour contextualiser
                            la <tt class="literal">Session</tt> courante. Voir
                            <a href="#architecture-current-session" title="2.5.&nbsp;Sessions Contextuelles">Section&nbsp;2.5, &laquo;&nbsp;Sessions Contextuelles&nbsp;&raquo;</a> pour plus
                            d'informations sur les strat&eacute;gies fournies.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">jta</tt> | <tt class="literal">thread</tt> |
                                <tt class="literal">custom.Class</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.query.factory_class</tt></td><td>
                            Choisi l'impl&eacute;mentation du parseur de requ&ecirc;te
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">org.hibernate.hql.ast.ASTQueryTranslatorFactory</tt> ou
                                <tt class="literal">org.hibernate.hql.classic.ClassicQueryTranslatorFactory</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.query.substitutions</tt></td><td>
                            Lien entre les tokens de requ&ecirc;tes Hibernate et les 
                            tokens SQL (les tokens peuvent &ecirc;tre des fonctions ou des
                            noms litt&eacute;raux par exemple).
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.hbm2ddl.auto</tt></td><td>
                            Valide ou exporte  automatiquement le sch&eacute;ma DDL vers la base de donn&eacute;es
                            lorsque la <tt class="literal">SessionFactory</tt> est cr&eacute;&eacute;e.
                            La valeur <tt class="literal">create-drop</tt> permet de supprimer 
                            le sch&eacute;ma de base de donn&eacute;es lorsque la <tt class="literal">SessionFactory</tt>
                            est ferm&eacute;e explicitement.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">validate</tt> | <tt class="literal">update</tt> | 
                                <tt class="literal">create</tt> | <tt class="literal">create-drop</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cglib.use_reflection_optimizer</tt></td><td>
                            Active l'utilisation de CGLIB &agrave; la place de la r&eacute;flexion &agrave; l'ex&eacute;cution
                            (Propri&eacute;t&eacute; de niveau syst&egrave;me). La r&eacute;flexion peut parfois &ecirc;tre utile pour
                            r&eacute;soudre des probl&egrave;mes. Notez qu'Hibernate a tout de m&ecirc;me toujours besoin
                            de CGLIB m&ecirc;me si l'optimiseur est d&eacute;sactiv&eacute;. Cette optimisation ne peut &ecirc;tre
                            d&eacute;finie que dans le fichier <tt class="literal">hibernate.cfg.xml</tt>.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr></tbody></table></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-dialects"></a>3.4.1.&nbsp;Dialectes SQL</h3></div></div><div></div></div><p>
                Vous devriez toujours positionner la propri&eacute;t&eacute; <tt class="literal">hibernate.dialect</tt> &agrave;
                la sous-classe de <tt class="literal">org.hibernate.dialect.Dialect</tt> appropri&eacute;e &agrave; 
                votre base de donn&eacute;es. Si vous sp&eacute;cifiez un dialecte,
                Hibernate utilisera des valeurs adapt&eacute;es pour certaines autres
                propri&eacute;t&eacute;s list&eacute;es ci-dessus, vous &eacute;vitant l'effort de le faire &agrave; la main.
            </p><div class="table"><a name="sql-dialects"></a><p class="title"><b>Tableau&nbsp;3.8.&nbsp;Dialectes SQL d'Hibernate (<tt class="literal">hibernate.dialect</tt>)</b></p><table summary="Dialectes SQL d'Hibernate (hibernate.dialect)" border="1"><colgroup><col><col></colgroup><thead><tr><th>SGBD</th><th>Dialecte</th></tr></thead><tbody><tr><td>DB2</td><td><tt class="literal">org.hibernate.dialect.DB2Dialect</tt></td></tr><tr><td>DB2 AS/400</td><td><tt class="literal">org.hibernate.dialect.DB2400Dialect</tt></td></tr><tr><td>DB2 OS390</td><td><tt class="literal">org.hibernate.dialect.DB2390Dialect</tt></td></tr><tr><td>PostgreSQL</td><td><tt class="literal">org.hibernate.dialect.PostgreSQLDialect</tt></td></tr><tr><td>MySQL</td><td><tt class="literal">org.hibernate.dialect.MySQLDialect</tt></td></tr><tr><td>MySQL with InnoDB</td><td><tt class="literal">org.hibernate.dialect.MySQLInnoDBDialect</tt></td></tr><tr><td>MySQL with MyISAM</td><td><tt class="literal">org.hibernate.dialect.MySQLMyISAMDialect</tt></td></tr><tr><td>Oracle (any version)</td><td><tt class="literal">org.hibernate.dialect.OracleDialect</tt></td></tr><tr><td>Oracle 9i/10g</td><td><tt class="literal">org.hibernate.dialect.Oracle9Dialect</tt></td></tr><tr><td>Sybase</td><td><tt class="literal">org.hibernate.dialect.SybaseDialect</tt></td></tr><tr><td>Sybase Anywhere</td><td><tt class="literal">org.hibernate.dialect.SybaseAnywhereDialect</tt></td></tr><tr><td>Microsoft SQL Server</td><td><tt class="literal">org.hibernate.dialect.SQLServerDialect</tt></td></tr><tr><td>SAP DB</td><td><tt class="literal">org.hibernate.dialect.SAPDBDialect</tt></td></tr><tr><td>Informix</td><td><tt class="literal">org.hibernate.dialect.InformixDialect</tt></td></tr><tr><td>HypersonicSQL</td><td><tt class="literal">org.hibernate.dialect.HSQLDialect</tt></td></tr><tr><td>Ingres</td><td><tt class="literal">org.hibernate.dialect.IngresDialect</tt></td></tr><tr><td>Progress</td><td><tt class="literal">org.hibernate.dialect.ProgressDialect</tt></td></tr><tr><td>Mckoi SQL</td><td><tt class="literal">org.hibernate.dialect.MckoiDialect</tt></td></tr><tr><td>Interbase</td><td><tt class="literal">org.hibernate.dialect.InterbaseDialect</tt></td></tr><tr><td>Pointbase</td><td><tt class="literal">org.hibernate.dialect.PointbaseDialect</tt></td></tr><tr><td>FrontBase</td><td><tt class="literal">org.hibernate.dialect.FrontbaseDialect</tt></td></tr><tr><td>Firebird</td><td><tt class="literal">org.hibernate.dialect.FirebirdDialect</tt></td></tr></tbody></table></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-outerjoin"></a>3.4.2.&nbsp;Chargement par Jointure Ouverte</h3></div></div><div></div></div><p>
                Si votre base de donn&eacute;es supporte les outer joins de type ANSI, Oracle ou Sybase, 
                <span class="emphasis"><em>le chargement par jointure ouverte</em></span> devrait am&eacute;liorer les 
                performances en limitant le nombre d'aller-retour avec la base de donn&eacute;es (la
                base de donn&eacute;es effectuant donc potentiellement plus de travail). Le chargement par
                jointure ouverte permet &agrave; un graphe entier d'objets connect&eacute;s par une relation plusieurs-&agrave;-un,
                un-&agrave;-plusieurs ou un-&agrave;-un d'&ecirc;tre charg&eacute; en un seul <tt class="literal">SELECT</tt> SQL.
            </p><p>
                Le chargement par jointure ouverte peut &ecirc;tre d&eacute;sactiver <span class="emphasis"><em>globalement</em></span>
                en mettant la propri&eacute;t&eacute; <tt class="literal">hibernate.max_fetch_depth</tt> &agrave; <tt class="literal">0</tt>.
                Une valeur de <tt class="literal">1</tt> ou plus active le chargement par jointure ouverte
                pour les associatiosn un-&agrave;-un et plusieurs-&agrave;-un qui ont &eacute;t&eacute; mapp&eacute;e avec
                <tt class="literal">fetch="join"</tt>.
            </p><p>
                Reportez vous &agrave; <a href="#performance-fetching" title="19.1.&nbsp;Strat&eacute;gies de chargement">Section&nbsp;19.1, &laquo;&nbsp;Strat&eacute;gies de chargement&nbsp;&raquo;</a> pour plus d'information.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-binarystreams"></a>3.4.3.&nbsp;Flux binaires</h3></div></div><div></div></div><p>
                Oracle limite la taille d'un tableau de <tt class="literal">byte</tt> qui peuvent &ecirc;tre
                pass&eacute;es &agrave; et vers son pilote JDBC. Si vous souhaitez utiliser des instances larges
                de type <tt class="literal">binary</tt> ou <tt class="literal">serializable</tt>, vous devez activer
                la propri&eacute;t&eacute; <tt class="literal">hibernate.jdbc.use_streams_for_binary</tt>. <span class="emphasis"><em>C'est une 
                fonctionalit&eacute; de niveau syst&egrave;me uniquement.</em></span>
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-cacheprovider"></a>3.4.4.&nbsp;Cache de second niveau et cache de requ&ecirc;tes</h3></div></div><div></div></div><p>
                Les propri&eacute;t&eacute;s pr&eacute;fix&eacute;es par <tt class="literal">hibernate.cache</tt>
                vous permettent d'utiliser un syst&egrave;me de cache de second niveau. Ce cache
                peut avoir une port&eacute;e dans le processus ou m&ecirc;me &ecirc;tre utilisable dans un
                syst&egrave;me distribu&eacute;. R&eacute;f&eacute;rez vous au chapitre <a href="#performance-cache" title="19.2.&nbsp;Le cache de second niveau">Section&nbsp;19.2, &laquo;&nbsp;Le cache de second niveau&nbsp;&raquo;</a> 
                pour plus de d&eacute;tails.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-querysubstitution"></a>3.4.5.&nbsp;Substitution dans le langage de requ&ecirc;tage</h3></div></div><div></div></div><p>
                Vous pouvez d&eacute;finir de nouveaux tokens dans les requ&ecirc;tes Hibernate en utilisant la propri&eacute;t&eacute;
                <tt class="literal">hibernate.query.substitutions</tt>. Par exemple :
            </p><pre class="programlisting">hibernate.query.substitutions vrai=1, faux=0</pre><p>
                remplacerait les tokens <tt class="literal">vrai</tt> et <tt class="literal">faux</tt> par
                des entiers dans le SQL g&eacute;n&eacute;r&eacute;.
            </p><pre class="programlisting">hibernate.query.substitutions toLowercase=LOWER</pre><p>
                permettrait de renommer la fonction SQL <tt class="literal">LOWER</tt> en <tt class="literal">toLowercase</tt>
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-statistics"></a>3.4.6.&nbsp;Statistiques Hibernate</h3></div></div><div></div></div><p>
                Si vous activez <tt class="literal">hibernate.generate_statistics</tt>, Hibernate va
                fournir un certains nombre de m&eacute;triques utiles pour r&eacute;gler les performances
                d'une application qui tourne via <tt class="literal">SessionFactory.getStatistics()</tt>.
                Hibernate peut aussi &ecirc;tre configur&eacute; pour exposer ces statistiques via JMX.
                Lisez les Javadoc des interfaces dans le package
                <tt class="literal">org.hibernate.stats</tt> pour plus d'informations.
            </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-logging"></a>3.5.&nbsp;Tracer</h2></div></div><div></div></div><p>
            Hibernate trace divers &eacute;v&egrave;nements en utilisant Apache commons-logging.
        </p><p>
            Le service commons-logging d&eacute;l&egrave;guera directement &agrave; Apache Log4j
            (si vous incluez <tt class="literal">log4j.jar</tt> dans votre classpath)
            ou le syst&egrave;me de trace du JDK 1.4 (si vous tournez sous le JDK 1.4
            et sup&eacute;rieur). Vous pouvez t&eacute;l&eacute;charger Log4j &agrave; partir de
            <tt class="literal">http://jakarta.apache.org</tt>. Pour utiliser Log4j,
            vous devrez placer dans votre classpath un fichier 
            <tt class="literal">log4j.properties</tt>. Un exemple de fichier est distribu&eacute;
            avec Hibernate dans le r&eacute;pertoire <tt class="literal">src/</tt>.
        </p><p>
            Nous vous recommandons fortement de vous familiariser avec les messages des traces 
            d'Hibernate. Beaucoup de soins a &eacute;t&eacute; apport&eacute; pour donner le plus de d&eacute;tails
            possible sans les rendre illisibles. C'est un outil essentiel en cas de soucis.
            Les cat&eacute;gories de trace les plus int&eacute;ressantes sont les suivantes :
        </p><div class="table"><a name="log-categories"></a><p class="title"><b>Tableau&nbsp;3.9.&nbsp;Cat&eacute;gories de trace d'Hibernate</b></p><table summary="Cat&eacute;gories de trace d'Hibernate" border="1"><colgroup><col><col></colgroup><thead><tr><th>Cat&eacute;gorie</th><th>Fonction</th></tr></thead><tbody><tr><td><tt class="literal">org.hibernate.SQL</tt></td><td>Trace toutes les requ&ecirc;ts SQL de type DML (gestion des donn&eacute;es) qui sont ex&eacute;cut&eacute;es</td></tr><tr><td><tt class="literal">org.hibernate.type</tt></td><td>Trace tous les param&egrave;tres JDBC</td></tr><tr><td><tt class="literal">org.hibernate.tool.hbm2ddl</tt></td><td>Trace toutes les requ&ecirc;ts SQL de type DDL (gestion de la structure de la base) qui sont ex&eacute;cut&eacute;es</td></tr><tr><td><tt class="literal">org.hibernate.pretty</tt></td><td>
                                Trace l'&eacute;tat de toutes les entit&eacute;s (20 entit&eacute;s maximum) qui
                                sont associ&eacute;es avec la session hibernate au moment du flush
                            </td></tr><tr><td><tt class="literal">org.hibernate.cache</tt></td><td>Trace toute l'activit&eacute; du cache de second niveau</td></tr><tr><td><tt class="literal">org.hibernate.transaction</tt></td><td>Trace toute l'activit&eacute; relative aux transactions</td></tr><tr><td><tt class="literal">org.hibernate.jdbc</tt></td><td>Trace toute acquisition de ressource JDBC</td></tr><tr><td><tt class="literal">org.hibernate.hql.ast.AST</tt></td><td>
                                Trace l'arbre syntaxique des requ&ecirc;tes HQL et SQL durant l'analyse syntaxique des requ&ecirc;tes
                            </td></tr><tr><td><tt class="literal">org.hibernate.secure</tt></td><td>Trace toutes les demandes d'autorisation JAAS</td></tr><tr><td><tt class="literal">org.hibernate</tt></td><td>
                                Trace tout (beaucoupe d'informations, mais tr&egrave;s utile pour r&eacute;soudre les probl&egrave;mes).
                            </td></tr></tbody></table></div><p>
            Lorsque vous d&eacute;veloppez des applications avec Hibernate, vous devriez quasiment toujours
            travailler avec le niveau <tt class="literal">debug</tt> activ&eacute; pour la cat&eacute;gorie
            <tt class="literal">org.hibernate.SQL</tt>, ou sinon avec la propri&eacute;t&eacute; 
            <tt class="literal">hibernate.show_sql</tt> activ&eacute;e.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-namingstrategy"></a>3.6.&nbsp;Impl&eacute;menter une <tt class="literal">NamingStrategy</tt></h2></div></div><div></div></div><p>
            L'interface <tt class="literal">org.hibernate.cfg.NamingStrategy</tt> vous permet de
            sp&eacute;cifier une "strat&eacute;gie de nommage" des objets et &eacute;l&eacute;ments de la base de donn&eacute;es.
        </p><p>
            Vous pouvez fournir des r&egrave;gles pour automatiquement g&eacute;n&eacute;rer les identifiants
            de base de donn&eacute;es &agrave; partir des identifiants Java, ou transformer une colonne
            ou table "logique" donn&eacute;e dans le fichier de mapping en une colonne ou table
            "physique". Cette fonctionnalit&eacute; aide &agrave; r&eacute;duire la verbosit&eacute; de documents
            de mapping, en &eacute;liminant le bruit r&eacute;p&eacute;titif (les pr&eacute;fixes <tt class="literal">TBL_</tt>
            par exemple). La strat&eacute;gie par d&eacute;faut utilis&eacute;e par Hibernate est minimale.
        </p><p>
            Vous pouvez d&eacute;finir une strat&eacute;gie diff&eacute;rente en appelant
            <tt class="literal">Configuration.setNamingStrategy()</tt> avant d'ajouter des
            mappings :
        </p><pre class="programlisting">SessionFactory sf = new Configuration()
    .setNamingStrategy(ImprovedNamingStrategy.INSTANCE)
    .addFile("Item.hbm.xml")
    .addFile("Bid.hbm.xml")
    .buildSessionFactory();</pre><p>
            <tt class="literal">net.sf.hibernate.cfg.ImprovedNamingStrategy</tt> est une 
            strat&eacute;gie fournie qui peut &ecirc;tre utile comme point de d&eacute;part de quelques
            applications.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-xmlconfig"></a>3.7.&nbsp;Fichier de configuration XML</h2></div></div><div></div></div><p>
            Une approche alternative est de sp&eacute;cifier toute la configuration dans un
            fichier nomm&eacute; <tt class="literal">hibernate.cfg.xml</tt>. Ce fichier peut &ecirc;tre 
            utilis&eacute; &agrave; la place du fichier <tt class="literal">hibernate.properties</tt>, voire
            m&ecirc;me peut servir &agrave; surcharger les propri&eacute;t&eacute;s si les deux fichiers sont pr&eacute;sents.
        </p><p>
            Le fichier de configuration XML doit par d&eacute;faut se placer &agrave; la racine
            du <tt class="literal">CLASSPATH</tt>. En voici un exemple :
        </p><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
    "-//Hibernate/Hibernate Configuration DTD//EN"
    "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;

&lt;hibernate-configuration&gt;

    &lt;!-- a SessionFactory instance listed as /jndi/name --&gt;
    &lt;session-factory
        name="java:hibernate/SessionFactory"&gt;

        &lt;!-- properties --&gt;
        &lt;property name="connection.datasource"&gt;java:/comp/env/jdbc/MyDB&lt;/property&gt;
        &lt;property name="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;
        &lt;property name="show_sql"&gt;false&lt;/property&gt;
        &lt;property name="transaction.factory_class"&gt;
            org.hibernate.transaction.JTATransactionFactory
        &lt;/property&gt;
        &lt;property name="jta.UserTransaction"&gt;java:comp/UserTransaction&lt;/property&gt;

        &lt;!-- mapping files --&gt;
        &lt;mapping resource="org/hibernate/auction/Item.hbm.xml"/&gt;
        &lt;mapping resource="org/hibernate/auction/Bid.hbm.xml"/&gt;

        &lt;!-- cache settings --&gt;
        &lt;class-cache class="org.hibernate.auction.Item" usage="read-write"/&gt;
        &lt;class-cache class="org.hibernate.auction.Bid" usage="read-only"/&gt;
        &lt;collection-cache collection="org.hibernate.auction.Item.bids" usage="read-write"/&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre><p>
          Commme vous pouvez le voir, l'avantage de cette approche est l'externalisation
          des noms des fichiers de mapping de la configuration. Le fichier <tt class="literal">hibernate.cfg.xml</tt>
          est &eacute;galement plus pratique quand on commence &agrave; r&eacute;gler le cache d'Hibernate. Notez
          que vous pouvez choisir entre utiliser <tt class="literal">hibernate.properties</tt> ou
          <tt class="literal">hibernate.cfg.xml</tt>, les deux sont &eacute;quivalents, sauf en ce qui
          concerne les b&eacute;n&eacute;fices de l'utilisation de la syntaxe XML mentionn&eacute;s ci-dessus.
       </p><p>
           Avec la configuration XML, d&eacute;marrer Hibernate devient donc aussi simple que ceci :
       </p><pre class="programlisting">SessionFactory sf = new Configuration().configure().buildSessionFactory();</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-j2ee"></a>3.8.&nbsp;Int&eacute;gration &agrave; un serveur d'application J2EE</h2></div></div><div></div></div><p>
            Hibernate poss&egrave;de les points suivants d'int&eacute;gration &agrave; l'infrastructure J2EE :
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                <span class="emphasis"><em>Source de donn&eacute;es g&eacute;r&eacute;e par le conteneur</em></span> : Hibernate peut
                utiliser des connexions JDBC g&eacute;r&eacute;es par le conteneur et fournie par l'interm&eacute;diaire
                de JNDI. Souvent, un <tt class="literal">TransactionManager</tt> compatible JTA
                et un <tt class="literal">ResourceManager</tt> s'occupent de la gestion des transactions (CMT).
                Ils sont particuli&egrave;rement pr&eacute;vus pour pouvoir g&eacute;rer des transactions distribu&eacute;es
                sur plusieurs sources de donn&eacute;es. Vous pouvez bien s&ucirc;r &eacute;galement d&eacute;finir vos
                limites de transaction dans votre programme (BMT) ou vous pouvez sinon aussi
                utiliser l'API optionnelle <tt class="literal">Transaction</tt> d'Hibernate qui vous garantira
                la portabilit&eacute; de votre code entre plusieurs serveurs d'application.
                </p></li></ul></div><div class="itemizedlist"><ul type="disc"><li><p>
                <span class="emphasis"><em>Association JNDI automatique</em></span>: Hibernate peut associer sa
                <tt class="literal">SessionFactory</tt> &agrave; JNDI apr&egrave;s le d&eacute;marrage.
                </p></li></ul></div><div class="itemizedlist"><ul type="disc"><li><p>
                <span class="emphasis"><em>Association de la Session &agrave; JTA:</em></span> La <tt class="literal">Session</tt> Hibernate
                peut &ecirc;tre associ&eacute;e automatiquement &agrave; une transaction JTA si vous utilisez les EJBs.
                Vous avez juste &agrave; r&eacute;cup&eacute;rer la <tt class="literal">SessionFactory</tt> depuis JNDI et
                &agrave; r&eacute;cup&eacute;rer la <tt class="literal">Session</tt> courante. Hibernate s'occupe de vider et
                fermer la <tt class="literal">Session</tt> lorsque le transaction JTA se termine. La
                d&eacute;marcation des transactions se fait de mani&egrave;re d&eacute;clarative dans les descripteurs de d&eacute;ploiement.
                </p></li></ul></div><div class="itemizedlist"><ul type="disc"><li><p>
                <span class="emphasis"><em>D&eacute;ploiement JMX :</em></span>Si vous avez un serveur d'application compatible JMX
                (JBoss AS par exemple), vous pouvez choisir de d&eacute;ployer Hibernate en temps que MBean g&eacute;r&eacute; par
                le serveur. Cela vous &eacute;vite de coder la ligne de d&eacute;marrage qui permet de construire
                la <tt class="literal">SessionFactory</tt> depuis la <tt class="literal">Configuration</tt>.
                Le conteneur va d&eacute;marrer votre <tt class="literal">HibernateService</tt>, et va id&eacute;alement
                s'occuper des d&eacute;pendances entre les services (la source de donn&eacute;es doit &ecirc;tre disponible
                avant qu'Hibernate ne d&eacute;marre, etc).
                </p></li></ul></div><p>
            En fonction de votre environnement, vous devrez peut &ecirc;tre mettre l'option de 
            configuration <tt class="literal">hibernate.connection.aggressive_release</tt> &agrave; vrai si
            le serveur d'application affiche des exceptions de type "connection containment".
        </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-transactionstrategy"></a>3.8.1.&nbsp;Configuration de la strat&eacute;gie transactionnelle</h3></div></div><div></div></div><p>
                L'API de la <tt class="literal">Session</tt> Hibernate est ind&eacute;pendante de tout syst&egrave;me
                de d&eacute;marcation des transactions qui peut &ecirc;tre pr&eacute;sent dans votre architecture. Si
                vous laissez Hibernate utiliser l'API JDBC directement via un pool de connexion, vous
                devrez commencer et terminer vos transactions en utilisant l'API JDBC. Si votre
                application tourne &agrave; l'int&eacute;rieur d'un serveur d'application J2EE, vous voudrez peut &ecirc;tre
                utiliser les transactions g&eacute;r&eacute;es par les beans (BMT) et appeller l'API JTA et 
                <tt class="literal">UserTransaction</tt> lorsque cela est n&eacute;cessaire.
            </p><p>
                Pour conserver votre code portable entre ces deux environnements (et d'autres &eacute;ventuels)
                nous vous recommandons d'utiliser l'API optionnelle <tt class="literal">Transaction</tt> d'Hibernate,
                qui va encapsuler et masquer le syst&egrave;me de transaction sous-jacent.
                Pour cela, vous devez pr&eacute;ciser une classe de fabrique d'instances de <tt class="literal">Transaction</tt>
                en positionnant la propri&eacute;t&eacute;
                <tt class="literal">hibernate.transaction.factory_class</tt>.
            </p><p>
                Il existe trois choix standards (fournis) :
            </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">net.sf.hibernate.transaction.JDBCTransactionFactory</tt></span></dt><dd><p>d&eacute;l&egrave;gue aux transactions de la base de donn&eacute;es (JDBC). Valeur par d&eacute;faut.</p></dd><dt><span class="term"><tt class="literal">org.hibernate.transaction.JTATransactionFactory</tt></span></dt><dd><p>
                            d&eacute;l&egrave;gue &agrave; CMT si une transaction existante est sous ce contexte (ex: m&eacute;thode
                            d'un EJB session), sinon une nouvelle transaction est entam&eacute;e et
                            une transaction g&eacute;r&eacute;e par le bean est utilis&eacute;e.
                        </p></dd><dt><span class="term"><tt class="literal">org.hibernate.transaction.CMTTransactionFactory</tt></span></dt><dd><p>d&eacute;l&egrave;gue &agrave; aux transactions JTA g&eacute;r&eacute;es par le conteneur</p></dd></dl></div><p>
                Vous pouvez &eacute;galement d&eacute;finir votre propre strat&eacute;gie transactionnelle
                (pour un service de transaction CORBA par exemple).
            </p><p>
                Certaines fonctionnalit&eacute;s d'Hibernate (i.e. le cache de second niveau, l'association
                automatique des Session &agrave; JTA, etc.) n&eacute;cessitent l'acc&egrave;s au <tt class="literal">TransactionManager</tt>
                JTA dans un environnement "manag&eacute;". Dans un serveur d'application, vous devez indiquer
                comment Hibernate peut obtenir une r&eacute;f&eacute;rence vers le <tt class="literal">TransactionManager</tt>,
                car J2EE ne fournit pas un seul m&eacute;canisme standard.
            </p><div class="table"><a name="jtamanagerlookup"></a><p class="title"><b>Tableau&nbsp;3.10.&nbsp;TransactionManagers JTA</b></p><table summary="TransactionManagers JTA" border="1"><colgroup><col><col></colgroup><thead><tr><th>Fabrique de Transaction</th><th align="center">Serveur d'application</th></tr></thead><tbody><tr><td><tt class="literal">org.hibernate.transaction.JBossTransactionManagerLookup</tt></td><td align="center">JBoss</td></tr><tr><td><tt class="literal">org.hibernate.transaction.WeblogicTransactionManagerLookup</tt></td><td align="center">Weblogic</td></tr><tr><td><tt class="literal">org.hibernate.transaction.WebSphereTransactionManagerLookup</tt></td><td align="center">WebSphere</td></tr><tr><td><tt class="literal">org.hibernate.transaction.WebSphereExtendedJTATransactionLookup</tt></td><td align="center">WebSphere 6</td></tr><tr><td><tt class="literal">org.hibernate.transaction.OrionTransactionManagerLookup</tt></td><td align="center">Orion</td></tr><tr><td><tt class="literal">org.hibernate.transaction.ResinTransactionManagerLookup</tt></td><td align="center">Resin</td></tr><tr><td><tt class="literal">org.hibernate.transaction.JOTMTransactionManagerLookup</tt></td><td align="center">JOTM</td></tr><tr><td><tt class="literal">org.hibernate.transaction.JOnASTransactionManagerLookup</tt></td><td align="center">JOnAS</td></tr><tr><td><tt class="literal">org.hibernate.transaction.JRun4TransactionManagerLookup</tt></td><td align="center">JRun4</td></tr><tr><td><tt class="literal">org.hibernate.transaction.BESTransactionManagerLookup</tt></td><td align="center">Borland ES</td></tr></tbody></table></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-jndi"></a>3.8.2.&nbsp;<tt class="literal">SessionFactory</tt> associ&eacute;e au JNDI</h3></div></div><div></div></div><p>
                Une <tt class="literal">SessionFactory</tt> Hibernate associ&eacute;e au JNDI peut 
                simplifier l'acc&egrave;s &agrave; la fabrique et donc la cr&eacute;ation de nouvelles
                <tt class="literal">Session</tt>s. Notez que cela n'est pas li&eacute; avec les <tt class="literal">Datasource</tt>
                associ&eacute;es au JNDI, elles utilisent juste le m&ecirc;me registre.
            </p><p>
                Si vous d&eacute;sirez associer la <tt class="literal">SessionFactory</tt> &agrave; un nom JNDI,
                sp&eacute;cifiez un nom (ex. <tt class="literal">java:hibernate/SessionFactory</tt>) en
                utilisant la propri&eacute;t&eacute; <tt class="literal">hibernate.session_factory_name</tt>.
                Si cette propri&eacute;t&eacute; est omise, la <tt class="literal">SessionFactory</tt> ne sera pas
                associ&eacute;e au JNDI (c'est particuli&egrave;rement pratique dans les environnements ayant une
                impl&eacute;mentation de JNDI en lecture seule, comme c'est le cas pour Tomcat).
            </p><p>
                Lorsqu'il associe la <tt class="literal">SessionFactory</tt> au JNDI, Hibernate utilisera 
                les valeurs de <tt class="literal">hibernate.jndi.url</tt>, <tt class="literal">hibernate.jndi.class</tt>
                pour instancier un contexte d'initialisation. S'ils ne sont pas sp&eacute;cifi&eacute;s, 
                l'<tt class="literal">InitialContext</tt> par d&eacute;faut sera utilis&eacute;.
            </p><p>
                Hibernate va automatiquement placer la <tt class="literal">SessionFactory</tt> dans JNDI
                apr&egrave;s avoir appel&eacute; <tt class="literal">cfg.buildSessionFactory()</tt>. Cela signifie que vous
                devez avoir cet appel dans un code de d&eacute;marrage (ou dans une classe utilitaire) dans
                votre application sauf si vous utilisez le d&eacute;ploiement JMX avec le service
                <tt class="literal">HibernateService</tt> pr&eacute;sent&eacute; plus tard dans ce document.
            </p><p>           
                Si vous utilisez <tt class="literal">SessionFactory</tt> JNDI, un EJB ou n'importe quelle autre classe
                peut obtenir la <tt class="literal">SessionFactory</tt> en utilisant un lookup JNDI.
            </p><p>
                Nous recommandons que vous liiez la <tt class="literal">SessionFactory</tt> &agrave; JNDI dans les
                environnements manag&eacute;s et que vous utilisiez un singleton <tt class="literal">static</tt> si ce n'est pas le cas.
                Pour isoler votre application de ces d&eacute;tails, nous vous recommandons aussi de masquer
                le code de lookup actuel pour une <tt class="literal">SessionFactory</tt> dans une classe helper,
                comme <tt class="literal">HibernateUtil.getSessionFactory()</tt>. Notez qu'une telle classe
                est aussi un moyen efficace de d&eacute;marrer Hibernate&#8212;voir chapitre 1.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-j2ee-currentsession"></a>3.8.3.&nbsp;Association automatique de la Session &agrave; JTA</h3></div></div><div></div></div><p>
                Le moyen le plus simple de g&eacute;rer les <tt class="literal">Session</tt>s et transactions est
                la gestion automatique de session "courante" offerte par Hibernate.
                Voir d&eacute;tail &agrave; <a href="#architecture-current-session" title="2.5.&nbsp;Sessions Contextuelles">Section&nbsp;2.5, &laquo;&nbsp;Sessions Contextuelles&nbsp;&raquo;</a>.
                En utilisant le contexte de session <tt class="literal">"jta"</tt> session context, s'il n'y a pas
                de <tt class="literal">Session</tt> associ&eacute;e &agrave; la transaction JTA courante, une session sera
                d&eacute;marr&eacute;e et associ&eacute;e &agrave; la transaction JTA courante la premi&egrave;re fois que vous appelez
                <tt class="literal">sessionFactory.getCurrentSession()</tt>. Les <tt class="literal">Session</tt>s
                obtenue via <tt class="literal">getCurrentSession()</tt> dans une contexte <tt class="literal">"jta"</tt> 
                seront automatiquement flush&eacute;es avant la validation de la transaction, ferm&eacute;es une fois
                la transaction compl&eacute;t&eacute;e, et lib&eacute;reront les connexions JDBC de mani&egrave;re aggressive
                apr&egrave;s chaque statement. Ceci permet aux <tt class="literal">Session</tt>s d'&ecirc;tre
                g&eacute;r&eacute;es par le cycle de vie de la transaction JTA &agrave; la quelle est sont associ&eacute;es, 
                laissant le code de l'utilisateur propre de ce type de gestion. Votre code peut
                soit utiliser JTA de mani&egrave;re programmatique via <tt class="literal">UserTransaction</tt>, ou (ce qui est recommand&eacute;
                pour la portabilit&eacute; du code) utiliser l'API <tt class="literal">Transaction</tt> API pour marquer
                les limites. Si vous ex&eacute;cutez sous un conteneur EJB, la d&eacute;marcation d&eacute;clarative des transactions
                avec CMT est recommand&eacute;e.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-j2ee-jmx"></a>3.8.4.&nbsp;D&eacute;ploiement JMX</h3></div></div><div></div></div><p>
                La ligne <tt class="literal">cfg.buildSessionFactory()</tt>  doit toujours &ecirc;tre ex&eacute;cut&eacute;e
                quelque part pour avoir une <tt class="literal">SessionFactory</tt> dans JNDI. Vous pouvez
                faire cela dans un bloc d'initialisation <tt class="literal">static</tt> (comme
                celui qui se trouve dans la classe <tt class="literal">HibernateUtil</tt>) ou vous pouvez
                d&eacute;ployer Hibernate en temps que <span class="emphasis"><em>service manag&eacute;</em></span>.
            </p><p>
                Hibernate est distribu&eacute; avec <tt class="literal">org.hibernate.jmx.HibernateService</tt>
                pour le d&eacute;ploiement sur un serveur d'application avec le support de JMX comme JBoss AS.
                Le d&eacute;ploiement et la configuration sont sp&eacute;cifiques &agrave; chaque vendeur. Voici un fichier
                <tt class="literal">jboss-service.xml</tt> d'exemple pour JBoss 4.0.x:
            </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;server&gt;

&lt;mbean code="org.hibernate.jmx.HibernateService"
    name="jboss.jca:service=HibernateFactory,name=HibernateFactory"&gt;

    &lt;!-- Required services --&gt;
    &lt;depends&gt;jboss.jca:service=RARDeployer&lt;/depends&gt;
    &lt;depends&gt;jboss.jca:service=LocalTxCM,name=HsqlDS&lt;/depends&gt;

    &lt;!-- Bind the Hibernate service to JNDI --&gt;
    &lt;attribute name="JndiName"&gt;java:/hibernate/SessionFactory&lt;/attribute&gt;

    &lt;!-- Datasource settings --&gt;
    &lt;attribute name="Datasource"&gt;java:HsqlDS&lt;/attribute&gt;
    &lt;attribute name="Dialect"&gt;org.hibernate.dialect.HSQLDialect&lt;/attribute&gt;

    &lt;!-- Transaction integration --&gt;
    &lt;attribute name="TransactionStrategy"&gt;
        org.hibernate.transaction.JTATransactionFactory&lt;/attribute&gt;
    &lt;attribute name="TransactionManagerLookupStrategy"&gt;
        org.hibernate.transaction.JBossTransactionManagerLookup&lt;/attribute&gt;
    &lt;attribute name="FlushBeforeCompletionEnabled"&gt;true&lt;/attribute&gt;
    &lt;attribute name="AutoCloseSessionEnabled"&gt;true&lt;/attribute&gt;

    &lt;!-- Fetching options --&gt;
    &lt;attribute name="MaximumFetchDepth"&gt;5&lt;/attribute&gt;

    &lt;!-- Second-level caching --&gt;
    &lt;attribute name="SecondLevelCacheEnabled"&gt;true&lt;/attribute&gt;
    &lt;attribute name="CacheProviderClass"&gt;org.hibernate.cache.EhCacheProvider&lt;/attribute&gt;
    &lt;attribute name="QueryCacheEnabled"&gt;true&lt;/attribute&gt;

    &lt;!-- Logging --&gt;
    &lt;attribute name="ShowSqlEnabled"&gt;true&lt;/attribute&gt;

    &lt;!-- Mapping files --&gt;
    &lt;attribute name="MapResources"&gt;auction/Item.hbm.xml,auction/Category.hbm.xml&lt;/attribute&gt;

&lt;/mbean&gt;

&lt;/server&gt;</pre><p>
                Ce fichier est d&eacute;ploy&eacute; dans un r&eacute;pertoire <tt class="literal">META-INF</tt> et est packag&eacute;
                dans un fichier JAR avec l'extension <tt class="literal">.sar</tt> (service archive).
                Vous devez &eacute;galement packager Hibernate, les librairies tierces requises, vos classes
                persistantes compil&eacute;es et vos fichiers de mapping dans la m&ecirc;me archive. Vos beans
                entreprise (souvent des EJBs session) peuvent rester dans leur propre fichier JAR mais
                vous pouvez inclure ce fichier JAR dans le jar principal du service pour avoir une seule unit&eacute;
                d&eacute;ployable &agrave; chaud. Vous pouvez consulter la documentation de JBoss AS pour plus d'information
                sur les services JMX et le d&eacute;ploiement des EJBs.
            </p></div></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="persistent-classes"></a>Chapitre&nbsp;4.&nbsp;Classes persistantes</h2></div></div><div></div></div><p>
        Les classes persistantes sont les classes d'une application qui impl&eacute;mentent
        les entit&eacute;s d'un probl&egrave;me m&eacute;tier (ex. Client et Commande dans une application
        de commerce &eacute;lectronique).
        Toutes les instances d'une classe persistante ne sont pas forc&eacute;ment 
        dans l'&eacute;tat persistant - au lieu de cela, une instance peut &ecirc;tre &eacute;ph&eacute;m&egrave;re (NdT : transient) ou d&eacute;tach&eacute;e.
    </p><p>
        Hibernate fonctionne de mani&egrave;re optimale lorsque ces classes suivent quelques r&egrave;gles
        simples, aussi connues comme le mod&egrave;le de programmation Plain Old Java Object
        (POJO). Cependant, aucune de ces r&egrave;gles ne sont des besoins absolus. En effet, Hibernate3 suppose tr&egrave;s peu de choses &agrave; propos
        de la nature de vos objets persistants. Vous pouvez exprimer un mod&egrave;le de domaine par d'autres moyens : utiliser des arbres
        d'instances de <tt class="literal">Map</tt>, par exemple.
    </p><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-pojo"></a>4.1.&nbsp;Un exemple simple de POJO</h2></div></div><div></div></div><p>
            Toute bonne application Java n&eacute;cessite une classe persistante
            repr&eacute;sentant les f&eacute;lins.
        </p><pre class="programlisting">package eg;
import java.util.Set;
import java.util.Date;

public class Cat {
    private Long id; // identifier

    private Date birthdate;
    private Color color;
    private char sex;
    private float weight;
    private int litterId;

    private Cat mother;
    private Set kittens = new HashSet();

    private void setId(Long id) {
        this.id=id;
    }
    public Long getId() {
        return id;
    }

    void setBirthdate(Date date) {
        birthdate = date;
    }
    public Date getBirthdate() {
        return birthdate;
    }

    void setWeight(float weight) {
        this.weight = weight;
    }
    public float getWeight() {
        return weight;
    }

    public Color getColor() {
        return color;
    }
    void setColor(Color color) {
        this.color = color;
    }

    void setSex(char sex) {
        this.sex=sex;
    }
    public char getSex() {
        return sex;
    }

    void setLitterId(int id) {
        this.litterId = id;
    }
    public int getLitterId() {
        return litterId;
    }

    void setMother(Cat mother) {
        this.mother = mother;
    }
    public Cat getMother() {
        return mother;
    }
    void setKittens(Set kittens) {
        this.kittens = kittens;
    }
    public Set getKittens() {
        return kittens;
    }

    // addKitten not needed by Hibernate
    public void addKitten(Cat kitten) {
        kitten.setMother(this);
    kitten.setLitterId( kittens.size() );
        kittens.add(kitten);
    }
}</pre><p>
            Il y a quatre r&egrave;gles &agrave; suivre ici :
        </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-pojo-constructor"></a>4.1.1.&nbsp;Impl&eacute;menter un constructeur sans argument</h3></div></div><div></div></div><p>
                <tt class="literal">Cat</tt> a un constructeur sans argument. Toutes les classes persistantes doivent avoir un
                constructeur par d&eacute;faut (lequel peut ne pas &ecirc;tre public) pour qu'Hibernate puissent les instancier en utilisant
                <tt class="literal">Constructor.newInstance()</tt>. Nous recommandons fortement d'avoir un constructeur par d&eacute;faut avec 
                au moins une visibilit&eacute; <span class="emphasis"><em>paquet</em></span> pour la g&eacute;n&eacute;ration du proxy &agrave; l'ex&eacute;cution dans Hibernate.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-pojo-identifier"></a>4.1.2.&nbsp;Fournir une propri&eacute;t&eacute; d'indentifiant (optionnel)</h3></div></div><div></div></div><p>
                <tt class="literal">Cat</tt> poss&egrave;de une propri&eacute;t&eacute; appel&eacute;e <tt class="literal">id</tt>.
                Cette propri&eacute;t&eacute; mappe la valeur de la colonne de cl&eacute; primaire de la table
                d'une base de donn&eacute;es.La propri&eacute;t&eacute; aurait pu s'appeler compl&egrave;tement autrement,
                et son type aurait pu &ecirc;tre n'importe quel type primitif, n'importe quel "encapsuleur"
                de type primitif, <tt class="literal">java.lang.String</tt> ou <tt class="literal">java.util.Date</tt>.
                (Si votre base de donn&eacute;es h&eacute;rit&eacute;e poss&egrave;de des cl&eacute;s composites, elles peuvent &ecirc;tre mapp&eacute;es
                en utilisant une classe d&eacute;finie par l'utilisateur et poss&eacute;dant les propri&eacute;t&eacute;s associ&eacute;es aux
                types de la cl&eacute; composite - voir la section concernant les identifiants composites plus tard).
            </p><p>
                La propri&eacute;t&eacute; d'identifiant est strictement optionnelle. Vous pouver l'oublier et laisser Hibernate
                s'occuper des identifiants de l'objet en interne. Toutefois, nous ne le recommandons pas.
            </p><p>
                En fait, quelques fonctionnalit&eacute;s ne sont disponibles que pour les classes
                d&eacute;clarant un identifiant de propri&eacute;t&eacute; :
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        Les r&eacute;attachements transitifs pour les objets d&eacute;tach&eacute;s (mise &agrave; jour en cascade ou fusion en cascade) - 
                        voir <a href="#objectstate-transitive" title="10.11.&nbsp;Persistance transitive">Section&nbsp;10.11, &laquo;&nbsp;Persistance transitive&nbsp;&raquo;</a>
                    </p></li><li><p>
                        <tt class="literal">Session.saveOrUpdate()</tt>
                    </p></li><li><p>
                        <tt class="literal">Session.merge()</tt>
                    </p></li></ul></div><p>
                Nous recommandons que vous d&eacute;clariez les propri&eacute;t&eacute;s d'identifiant de mani&egrave;re
                uniforme. Nous recommandons &eacute;galement que vous utilisiez un type nullable
                (ie. non primitif).
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-pojo-final"></a>4.1.3.&nbsp;Favoriser les classes non finales (optionnel)</h3></div></div><div></div></div><p>
                Une fonctionnalit&eacute; clef d'Hibernate, les <span class="emphasis"><em>proxies</em></span>, n&eacute;cessitent
                que la classe persistente soit non finale ou qu'elle soit l'impl&eacute;mentation d'une
                interface qui d&eacute;clare toutes les m&eacute;thodes publiques.
            </p><p>
                Vous pouvez persister, gr&acirc;ce &agrave; Hibernate, les classes <tt class="literal">final</tt>
                qui n'impl&eacute;mentent pas d'interface, mais vous ne pourrez pas utiliser les proxies pour les chargements d'associations paresseuses
                - ce qui limitera vos possibilit&eacute;s d'ajustement des performances.
            </p><p>
                Vous devriez aussi &eacute;viter de d&eacute;clarer des m&eacute;thodes <tt class="literal">public final</tt> sur des classes
                non-finales. Si vous voulez utiliser une classe avec une m&eacute;thode <tt class="literal">public final</tt>, vous devez
                explicitement d&eacute;sactiver les proxies en param&eacute;trant
                <tt class="literal">lazy="false"</tt>.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-pojo-accessors"></a>4.1.4.&nbsp;D&eacute;clarer les accesseurs et mutateurs des attributs persistants (optionnel)</h3></div></div><div></div></div><p>
                <tt class="literal">Cat</tt> d&eacute;clare des mutateurs pour toutes ses champs persistants. Beaucoup d'autres
                solutions de mapping Objet/relationnel persistent directement les variables d'instance. Nous pensons
                qu'il est bien mieux de fournir une indirection entre le sch&eacute;ma relationnel et les structures de donn&eacute;es internes de la classe.
                Par d&eacute;faut, Hibernate persiste les propri&eacute;t&eacute;s suivant le style JavaBean, et reconna&icirc;t les noms de m&eacute;thodes de la forme <tt class="literal">
                getFoo</tt>, <tt class="literal">isFoo</tt> et
                <tt class="literal">setFoo</tt>. Nous pouvons changer pour un acc&egrave;s direct aux champs pour des propri&eacute;t&eacute;s particuli&egrave;res, si besoin est.
            </p><p>
                Les propri&eacute;t&eacute;s <span class="emphasis"><em>n'ont pas</em></span> &agrave; &ecirc;tre d&eacute;clar&eacute;es publiques -
                Hibernate peut persister une propri&eacute;t&eacute; avec un paire de getter/setter de
                visibilit&eacute; par d&eacute;fault, <tt class="literal">protected</tt> ou <tt class="literal">
                private</tt>.
            </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-inheritance"></a>4.2.&nbsp;Impl&eacute;menter l'h&eacute;ritage</h2></div></div><div></div></div><p>
            Une sous-classe doit &eacute;galement suivre la premi&egrave;re et la seconde r&egrave;gle.
            Elle h&eacute;rite sa propri&eacute;t&eacute; d'identifiant de <tt class="literal">Cat</tt>.
        </p><pre class="programlisting">package eg;

public class DomesticCat extends Cat {
        private String name;

        public String getName() {
                return name;
        }
        protected void setName(String name) {
                this.name=name;
        }
}</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-equalshashcode"></a>4.3.&nbsp;Impl&eacute;menter <tt class="literal">equals()</tt> et <tt class="literal">hashCode()</tt></h2></div></div><div></div></div><p>
            Vous devez surcharger les m&eacute;thodes <tt class="literal">equals()</tt> et
            <tt class="literal">hashCode()</tt> si vous
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    avez l'intention de mettre des instances de classes persistantes dans un <tt class="literal">Set</tt>
                    (la mani&egrave;re recommand&eacute;e pour repr&eacute;senter des associations pluri-valu&eacute;es)
                    <span class="emphasis"><em>et</em></span>
                </p></li><li><p>
                    avez l'intention d'utiliser le r&eacute;attachement d'instances d&eacute;tach&eacute;es
                </p></li></ul></div><p>
            Hibernate garantit l'&eacute;quivalence de l'identit&eacute; persistante (ligne de base de donn&eacute;es) et l'identit&eacute; Java seulement
            &agrave; l'int&eacute;rieur de la port&eacute;e d'une session particuli&egrave;re. Donc d&egrave;s que nous m&eacute;langeons des instances venant de diff&eacute;rentes
            sessions, nous devons impl&eacute;menter <tt class="literal">equals()</tt> et
            <tt class="literal">hashCode()</tt> si nous souhaitons avoir une s&eacute;mantique correcte pour les <tt class="literal">Set</tt>s.
        </p><p>
            La mani&egrave;re la plus &eacute;vidente est d'impl&eacute;menter <tt class="literal">equals()</tt>/<tt class="literal">hashCode()</tt>
            en comparant la valeur de l'identifiant des deux objets. Si cette valeur est identique, les deux
            doivent repr&eacute;senter la m&ecirc;me ligne de base de donn&eacute;es, ils sont donc &eacute;gaux (si les deux sont
            ajout&eacute;s &agrave; un <tt class="literal">Set</tt>, nous n'aurons qu'un seul &eacute;l&eacute;ment dans le
            <tt class="literal">Set</tt>). Malheureusement, nous ne pouvons pas utiliser cette approche avec 
            des identifiants g&eacute;n&eacute;r&eacute;s ! Hibernate n'assignera de
            valeur d'identifiant qu'aux objets qui sont persistants, une instance nouvellement cr&eacute;&eacute;e n'aura
            donc pas de valeur d'identifiant ! De plus, si une instance est non sauvegard&eacute;e et actuellement dans un <tt class="literal">Set</tt>,
            le sauvegarder assignera une valeur d'identifiant &agrave; l'objet. Si <tt class="literal">equals()</tt> et <tt class="literal">hashCode()</tt>
            sont bas&eacute;es sur la valeur de l'identifiant, le code de hachage devrait changer, rompant le contrat du <tt class="literal">Set</tt>. 
            Regardez sur le site web d'Hibernate pour une discussion compl&egrave;te de ce probl&egrave;me. 
            Notez que ceci n'est pas un probl&egrave;me d'Hibernate, mais la s&eacute;mantique normale de Java pour l'identit&eacute; d'un objet et l'&eacute;galit&eacute;.
        </p><p>
            Nous recommandons donc d'impl&eacute;menter
            <tt class="literal">equals()</tt> et <tt class="literal">hashCode()</tt> en utilisant <span class="emphasis"><em>
            l'&eacute;galit&eacute; par cl&eacute; m&eacute;tier</em></span>.L'&eacute;galit&eacute; par cl&eacute; m&eacute;tier signifie que la m&eacute;thode <tt class="literal">equals()</tt>
            compare uniquement les propri&eacute;t&eacute;s qui forment une cl&eacute; m&eacute;tier, une cl&eacute; qui
            identifierait notre instance dans le monde r&eacute;el (une cl&eacute; candidate
            <span class="emphasis"><em>naturelle</em></span>) :
        </p><pre class="programlisting">public class Cat {

    ...
    public boolean equals(Object other) {
        if (this == other) return true;
        if ( !(other instanceof Cat) ) return false;

        final Cat cat = (Cat) other;

        if ( !cat.getLitterId().equals( getLitterId() ) ) return false;
        if ( !cat.getMother().equals( getMother() ) ) return false;

        return true;
    }

    public int hashCode() {
        int result;
        result = getMother().hashCode();
        result = 29 * result + getLitterId();
        return result;
    }

}</pre><p>
            Notez qu'une clef m&eacute;tier ne doit pas &ecirc;tre solide comme une clef primaire de base de donn&eacute;es 
            (voir <a href="#transactions-basics-identity" title="11.1.3.&nbsp;L'identit&eacute; des objets">Section&nbsp;11.1.3, &laquo;&nbsp;L'identit&eacute; des objets&nbsp;&raquo;</a>). Les propri&eacute;t&eacute;s
            immuables ou uniques sont g&eacute;n&eacute;ralement de bonnes candidates pour une clef m&eacute;tier.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-dynamicmodels"></a>4.4.&nbsp;Mod&egrave;les dynamiques</h2></div></div><div></div></div><p>
            <span class="emphasis"><em>Notez que la fonctionnalit&eacute;s suivantes sont actuellement consid&eacute;r&eacute;es
            comme exp&eacute;rimentales et peuvent changer dans un futur proche.</em></span>
        </p><p>
            Les entit&eacute;s persistantes ne doivent pas n&eacute;cessairement &ecirc;tre repr&eacute;sent&eacute;es comme
            des classes POJO ou des objets JavaBean &agrave; l'ex&eacute;cution. Hibernate supporte aussi les
            mod&egrave;les dynamiques (en utilisant des <tt class="literal">Map</tt>s de <tt class="literal">Map</tt>s
            &agrave; l'ex&eacute;cution) et la repr&eacute;sentation des entit&eacute;s comme des arbres DOM4J. Avec cette
            approche, vous n'&eacute;crivez pas de classes persistantes, seulement des fichiers de mapping.
        </p><p>
            Par d&eacute;faut, Hibernate fonctionne en mode POJO normal. Vous pouvez param&eacute;trer
            un mode de repr&eacute;sentation d'entit&eacute; par d&eacute;faut pour une <tt class="literal">SessionFactory</tt>
            particuli&egrave;re en utilisant l'option de configuration <tt class="literal">default_entity_mode</tt>
            (voir <a href="#configuration-optional-properties" title="Tableau&nbsp;3.3.&nbsp;Propri&eacute;t&eacute;s de configuration d'Hibernate">Tableau&nbsp;3.3, &laquo;&nbsp;Propri&eacute;t&eacute;s de configuration d'Hibernate&nbsp;&raquo;</a>).
        </p><p>
            Les exemples suivants d&eacute;montrent la repr&eacute;sentation utilisant des <tt class="literal">Map</tt>s.
            D'abord, dans le fichier de mapping, un <tt class="literal">entity-name</tt> doit &ecirc;tre d&eacute;clar&eacute;
            au lieu (ou en plus) d'un nom de classe :
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class entity-name="Customer"&gt;

        &lt;id name="id"
            type="long"
            column="ID"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;

        &lt;property name="name"
            column="NAME"
            type="string"/&gt;

        &lt;property name="address"
            column="ADDRESS"
            type="string"/&gt;

        &lt;many-to-one name="organization"
            column="ORGANIZATION_ID"
            class="Organization"/&gt;

        &lt;bag name="orders"
            inverse="true"
            lazy="false"
            cascade="all"&gt;
            &lt;key column="CUSTOMER_ID"/&gt;
            &lt;one-to-many class="Order"/&gt;
        &lt;/bag&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            Notez que m&ecirc;me si des associations sont d&eacute;clar&eacute;es en utilisant des noms de classe cible,
            le type de cible d'une association peut aussi &ecirc;tre une entit&eacute; dynamique au lieu d'un POJO.
        </p><p>
            Apr&egrave;s avoir configur&eacute; le mode d'entit&eacute; par d&eacute;faut &agrave; <tt class="literal">dynamic-map</tt>
            pour la <tt class="literal">SessionFactory</tt>, nous pouvons lors de l'ex&eacute;cution fonctionner
            avec des <tt class="literal">Map</tt>s de <tt class="literal">Map</tt>s :
        </p><pre class="programlisting">Session s = openSession();
Transaction tx = s.beginTransaction();
Session s = openSession();

// Create a customer
Map david = new HashMap();
david.put("name", "David");

// Create an organization
Map foobar = new HashMap();
foobar.put("name", "Foobar Inc.");

// Link both
david.put("organization", foobar);

// Save both
s.save("Customer", david);
s.save("Organization", foobar);

tx.commit();
s.close();</pre><p>
            Les avantages d'un mapping dynamique sont un gain de temps pour le prototypage
            sans la n&eacute;cessit&eacute; d'impl&eacute;menter les classes d'entit&eacute;. Pourtant, vous perdez la
            v&eacute;rification du typage au moment de la compilation et aurez plus d'exceptions &agrave;
            g&eacute;rer lors de l'ex&eacute;cution. Gr&acirc;ce au mapping d'Hibernate, le sch&eacute;ma de la base de
            donn&eacute;es peut facilement &ecirc;tre normalis&eacute; et solidifi&eacute;, permettant de rajouter une
            impl&eacute;mentation propre du mod&egrave;le de domaine plus tard.
        </p><p>
            Les modes de repr&eacute;sentation d'une entit&eacute; peut aussi &ecirc;tre configur&eacute; par <tt class="literal">Session</tt> :
        </p><pre class="programlisting">Session dynamicSession = pojoSession.getSession(EntityMode.MAP);

// Create a customer
Map david = new HashMap();
david.put("name", "David");
dynamicSession.save("Customer", david);
...
dynamicSession.flush();
dynamicSession.close()
...
// Continue on pojoSession
</pre><p>
            Veuillez noter que l'appel &agrave; <tt class="literal">getSession()</tt> en utilisant un
            <tt class="literal">EntityMode</tt> se fait sur l'API <tt class="literal">Session</tt>, pas
            <tt class="literal">SessionFactory</tt>. De cette mani&egrave;re, la nouvelle <tt class="literal">Session</tt>
            partage les connexions JDBC, transactions et autres informations de contexte sous-jacentes.
            Cela signifie que vous n'avez pas &agrave; appeler <tt class="literal">flush()</tt> et <tt class="literal">close()</tt>
            sur la <tt class="literal">Session</tt> secondaire, et laissez aussi la gestion de la transaction
            et de la connexion &agrave; l'unit&eacute; de travail primaire.
        </p><p>
            Plus d'informations &agrave; propos de la repr&eacute;sentation XML peuvent &ecirc;tre trouv&eacute;es dans
            <a href="#xml" title="Chapitre&nbsp;18.&nbsp;Mapping XML">Chapitre&nbsp;18, <i>Mapping XML</i></a>.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-tuplizers"></a>4.5.&nbsp;Tuplizers</h2></div></div><div></div></div><p>
            <tt class="literal">org.hibernate.tuple.Tuplizer</tt>, et ses sous-interfaces, sont responsables
            de la gestion d'une repr&eacute;sentation particuli&egrave;re d'un morceau de donn&eacute;es, en fonction du
            <tt class="literal">org.hibernate.EntityMode</tt> de r&eacute;pr&eacute;sentation. Si un morceau donn&eacute; de donn&eacute;es
            est pens&eacute; comme une structure de donn&eacute;es, alors un tuplizer est la chose qui sait comment
            cr&eacute;er une telle structure de donn&eacute;es, comment extraire des valeurs et injecter des valeurs dans
            une telle structure de donn&eacute;es. Par exemple, pour le mode d'entit&eacute; POJO, le tuplizer correspondant
            sait comment cr&eacute;er le POJO &agrave; travers son constructeur et comment acc&eacute;der aux propri&eacute;t&eacute;s du POJO
            utilisant les accesseurs de la propri&eacute;t&eacute; d&eacute;finie. Il y a deux types de Tuplizers haut niveau,
            repr&eacute;sent&eacute; par les interfaces <tt class="literal">org.hibernate.tuple.EntityTuplizer</tt> et
            <tt class="literal">org.hibernate.tuple.ComponentTuplizer</tt>. Les <tt class="literal">EntityTuplizer</tt>s
            sont responsables de la gestion des contrats mentionn&eacute;s ci-dessus pour les entit&eacute;s, alors que
            les <tt class="literal">ComponentTuplizer</tt>s s'occupent des composants.
        </p><p>
            Les utilisateurs peuvent aussi brancher leurs propres tuplizers. Peut-&ecirc;tre vous est-il n&eacute;cessaire qu'une
            impl&eacute;mentation de <tt class="literal">java.util.Map</tt> autre que <tt class="literal">java.util.HashMap</tt>
            soit utilis&eacute;e dans le mode d'entit&eacute; dynamic-map ; ou peut-&ecirc;tre avez-vous besoin de d&eacute;finir une
            stat&eacute;gie de g&eacute;n&eacute;ration de proxy diff&eacute;rente de celle utilis&eacute;e par d&eacute;faut. Les deux devraient &ecirc;tre
            effectu&eacute;es en d&eacute;finissant une impl&eacute;mentation de tuplizer utilisateur. Les d&eacute;finitions de tuplizers
            sont attach&eacute;es au mapping de l'entit&eacute; ou du composant qu'ils sont cens&eacute;s g&eacute;rer. Retour &agrave; l'exemple de
            notre entit&eacute; utilisateur :
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    &lt;class entity-name="Customer"&gt;
        &lt;!--
            Override the dynamic-map entity-mode
            tuplizer for the customer entity
        --&gt;
        &lt;tuplizer entity-mode="dynamic-map"
                class="CustomMapTuplizerImpl"/&gt;

        &lt;id name="id" type="long" column="ID"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;

        &lt;!-- other properties --&gt;
        ...
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;


public class CustomMapTuplizerImpl
        extends org.hibernate.tuple.DynamicMapEntityTuplizer {
    // override the buildInstantiator() method to plug in our custom map...
    protected final Instantiator buildInstantiator(
            org.hibernate.mapping.PersistentClass mappingInfo) {
        return new CustomMapInstantiator( mappingInfo );
    }

    private static final class CustomMapInstantiator
            extends org.hibernate.tuple.DynamicMapInstantitor {
        // override the generateMap() method to return our custom map...
        protected final Map generateMap() {
            return new CustomMap();
        }
    }
}</pre></div><p>
        TODO: Document user-extension framework in the property and proxy packages
    </p></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="mapping"></a>Chapitre&nbsp;5.&nbsp;Mapping O/R basique</h2></div></div><div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-declaration"></a>5.1.&nbsp;D&eacute;claration de Mapping</h2></div></div><div></div></div><p>
            Les mappings Objet/relationnel sont g&eacute;n&eacute;ralement d&eacute;finis dans un document XML. 
            Le document de mapping est con&ccedil;u pour &ecirc;tre lisible et &eacute;ditable &agrave; la main. 
            Le langage de mapping est Java-centrique, c'est &agrave; dire que les mappings sont construits 
            &agrave; partir des d&eacute;clarations des classes persistantes et non des d&eacute;clarations des tables.
        </p><p>
            Remarquez que m&ecirc;me si beaucoup d'utilisateurs de Hibernate pr&eacute;f&egrave;rent &eacute;crire les 
            fichiers de mappings &agrave; la main, plusieurs outils existent pour g&eacute;n&eacute;rer ce document, 
            notamment XDoclet, Middlegen et AndroMDA.
        </p><p>D&eacute;marrons avec un exemple de mapping :</p><a name="mapping-declaration-ex1"></a><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
      "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
          "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

        &lt;class name="Cat" 
            table="cats"
            discriminator-value="C"&gt;
                
                &lt;id name="id"&gt;
                        &lt;generator class="native"/&gt;
                &lt;/id&gt;

                &lt;discriminator column="subclass" 
                     type="character"/&gt;

                &lt;property name="weight"/&gt;

                &lt;property name="birthdate"
                    type="date" 
                    not-null="true" 
                    update="false"/&gt;

                &lt;property name="color"
                    type="eg.types.ColorUserType"
                    not-null="true"
                    update="false"/&gt;

                &lt;property name="sex"
                    not-null="true" 
                    update="false"/&gt;

                &lt;property name="litterId"
                    column="litterId"
                    update="false"/&gt;

                &lt;many-to-one name="mother"
                    column="mother_id"
                    update="false"/&gt;

                &lt;set name="kittens"
                    inverse="true"
                    order-by="litter_id"&gt;
                        &lt;key column="mother_id"/&gt;
                        &lt;one-to-many class="Cat"/&gt;
                &lt;/set&gt;

                &lt;subclass name="DomesticCat"
                    discriminator-value="D"&gt;

                        &lt;property name="name" 
                            type="string"/&gt;

                &lt;/subclass&gt;

        &lt;/class&gt;

        &lt;class name="Dog"&gt;
                &lt;!-- mapping for Dog could go here --&gt;
        &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
             Etudions le contenu du document de mapping. Nous d&eacute;crirons uniquement 
             les &eacute;l&eacute;ments et attributs du document utilis&eacute;s par Hibernate &agrave; l'ex&eacute;cution. 
             Le document de mapping contient aussi des attributs et &eacute;l&eacute;ments optionnels 
             qui agissent sur le sch&eacute;ma de base de donn&eacute;es export&eacute; par l'outil de 
             g&eacute;n&eacute;ration de sch&eacute;ma. (Par exemple l'attribut <tt class="literal">not-null</tt>.)
        </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-doctype"></a>5.1.1.&nbsp;Doctype</h3></div></div><div></div></div><p>
                Tous les mappings XML devraient utiliser le doctype indiqu&eacute;. 
                Ce fichier est pr&eacute;sent &agrave; l'URL ci-dessus, dans le r&eacute;pertoire 
                <tt class="literal">hibernate-x.x.x/src/org/hibernate</tt> ou dans <tt class="literal">hibernate3.jar</tt>. 
                Hibernate va toujours chercher la DTD dans son classpath en premier lieu. Si vous constatez 
                des recherches de la DTD sur Internet, v&eacute;rifiez votre d&eacute;claration de DTD par rapport 
                au contenu de votre classpath.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-mapping"></a>5.1.2.&nbsp;hibernate-mapping</h3></div></div><div></div></div><p>
                Cet &eacute;l&eacute;ment a plusieurs attributs optionnels. Les attributs <tt class="literal">schema</tt> et <tt class="literal">catalog</tt> 
                indiquent que les tables r&eacute;f&eacute;renc&eacute;es par ce mapping appartiennent au sch&eacute;ma nomm&eacute; et/ou au catalogue. 
                S'ils sont sp&eacute;cifi&eacute;s, les noms de tables seront qualifi&eacute;s par les noms de sch&eacute;ma et catalogue. 
                L'attribut <tt class="literal">default-cascade</tt> indique quel type de cascade sera utlis&eacute; par d&eacute;faut 
                pour les propri&eacute;t&eacute;s et collections qui ne pr&eacute;cisent pas l'attribut <tt class="literal">cascade</tt>. 
                L'attribut <tt class="literal">auto-import</tt> nous permet d'utiliser par d&eacute;faut des noms de classes 
                non qualifi&eacute;s dans le langage de requ&ecirc;te.
            </p><div class="programlistingco"><pre class="programlisting">&lt;hibernate-mapping
         schema="schemaName"                          <span class="co">(1)</span>
         catalog="catalogName"                        <span class="co">(2)</span>
         default-cascade="cascade_style"              <span class="co">(3)</span>
         default-access="field|property|ClassName"    <span class="co">(4)</span>
         default-lazy="true|false"                    <span class="co">(5)</span>
         auto-import="true|false"                     <span class="co">(6)</span>
         package="package.name"                       <span class="co">(7)</span>
 /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">schema</tt> (optionnel) : Le nom d'un sch&eacute;ma de base de donn&eacute;es.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">catalog</tt> (optionnel) : Le nom d'un catalogue de base de donn&eacute;es.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">default-cascade</tt> (optionnel - par d&eacute;faut vaut :  <tt class="literal">none</tt>) : 
                             Un type de cascade par d&eacute;faut.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">default-access</tt> (optionnel - par d&eacute;faut vaut : <tt class="literal">property</tt>) :
                            Comment hibernate acc&egrave;dera aux propri&eacute;t&eacute;s. On peut aussi 
                            red&eacute;finir sa propre impl&eacute;mentation de <tt class="literal">PropertyAccessor</tt>.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">default-lazy</tt> (optionnel - par d&eacute;faut vaut : <tt class="literal">true</tt>) :
                             Valeur par d&eacute;faut pour un attribut <tt class="literal">lazy</tt> 
                             non sp&eacute;cifi&eacute; : celui des mappings de classes et de collection.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">auto-import</tt> (optionnel - par d&eacute;faut vaut : <tt class="literal">true</tt>) :
                             Sp&eacute;cifie si l'on peut utiliser des noms de classes 
                             non qualifi&eacute;s (des classes de ce mapping) dans le langage de requ&ecirc;te.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">package</tt> (optionnel) : Pr&eacute;fixe de package par d&eacute;faut pour 
                            les noms de classe non qualifi&eacute;s du document de mapping.
                             
                         </p></td></tr></table></div></div><p>
                 Si deux classes poss&egrave;dent le m&ecirc;me nom de classe (non qualifi&eacute;), vous devez indiquer 
                 <tt class="literal">auto-import="false"</tt>. Hibernate lancera une exception 
                 si vous essayez d'assigner &agrave; deux classes le m&ecirc;me nom import&eacute;.
             </p><p>
                 Notez que l'&eacute;l&eacute;ment <tt class="literal">hibernate-mapping</tt> vous permet d'imbriquer plusieurs mappings de
                 <tt class="literal">&lt;class&gt;</tt> persistantes, comme dans l'exemple ci-dessus.
                 Cependant la bonne pratique (ce qui est attendu par certains outils) est 
                 de mapper une seule classe (ou une seule hi&eacute;rarchie de classes)
                 par fichier de mapping et de nommer ce fichier d'apr&egrave;s le nom de la superclasse, par exemple
                 <tt class="literal">Cat.hbm.xml</tt>, <tt class="literal">Dog.hbm.xml</tt>, ou en cas d'h&eacute;ritage,
                 <tt class="literal">Animal.hbm.xml</tt>.
             </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-class"></a>5.1.3.&nbsp;class</h3></div></div><div></div></div><p>
                D&eacute;clarez une classe persistante avec l'&eacute;l&eacute;ment <tt class="literal">class</tt> :
            </p><div class="programlistingco"><pre class="programlisting">&lt;class
        name="ClassName"                              <span class="co">(1)</span>
        table="tableName"                             <span class="co">(2)</span>
        discriminator-value="discriminator_value"     <span class="co">(3)</span>
        mutable="true|false"                          <span class="co">(4)</span>
        schema="owner"                                <span class="co">(5)</span>
        catalog="catalog"                             <span class="co">(6)</span>
        proxy="ProxyInterface"                        <span class="co">(7)</span>
        dynamic-update="true|false"                   <span class="co">(8)</span>
        dynamic-insert="true|false"                   <span class="co">(9)</span>
        select-before-update="true|false"             <span class="co">(10)</span>
        polymorphism="implicit|explicit"              <span class="co">(11)</span>
        where="arbitrary sql where condition"         <span class="co">(12)</span>
        persister="PersisterClass"                    <span class="co">(13)</span>
        batch-size="N"                                <span class="co">(14)</span>
        optimistic-lock="none|version|dirty|all"      <span class="co">(15)</span>
        lazy="true|false"                             <span class="co">(16)</span>
        entity-name="EntityName"                      <span class="co">(17)</span>
        catalog="catalog"                             <span class="co">(18)</span>
        check="arbitrary sql check condition"         <span class="co">(19)</span>
        rowid="rowid"                                 <span class="co">(20)</span>
        subselect="SQL expression"                    <span class="co">(21)</span>
        abstract="true|false"
        entity-name="EntityName"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> (optionnel) : Le nom Java complet de la classe (ou interface) persistante.
                             Si cet attribut est absent, il est suppos&eacute; que ce mapping ne se rapporte pas &agrave; une entit&eacute; POJO.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">table</tt> (optionnel - par d&eacute;faut le nom (non-qualifi&eacute;) de la classe) :  Le 
                            nom de sa table en base de donn&eacute;es.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">discriminator-value</tt> (optionnel - par d&eacute;faut le nom de la classe) : 
                            Une valeur permettant de distinguer les sous-classes dans le cas de l'utilisation du polymorphisme. 
                            Les valeurs <tt class="literal">null</tt> et <tt class="literal">not null</tt> sont autoris&eacute;es.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">mutable</tt> (optionnel, vaut <tt class="literal">true</tt> par d&eacute;faut) : Sp&eacute;cifie 
                            que des instances de la classe sont (ou non) immuables.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">schema</tt> (optionnel) : Surcharge le nom de sch&eacute;ma sp&eacute;cifi&eacute; par 
                            l'&eacute;l&eacute;ment racine <tt class="literal">&lt;hibernate-mapping&gt;</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">catalog</tt> (optionnel) : Surcharge le nom du catalogue sp&eacute;cifi&eacute; par
                            l'&eacute;l&eacute;ment racine <tt class="literal">&lt;hibernate-mapping&gt;</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">proxy</tt> (optionnel) : Sp&eacute;cifie une interface &agrave; utiliser pour l'initialisation diff&eacute;r&eacute;e (lazy loading)
                            des proxies. Vous pouvez indiquer le nom de la classe elle-m&ecirc;me.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">dynamic-update</tt> (optionnel, par d&eacute;faut &agrave; <tt class="literal">false</tt>) : 
                            Sp&eacute;cifie que les  <tt class="literal">UPDATE</tt> SQL doivent &ecirc;tre g&eacute;n&eacute;r&eacute;s &agrave; l'ex&eacute;cution et contenir 
                            uniquement les colonnes dont les valeurs ont &eacute;t&eacute; modifi&eacute;es.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                            <tt class="literal">dynamic-insert</tt> (optionnel, par d&eacute;faut &agrave; <tt class="literal">false</tt>): 
                            Sp&eacute;cifie que les <tt class="literal">INSERT</tt> SQL doivent &ecirc;tre g&eacute;n&eacute;r&eacute;s &agrave; l'ex&eacute;cution et ne contenir 
                            que les colonnes dont les valeurs sont non nulles.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                            <tt class="literal">select-before-update</tt> (optionnel, par d&eacute;faut &agrave; <tt class="literal">false</tt>): 
                            Sp&eacute;cifie que Hibernate ne doit <span class="emphasis"><em>jamais</em></span> ex&eacute;cuter un <tt class="literal">UPDATE</tt> SQL 
                            sans &ecirc;tre certain qu'un objet a &eacute;t&eacute; r&eacute;ellement modifi&eacute;. Dans certains cas, (en r&eacute;alit&eacute;, seulement 
                            quand un objet transient a &eacute;t&eacute; associ&eacute; &agrave; une nouvelle session par <tt class="literal">update()</tt>), 
                            cela signifie que Hibernate ex&eacute;cutera un <tt class="literal">SELECT</tt> SQL pour s'assurer qu'un 
                            <tt class="literal">UPDATE</tt> SQL est v&eacute;ritablement n&eacute;cessaire.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(11)</td><td valign="top" align="left"><p>
                            <tt class="literal">polymorphism</tt> (optionnel, vaut <tt class="literal">implicit</tt> par d&eacute;faut) : 
                            D&eacute;termine si, pour cette classe, une requ&ecirc;te polymorphique implicite ou explicite est utilis&eacute;e.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(12)</td><td valign="top" align="left"><p>
                            <tt class="literal">where</tt> (optionnel) sp&eacute;cifie une clause SQL <tt class="literal">WHERE</tt> 
                            &agrave; utiliser lorsque l'on r&eacute;cup&egrave;re des objets de cette classe.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(13)</td><td valign="top" align="left"><p>
                            <tt class="literal">persister</tt> (optionnel) : Sp&eacute;cifie un <tt class="literal">ClassPersister</tt> particulier.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(14)</td><td valign="top" align="left"><p>
                            <tt class="literal">batch-size</tt> (optionnel, par d&eacute;faut = <tt class="literal">1</tt>) : sp&eacute;cifie une taille de batch 
                            pour remplir les instances de cette classe par identifiant en une seule requ&ecirc;te.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(15)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (optionnel, par d&eacute;faut = <tt class="literal">version</tt>) : 
                            D&eacute;termine la strat&eacute;gie de verrou optimiste.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(16)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optionnel) : D&eacute;clarer <tt class="literal">lazy="true"</tt> est un raccourci
                            pour sp&eacute;cifier le nom de la classe comme &eacute;tant l'interface <tt class="literal">proxy</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(17)</td><td valign="top" align="left"><p>
                            <tt class="literal">entity-name</tt> (optionnel) : Hibernate3 permet &agrave; une classe d'&ecirc;tre
                            mapp&eacute;e plusieurs fois (potentiellement &agrave; plusieurs tables), et permet aux mappings d'entit&eacute; d'&ecirc;tre
                            repr&eacute;sent&eacute;s par des Maps ou du XML au niveau Java. Dans ces cas, vous devez indiquer un nom explicite arbitraire pour
                            les entit&eacute;s. Voir <a href="#persistent-classes-dynamicmodels" title="4.4.&nbsp;Mod&egrave;les dynamiques">Section&nbsp;4.4, &laquo;&nbsp;Mod&egrave;les dynamiques&nbsp;&raquo;</a> et <a href="#xml" title="Chapitre&nbsp;18.&nbsp;Mapping XML">Chapitre&nbsp;18, <i>Mapping XML</i></a>
                            pour plus d'informations.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(18)</td><td valign="top" align="left"><p>
                            <tt class="literal">catalog</tt> (optionnel) : The name of a database catalog used for this
                            class and its table.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(19)</td><td valign="top" align="left"><p>
                            <tt class="literal">check</tt> (optionnel) : expression SQL utilis&eacute;e pour g&eacute;n&eacute;rer une contrainte 
                            de v&eacute;rification multi-lignes pour la g&eacute;n&eacute;ration automatique de sch&eacute;ma.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(20)</td><td valign="top" align="left"><p>
                            <tt class="literal">rowid</tt> (optionnel) : Hibernate peut utiliser des ROWID sur les bases de
                            donn&eacute;es qui utilisent ce m&eacute;canisme. Par exemple avec Oracle, Hibernate peut utiliser la colonne additionnelle 
                            <tt class="literal">rowid</tt> pour des mises &agrave; jour rapides si cette option vaut  <tt class="literal">rowid</tt>. Un ROWID repr&eacute;sente
                            la localisation physique d'un tuple enregistr&eacute;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(21)</td><td valign="top" align="left"><p>
                            <tt class="literal">subselect</tt> (optionnel) : Permet de mapper une entit&eacute; immuable en lecture-seule 
                            sur un sous-select de base de donn&eacute;es. Utile pour avoir une vue au lieu d'une table en base, mais &agrave; &eacute;viter. Voir plus bas 
                            pour plus d'information.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">???</td><td valign="top" align="left"><p>
                            <tt class="literal">abstract</tt> (optionnel) : Utilis&eacute; pour marquer des superclasses abstraites dans 
                            des hi&eacute;rarchies de <tt class="literal">&lt;union-subclass&gt;</tt>.
                        </p></td></tr></table></div></div><p>
                Il est tout &agrave; fait possible d'utiliser une interface comme nom 
                de classe persistante. Vous devez alors d&eacute;clarer les classes impl&eacute;mentant
                cette interface en utilisant l'&eacute;l&eacute;ment <tt class="literal">&lt;subclass&gt;</tt>. 
                Vous pouvez faire persister toute classe interne <span class="emphasis"><em>static</em></span>. 
                Vous devez alors sp&eacute;cifier le nom de la classe par la notation habituelle 
                des classes internes c'est &agrave; dire <tt class="literal">eg.Foo$Bar</tt>.
            </p><p>
                Les classes immuables, <tt class="literal">mutable="false"</tt>, ne peuvent 
                pas &ecirc;tre modifi&eacute;es ou supprim&eacute;es par l'application. Cela permet 
                &agrave; Hibernate de faire quelques optimisations mineures sur les performances.
            </p><p>
                L'attribut optionnnel <tt class="literal">proxy</tt> permet les intialisations 
                diff&eacute;r&eacute;es des instances persistantes de la classe. Hibernate retournera 
                initialement des proxies CGLIB qui impl&eacute;mentent l'interface nomm&eacute;e. 
                Le v&eacute;ritable objet persistant ne sera charg&eacute; que lorsque une m&eacute;thode du proxy 
                sera appel&eacute;e. Voir plus bas le paragraphe abordant les proxies et le chargement diff&eacute;r&eacute; (lazy initialization).
            </p><p>
                Le polymorphisme <span class="emphasis"><em>implicite</em></span> 
                signifie que les instances de la classe seront retourn&eacute;es par une 
                requ&ecirc;te qui utilise les noms de la classe ou de chacune de ses 
                superclasses ou encore des interfaces impl&eacute;ment&eacute;es par cette classe 
                ou ses superclasses. Les instances des classes filles seront retourn&eacute;es 
                par une requ&ecirc;te qui utilise le nom de la classe elle m&ecirc;me. Le polymorphisme 
                <span class="emphasis"><em>explicite</em></span>   signifie que les instances de la classe 
                ne seront retourn&eacute;es que par une requ&ecirc;te qui utilise explicitement 
                son nom et que seules les instances des classes filles d&eacute;clar&eacute;es dans les &eacute;l&eacute;ments 
                <tt class="literal">&lt;subclass&gt;</tt> ou <tt class="literal">&lt;joined-subclass&gt;</tt> 
                seront retourn&eacute;es. Dans la majorit&eacute;s des cas la valeur par d&eacute;faut, 
                <tt class="literal">polymorphism="implicit"</tt>,
                est appropri&eacute;e. Le polymorphisme explicite est utile lorsque deux 
                classes diff&eacute;rentes sont mapp&eacute;es &agrave; la m&ecirc;me table (ceci permet d'&eacute;crire 
                une classe "l&eacute;g&egrave;re" qui ne contient qu'une partie des colonnes de 
                la table - voir la partie design pattern du site communautaire). 
            </p><p>
                L'attribut <tt class="literal">persister</tt> vous permet de customiser 
                la strat&eacute;gie utilis&eacute;e pour la classe. Vous pouvez, par exemple, sp&eacute;cifier 
                votre propre sous-classe de <tt class="literal">org.hibernate.persister.EntityPersister</tt> ou 
                vous pourriez aussi cr&eacute;er une nouvelle impl&eacute;mentation de l'interface <tt class="literal">org.hibernate.persister.ClassPersister</tt> 
                qui proposerait une persistance via, par exemple, des appels de proc&eacute;dures 
                stock&eacute;es, de la s&eacute;rialisation vers des fichiers plats ou un annuaire LDAP. 
                Voir <tt class="literal">org.hibernate.test.CustomPersister</tt> pour un exemple simple (d'une "persistance" 
                vers une <tt class="literal">Hashtable</tt>).
            </p><p>
                Notez que les param&egrave;tres <tt class="literal">dynamic-update</tt> et <tt class="literal">dynamic-insert</tt> 
                ne sont pas h&eacute;rit&eacute;s par les sous-classes et peuvent donc &ecirc;tre sp&eacute;cifi&eacute;s 
                pour les &eacute;l&eacute;ments <tt class="literal">&lt;subclass&gt;</tt> ou <tt class="literal">&lt;joined-subclass&gt;</tt>
                Ces param&egrave;tres peuvent am&eacute;liorer les performances dans certains cas, 
                mais peuvent aussi les amoindrir. A utiliser en connaissance de causes.
            </p><p>
                L'utilisation de <tt class="literal">select-before-update</tt> va g&eacute;n&eacute;ralement 
                faire baisser les performances. Ce param&egrave;tre est pratique  
                pour pr&eacute;venir l'appel inutile d'un trigger sur modification quand on 
                r&eacute;attache un graphe d'instances &agrave; une <tt class="literal">Session</tt>.
            </p><p>
                Si vous utilisez le <tt class="literal">dynamic-update</tt>, les diff&eacute;rentes 
                strat&eacute;gies de verrouillage optimiste (optimistic locking) sont les suivantes:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        <tt class="literal">version</tt> v&eacute;rifie les colonnes version/timestamp
                    </p></li><li><p>
                        <tt class="literal">all</tt> v&eacute;rifie toutes les colonnes
                    </p></li><li><p>
                        <tt class="literal">dirty</tt> v&eacute;rifie les colonnes modifi&eacute;es, permettant des updates concurrents
                    </p></li><li><p>
                        <tt class="literal">none</tt> pas de verrouillage optimiste
                    </p></li></ul></div><p>
                Nous encourageons <span class="emphasis"><em>tr&egrave;s</em></span> fortement l'utilisation 
                de colonnes de version/timestamp pour le verrouillage optimiste 
                avec Hibernate. C'est la meilleure strat&eacute;gie en regard des performances 
                et la seule qui g&egrave;re correctement les modifications sur les objets d&eacute;tach&eacute;s 
                (c'est &agrave; dire lorsqu'on utilise <tt class="literal">Session.merge()</tt>).
            </p><p>
                Il n'y a pas de diff&eacute;rence entre table et vue pour le mapping Hibernate, 
                tant que c'est transparent au niveau base de donn&eacute;es (remarquez 
                que certaines BDD ne supportent pas les vues correctement, notamment 
                pour les updates). Vous rencontrerez peut-&ecirc;tre des cas o&ugrave; vous 
                souhaitez utiliser une vue mais ne pouvez pas en cr&eacute;er sur votre BDD 
                (par exemple &agrave; cause de sch&eacute;mas anciens et fig&eacute;s). Dans ces cas, 
                vous pouvez mapper une entit&eacute; immuable en lecture seule sur un sous-select SQL donn&eacute;:
            </p><pre class="programlisting">&lt;class name="Summary"&gt;
    &lt;subselect&gt;
        select item.name, max(bid.amount), count(*)
        from item
        join bid on bid.item_id = item.id
        group by item.name
    &lt;/subselect&gt;
    &lt;synchronize table="item"/&gt;
    &lt;synchronize table="bid"/&gt;
    &lt;id name="name"/&gt;
    ...
&lt;/class&gt;</pre><p>
                D&eacute;clarez les tables &agrave; synchroniser avec cette entit&eacute; pour assurer 
                que le flush automatique se produise correctement,
                et pour que les requ&ecirc;tes sur l'entit&eacute; d&eacute;riv&eacute;e ne renvoient pas des donn&eacute;es p&eacute;rim&eacute;es.    
                Le lit&eacute;ral <tt class="literal">&lt;subselect&gt;</tt> est disponible 
                comme attribut ou comme &eacute;l&eacute;ment de mapping.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-id"></a>5.1.4.&nbsp;id</h3></div></div><div></div></div><p>
                Les classes mapp&eacute;es <span class="emphasis"><em>doivent</em></span> d&eacute;clarer la 
                clef primaire de la table en base de donn&eacute;es.
                La plupart des classes auront aussi une propri&eacute;t&eacute; de type 
                javabean pr&eacute;sentant l'identifiant unique d'une instance.
                L'&eacute;l&eacute;ment <tt class="literal">&lt;id&gt;</tt> sert &agrave; d&eacute;finir le 
                mapping entre cette propri&eacute;t&eacute; et la clef primaire en base.
            </p><div class="programlistingco"><pre class="programlisting">&lt;id
        name="propertyName"                                     <span class="co">(1)</span>
        type="typename"                                         <span class="co">(2)</span>
        column="column_name"                                    <span class="co">(3)</span>
        unsaved-value="null|any|none|undefined|id_value"        <span class="co">(4)</span>
        access="field|property|ClassName"&gt;                      <span class="co">(5)</span>

        &lt;generator class="generatorClass"/&gt;
&lt;/id&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> (optionnel) : Nom de la propri&eacute;t&eacute; qui sert d'identifiant.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optionnel) : Nom indiquant le type Hibernate.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optionnel - le nom de la propri&eacute;t&eacute; est pris par d&eacute;faut) : Nom de la clef primaire.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">unsaved-value</tt> (optionnel - par d&eacute;faut une valeur "bien choisie") : 
                            Une valeur de la propri&eacute;t&eacute; d'identifiant qui indique que l'instance est nouvellement
                            instanci&eacute;e (non sauvegard&eacute;e), et qui la distingue des instances <tt class="literal">transient</tt>s qui ont
                            &eacute;t&eacute; sauvegard&eacute;es ou charg&eacute;es dans une session pr&eacute;c&eacute;dente.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optionnel - par d&eacute;faut <tt class="literal">property</tt>) : La strat&eacute;gie que doit utiliser Hibernate 
                            pour acc&eacute;der aux valeurs des propri&eacute;t&eacute;s.
                        </p></td></tr></table></div></div><p>
                Si l'attribut <tt class="literal">name</tt> est absent, Hibernate consid&egrave;re que la classe ne poss&egrave;de pas de propri&eacute;t&eacute; identifiant.
            </p><p>
                L'attribut <tt class="literal">unsaved-value</tt> est important ! Si 
                l'identifiant de votre classe n'a pas une valeur par d&eacute;faut compatible avec 
                le comportement standard de Java (z&eacute;ro ou null), vous devez alors pr&eacute;ciser la valeur par d&eacute;faut.
            </p><p>
                La d&eacute;claration alternative <tt class="literal">&lt;composite-id&gt;</tt> 
                permet l'accc&egrave;s aux donn&eacute;es d'anciens syst&egrave;mes qui utilisent des
                clefs compos&eacute;es. Son utilisation est fortement d&eacute;conseill&eacute;e pour d'autres cas.
            </p><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-generator"></a>5.1.4.1.&nbsp;Generator</h4></div></div><div></div></div><p>
                        L'&eacute;l&eacute;ment fils <tt class="literal">&lt;generator&gt;</tt> nomme une classe Java utilis&eacute;e pour g&eacute;n&eacute;rer 
                        les identifiants uniques pour les instances des classes persistantes. Si des param&egrave;tres sont requis 
                        pour configurer ou initialiser l'instance du g&eacute;n&eacute;rateur, ils sont pass&eacute;s en utilisant l'&eacute;l&eacute;ment <tt class="literal">&lt;param&gt;</tt>.
                </p><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="org.hibernate.id.TableHiLoGenerator"&gt;
                &lt;param name="table"&gt;uid_table&lt;/param&gt;
                &lt;param name="column"&gt;next_hi_value_column&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>
                        Tous les g&eacute;n&eacute;rateurs doivent impl&eacute;menter l'interface <tt class="literal">org.hibernate.id.IdentifierGenerator</tt>.
                        C'est une interface tr&egrave;s simple ; certaines applications peuvent proposer leur propre impl&eacute;mentations sp&eacute;cialis&eacute;es. 
                        Cependant, Hibernate propose une s&eacute;rie d'impl&eacute;mentations int&eacute;gr&eacute;es. Il existe des noms raccourcis pour les g&eacute;n&eacute;rateurs int&eacute;gr&eacute;s :
                    </p><div class="variablelist"><dl><dt><span class="term">
                                <tt class="literal">increment</tt>
                            </span></dt><dd><p>
                                    G&eacute;n&egrave;re des identifiants de type <tt class="literal">long</tt>, <tt class="literal">short</tt> ou
                                    <tt class="literal">int</tt> qui ne sont uniques que si aucun autre processus n'ins&egrave;re de donn&eacute;es dans la m&ecirc;me table.
                                    <span class="emphasis"><em>Ne pas utiliser en environnement clusteris&eacute;.</em></span>
                                </p></dd><dt><span class="term">
                                <tt class="literal">identity</tt>
                            </span></dt><dd><p>
                                    Utilisation de la colonne identity de DB2, MySQL, MS SQL Server, Sybase et
                                    HypersonicSQL. L'identifiant renvoy&eacute; est de type <tt class="literal">long</tt>,
                                    <tt class="literal">short</tt> ou <tt class="literal">int</tt>.
                            </p></dd><dt><span class="term">
                                <tt class="literal">sequence</tt>
                            </span></dt><dd><p>
                                    Utilisation des s&eacute;quences dans  DB2, PostgreSQL, Oracle, SAP DB, McKoi ou d'un g&eacute;n&eacute;rateur dans Interbase.
                                    L'identifiant renvoy&eacute; est de type <tt class="literal">long</tt>,
                                    <tt class="literal">short</tt> ou <tt class="literal">int</tt>
                                </p></dd><dt><span class="term">
                                <tt class="literal">hilo</tt>
                            </span></dt><dd><p><a name="mapping-declaration-id-hilodescription"></a>
                                    Utilise un algorithme hi/lo pour g&eacute;n&eacute;rer de fa&ccedil;on efficace des identifiants de type
                                    <tt class="literal">long</tt>, <tt class="literal">short</tt> ou <tt class="literal">int</tt>,
                                    en prenant comme source de valeur "hi" une table et une colonne (par d&eacute;faut 
                                    <tt class="literal">hibernate_unique_key</tt> et
                                    <tt class="literal">next_hi</tt> respectivement). L'algorithme hi/lo g&eacute;n&egrave;re des identifiants uniques 
                                    pour une base de donn&eacute;es particuli&egrave;re seulement.
                            </p></dd><dt><span class="term">
                                <tt class="literal">seqhilo</tt>
                            </span></dt><dd><p>
                                    Utilise un algorithme hi/lo pour g&eacute;n&eacute;rer efficacement des identifiants de type                                      <tt class="literal">long</tt>, <tt class="literal">short</tt> ou <tt class="literal">int</tt>,
                                    &eacute;tant donn&eacute; un nom de s&eacute;quence en base.
                            </p></dd><dt><span class="term">
                                <tt class="literal">uuid</tt>
                            </span></dt><dd><p>
                                    Utilise un algorithme de type UUID 128 bits pour g&eacute;n&eacute;rer des identifiants de 
                                    type string, unique au sein d'un r&eacute;seau (l'adresse IP est utilis&eacute;e). 
                                    Le UUID en cod&eacute; en une cha&icirc;ne de nombre h&eacute;xad&eacute;cimaux de longueur 32.
                            </p></dd><dt><span class="term">
                                <tt class="literal">guid</tt>
                            </span></dt><dd><p>
                                    Utilise une cha&icirc;ne GUID g&eacute;n&eacute;r&eacute;e par la base pour MS SQL Server et MySQL.
                            </p></dd><dt><span class="term">
                                <tt class="literal">native</tt>
                            </span></dt><dd><p>
                                    Choisit <tt class="literal">identity</tt>, <tt class="literal">sequence</tt> ou
                                    <tt class="literal">hilo</tt> selon les possibilit&eacute;s offertes par la base de donn&eacute;es sous-jacente.
                            </p></dd><dt><span class="term">
                                <tt class="literal">assigned</tt>
                            </span></dt><dd><p>
                                    Laisse l'application affecter un identifiant &agrave; l'objet avant que la m&eacute;tode 
                                    <tt class="literal">save()</tt> soit appel&eacute;e. Il s'agit de la strat&eacute;gie par d&eacute;faut 
                                    si aucun <tt class="literal">&lt;generator&gt;</tt> n'est sp&eacute;cifi&eacute;.
                            </p></dd><dt><span class="term">
                                <tt class="literal">select</tt>
                            </span></dt><dd><p>
                                    R&eacute;cup&egrave;re une clef primaire assign&eacute;e par un trigger en s&eacute;lectionnant 
                                    la ligne par une clef unique quelconque.
                            </p></dd><dt><span class="term">
                                <tt class="literal">foreign</tt>
                            </span></dt><dd><p>
                                    Utilise l'identifiant d'un objet associ&eacute;. Habituellement utilis&eacute; en conjonction
                                    avec une association <tt class="literal">&lt;one-to-one&gt;</tt> sur la clef primaire.
                            </p></dd></dl></div><p>
                </p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-hilo"></a>5.1.4.2.&nbsp;algorithme Hi/lo</h4></div></div><div></div></div><p>
                    Les g&eacute;n&eacute;rateurs <tt class="literal">hilo</tt> et <tt class="literal">seqhilo</tt> proposent deux impl&eacute;mentations
                    alternatives de l'algorithme hi/lo, une approche largement utilis&eacute;e pour g&eacute;n&eacute;rer des identifiants. La 
                    premi&egrave;re impl&eacute;mentation n&eacute;cessite une table "sp&eacute;ciale" en base pour h&eacute;berger la prochaine valeur "hi" disponible.
                    La seconde utilise une s&eacute;quence de type Oracle (quand la base sous-jacente le propose).
                </p><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="hilo"&gt;
                &lt;param name="table"&gt;hi_value&lt;/param&gt;
                &lt;param name="column"&gt;next_value&lt;/param&gt;
                &lt;param name="max_lo"&gt;100&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="seqhilo"&gt;
                &lt;param name="sequence"&gt;hi_value&lt;/param&gt;
                &lt;param name="max_lo"&gt;100&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>
                    Malheureusement, vous ne pouvez pas utilisez <tt class="literal">hilo</tt> quand vous apportez 
                    votre propre <tt class="literal">Connection</tt> &agrave; Hibernate. Quand Hibernate utilise une datasource du serveur 
                    d'application pour obtenir des connexions inscrites avec JTA, vous devez correctement configurer 
                    <tt class="literal">hibernate.transaction.manager_lookup_class</tt>.
                </p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-uuid"></a>5.1.4.3.&nbsp;UUID algorithm</h4></div></div><div></div></div><p>
                    Le contenu du UUID est : adresse IP, date de d&eacute;marrage de la JVM (pr&eacute;cis au quart de seconde), 
                    l'heure syst&egrave;me et un compteur (unique au sein de la JVM). Il n'est pas possible d'obtenir l'adresse 
                    MAC ou une adresse m&eacute;moire &agrave; partir de Java, c'est donc le mieux que l'on puisse faire sans utiliser JNI.
                </p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-sequences"></a>5.1.4.4.&nbsp;Colonnes identifiantes et s&eacute;quences</h4></div></div><div></div></div><p>
                    Pour les bases qui impl&eacute;mentent les colonnes "identit&eacute;" (DB2, MySQL, Sybase, MS SQL), 
                    vous pouvez utiliser la g&eacute;n&eacute;ration de clef par <tt class="literal">identity</tt>. 
                    Pour les bases qui impl&eacute;mentent les s&eacute;quences (DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB) 
                    vous pouvez utiliser la g&eacute;n&eacute;ration de clef par <tt class="literal">sequence</tt>. Ces deux m&eacute;thodes n&eacute;cessitent
                    deux requ&ecirc;tes SQL pour ins&eacute;rer un objet.
                </p><pre class="programlisting">&lt;id name="id" type="long" column="person_id"&gt;
        &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;person_id_sequence&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><pre class="programlisting">&lt;id name="id" type="long" column="person_id" unsaved-value="0"&gt;
        &lt;generator class="identity"/&gt;
&lt;/id&gt;</pre><p>Pour le d&eacute;veloppement multi-plateformes, la strat&eacute;gie <tt class="literal">native</tt> choisira
                    entre les m&eacute;thodes <tt class="literal">identity</tt>, <tt class="literal">sequence</tt> et
                    <tt class="literal">hilo</tt>, selon les possibilit&eacute;s offertes par la base sous-jacente.
                </p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-assigned"></a>5.1.4.5.&nbsp;Identifiants assign&eacute;s</h4></div></div><div></div></div><p>
                    Si vous souhaitez que l'application assigne des identifiants (par opposition 
                    &agrave; la g&eacute;n&eacute;ration par Hibernate), vous pouvez utiliser le g&eacute;n&eacute;rateur  <tt class="literal">assigned</tt>.
                    Ce g&eacute;n&eacute;rateur sp&eacute;cial utilisera une valeur d'identifiant d&eacute;j&agrave; utilis&eacute; par la propri&eacute;t&eacute; identifiant l'objet.
                    Ce g&eacute;n&eacute;rateur est utilis&eacute; quand la clef primaire est une clef naturelle plut&ocirc;t qu'une clef secondaire.
                    C'est le comportement par d&eacute;faut si vous ne pr&eacute;cisez pas d'&eacute;l&eacute;ment <tt class="literal">&lt;generator&gt;</tt>.
                </p><p>
                    Choisir le g&eacute;n&eacute;rateur <tt class="literal">assigned</tt> fait utiliser
                    <tt class="literal">unsaved-value="undefined"</tt> par Hibernate, le for&ccedil;ant &agrave; interroger
                    la base pour d&eacute;terminer si l'instance est transiente ou d&eacute;tach&eacute;e, &agrave; moins d'utiliser 
                    une propri&eacute;t&eacute; version ou timestamp, ou alors de d&eacute;finir 
                    <tt class="literal">Interceptor.isUnsaved()</tt>.
                </p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-select"></a>5.1.4.6.&nbsp;Clefs primaires assign&eacute;es par trigger</h4></div></div><div></div></div><p>
                    Pour les sch&eacute;mas de base h&eacute;rit&eacute;s d'anciens syst&egrave;mes uniquement (Hibernate ne g&eacute;n&egrave;re pas de DDL avec des triggers)  
                </p><pre class="programlisting">&lt;id name="id" type="long" column="person_id"&gt;
        &lt;generator class="select"&gt;
                &lt;param name="key"&gt;socialSecurityNumber&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>
                    Dans l'exemple ci-dessus, <tt class="literal">socialSecurityNumber</tt> a une 
                    valeur unique d&eacute;finie par la classe en tant que clef naturelle et <tt class="literal">person_id</tt> 
                    est une clef secondaire dont la valeur est g&eacute;n&eacute;r&eacute;e par trigger.
                </p></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-compositeid"></a>5.1.5.&nbsp;composite-id</h3></div></div><div></div></div><pre class="programlisting">&lt;composite-id
        name="propertyName"
        class="ClassName"
        mapped="true|false"
        access="field|property|ClassName"&gt;
        node="element-name|."

        &lt;key-property name="propertyName" type="typename" column="column_name"/&gt;
        &lt;key-many-to-one name="propertyName class="ClassName" column="column_name"/&gt;
        ......
&lt;/composite-id&gt;</pre><p>
               Pour une table avec clef compos&eacute;e, vous pouvez mapper plusieurs attributs de la classe 
               comme propri&eacute;t&eacute;s identifiantes. L'&eacute;lement <tt class="literal">&lt;composite-id&gt;</tt> accepte 
               les mappings de propri&eacute;t&eacute;s <tt class="literal">&lt;key-property&gt;</tt> et les mappings 
               <tt class="literal">&lt;key-many-to-one&gt;</tt> comme fils.
            </p><pre class="programlisting">&lt;composite-id&gt;
        &lt;key-property name="medicareNumber"/&gt;
        &lt;key-property name="dependent"/&gt;
&lt;/composite-id&gt;</pre><p>
                Vos classes persistantes <span class="emphasis"><em>doivent</em></span> surcharger les m&eacute;thodes <tt class="literal">equals()</tt> 
                et <tt class="literal">hashCode()</tt> pour impl&eacute;menter l'&eacute;galit&eacute; d'identifiant compos&eacute;. Elles doivent aussi 
                implenter l'interface <tt class="literal">Serializable</tt>.
            </p><p>
                Malheureusement cette approche sur les identifiants compos&eacute;s signifie qu'un objet persistant
                est son propre identifiant. Il n'y a pas d'autre moyen pratique de manipuler l'objet que par l'objet lui-m&ecirc;me.
                Vous devez instancier une instance de la classe persistante elle-m&ecirc;me et peupler ses attributs identifiants 
                avant de pouvoir appeler la m&eacute;thode <tt class="literal">load()</tt> pour charger son &eacute;tat persistant associ&eacute; 
                &agrave; une clef compos&eacute;e. Nous appelons cette approche "identifiant compos&eacute; <span class="emphasis"><em>embarqu&eacute;</em></span>"
                et ne la recommandons pas pour des applications complexes.
            </p><p>
                Une seconde approche, appel&eacute;e identifiant compos&eacute; <span class="emphasis"><em>mapp&eacute;</em></span>,
                consiste &agrave; encapsuler les propri&eacute;t&eacute;s identifiantes (celles contenues dans <tt class="literal">&lt;composite-id&gt;</tt>)
                dans une classe particuli&egrave;re.
            </p><pre class="programlisting">&lt;composite-id class="MedicareId" mapped="true"&gt;
        &lt;key-property name="medicareNumber"/&gt;
        &lt;key-property name="dependent"/&gt;
&lt;/composite-id&gt;</pre><p>
                Dans cet exemple, la classe d'identifiant compos&eacute;e,<tt class="literal">MedicareId</tt> et la classe mapp&eacute;e elle-m&ecirc;me,
                poss&egrave;dent les propri&eacute;t&eacute;s <tt class="literal">medicareNumber</tt>
                et <tt class="literal">dependent</tt>. La classe identifiante doit red&eacute;finir
                <tt class="literal">equals()</tt> et <tt class="literal">hashCode()</tt> et impl&eacute;menter 
                <tt class="literal">Serializable</tt>. Le d&eacute;savantage de cette approche est la
                duplication du code.
            </p><p>
                Les attributs suivants servent &agrave; configurer un identifiant compos&eacute; mapp&eacute; :
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">mapped</tt> (optionnel, d&eacute;faut &agrave; <tt class="literal">false</tt>) :
                        indique qu'un identifiant compos&eacute; mapp&eacute; est utilis&eacute;, et que les propri&eacute;t&eacute;s
                        contenues font r&eacute;f&eacute;rence aux deux classes (celle mapp&eacute;e et la classe identifiante).
                    </p></li><li><p>
                        <tt class="literal">class</tt> (optionnel, mais requis pour un identifiant compos&eacute; mapp&eacute;) : 
                        La classe composant utilis&eacute;e comme identifiant compos&eacute;.
                    </p></li></ul></div><p>
                Nous d&eacute;crirons une troisi&egrave;me approche beaucoup plus efficace ou l'identifiant compos&eacute;
                est impl&eacute;ment&eacute; comme une classe composant dans <a href="#components-compositeid" title="8.4.&nbsp;Utiliser un composant comme identifiant">Section&nbsp;8.4, &laquo;&nbsp;Utiliser un composant comme identifiant&nbsp;&raquo;</a>. 
                Les attributs d&eacute;crits ci dessous, ne s'appliquent que pour cette derni&egrave;re approche :
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">name</tt> (optionnel, requis pour cette approche) : une propri&eacute;t&eacute; de type
                        composant qui contient l'identifiant compos&eacute; (voir chapitre 9).
                    </p></li><li><p>
                        <tt class="literal">access</tt> (optionnel - d&eacute;faut &agrave; <tt class="literal">property</tt>) :
                        La strat&eacute;gie qu'Hibernate utilisera pour acc&eacute;der &agrave; la valeur de la propri&eacute;t&eacute;.
                    </p></li><li><p>
                        <tt class="literal">class</tt> (optionnel - d&eacute;faut au type de la propri&eacute;t&eacute; d&eacute;termin&eacute; par r&eacute;flexion) : 
                        La classe composant utilis&eacute;e comme identifiant (voir prochaine section).
                    </p></li></ul></div><p>
                Cette derni&egrave;re approche est celle que nous recommandons pour toutes vos applications.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-discriminator"></a>5.1.6.&nbsp;discriminator</h3></div></div><div></div></div><p>
                   L'&eacute;l&eacute;ment <tt class="literal">&lt;discriminator&gt;</tt> est n&eacute;cessaire pour la persistance polymorphique 
                   qui utilise la strat&eacute;gie de mapping de table par hi&eacute;rarchie de classe. La colonne discriminante contient 
                   une valeur marqueur qui permet &agrave; la couche de persistance de savoir quelle 
                   sous-classe instancier pour une ligne particuli&egrave;re de table en base. Un nombre restreint de types 
                   peuvent &ecirc;tre utilis&eacute;s :
                <tt class="literal">string</tt>, <tt class="literal">character</tt>, <tt class="literal">integer</tt>, 
                <tt class="literal">byte</tt>, <tt class="literal">short</tt>, <tt class="literal">boolean</tt>, 
                <tt class="literal">yes_no</tt>, <tt class="literal">true_false</tt>.
            </p><div class="programlistingco"><pre class="programlisting">&lt;discriminator
        column="discriminator_column"                      <span class="co">(1)</span>
        type="discriminator_type"                          <span class="co">(2)</span>
        force="true|false"                                 <span class="co">(3)</span>
        insert="true|false"                                <span class="co">(4)</span>
        formula="arbitrary sql expression"                 <span class="co">(5)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">class</tt>) le 
                            nom de la colonne discriminante.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">string</tt>) un nom 
                            indiquant le type Hibernate.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">force</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">false</tt>) 
                                   "oblige" Hibernate &agrave; sp&eacute;cifier une valeur discriminante autoris&eacute;e m&ecirc;me quand on r&eacute;cup&egrave;re 
                                   toutes les instances de la classe de base.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">insert</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">true</tt>)
                                   &agrave; passer &agrave;  <tt class="literal">false</tt> si la colonne discriminante fait aussi partie 
                                   d'un identifiant compos&eacute; mapp&eacute; (Indique &agrave; Hibernate de ne pas inclure la colonne 
                                   dans les <tt class="literal">INSERT</tt> SQL).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">formula</tt> (optionnel) une expression SQL arbitraire qui est ex&eacute;cut&eacute;e 
                            quand un type doit &ecirc;tre &eacute;valu&eacute;. Permet la discrimination bas&eacute;e sur le contenu.
                        </p></td></tr></table></div></div><p>
                   Les v&eacute;ritables valeurs de la colonne discriminante sont sp&eacute;cifi&eacute;es par l'attribut 
                <tt class="literal">discriminator-value</tt> des &eacute;l&eacute;ments <tt class="literal">&lt;class&gt;</tt> et 
                <tt class="literal">&lt;subclass&gt;</tt>.
            </p><p>
                L'attribut <tt class="literal">force</tt> n'est utile que si la table contient des lignes avec des 
                valeurs "extra" discriminantes qui ne sont pas mapp&eacute;es &agrave; une classe persistante. Ce ne sera g&eacute;n&eacute;ralement pas le cas.
            </p><p>
                En utilisant l'attribut <tt class="literal">formula</tt> vous pouvez d&eacute;clarer une expression SQL arbitraire 
                qui sera utilis&eacute;e pour &eacute;valuer le type d'une ligne :
            </p><pre class="programlisting">&lt;discriminator
    formula="case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end"
    type="integer"/&gt;</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-version"></a>5.1.7.&nbsp;version (optionnel)</h3></div></div><div></div></div><p>
                   L'&eacute;l&eacute;ment <tt class="literal">&lt;version&gt;</tt> est optionnel et indique que la table contient 
                   des donn&eacute;es versionn&eacute;es. C'est particuli&egrave;rement utile si vous avez l'intention d'utiliser 
                   des <span class="emphasis"><em>transactions longues</em></span> (voir plus-bas).   
            </p><div class="programlistingco"><pre class="programlisting">&lt;version
        column="version_column"                            <span class="co">(1)</span>
        name="propertyName"                                <span class="co">(2)</span>
        type="typename"                                    <span class="co">(3)</span>
        access="field|property|ClassName"                  <span class="co">(4)</span>
        unsaved-value="null|negative|undefined"            <span class="co">(5)</span>
        generated="never|always"                                     <span class="co">(6)</span>
        insert="true|false"                                          <span class="co">(7)</span>
        node="element-name|@attribute-name|element/@attribute|."
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optionnel - par d&eacute;faut &eacute;gal au nom de la propri&eacute;t&eacute;) : Le nom de la colonne 
                            contenant le num&eacute;ro de version.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> : Le nom d'un attribut de la classe persistante.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">integer</tt>) : 
                            Le type du num&eacute;ro de version.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">property</tt>) : La strat&eacute;gie 
                            &agrave; utiliser par Hibernate pour acc&eacute;der &agrave; la valeur de la propri&eacute;t&eacute;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">unsaved-value</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">undefined</tt>) : 
                            Une valeur de la propri&eacute;t&eacute; d'identifiant qui indique que l'instance est nouvellement 
                            instanci&eacute;e (non sauvegard&eacute;e), et qui la distingue des instances d&eacute;tach&eacute;es qui ont 
                            &eacute;t&eacute; sauvegard&eacute;es ou charg&eacute;es dans une session pr&eacute;c&eacute;dente (<tt class="literal">undefined</tt> indique 
                            que la valeur de l'atribut identifiant devrait &ecirc;tre utilis&eacute;).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">generated</tt> (optional - d&eacute;faut &agrave; <tt class="literal">never</tt>) :
                            Indique que la valeur de la propri&eacute;t&eacute; version est g&eacute;n&eacute;r&eacute;e par la base de donn&eacute;es
                            cf. <a href="#mapping-generated" title="5.6.&nbsp;Propri&eacute;t&eacute;s g&eacute;n&eacute;r&eacute;es">Section&nbsp;5.6, &laquo;&nbsp;Propri&eacute;t&eacute;s g&eacute;n&eacute;r&eacute;es&nbsp;&raquo;</a>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">insert</tt> (optionnel - d&eacute;faut &agrave; <tt class="literal">true</tt>) :
                            Indique si la colonne de version doit &ecirc;tre incluse dans les ordres insert.
                            Peut &ecirc;tre &agrave; <tt class="literal">false</tt> si et seulement si la colonne de la
                            base de donn&eacute;es est d&eacute;finie avec une valeur par d&eacute;faut &agrave; <tt class="literal">0</tt>.
                        </p></td></tr></table></div></div><p>
                Les num&eacute;ros de version doivent avoir les types Hibernate <tt class="literal">long</tt>, <tt class="literal">integer</tt>,
                <tt class="literal">short</tt>, <tt class="literal">timestamp</tt> ou <tt class="literal">calendar</tt>.
            </p><p>
                   Une propri&eacute;t&eacute; de version ou un timestamp ne doit jamais &ecirc;tre null pour une instance 
                   d&eacute;tach&eacute;e, ainsi Hibernate pourra d&eacute;tecter toute instance ayant une version ou un timestamp null 
                   comme transient, quelles que soient les strat&eacute;gies <tt class="literal">unsaved-value</tt> sp&eacute;cifi&eacute;es.
                   <span class="emphasis"><em>D&eacute;clarer un num&eacute;ro de version ou un timestamp "nullable" est un moyen pratique d'&eacute;viter 
                   tout probl&egrave;me avec les r&eacute;attachements transitifs dans Hibernate, particuli&egrave;rement utile pour ceux qui 
                   utilisent des identifiants assign&eacute;s ou des clefs compos&eacute;es !</em></span>
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-timestamp"></a>5.1.8.&nbsp;timestamp (optionnel)</h3></div></div><div></div></div><p>
                   L'&eacute;l&eacute;ment optionnel <tt class="literal">&lt;timestamp&gt;</tt> indique que la table contient des donn&eacute;es 
                   horodat&eacute;es (timestamp). Cela sert d'alternative &agrave; l'utilisation de num&eacute;ros de version. Les timestamps (ou horodatage) 
                   sont par nature une impl&eacute;mentation moins fiable pour l'optimistic locking. Cependant, l'application 
                   peut parfois utiliser l'horodatage &agrave; d'autres fins.
            </p><div class="programlistingco"><pre class="programlisting">&lt;timestamp
        column="timestamp_column"           <span class="co">(1)</span>
        name="propertyName"                 <span class="co">(2)</span>
        access="field|property|ClassName"   <span class="co">(3)</span>
        unsaved-value="null|undefined"      <span class="co">(4)</span>
        source="vm|db"                                               <span class="co">(5)</span>
        generated="never|always"                                     <span class="co">(6)</span>
        node="element-name|@attribute-name|element/@attribute|."
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optionnel - par d&eacute;faut &agrave; le nom de la propri&eacute;t&eacute;) : Le nom d'une colonne 
                            contenant le timestamp.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> : Le nom d'une propri&eacute;t&eacute; au sens JavaBean de type 
                            <tt class="literal">Date</tt> ou <tt class="literal">Timestamp</tt> de la classe persistante.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">property</tt>) : La strat&eacute;gie 
                            &agrave; utiliser par Hibernate pour acc&eacute;der &agrave; la valeur de la propri&eacute;t&eacute;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">unsaved-value</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">null</tt>) : 
                              Propri&eacute;t&eacute; dont la valeur est un num&eacute;ro de version qui indique que l'instance est nouvellement 
                              instanci&eacute;e (non sauvegard&eacute;e), et qui la distingue des instances d&eacute;tach&eacute;es qui ont 
                              &eacute;t&eacute; sauvegard&eacute;es ou charg&eacute;es dans une session pr&eacute;c&eacute;dente (<tt class="literal">undefined</tt> indique 
                              que la valeur de l'attribut identifiant devrait &ecirc;tre utilis&eacute;e).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">source</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">vm</tt>) :
                            D'o&ugrave; Hibernate doit-il r&eacute;cup&eacute;rer la valeur du timestamp? Depuis la base de donn&eacute;es
                            ou depuis la JVM d'ex&eacute;cution? Les valeurs de timestamp de la base de donn&eacute;es provoquent
                            une surcharge puisque Hibernate doit interroger la base pour d&eacute;terminer la prochaine valeur
                            mais cela est plus s&ucirc;r lorsque vous fonctionnez dans un cluster. Remarquez aussi que
                            certains des dialectes ne supportent pas cette fonction, et que d'autres l'impl&eacute;mentent
                            mal, provoquant des erreurs de pr&eacute;cision (Oracle 8 par exemple).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">generated</tt> (optional - d&eacute;faut &agrave; <tt class="literal">never</tt>) :
                            Indique que la valeur de ce timestamp est g&eacute;n&eacute;r&eacute;e par la base de donn&eacute;es
                            cf. <a href="#mapping-generated" title="5.6.&nbsp;Propri&eacute;t&eacute;s g&eacute;n&eacute;r&eacute;es">Section&nbsp;5.6, &laquo;&nbsp;Propri&eacute;t&eacute;s g&eacute;n&eacute;r&eacute;es&nbsp;&raquo;</a>.
                        </p></td></tr></table></div></div><p>
                Notez que <tt class="literal">&lt;timestamp&gt;</tt> est &eacute;quivalent &agrave; 
                <tt class="literal">&lt;version type="timestamp"&gt;</tt>.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-property"></a>5.1.9.&nbsp;property</h3></div></div><div></div></div><p>
                L'&eacute;l&eacute;ment <tt class="literal">&lt;property&gt;</tt> d&eacute;clare une propri&eacute;t&eacute; de la classe au sens JavaBean.
            </p><div class="programlistingco"><pre class="programlisting">&lt;property
        name="propertyName"                 <span class="co">(1)</span>
        column="column_name"                <span class="co">(2)</span>
        type="typename"                     <span class="co">(3)</span>
        update="true|false"                 <span class="co">(4)</span>
        insert="true|false"                 <span class="co">(4)</span>
        formula="arbitrary SQL expression"  <span class="co">(5)</span>
        access="field|property|ClassName"   <span class="co">(6)</span>
        lazy="true|false"                   <span class="co">(7)</span>
        unique="true|false"                 <span class="co">(8)</span>
        not-null="true|false"               <span class="co">(9)</span>
        optimistic-lock="true|false"        <span class="co">(10)</span>
        generated="never|insert|always"                              <span class="co">(11)</span>
        node="element-name|@attribute-name|element/@attribute|."
        index="index_name"
        unique_key="unique_key_id"
        length="L"
        precision="P"
        scale="S"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> : nom de la propri&eacute;t&eacute;, avec une lettre initiale en minuscule.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optionnel - par d&eacute;faut au nom de la propri&eacute;t&eacute;) : le nom 
                                   de la colonne mapp&eacute;e. Cela peut aussi &ecirc;tre indiqu&eacute; dans le(s) sous-&eacute;l&eacute;ment(s) 
                            <tt class="literal">&lt;column&gt;</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optionnel) : nom indiquant le type Hibernate.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">update, insert</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">true</tt>) :
                           indique que les colonnes mapp&eacute;es devraient &ecirc;tre incluses dans des <tt class="literal">UPDATE</tt> SQL 
                           et/ou des <tt class="literal">INSERT</tt>. Mettre les deux &agrave; <tt class="literal">false</tt> 
                           emp&ecirc;che la propagation en base de donn&eacute;es (utile si vous savez qu'un trigger affectera la valeur &agrave; la  colonne). 
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">formula</tt> (optionnel) : une expression SQL qui d&eacute;finit la valeur pour une propri&eacute;t&eacute; 
                            <span class="emphasis"><em>calcul&eacute;e</em></span>. Les propri&eacute;t&eacute;s calcul&eacute;es ne poss&egrave;de pas leur propre mapping.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">property</tt>): Strat&eacute;gie que Hibernate
                             doit utiliser pour acc&eacute;der &agrave; cette valeur.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">false</tt>): Indique 
                            que cette propri&eacute;t&eacute; devrait &ecirc;tre charg&eacute;e en diff&eacute;r&eacute; (lazy loading) quand on acc&egrave;de &agrave; la variable 
                            d'instance pour la premi&egrave;re fois.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">unique</tt> (optionnel): G&eacute;n&egrave;re le DDL d'une contrainte d'unicit&eacute; pour les colonnes. 
                            Permet aussi d'en faire la cible d'un <tt class="literal">property-ref</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                            <tt class="literal">not-null</tt> (optionnel): G&eacute;n&egrave;re le DDL d'une contrainte de non nullit&eacute; pour les colonnes.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">true</tt>): 
                            Indique que les mises &agrave; jour de cette propri&eacute;t&eacute; peuvent ou non n&eacute;cessiter l'acquisition 
                            d'un verrou optimiste. En d'autres termes, cela d&eacute;termine s'il est n&eacute;cessaire d'incr&eacute;menter 
                            un num&eacute;ro de version quand cette propri&eacute;t&eacute; est marqu&eacute;e obsol&egrave;te (dirty).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(11)</td><td valign="top" align="left"><p>
                            <tt class="literal">generated</tt> (optional - d&eacute;faut &agrave;<tt class="literal">never</tt>):
                            Indique que la valeur de ce timestamp est g&eacute;n&eacute;r&eacute;e par la base de donn&eacute;es
                            cf. <a href="#mapping-generated" title="5.6.&nbsp;Propri&eacute;t&eacute;s g&eacute;n&eacute;r&eacute;es">Section&nbsp;5.6, &laquo;&nbsp;Propri&eacute;t&eacute;s g&eacute;n&eacute;r&eacute;es&nbsp;&raquo;</a>.
                        </p></td></tr></table></div></div><p>
                <span class="emphasis"><em>typename</em></span> peut &ecirc;tre:
            </p><div class="orderedlist"><ol type="1" compact><li><p>
                        Nom d'un type basique Hibernate (ex: <tt class="literal">integer, string, character,
                        date, timestamp, float, binary, serializable, object, blob</tt>).
                    </p></li><li><p>
                        Nom d'une classe Java avec un type basique par d&eacute;faut (ex: <tt class="literal">int, float,
                        char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</tt>).
                    </p></li><li><p>
                        Nom d'une classe Java s&eacute;rialisable.
                    </p></li><li><p>
                       Nom d'une classe ayant un type sp&eacute;cifique (ex: <tt class="literal">com.illflow.type.MyCustomType</tt>).
                    </p></li></ol></div><p>
                   Si vous n'indiquez pas un type, Hibernate utlisera la r&eacute;flexion sur le nom de la propri&eacute;t&eacute; 
                   pour tenter de trouver le type Hibernate correct. Hibernate essayera d'interpr&ecirc;ter 
                   le nom de la classe retourn&eacute;e par le getter de la propri&eacute;t&eacute; en utilisant les r&eacute;gles 2, 3, 
                   4 dans cet ordre. Cependant, ce n'est pas toujours suffisant. Dans certains cas vous aurez 
                   encore besoin de l'attribut <tt class="literal">type</tt> (Par exemple, pour distinguer 
                   <tt class="literal">Hibernate.DATE</tt> et <tt class="literal">Hibernate.TIMESTAMP</tt>, ou pour pr&eacute;ciser 
                   un type sp&eacute;cifique).
            </p><p>
                   L'attribut <tt class="literal">access</tt> permet de contr&ocirc;ler comment Hibernate acc&egrave;dera 
                   &agrave; la propri&eacute;t&eacute; &agrave; l'ex&eacute;cution. Par d&eacute;faut, Hibernate utilisera les m&eacute;thodes set/get. 
                   Si vous indiquez <tt class="literal">access="field"</tt>, Hibernate ignorera les getter/setter 
                   et acc&egrave;dera &agrave; la propri&eacute;t&eacute; directement en utilisant la r&eacute;flexion. Vous pouvez sp&eacute;cifier 
                   votre propre strat&eacute;gie d'acc&egrave;s aux propri&eacute;t&eacute; en donnant une classe qui impl&eacute;mente l'interface 
                <tt class="literal">org.hibernate.property.PropertyAccessor</tt>.
            </p><p>
                   Une fonctionnalit&eacute; particuli&egrave;rement int&eacute;ressante est les propri&eacute;t&eacute;s d&eacute;riv&eacute;es.
                   Ces propri&eacute;t&eacute;s sont par d&eacute;finition en lecture seule, la valeur de la propri&eacute;t&eacute; est calcul&eacute;e au chargement. 
                   Le calcul est d&eacute;clar&eacute; comme une expression SQL, qui se traduit par une sous-requ&ecirc;te <tt class="literal">SELECT</tt> 
                   dans la requ&ecirc;te SQL qui charge une instance :
            </p><pre class="programlisting">
&lt;property name="totalPrice"
    formula="( SELECT SUM (li.quantity*p.price) FROM LineItem li, Product p
                WHERE li.productId = p.productId
                AND li.customerId = customerId
                AND li.orderNumber = orderNumber )"/&gt;</pre><p>
                   Remarquez que vous pouvez r&eacute;f&eacute;rencer la propre table des entit&eacute;s en ne d&eacute;clarant pas un 
                   alias sur une colonne particuli&egrave;re (<tt class="literal">customerId</tt> dans l'exemple donn&eacute;). 
                   Notez aussi que vous pouvez utiliser le sous-&eacute;l&eacute;ment de mapping <tt class="literal">&lt;formula&gt;</tt> 
                   plut&ocirc;t que d'utiliser l'attribut si vous le souhaitez.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-manytoone"></a>5.1.10.&nbsp;many-to-one</h3></div></div><div></div></div><p> Une association ordinaire vers une autre classe persistante est d&eacute;clar&eacute;e en utilisant 
                   un &eacute;l&eacute;ment <tt class="literal">many-to-one</tt>. Le mod&egrave;le relationnel est une association 
                   de type many-to-one : une clef &eacute;trang&egrave;re dans une table r&eacute;f&eacute;rence la ou les clef(s) primaire(s) dans la table cible.
            </p><div class="programlistingco"><pre class="programlisting">&lt;many-to-one
        name="propertyName"                                <span class="co">(1)</span>
        column="column_name"                               <span class="co">(2)</span>
        class="ClassName"                                  <span class="co">(3)</span>
        cascade="cascade_style"                            <span class="co">(4)</span>
        fetch="join|select"                                <span class="co">(5)</span>
        update="true|false"                                <span class="co">(6)</span>
        insert="true|false"                                <span class="co">(6)</span>
        property-ref="propertyNameFromAssociatedClass"     <span class="co">(7)</span>
        access="field|property|ClassName"                  <span class="co">(8)</span>
        unique="true|false"                                <span class="co">(9)</span>
        not-null="true|false"                              <span class="co">(10)</span>
        optimistic-lock="true|false"                       <span class="co">(11)</span>
        lazy="proxy|no-proxy|false"                        <span class="co">(12)</span>
        not-found="ignore|exception"                       <span class="co">(13)</span>          <span class="co">(14)</span>
        entity-name="EntityName"                                     <span class="co">(15)</span>
        formula="arbitrary SQL expression"                           <span class="co">(16)</span>
        node="element-name|@attribute-name|element/@attribute|."
        embed-xml="true|false"
        index="index_name"
        unique_key="unique_key_id"
        foreign-key="foreign_key_name"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> : Nom de la propri&eacute;t&eacute;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optionnel) : Le nom de la clef &eacute;trang&egrave;re. Cela peut &ecirc;tre 
                            aussi indiqu&eacute; avec le sous-&eacute;l&eacute;ment <tt class="literal">&lt;column&gt;</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (optionnel - par d&eacute;faut le type de la propri&eacute;t&eacute; d&eacute;termin&eacute; 
                            par r&eacute;flexion) : Le nom de la classe associ&eacute;e.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">cascade</tt> (optionnel) : Indique quelles op&eacute;rations doivent 
                            &ecirc;tre propag&eacute;es de l'objet p&egrave;re vers les objets associ&eacute;s.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">fetch</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">select</tt>) : 
                            Choisit entre le chargement de type outer-join ou le chargement par select successifs.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">update, insert</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">true</tt>) :
                           indique que les colonnes mapp&eacute;es devraient &ecirc;tre incluses dans des <tt class="literal">UPDATE</tt> SQL 
                           et/ou des <tt class="literal">INSERT</tt>. Mettre les deux &agrave; <tt class="literal">false</tt> 
                           emp&ecirc;che la propagation en base de donn&eacute;es (utile si vous savez qu'un trigger affectera la valeur &agrave; la  colonne).                         
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">property-ref</tt> : (optionnel) Le nom d'une propri&eacute;t&eacute; de la classe 
                            associ&eacute;e qui est li&eacute;e &agrave; cette clef &eacute;trang&egrave;re. Si ce n'est pas sp&eacute;cifi&eacute;, la clef primaire de la 
                            classe associ&eacute;e est utilis&eacute;e.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">property</tt>) : La 
                            strat&eacute;gie &agrave; utiliser par Hibernate pour acc&eacute;der &agrave; la valeur de cette propri&eacute;t&eacute;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                            <tt class="literal">unique</tt> (optionnel) : G&eacute;n&egrave;re le DDL d'une contrainte d'unicit&eacute; pour la clef &eacute;trang&egrave;re. 
                            Permet aussi d'en faire la cible d'un <tt class="literal">property-ref</tt>. Cela permet de cr&eacute;er une v&eacute;ritable 
                            association one-to-one.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                            <tt class="literal">not-null</tt> (optionnel) : G&eacute;n&egrave;re le DDL pour une contrainte de non nullit&eacute; pour la clef &eacute;trang&egrave;re.
                       </p></td></tr><tr><td width="5%" valign="top" align="left">(11)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">true</tt>) : 
                            Indique que les mises &agrave; jour de cette propri&eacute;t&eacute; requi&egrave;rent ou non l'acquisition 
                            d'un verrou optimiste. En d'autres termes, d&eacute;termine si un incr&eacute;ment de version doit 
                            avoir lieu quand la propri&eacute;t&eacute; est marqu&eacute;e obsol&egrave;te (dirty).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(12)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">false</tt>) : Indique 
                            que cette propri&eacute;t&eacute; doit &ecirc;tre charg&eacute;e en diff&eacute;r&eacute; (lazy loading) au premier acc&egrave;s 
                            &agrave; la variable d'instance (n&eacute;cessite une instrumentation du bytecode lors de la phase 
                            de construction). Remarquez que cela n'influence pas le comportement du proxy 
                            Hibernate - comme l'attribut <tt class="literal">lazy</tt> sur des classes ou des mappings 
                            de collections, mais utilise l'interception pour le chargement diff&eacute;r&eacute;.
                            <tt class="literal">lazy="false"</tt> indique que l'association sera toujours charg&eacute;e.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(13)</td><td valign="top" align="left"><p>
                            <tt class="literal">not-found</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">exception</tt>) : 
                            Indique comment les clefs &eacute;trang&egrave;res qui r&eacute;f&eacute;rencent des lignes manquantes doivent &ecirc;tre manipul&eacute;es :
                            <tt class="literal">ignore</tt> traitera une ligne manquante comme une association nulle.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(15)</td><td valign="top" align="left"><p>
                            <tt class="literal">entity-name</tt> (optionnel) : Le nom de l'entit&eacute; de la classe associ&eacute;e.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(16)</td><td valign="top" align="left"><p>
                            <tt class="literal">formula</tt> (optionnel) : une expression SQL qui d&eacute;finit la valeur
                            pour une cl&eacute; &eacute;trang&egrave;re calcul&eacute;e.
                        </p></td></tr></table></div></div><p>
                Donner une valeur significative &agrave; l'attribut <tt class="literal">cascade</tt> autre que 
                <tt class="literal">none</tt>  propagera certaines op&eacute;rations &agrave; l'objet associ&eacute;. Les valeurs 
                significatives sont les noms des op&eacute;rations Hibernate basiques,     
                <tt class="literal">persist, merge, delete, save-update, evict, replicate, lock,
                refresh</tt>, ainsi que les valeurs sp&eacute;ciales <tt class="literal">delete-orphan</tt> 
                et <tt class="literal">all</tt> et des combinaisons de noms d'op&eacute;rations s&eacute;par&eacute;es par des virgules,
                comme par exemple <tt class="literal">cascade="persist,merge,evict"</tt> ou
                <tt class="literal">cascade="all,delete-orphan"</tt>. Voir <a href="#objectstate-transitive" title="10.11.&nbsp;Persistance transitive">Section&nbsp;10.11, &laquo;&nbsp;Persistance transitive&nbsp;&raquo;</a>
                pour une explication compl&egrave;te.
                Notez que les assocations many-to-one et one-to-one ne supportent pas orphan delete.
            </p><p>
                Une d&eacute;claration <tt class="literal">many-to-one</tt> typique est aussi simple que :
            </p><pre class="programlisting">&lt;many-to-one name="product" class="Product" column="PRODUCT_ID"/&gt;</pre><p>
                L'attribut <tt class="literal">property-ref</tt> devrait &ecirc;tre utilis&eacute; pour mapper seulement des donn&eacute;es 
                provenant d'un ancien syst&egrave;me o&ugrave; les clefs &eacute;trang&egrave;res font r&eacute;f&eacute;rence &agrave; une clef unique de la table associ&eacute;e 
                et qui n'est pas la clef primaire. C'est un cas de mauvaise conception relationnelle.
                Par exemple, supposez que la classe <tt class="literal">Product</tt> a un num&eacute;ro de s&eacute;rie unique qui n'est pas
                la clef primaire. (L'attribut <tt class="literal">unique</tt> contr&ocirc;le la g&eacute;n&eacute;ration DDL par Hibernate avec 
                l'outil SchemaExport.)
            </p><pre class="programlisting">&lt;property name="serialNumber" unique="true" type="string" column="SERIAL_NUMBER"/&gt;</pre><p>
                Ainsi le mapping pour <tt class="literal">OrderItem</tt> peut utiliser :
            </p><pre class="programlisting">&lt;many-to-one name="product" property-ref="serialNumber" column="PRODUCT_SERIAL_NUMBER"/&gt;</pre><p>
                bien que ce ne soit certainement pas encourag&eacute;.
            </p><p>
                Si la clef unique r&eacute;f&eacute;renc&eacute;e comprend des propri&eacute;t&eacute;s multiples de l'entit&eacute; associ&eacute;e, vous devez mapper
                ces propri&eacute;t&eacute;s &agrave; l'int&eacute;rieur d'un &eacute;l&eacute;ment <tt class="literal">&lt;properties&gt;</tt>.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-onetoone"></a>5.1.11.&nbsp;one-to-one</h3></div></div><div></div></div><p>
                Une association one-to-one vers une autre classe persistante est d&eacute;clar&eacute;e avec l'&eacute;l&eacute;ment
                <tt class="literal">one-to-one</tt>.
            </p><div class="programlistingco"><pre class="programlisting">&lt;one-to-one
        name="propertyName"                                <span class="co">(1)</span>
        class="ClassName"                                  <span class="co">(2)</span>
        cascade="cascade_style"                            <span class="co">(3)</span>
        constrained="true|false"                           <span class="co">(4)</span>
        fetch="join|select"                                <span class="co">(5)</span>
        property-ref="propertyNameFromAssociatedClass"     <span class="co">(6)</span>
        access="field|property|ClassName"                  <span class="co">(7)</span>
        formula="any SQL expression"                       <span class="co">(8)</span>
        entity-name="EntityName"                                     <span class="co">(9)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> : Le nom de la propri&eacute;t&eacute;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (optionnel - par d&eacute;faut du type de la propri&eacute;t&eacute; 
                            d&eacute;termin&eacute; par r&eacute;flexion) : Le nom de la classe associ&eacute;e.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">cascade</tt> (optionnel) :  Indique quelles op&eacute;rations doivent 
                            &ecirc;tre cascad&eacute;es de l'objet p&egrave;re vers l'objet associ&eacute;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">constrained</tt> (optionnel) : Indique qu'une contrainte de clef &eacute;trang&egrave;re 
                            sur la clef primaire de la table mapp&eacute;e r&eacute;f&eacute;rence la table de la classe associ&eacute;e.
                            Cette option affecte l'ordre dans lequel chaque <tt class="literal">save()</tt> et chaque
                            <tt class="literal">delete()</tt> sont cascad&eacute;s et d&eacute;termine si l'association peut utiliser un proxy 
                            (aussi utilis&eacute; par l'outil d'export de sch&eacute;ma).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">fetch</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">select</tt>) : 
                            Choisit entre r&eacute;cup&eacute;ration par jointure externe ou select s&eacute;quentiel.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">property-ref</tt> (optionnel) : Le nom de la propri&eacute;t&eacute; de la classe associ&eacute;e qui est jointe &agrave; la clef
                            primaire de cette classe. Si ce n'est pas sp&eacute;cifi&eacute;, la clef primaire de la classe associ&eacute;e est utilis&eacute;e.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">property</tt>) : 
                            La strat&eacute;gie &agrave; utiliser par Hibernate pour acc&eacute;der &agrave; la valeur de la propri&eacute;t&eacute;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">formula</tt> (optionnel) : Presque toutes les associations one-to-one pointent sur la clef primaire 
                            de l'entit&eacute; propri&eacute;taire. Dans les rares cas diff&eacute;rents, vous devez donner une ou plusieurs 
                            autres colonnes ou expression &agrave; joindre par une formule SQL (voir <tt class="literal">org.hibernate.test.onetooneformula</tt> pour un exemple).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optionnel - par d&eacute;faut <tt class="literal">proxy</tt>) : 
                            Par d&eacute;faut, les associations simples sont soumise &agrave; proxy. <tt class="literal">lazy="no-proxy"</tt>
                            sp&eacute;cifie que la propri&eacute;t&eacute; doit &ecirc;tre charg&eacute;e &agrave; la demande au premier acc&egrave;s &agrave; l'instance.
                            (n&eacute;cessite l'intrumentation du bytecode &agrave; la construction). 
                            <tt class="literal">lazy="false"</tt> indique que l'association sera toujours charg&eacute;e
                            agressivement. <span class="emphasis"><em>Notez que si <tt class="literal">constrained="false"</tt>,
                            l'utilisation de proxy est impossible et Hibernate chargera automatiquement l'association !</em></span>
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                            <tt class="literal">entity-name</tt> (optional) : The entity name of the associated class.
                        </p></td></tr></table></div></div><p>
                Il existe deux types d'associations one-to-one :
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                associations par clef primaire
            </p></li><li><p>
                association par clef &eacute;trang&egrave;re unique
            </p></li></ul></div><p>
                Les associations par clef primaire ne n&eacute;cessitent pas une colonne suppl&eacute;mentaire en table ; si deux lignes sont 
                li&eacute;s par l'association alors les deux lignes de la table partagent la m&ecirc;me valeur de clef primaire. Donc si vous 
                voulez que deux objets soient li&eacute;s par une association par clef primaire, vous devez faire en sorte qu'on leur 
                assigne la m&ecirc;me valeur d'identifiant !
            </p><p>
                Pour une association par clef primaire, ajoutez les mappings suivants &agrave; <tt class="literal">Employee</tt> et 
                <tt class="literal">Person</tt>, respectivement.
            </p><pre class="programlisting">&lt;one-to-one name="person" class="Person"/&gt;</pre><pre class="programlisting">&lt;one-to-one name="employee" class="Employee" constrained="true"/&gt;</pre><p>
                Maintenant, vous devez faire en sorte que les clefs primaires des lignes li&eacute;es dans les tables PERSON et EMPLOYEE 
                sont &eacute;gales. On utilise une strat&eacute;gie Hibernate sp&eacute;ciale de g&eacute;n&eacute;ration d'identifiants appel&eacute;e 
                <tt class="literal">foreign</tt> :
            </p><pre class="programlisting">&lt;class name="person" table="PERSON"&gt;
    &lt;id name="id" column="PERSON_ID"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"&gt;employee&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    ...
    &lt;one-to-one name="employee"
        class="Employee"
        constrained="true"/&gt;
&lt;/class&gt;</pre><p>
                Une instance fra&icirc;chement enregistr&eacute;e de <tt class="literal">Person</tt> se voit alors assign&eacute;e la m&ecirc;me valeur 
                de clef primaire que l'instance de <tt class="literal">Employee</tt> r&eacute;f&eacute;renc&eacute;e par la propri&eacute;t&eacute; <tt class="literal">employee</tt> 
                de cette <tt class="literal">Person</tt>.
            </p><p>
                Alternativement, une clef &eacute;trang&egrave;re avec contrainte d'unicit&eacute; de <tt class="literal">Employee</tt> vers 
                <tt class="literal">Person</tt> peut &ecirc;tre indiqu&eacute;e ainsi :
            </p><pre class="programlisting">&lt;many-to-one name="person" class="Person" column="PERSON_ID" unique="true"/&gt;</pre><p>
                Et cette association peut &ecirc;tre rendue bidirectionnelle en ajoutant ceci au mapping de <tt class="literal">Person</tt> :
            </p><pre class="programlisting">&lt;one-to-one name"employee" class="Employee" property-ref="person"/&gt;</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-naturalid"></a>5.1.12.&nbsp;natural-id</h3></div></div><div></div></div><pre class="programlisting">&lt;natural-id mutable="true|false"/&gt;
        &lt;property ... /&gt;
        &lt;many-to-one ... /&gt;
        ......
&lt;/natural-id&gt;</pre><p>
                Bien que nous recommandions l'utilisation de cl&eacute; primaire g&eacute;n&eacute;r&eacute;e, vous devriez toujours
                essayer d'identifier des cl&eacute; m&eacute;tier (naturelles) pour toutes vos entit&eacute;s. Une cl&eacute; naturelle
                est une propri&eacute;t&eacute; ou une combinaison de propri&eacute;t&eacute;s uniques et non nulles. Si elle est aussi
                immuable, c'est encore mieux. Mappez les propri&eacute;t&eacute;s de la cl&eacute; naturelle dans l'&eacute;l&eacute;ment
                <tt class="literal">&lt;natural-id&gt;</tt>. Hibernate g&eacute;n&eacute;rera la cl&eacute; unique n&eacute;cessaire et les contraintes
                de non-nullit&eacute;, et votre mapping s'auto-documentera.
            </p><p>
                Nous vous recommandons fortement d'impl&eacute;menter <tt class="literal">equals()</tt> et 
                <tt class="literal">hashCode()</tt> pour comparer les cl&eacute;s naturelles de l'entit&eacute;.
            </p><p>
                Ce mapping n'est pas destin&eacute; &agrave; &ecirc;tre utilis&eacute; avec des entit&eacute;s qui ont des cl&eacute;s naturelles.
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">mutable</tt> (optionel, par d&eacute;faut &agrave; <tt class="literal">false</tt>) : 
                        Par d&eacute;faut, les identifiants naturels sont suppos&eacute;s &ecirc;tre immuable (constants).
                    </p></li></ul></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-component"></a>5.1.13.&nbsp;component, dynamic-component</h3></div></div><div></div></div><p>
                L'&eacute;l&eacute;ment <tt class="literal">&lt;component&gt;</tt> mappe les propri&eacute;t&eacute;s d'un objet fils 
                aux colonnes d'une classe parente. Les composants peuvent en retour d&eacute;clarer leurs propres 
                propri&eacute;t&eacute;s, composants ou collections. Voir "Components" plus bas.
            </p><div class="programlistingco"><pre class="programlisting">&lt;component 
        name="propertyName"                 <span class="co">(1)</span>
        class="className"                   <span class="co">(2)</span>
        insert="true|false"                 <span class="co">(3)</span>
        update="true|false"                 <span class="co">(4)</span>
        access="field|property|ClassName"   <span class="co">(5)</span>
        lazy="true|false"                   <span class="co">(6)</span>
        optimistic-lock="true|false"        <span class="co">(7)</span>
        unique="true|false"                 <span class="co">(8)</span>
&gt;
        
        &lt;property ...../&gt;
        &lt;many-to-one .... /&gt;
        ........
&lt;/component&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> : Nom de la propri&eacute;t&eacute;
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (optionnel - par d&eacute;faut au type de la propri&eacute;t&eacute; d&eacute;termin&eacute; par r&eacute;flexion) : 
                            le nom de la classe (fille) du composant.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">insert</tt> : Est ce que les colonnes mapp&eacute;es apparaissent dans les 
                            <tt class="literal">INSERT</tt>s ?
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">update</tt>: Est ce que les colonnes mapp&eacute;es apparaissent dans les 
                            <tt class="literal">UPDATE</tt>s ?
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">property</tt>) : 
                            La strat&eacute;gie que Hibernate doit utiliser pour acc&eacute;der &agrave; la valeur de cette propri&eacute;t&eacute;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">false</tt>) : 
                            Indique que ce composant doit &ecirc;tre charg&eacute; au premier acc&egrave;s 
                            &agrave; la variable d'instance (n&eacute;cessite une instrumentation du bytecode au moment du build).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">true</tt>) :
                                Indique que les mises &agrave; jour sur ce composant n&eacute;cessitent ou non l'acquisition d'un 
                                verrou optimiste. En d'autres termes, cela d&eacute;termine si une incr&eacute;mentation de version 
                                doit avoir lieu quand la propri&eacute;t&eacute; est marqu&eacute;e obsol&egrave;te (dirty).
                            </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">unique</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">false</tt>) :
                                Indique qu'une contrainte d'unicit&eacute; existe sur toutes les colonnes mapp&eacute;es de ce composant.
                            </p></td></tr></table></div></div><p>
                Les tags fils <tt class="literal">&lt;property&gt;</tt> mappent les propri&eacute;t&eacute;s 
                de la classe fille sur les colonnes de la table.
            </p><p>
                L'&eacute;l&eacute;ment <tt class="literal">&lt;component&gt;</tt> permet de d&eacute;clarer sous-&eacute;l&eacute;ment <tt class="literal">&lt;parent&gt;</tt> qui associe une propri&eacute;t&eacute;
                de la classe composant comme une r&eacute;f&eacute;rence arri&egrave;re vers l'entit&eacute; contenante.
            </p><p>
                L'&eacute;l&eacute;ment <tt class="literal">&lt;dynamic-component&gt;</tt> permet &agrave; une <tt class="literal">Map</tt> d'&ecirc;tre mapp&eacute;e 
                comme un composant, quand les noms de la propri&eacute;t&eacute; font r&eacute;f&eacute;rence aux clefs de cette Map, voir 
                <a href="#components-dynamic" title="8.5.&nbsp;Composant Dynamique">Section&nbsp;8.5, &laquo;&nbsp;Composant Dynamique&nbsp;&raquo;</a>.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-properties"></a>5.1.14.&nbsp;properties</h3></div></div><div></div></div><p>
                L'&eacute;l&eacute;ment <tt class="literal">&lt;properties&gt;</tt> permet la d&eacute;finition d'un groupement logique nomm&eacute; 
                des propri&eacute;t&eacute;s d'une classe. L'utilisation la plus importante de cette construction est la possibilit&eacute; 
                pour une combinaison de propri&eacute;t&eacute;s d'&ecirc;tre la cible d'un <tt class="literal">property-ref</tt>. C'est aussi 
                un moyen pratique de d&eacute;finir une contrainte d'unicit&eacute; multi-colonnes.
            </p><div class="programlistingco"><pre class="programlisting">&lt;properties 
        name="logicalName"                  <span class="co">(1)</span>
        insert="true|false"                 <span class="co">(2)</span>
        update="true|false"                 <span class="co">(3)</span>
        optimistic-lock="true|false"        <span class="co">(4)</span>
        unique="true|false"                 <span class="co">(5)</span>
&gt;
        
        &lt;property ...../&gt;
        &lt;many-to-one .... /&gt;
        ........
&lt;/properties&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> : Le nom logique d'un regroupement et 
                            <span class="emphasis"><em>non</em></span> le v&eacute;ritable nom d'une propri&eacute;t&eacute;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">insert</tt> : Est-ce que les colonnes mapp&eacute;es apparaissent dans les 
                            <tt class="literal">INSERT</tt>s ?
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">update</tt> : Est-ce que les colonnes mapp&eacute;es apparaissent dans les 
                            <tt class="literal">UPDATE</tt>s ?
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">true</tt>) :
                                Indique que les mises &agrave; jour sur ce composant n&eacute;cessitent ou non l'acquisition d'un 
                                verrou optimiste. En d'autres termes, cela d&eacute;termine si une incr&eacute;mentation 
                                de version doit avoir lieu quand la propri&eacute;t&eacute; est marqu&eacute;e obsol&egrave;te (dirty).
                            </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">unique</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">false</tt>) :
                            Indique qu'une contrainte d'unicit&eacute; existe sur toutes les colonnes mapp&eacute;es de ce composant.
                            </p></td></tr></table></div></div><p>
                Par exemple, si nous avons le mapping de <tt class="literal">&lt;properties&gt;</tt> suivant :
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="personNumber"/&gt;
    ...
    &lt;properties name="name" 
            unique="true" update="false"&gt;
        &lt;property name="firstName"/&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="lastName"/&gt;
    &lt;/properties&gt;
&lt;/class&gt;</pre><p>
                Alors nous pourrions avoir une association sur des donn&eacute;es d'un ancien syst&egrave;me (legacy) qui font r&eacute;f&eacute;rence 
                &agrave; cette clef unique de la table <tt class="literal">Person</tt> au lieu de la clef primaire :
            </p><pre class="programlisting">&lt;many-to-one name="person" 
         class="Person" property-ref="name"&gt;
    &lt;column name="firstName"/&gt;
    &lt;column name="initial"/&gt;
    &lt;column name="lastName"/&gt;
&lt;/many-to-one&gt;</pre><p>
                Nous ne recommandons pas l'utilisation de ce genre de chose en dehors du contexte de mapping de donn&eacute;es h&eacute;rit&eacute;es 
                d'anciens syst&egrave;mes.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-subclass"></a>5.1.15.&nbsp;subclass</h3></div></div><div></div></div><p>
                Pour finir, la persistance polymorphique n&eacute;cessite la d&eacute;claration de chaque sous-classe de la classe persistante de base. 
                pour la strat&eacute;gie de mapping de type table-per-class-hierarchy, on utilise la d&eacute;claration 
                <tt class="literal">&lt;subclass&gt;</tt>.    
            </p><div class="programlistingco"><pre class="programlisting">&lt;subclass
        name="ClassName"                              <span class="co">(1)</span>
        discriminator-value="discriminator_value"     <span class="co">(2)</span>
        proxy="ProxyInterface"                        <span class="co">(3)</span>
        lazy="true|false"                             <span class="co">(4)</span>
        dynamic-update="true|false"
        dynamic-insert="true|false"
        entity-name="EntityName"
        node="element-name"
        extends="SuperclassName"&gt;

        &lt;property .... /&gt;
        .....
&lt;/subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> : Le nom complet de la sous-classe.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">discriminator-value</tt> (optionnel - par d&eacute;faut le nom de la classe) : 
                            une valeur qui distingue les diff&eacute;rentes sous-classes.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">proxy</tt> (optionnel) : Indique une classe ou interface &agrave; utiliser pour les chargements
                            &agrave; la demande des proxies (lazy).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optionnel, par d&eacute;faut &agrave; <tt class="literal">true</tt>) : Sp&eacute;cifier 
                            <tt class="literal">lazy="false"</tt> d&eacute;sactive l'utilisation du chargement &agrave; la demande (lazy).
                        </p></td></tr></table></div></div><p>
                Chaque sous-classe devrait d&eacute;clarer ses propres propri&eacute;t&eacute;s persistantes et sous-classes.
                Les propri&eacute;t&eacute;s <tt class="literal">&lt;version&gt;</tt> et <tt class="literal">&lt;id&gt;</tt> 
                sont implicitement h&eacute;rit&eacute;s de la classe de base. Chaque sous-classe dans une hi&eacute;rarchie doit 
                d&eacute;finir une unique <tt class="literal">discriminator-value</tt>. Si aucune n'est sp&eacute;cifi&eacute;e, 
                le nom complet de la classe Java est utilis&eacute;.
            </p><p>
                Pour plus d'infos sur le mapping d'h&eacute;ritage, voir <a href="#inheritance" title="Chapitre&nbsp;9.&nbsp;Mapping d'h&eacute;ritage de classe">Chapitre&nbsp;9, <i>Mapping d'h&eacute;ritage de classe</i></a>.
        </p><pre class="programlisting">
&lt;hibernate-mapping&gt;
    &lt;subclass name="DomesticCat" extends="Cat" discriminator-value="D"&gt;
         &lt;property name="name" type="string"/&gt;
    &lt;/subclass&gt;
&lt;/hibernate-mapping&gt;</pre><p>
                Pour des informations sur les mappings d'h&eacute;ritage, voir <a href="#inheritance" title="Chapitre&nbsp;9.&nbsp;Mapping d'h&eacute;ritage de classe">Chapitre&nbsp;9, <i>Mapping d'h&eacute;ritage de classe</i></a>.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-joinedsubclass"></a>5.1.16.&nbsp;joined-subclass</h3></div></div><div></div></div><p>
                Une autre fa&ccedil;on possible de faire est la suivante, chaque sous-classe peut &ecirc;tre mapp&eacute;e vers sa propre table (strat&eacute;gie 
                de mapping de type table-per-subclass). L'&eacute;tat h&eacute;rit&eacute; est r&eacute;cup&eacute;r&eacute; en joignant la table de la super-classe.
                L'&eacute;l&eacute;ment <tt class="literal">&lt;joined-subclass&gt;</tt> est utilis&eacute;.
            </p><div class="programlistingco"><pre class="programlisting">&lt;joined-subclass
        name="ClassName"                    <span class="co">(1)</span>
        table="tablename"                   <span class="co">(2)</span>
        proxy="ProxyInterface"              <span class="co">(3)</span>
        lazy="true|false"                   <span class="co">(4)</span>
        dynamic-update="true|false"
        dynamic-insert="true|false"
        schema="schema"
        catalog="catalog"
        extends="SuperclassName"
        persister="ClassName"
        subselect="SQL expression"
        entity-name="EntityName"&gt;

        &lt;key .... &gt;

        &lt;property .... /&gt;
        .....
&lt;/joined-subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> : Le nom Java complet de la sous-classe.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">table</tt> : Le nom de la table de la sous-classe.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">proxy</tt> (optionnel) : Indique une classe ou interface pour le chargement diff&eacute;r&eacute; des proxies.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optionnel, par d&eacute;faut &agrave; <tt class="literal">true</tt>) : Indiquer 
                            <tt class="literal">lazy="false"</tt> d&eacute;sactive l'utilisation du chargement &agrave; la demande.
                         </p></td></tr></table></div></div><p>
                Aucune colonne discriminante n'est n&eacute;cessaire pour cette strat&eacute;gie de mapping. Cependant, 
                chaque sous-classe doit d&eacute;clarer une colonne de table contenant l'objet identifiant qui utilise l'&eacute;l&eacute;ment 
                <tt class="literal">&lt;key&gt;</tt>. Le mapping au d&eacute;but de ce chapitre serait r&eacute;-&eacute;crit ainsi :
            </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

        &lt;class name="Cat" table="CATS"&gt;
                &lt;id name="id" column="uid" type="long"&gt;
                        &lt;generator class="hilo"/&gt;
                &lt;/id&gt;
                &lt;property name="birthdate" type="date"/&gt;
                &lt;property name="color" not-null="true"/&gt;
                &lt;property name="sex" not-null="true"/&gt;
                &lt;property name="weight"/&gt;
                &lt;many-to-one name="mate"/&gt;
                &lt;set name="kittens"&gt;
                        &lt;key column="MOTHER"/&gt;
                        &lt;one-to-many class="Cat"/&gt;
                &lt;/set&gt;
                &lt;joined-subclass name="DomesticCat" table="DOMESTIC_CATS"&gt;
                    &lt;key column="CAT"/&gt;
                    &lt;property name="name" type="string"/&gt;
                &lt;/joined-subclass&gt;
        &lt;/class&gt;

        &lt;class name="eg.Dog"&gt;
                &lt;!-- mapping for Dog could go here --&gt;
        &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
                 Pour des informations sur les mappings d'h&eacute;ritage, voir <a href="#inheritance" title="Chapitre&nbsp;9.&nbsp;Mapping d'h&eacute;ritage de classe">Chapitre&nbsp;9, <i>Mapping d'h&eacute;ritage de classe</i></a>.
             </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-unionsubclass"></a>5.1.17.&nbsp;union-subclass</h3></div></div><div></div></div><p>
               Une troisi&egrave;me option est de seulement mapper vers des tables les classes concr&egrave;tes 
               d'une hi&eacute;rarchie d'h&eacute;ritage, (strat&eacute;gie de type table-per-concrete-class) o&ugrave; 
               chaque table d&eacute;finit tous les &eacute;tats persistants de la classe, y compris les &eacute;tats h&eacute;rit&eacute;s. 
               Dans Hibernate il n'est absolument pas n&eacute;cessaire de mapper explicitement de telles hi&eacute;rarchies 
               d'h&eacute;ritage. Vous pouvez simplement mapper chaque classe avec une d&eacute;claration <tt class="literal">&lt;class&gt;</tt> 
               diff&eacute;rente. Cependant, si vous souhaitez utiliser des associations polymorphiques (c&agrave;d une association 
               vers la superclasse de la hi&eacute;rarchie), vous devez utiliser le mapping <tt class="literal">&lt;union-subclass&gt;</tt>.
           </p><div class="programlistingco"><pre class="programlisting">&lt;union-subclass
        name="ClassName"                    <span class="co">(1)</span>
        table="tablename"                   <span class="co">(2)</span>
        proxy="ProxyInterface"              <span class="co">(3)</span>
        lazy="true|false"                   <span class="co">(4)</span>
        dynamic-update="true|false"
        dynamic-insert="true|false"
        schema="schema"
        catalog="catalog"
        extends="SuperclassName"
        abstract="true|false"
        persister="ClassName"
        subselect="SQL expression"
        entity-name="EntityName"&gt;

        &lt;property .... /&gt;
        .....
&lt;/union-subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> : Le nom Java complet de la sous-classe.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">table</tt> : nom de la table de la sous-classe.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">proxy</tt> (optionnel) : Indique une classe ou interface pour le chargement diff&eacute;r&eacute; des proxies.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optionnel, par d&eacute;faut &agrave; <tt class="literal">true</tt>) : Indiquer 
                            <tt class="literal">lazy="false"</tt> d&eacute;sactive l'utilisation du chargement &agrave; la demande.
                         </p></td></tr></table></div></div><p>
                Aucune colonne discriminante ou colonne clef n'est requise pour cette strat&eacute;gie de mapping.
            </p><p>
                Pour des informations sur les mappings d'h&eacute;ritage, voir <a href="#inheritance" title="Chapitre&nbsp;9.&nbsp;Mapping d'h&eacute;ritage de classe">Chapitre&nbsp;9, <i>Mapping d'h&eacute;ritage de classe</i></a>.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-join"></a>5.1.18.&nbsp;join</h3></div></div><div></div></div><p>
                En utilisant l'&eacute;l&eacute;ment <tt class="literal">&lt;join&gt;</tt>, il est possible de mapper 
                des propri&eacute;t&eacute;s d'une classe sur plusieurs tables.
            </p><div class="programlistingco"><pre class="programlisting">&lt;join
        table="tablename"                        <span class="co">(1)</span>
        schema="owner"                           <span class="co">(2)</span>
        catalog="catalog"                        <span class="co">(3)</span>
        fetch="join|select"                      <span class="co">(4)</span>
        inverse="true|false"                     <span class="co">(5)</span>
        optionnel="true|false"&gt;                  <span class="co">(6)</span>
        
        &lt;key ... /&gt;
        
        &lt;property ... /&gt;
        ...
&lt;/join&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">table</tt> : Le nom de la table jointe.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">schema</tt> (optionnel) : court-circuite le nom de sch&eacute;ma sp&eacute;cifi&eacute; par l'&eacute;l&eacute;ment de base 
                            <tt class="literal">&lt;hibernate-mapping&gt;</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">catalog</tt> (optionnel) : court-circuite le nom de catalogue sp&eacute;cifi&eacute; par l'&eacute;l&eacute;ment de base 
                            <tt class="literal">&lt;hibernate-mapping&gt;</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">fetch</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">join</tt>) :
                            Si positionn&eacute; &agrave; <tt class="literal">join</tt>, Hibernate utilisera une jointure interne pour charger
                            une <tt class="literal">jointure</tt> d&eacute;finie par une classe ou ses super-classes et une jointure externe
                            pour une <tt class="literal">&lt;jointure&gt;</tt> d&eacute;finie par une sous-classe.
                            Si positionn&eacute; &agrave; <tt class="literal">select</tt> alors Hibernate utilisera un select s&eacute;quentiel 
                            pour une <tt class="literal">&lt;jointure&gt;</tt> d&eacute;finie sur une sous-classe, qui ne sera d&eacute;livr&eacute;e que
                            si une ligne se repr&eacute;sente une instance de la sous-classe. Les jointures internes seront quand m&ecirc;me 
                            utilis&eacute;es pour charger une <tt class="literal">&lt;jointure&gt;</tt> d&eacute;finie par une classe et ses super-classes.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">inverse</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">false</tt>) :
                            Si positionn&eacute; &agrave; true, Hibernate n'essaiera pas d'ins&eacute;rer ou de mettre &agrave; jour les 
                            propri&eacute;t&eacute;s d&eacute;finies par cette jointure.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">optionnel</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">false</tt>) :
                            Si positionn&eacute; &agrave; true, Hibernate ins&egrave;rera une ligne seulement si les propri&eacute;t&eacute;s d&eacute;finies 
                            par cette jointure sont non-nulles et utilisera toujours une jointure externe pour charger les propri&eacute;t&eacute;s.
                        </p></td></tr></table></div></div><p>
                Par exemple, les informations d'adresse pour une personne peuvent &ecirc;tre mapp&eacute;es vers une table 
                s&eacute;par&eacute;e (tout en pr&eacute;servant des s&eacute;mantiques de type valeur pour toutes ses propri&eacute;t&eacute;s) :
            </p><pre class="programlisting">&lt;class name="Person"
    table="PERSON"&gt;

    &lt;id name="id" column="PERSON_ID"&gt;...&lt;/id&gt;

    &lt;join table="ADDRESS"&gt;
        &lt;key column="ADDRESS_ID"/&gt;
        &lt;property name="address"/&gt;
        &lt;property name="zip"/&gt;
        &lt;property name="country"/&gt;
    &lt;/join&gt;
    ...</pre><p>
                Cette fonctionnalit&eacute; est souvent seulement utile pour les mod&egrave;les de donn&eacute;es 
                h&eacute;rit&eacute;s d'anciens syst&egrave;mes (legacy), nous recommandons d'utiliser moins de tables que de classes 
                et un mod&egrave;le de domaine &agrave; granularit&eacute; fine. Cependant, c'est utile 
                pour passer d'une strat&eacute;gie de mapping d'h&eacute;ritage &agrave; une autre dans une hi&eacute;rarchie simple ainsi qu'il est 
                expliqu&eacute; plus tard.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-key"></a>5.1.19.&nbsp;key</h3></div></div><div></div></div><p>
                Nous avons rencontr&eacute; l'&eacute;l&eacute;ment <tt class="literal">&lt;key&gt;</tt> &agrave; plusieurs reprises maintenant. 
                Il appara&icirc;t partout que l'&eacute;l&eacute;ment de mapping parent d&eacute;finit une jointure sur une nouvele table, et 
                d&eacute;finit la clef &eacute;trang&egrave;re dans la table jointe, ce qui r&eacute;f&eacute;rence la clef primaire de la table d'origine.
            </p><div class="programlistingco"><pre class="programlisting">&lt;key
        column="columnname"                      <span class="co">(1)</span>
        on-delete="noaction|cascade"             <span class="co">(2)</span>
        property-ref="propertyName"              <span class="co">(3)</span>
        not-null="true|false"                    <span class="co">(4)</span>
        update="true|false"                      <span class="co">(5)</span>
        unique="true|false"                      <span class="co">(6)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optionnel) : Le nom de la colonne de la clef &eacute;trang&egrave;re
                            Cela peut aussi &ecirc;tre sp&eacute;cifi&eacute; par l'&eacute;l&eacute;ment(s) int&eacute;gr&eacute;(s) <tt class="literal">&lt;column&gt;</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">on-delete</tt> (optionnel, par d&eacute;faut &agrave; <tt class="literal">noaction</tt>) :
                            Indique si la contrainte de clef &eacute;trang&egrave;re poss&egrave;de la possibilit&eacute; au niveau base de donn&eacute;es 
                            de suppression en cascade.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">property-ref</tt> (optionnel) : Indique que la clef &eacute;trang&egrave;re fait 
                            r&eacute;f&eacute;rence &agrave; des colonnes qui ne sont pas la clef primaire de la table d'origine 
                            (Pour les donn&eacute;es de syst&egrave;mes legacy).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">not-null</tt> (optionnel) : Indique que les colonnes des clefs &eacute;trang&egrave;res ne 
                            peuvent pas &ecirc;tre nulles (c'est implicite si la clef &eacute;trang&egrave;re fait partie de la clef primaire).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">update</tt> (optionnel) : Indique que la clef &eacute;trang&egrave;re ne devrait jamais &ecirc;tre mise &agrave; jour 
                            (implicite si celle-ci fait partie de la clef primaire).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">unique</tt> (optionnel) : Indique que la clef &eacute;trang&egrave;re doit poss&eacute;der une contrainte 
                            d'unicit&eacute; (implicite si la clef &eacute;trang&egrave;re est aussi la clef primaire).
                        </p></td></tr></table></div></div><p>
                Nous recommandons pour les syst&egrave;mes o&ugrave; les suppressions doivent &ecirc;tre performantes de d&eacute;finir toutes 
                les clefs <tt class="literal">on-delete="cascade"</tt>, ainsi Hibernate utilisera une contrainte 
                <tt class="literal">ON CASCADE DELETE</tt> au niveau base de donn&eacute;es, plut&ocirc;t que de nombreux
                <tt class="literal">DELETE</tt> individuels. Attention, cette fonctionnalit&eacute; court-circuite la strat&eacute;gie 
                habituelle de verrou optimiste pour les donn&eacute;es versionn&eacute;es.
            </p><p>
                Les attributs <tt class="literal">not-null</tt> et <tt class="literal">update</tt> sont utiles pour 
                mapper une association one-to-many unidirectionnelle. Si vous mappez un one-to-many unidirectionnel 
                vers une clef &eacute;trang&egrave;re non nulle, vous <span class="emphasis"><em>devez</em></span> d&eacute;clarer la colonne de la clef 
                en utilisant <tt class="literal">&lt;key not-null="true"&gt;</tt>.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-column"></a>5.1.20.&nbsp;&eacute;l&eacute;ments column et formula</h3></div></div><div></div></div><p>
               Tout &eacute;l&eacute;ment de mapping qui accepte un attribut <tt class="literal">column</tt> acceptera alternativement 
               un sous-&eacute;l&eacute;ment <tt class="literal">&lt;column&gt;</tt>. De fa&ccedil;on identique, <tt class="literal">&lt;formula&gt;</tt> 
               est une alternative &agrave; l'attribut <tt class="literal">formula</tt>.
           </p><pre class="programlisting">&lt;column
        name="column_name"
        length="N"
        precision="N"
        scale="N"
        not-null="true|false"
        unique="true|false"
        unique-key="multicolumn_unique_key_name"
        index="index_name"
        sql-type="sql_type_name"
        check="SQL expression"/&gt;</pre><pre class="programlisting">&lt;formula&gt;SQL expression&lt;/formula&gt;</pre><p>
                Les attributs <tt class="literal">column</tt> et <tt class="literal">formula</tt> peuvent m&ecirc;me &ecirc;tre combin&eacute;s 
                au sein d'une m&ecirc;me propri&eacute;t&eacute; ou mapping d'association pour exprimer, par exemple, des conditions 
                de jointure exotiques.
            </p><pre class="programlisting">&lt;many-to-one name="homeAddress" class="Address"
        insert="false" update="false"&gt;
    &lt;column name="person_id" not-null="true" length="10"/&gt;
    &lt;formula&gt;'MAILING'&lt;/formula&gt;
&lt;/many-to-one&gt;</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-import"></a>5.1.21.&nbsp;import</h3></div></div><div></div></div><p>
                Supposez que votre application poss&egrave;de deux classes persistantes du m&ecirc;me nom, et vous ne voulez pas pr&eacute;ciser 
                le nom Java complet (packages inclus) dans les queries Hibernate. Les classes peuvent alors &ecirc;tre "import&eacute;es" 
                explicitement plut&ocirc;t que de compter sur <tt class="literal">auto-import="true"</tt>.Vous pouvez m&ecirc;me importer 
                des classes et interfaces qui ne sont pas mapp&eacute;es explicitement.
            </p><pre class="programlisting">&lt;import class="java.lang.Object" rename="Universe"/&gt;</pre><div class="programlistingco"><pre class="programlisting">&lt;import
        class="ClassName"              <span class="co">(1)</span>
        rename="ShortName"             <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> : Nom Java complet de la classe.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">rename</tt> (optionnel - par d&eacute;faut vaut le nom de la classe Java (sans package)) :
                            Nom pouvant &ecirc;tre utilis&eacute; dans le langage de requ&ecirc;te.
                        </p></td></tr></table></div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-anymapping"></a>5.1.22.&nbsp;any</h3></div></div><div></div></div><p>
                Il existe encore un type de mapping de propri&eacute;t&eacute;. L'&eacute;l&eacute;ment de mapping <tt class="literal">&lt;any&gt;</tt> 
                d&eacute;finit une association polymorphique vers des classes de tables multiples. Ce type de mapping requiert 
                toujours plus d'une colonne. La premi&egrave;re colonne contient le type de l'entit&eacute; associ&eacute;e. Les colonnes 
                restantes contiennent l'identifiant. il est impossible de sp&eacute;cifier une contrainte de clef &eacute;trang&egrave;re 
                pour ce type d'association, donc ce n'est certainement pas consid&eacute;r&eacute; comme le moyen habituel de mapper 
                des associations (polymorphiques). Vous devriez utiliser cela uniquement dans des cas particuliers 
                (par exemple des logs d'audit, des donn&eacute;es de session utilisateur, etc...).
            </p><p>
                 L'attribut <tt class="literal">meta-type</tt> permet &agrave; l'application de sp&eacute;cifier un type personnalis&eacute; qui mappe 
                 des valeurs de colonnes de le base de donn&eacute;es sur des classes persistantes qui ont un attribut identifiant 
                 du type sp&eacute;cifi&eacute; par <tt class="literal">id-type</tt>. Vous devez sp&eacute;cifier le mapping &agrave; partir de valeurs du 
                 m&eacute;ta-type sur les noms des classes.
            </p><pre class="programlisting">&lt;any name="being" id-type="long" meta-type="string"&gt;
    &lt;meta-value value="TBL_ANIMAL" class="Animal"/&gt;
    &lt;meta-value value="TBL_HUMAN" class="Human"/&gt;
    &lt;meta-value value="TBL_ALIEN" class="Alien"/&gt;
    &lt;column name="table_name"/&gt;
    &lt;column name="id"/&gt;
&lt;/any&gt;</pre><div class="programlistingco"><pre class="programlisting">&lt;any
        name="propertyName"                      <span class="co">(1)</span>
        id-type="idtypename"                     <span class="co">(2)</span>
        meta-type="metatypename"                 <span class="co">(3)</span>
        cascade="cascade_style"                  <span class="co">(4)</span>
        access="field|property|ClassName"        <span class="co">(5)</span>
        optimistic-lock="true|false"             <span class="co">(6)</span>
&gt;
        &lt;meta-value ... /&gt;
        &lt;meta-value ... /&gt;
        .....
        &lt;column .... /&gt;
        &lt;column .... /&gt;
        .....
&lt;/any&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> : le nom de la propri&eacute;t&eacute;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">id-type</tt> : le type identifiant.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">meta-type</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">string</tt>) : 
                            Tout type permis pour un mapping par discriminateur.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">cascade</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">none</tt>) : 
                            le style de cascade.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">property</tt>) : La strat&eacute;gie 
                            &agrave; utiliser par Hibernate pour acc&eacute;der &agrave; cette propri&eacute;t&eacute;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (optionnel - par d&eacute;faut &agrave; <tt class="literal">true</tt>) : 
                            Indique que les mises &agrave; jour sur cette propri&eacute;t&eacute; n&eacute;cessitent ou non l'acquisition d'un 
                            verrou optimiste. En d'autres termes, d&eacute;finit si un incr&eacute;ment de version doit avoir lieu 
                            quand cette propri&eacute;t&eacute; est marqu&eacute;e dirty.
                        </p></td></tr></table></div></div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-types"></a>5.2.&nbsp;Hibernate Types</h2></div></div><div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-entitiesvalues"></a>5.2.1.&nbsp;Entit&eacute;s et valeurs</h3></div></div><div></div></div><p>
                Pour comprendre le comportement des diff&eacute;rents objets Java par rapport au service 
                de persistance, nous avons besoin de les classer en deux groupes :
            </p><p>
                Une <span class="emphasis"><em>entit&eacute;</em></span> existe ind&eacute;pendamment de tout autre objet poss&eacute;dant 
                une r&eacute;f&eacute;rence vers l'entit&eacute;. Comparez cela avec le mod&egrave;le Java habituel o&ugrave; un objet 
                est supprim&eacute; par le garbage collector d&egrave;s qu'il n'est plus r&eacute;f&eacute;renc&eacute;. Les entit&eacute;s 
                doivent &ecirc;tre explicitement enregistr&eacute;es et supprim&eacute;es (sauf dans les cas o&ugrave; 
                sauvegardes et suppressions sont <span class="emphasis"><em>cascad&eacute;es</em></span> d'une entit&eacute; m&egrave;re 
                vers ses enfants). C'est diff&eacute;rent du mod&egrave;le ODMG de persistance par 
                atteignabilit&eacute; - et correspond mieux &agrave; la fa&ccedil;on dont les objets sont 
                habituellement utilis&eacute;s dans des grands syst&egrave;mes. Les entit&eacute;s permettent les r&eacute;f&eacute;rences 
                circulaires et partag&eacute;es. Elles peuvent aussi &ecirc;tre versionn&eacute;es.
            </p><p>
                L'&eacute;tat persistant d'une entit&eacute; consiste en des r&eacute;f&eacute;rences vers d'autres entit&eacute;s et 
                instances de types <span class="emphasis"><em>valeurs</em></span>. Ces valeurs sont des types primitifs, 
                des collections (et non le contenu d'une collection), des composants de certains objets 
                immuables. Contrairement aux entit&eacute;s, les valeurs (et en particulier les collections et 
                composants) <span class="emphasis"><em>sont</em></span> persist&eacute;s par atteignabiliit&eacute;. Comme les 
                valeurs (et types primitifs) sont persist&eacute;s et supprim&eacute;s avec l'entit&eacute; qui les contient, 
                ils ne peuvent pas poss&eacute;der leurs propres versions. Les valeurs n'ont pas d'identit&eacute; 
                ind&eacute;pendantes, ainsi elles ne peuvent pas &ecirc;tre partag&eacute;es par deux entit&eacute;s ou collections.
            </p><p>
                Jusqu'&agrave; pr&eacute;sent nous avons utilis&eacute; le terme "classe persistante" pour parler d'entit&eacute;s. 
                Nous allons continuer &agrave; faire ainsi. Cependant, au sens strict, toutes 
                les classes d&eacute;finies par un utilisateur poss&eacute;dant un &eacute;tat persistant ne sont pas des 
                entit&eacute;s. Un <span class="emphasis"><em>composant</em></span> est une classe d&eacute;finie par un utilisateur 
                avec les caract&eacute;ristiques d'une valeur. Une propri&eacute;t&eacute; Java de type <tt class="literal">java.lang.String</tt>
                a aussi les caract&eacute;ristiques d'une valeur. 
                
                
                
                Given this definition, we can say that all types (classes) provided
                by the JDK have value type semantics in Java, while user-defined types may
                be mapped with entity or value type semantics. This decision is up to the
                application developer. A good hint for an entity class in a domain model are
                shared references to a single instance of that class, while composition or
                aggregation usually translates to a value type.
            </p><p>
                Nous nous pencherons sur ces deux concepts tout au long de la documentation.
            </p><p>
                Le d&eacute;fi est de mapper les type Javas (et la d&eacute;finition des d&eacute;veloppeurs des 
                entit&eacute;s et valeurs types) sur les types du SQL ou des bases de donn&eacute;es. Le pont 
                entre les deux syst&egrave;mes est propos&eacute; par Hibernate : pour les entit&eacute;s nous utilisons 
                <tt class="literal">&lt;class&gt;</tt>, <tt class="literal">&lt;subclass&gt;</tt> et ainsi de suite.
                Pour les types valeurs nous utilisons <tt class="literal">&lt;property&gt;</tt>,
                <tt class="literal">&lt;component&gt;</tt>, etc., habituellement avec un attribut <tt class="literal">type</tt>. 
                La valeur de cet attribut est le nom d'un <span class="emphasis"><em>type de mapping</em></span> Hibernate. 
                Hibernate propose de base de nombreux mappings (pour les types de valeurs standards du JDK). 
                Vous pouvez &eacute;crire vos propres types de mappings et impl&eacute;menter aussi vos propres strat&eacute;gies 
                de conversion, nous le verrons plus tard.
            </p><p>
                Tous les types propos&eacute;s de base par Hibernate &agrave; part les collections autorisent la valeur null.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-basictypes"></a>5.2.2.&nbsp;Basic value types</h3></div></div><div></div></div><p>
                Les <span class="emphasis"><em>types basiques de mapping</em></span> propos&eacute;s de base peuvent grossi&egrave;rement &ecirc;tre 
                rang&eacute;s dans les cat&eacute;gories suivantes :
                </p><div class="variablelist"><dl><dt><span class="term">
                            <tt class="literal">integer, long, short, float, double, character, byte,
                            boolean, yes_no, true_false</tt>
                        </span></dt><dd><p>
                                Les mappings de type des primitives Java ou leurs classes wrappers (ex: Integer 
                                pour int) vers les types SQL (propri&eacute;taires) appropri&eacute;s. <tt class="literal">boolean, 
                                yes_no</tt>et <tt class="literal">true_false</tt> sont tous des alternatives 
                                pour les types Java <tt class="literal">boolean</tt> ou <tt class="literal">java.lang.Boolean</tt>.
                            </p></dd><dt><span class="term">
                            <tt class="literal">string</tt>
                        </span></dt><dd><p>
                                Mapping de type de <tt class="literal">java.lang.String</tt> vers
                                <tt class="literal">VARCHAR</tt> (ou le <tt class="literal">VARCHAR2</tt> Oracle).
                            </p></dd><dt><span class="term">
                            <tt class="literal">date, time, timestamp</tt>
                        </span></dt><dd><p>
                                Mappings de type pour <tt class="literal">java.util.Date</tt> et ses sous-classes  
                                vers les types SQL <tt class="literal">DATE</tt>, <tt class="literal">TIME</tt> et
                                <tt class="literal">TIMESTAMP</tt> (ou &eacute;quivalent).
                            </p></dd><dt><span class="term">
                            <tt class="literal">calendar, calendar_date</tt>
                        </span></dt><dd><p>
                                Mappings de type pour <tt class="literal">java.util.Calendar</tt> vers les types SQL 
                                <tt class="literal">TIMESTAMP</tt> et <tt class="literal">DATE</tt>
                                (ou &eacute;quivalent).
                            </p></dd><dt><span class="term">
                            <tt class="literal">big_decimal, big_integer</tt>
                        </span></dt><dd><p>
                                Mappings de type pour <tt class="literal">java.math.BigDecimal</tt> et
                                <tt class="literal">java.math.BigInteger</tt> vers <tt class="literal">NUMERIC</tt> 
                                (ou le <tt class="literal">NUMBER</tt> Oracle).
                            </p></dd><dt><span class="term">
                            <tt class="literal">locale, timezone, currency</tt>
                        </span></dt><dd><p>
                                Mappings de type pour <tt class="literal">java.util.Locale</tt>,
                                <tt class="literal">java.util.TimeZone</tt> et 
                                <tt class="literal">java.util.Currency</tt> 
                                vers <tt class="literal">VARCHAR</tt> (ou le <tt class="literal">VARCHAR2</tt> Oracle).
                                Les instances de <tt class="literal">Locale</tt> et <tt class="literal">Currency</tt> sont 
                                mapp&eacute;es sur leurs codes ISO. Les instances de <tt class="literal">TimeZone</tt> sont
                                mapp&eacute;es sur leur <tt class="literal">ID</tt>.
                            </p></dd><dt><span class="term">
                            <tt class="literal">class</tt>
                        </span></dt><dd><p>
                                Un type de mapping pour <tt class="literal">java.lang.Class</tt> vers
                                <tt class="literal">VARCHAR</tt> (ou le <tt class="literal">VARCHAR2</tt> Oracle).
                                Un objet <tt class="literal">Class</tt> est mapp&eacute; sur son nom Java complet.
                            </p></dd><dt><span class="term">
                            <tt class="literal">binary</tt>
                        </span></dt><dd><p>
                                Mappe les tableaux de bytes vers le type binaire SQL appropri&eacute;.
                            </p></dd><dt><span class="term">
                            <tt class="literal">text</tt>
                        </span></dt><dd><p>
                                Mappe les longues cha&icirc;nes de caract&egrave;res Java vers les types SQL 
                                <tt class="literal">CLOB</tt> ou <tt class="literal">TEXT</tt>.
                            </p></dd><dt><span class="term">
                            <tt class="literal">serializable</tt>
                        </span></dt><dd><p>
                                Mappe les types Java s&eacute;rialisables vers le type SQL binaire appropri&eacute;. Vous pouvez 
                                aussi indiquer le type Hibernate <tt class="literal">serializable</tt> avec le nom 
                                d'une classe Java s&eacute;rialisable ou une interface qui ne soit pas par d&eacute;faut un type de base.
                            </p></dd><dt><span class="term">
                            <tt class="literal">clob, blob</tt>
                        </span></dt><dd><p>
                                Mappings de type pour les classes JDBC <tt class="literal">java.sql.Clob</tt> and
                                <tt class="literal">java.sql.Blob</tt>. Ces types peuvent ne pas convenir pour certaines 
                                applications car un objet blob ou clob peut ne pas &ecirc;tre r&eacute;utilisable en dehors 
                                d'une transaction (de plus l'impl&eacute;mentation par les pilotes est moyennement bonne).
                           </p></dd><dt><span class="term">
                            <tt class="literal">imm_date, imm_time, imm_timestamp, imm_calendar, imm_calendar_date,
                            imm_serializable, imm_binary</tt>
                        </span></dt><dd><p>
                                Mappings de type pour ceux qui sont habituellement modifiable, pour lesquels
                                Hibernate effectue certains optimisations convenant seulement aux types Java immuables,
                                et l'application les traite comme immuable. 
                                Par exemple, vous ne devriez pas appeler <tt class="literal">Date.setTime()</tt> sur une instance
                                mapp&eacute;e sur un <tt class="literal">imm_timestamp</tt>. Pour changer la valeur
                                de la propri&eacute;t&eacute;, et faire que cette modification soit persist&eacute;e, l'application
                                doit assigner un nouvel (non identique) objet &agrave; la propri&eacute;t&eacute;.
                            </p></dd></dl></div><p>
            </p><p>
                Les identifiants uniques des entit&eacute;s et collections peuvent &ecirc;tre de n'importe quel type de base except&eacute; 
                <tt class="literal">binary</tt>, <tt class="literal">blob</tt> et <tt class="literal">clob</tt> (les identifiants 
                composites sont aussi permis, voir plus bas).
            </p><p>
                Les types de base des valeurs ont des <tt class="literal">Type</tt> constants correspondants d&eacute;finis 
                dans <tt class="literal">org.hibernate.Hibernate</tt>. Par exemple, <tt class="literal">Hibernate.STRING</tt>
                repr&eacute;sent&eacute; le type <tt class="literal">string</tt>.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-custom"></a>5.2.3.&nbsp;Types de valeur d&eacute;finis par l'utilisateur</h3></div></div><div></div></div><p>
                Il est assez facile pour les d&eacute;veloppeurs de cr&eacute;er leurs propres types de valeurs. Par exemple, 
                vous pourriez vouloir persister des propri&eacute;t&eacute;s du type <tt class="literal">java.lang.BigInteger</tt>
                dans des colonnnes <tt class="literal">VARCHAR</tt>. Hibernate ne procure pas par d&eacute;faut un type pour cela. 
                Mais les types que vous pouvez cr&eacute;er ne se limitent pas &agrave; mapper des propri&eacute;t&eacute;s (ou &eacute;l&eacute;ment collection) 
                &agrave; une simple colonne d'une table. Donc, par exemple, vous pourriez avoir une propri&eacute;t&eacute; Java 
                <tt class="literal">getName()</tt>/<tt class="literal">setName()</tt> de type 
                <tt class="literal">java.lang.String</tt> persist&eacute;e dans les colonnes  
                <tt class="literal">FIRST_NAME</tt>, <tt class="literal">INITIAL</tt>, <tt class="literal">SURNAME</tt>.
            </p><p>
                Pour impl&eacute;menter votre propre type, vous pouvez soit impl&eacute;menter <tt class="literal">org.hibernate.UserType</tt> 
                soit <tt class="literal">org.hibernate.CompositeUserType</tt> et d&eacute;clarer des propri&eacute;t&eacute;s utilisant des 
                noms de classes complets du type. Regardez <tt class="literal">org.hibernate.test.DoubleStringType</tt> 
                pour voir ce qu'il est possible de faire.
            </p><pre class="programlisting">&lt;property name="twoStrings" type="org.hibernate.test.DoubleStringType"&gt;
    &lt;column name="first_string"/&gt;
    &lt;column name="second_string"/&gt;
&lt;/property&gt;</pre><p>
                Remarquez l'utilisation des tags <tt class="literal">&lt;column&gt;</tt> pour mapper une propri&eacute;t&eacute; sur des colonnes 
                multiples.
            </p><p>
                Les interfaces <tt class="literal">CompositeUserType</tt>, <tt class="literal">EnhancedUserType</tt>,
                <tt class="literal">UserCollectionType</tt>, et <tt class="literal">UserVersionType</tt> permettent des utilisations 
                plus sp&eacute;cialis&eacute;es.
            </p><p>
                Vous pouvez m&ecirc;me donner des param&egrave;tres en indiquant <tt class="literal">UserType</tt> dans le fichier 
                de mapping ; Pour cela, votre <tt class="literal">UserType</tt> doit impl&eacute;menter l'interface 
                <tt class="literal">org.hibernate.usertype.ParameterizedType</tt>. Pour sp&eacute;cifier des param&egrave;tres dans 
                votre type propre, vous pouvez utiliser l'&eacute;l&eacute;ment <tt class="literal">&lt;type&gt;</tt> dans vos fichiers de mapping.
            </p><pre class="programlisting">&lt;property name="priority"&gt;
    &lt;type name="com.mycompany.usertypes.DefaultValueIntegerType"&gt;
        &lt;param name="default"&gt;0&lt;/param&gt;
    &lt;/type&gt;
&lt;/property&gt;</pre><p>
                Le <tt class="literal">UserType</tt> permet maintenant de r&eacute;cup&eacute;rer la valeur pour le param&egrave;tre nomm&eacute; 
                <tt class="literal">default</tt> &agrave; partir de l'objet <tt class="literal">Properties</tt> qui lui est pass&eacute;.
            </p><p>
                Si vous utilisez fr&eacute;quemment un <tt class="literal">UserType</tt>, cela peut &ecirc;tre utile de lui d&eacute;finir un 
                nom plus court. Vous pouvez faire cela en utilisant l'&eacute;l&eacute;ment <tt class="literal">&lt;typedef&gt;</tt>. 
                Les typedefs permettent d'assigner un nom &agrave; votre type propre et peuvent aussi contenir une liste de 
                valeurs de param&egrave;tres par d&eacute;faut si ce type est param&eacute;tr&eacute;.
            </p><pre class="programlisting">&lt;typedef class="com.mycompany.usertypes.DefaultValueIntegerType" name="default_zero"&gt;
    &lt;param name="default"&gt;0&lt;/param&gt;
&lt;/typedef&gt;</pre><pre class="programlisting">&lt;property name="priority" type="default_zero"/&gt;</pre><p>
                Il est aussi possible de red&eacute;finir les param&egrave;tres par d&eacute;faut du typedef au cas par cas en 
                utilisant des param&egrave;tres type sur le mapping de la propri&eacute;t&eacute;. 
            </p><p>
                Bien que le fait que Hibernate propose de base une riche vari&eacute;t&eacute; de types, et qu'il supporte les composants 
                signifie que vous aurez tr&egrave;s rarement <span class="emphasis"><em>besoin</em></span> d'utiliser un nouveau type propre, 
                il est n&eacute;anmoins de bonne pratique d'utiliser des types propres pour les classes (non entit&eacute;s) qui 
                apparaissent fr&eacute;quemment dans votre application. Par exemple une classe <tt class="literal">MonetaryAmount</tt> 
                est un bon candidat pour un <tt class="literal">CompositeUserType</tt> m&ecirc;me s'il pourrait facilement 
                &ecirc;tre mapp&eacute; comme un composant. Une motivation pour cela est l'abstraction. Avec un type propre 
                vos documents de mapping sont &agrave; l'abri des changements futurs dans votre fa&ccedil;on de repr&eacute;senter des 
                valeurs mon&eacute;taires.
            </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-entityname"></a>5.3.&nbsp;Mapper une classe plus d'une fois</h2></div></div><div></div></div><p>
            Il est possible de proposer plus d'un mapping par classe persistante. Dans ce cas, vous
            devez sp&eacute;cifier un <span class="emphasis"><em>nom d'entit&eacute;</em></span> pour lever l'ambiguit&eacute; entre les instances
            des entit&eacute;s mapp&eacute;es (par d&eacute;faut, le nom de l'entit&eacute; est celui de la classe). Hibernate
            vous permet de sp&eacute;cifier le nom de l'entit&eacute; lorsque vous utilisez des objets persistants, lorsque
            vous &eacute;crivez des requ&ecirc;tes ou quand vous mappez des associations vers les entit&eacute;s nomm&eacute;es.
        </p><pre class="programlisting">&lt;class name="Contract" table="Contracts" 
        entity-name="CurrentContract"&gt;
    ...
    &lt;set name="history" inverse="true" 
            order-by="effectiveEndDate desc"&gt;
        &lt;key column="currentContractId"/&gt;
        &lt;one-to-many entity-name="HistoricalContract"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Contract" table="ContractHistory" 
        entity-name="HistoricalContract"&gt;
    ...
    &lt;many-to-one name="currentContract" 
            column="currentContractId" 
            entity-name="CurrentContract"/&gt;
&lt;/class&gt;</pre><p>
            Remarquez comment les associations sont d&eacute;sormais sp&eacute;cifi&eacute;es en utilisant
            <tt class="literal">entity-name</tt> au lieu de <tt class="literal">class</tt>.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-quotedidentifiers"></a>5.4.&nbsp;SQL quoted identifiers</h2></div></div><div></div></div><p>
            Vous pouvez forcer Hibernate &agrave; mettre un identifiant entre quotes dans le SQL g&eacute;n&eacute;r&eacute; en mettant le nom 
            de la table ou de la colonne entre backticks dans le 
            document de mapping. Hibernate utilisera les bons styles de quotes pour le <tt class="literal">Dialect</tt> SQL 
            (habituellement des doubles quotes, mais des parenth&egrave;ses pour SQL server et des backticks pour MySQL).
        </p><pre class="programlisting">&lt;class name="LineItem" table="`Line Item`"&gt;
    &lt;id name="id" column="`Item Id`"/&gt;&lt;generator class="assigned"/&gt;&lt;/id&gt;
    &lt;property name="itemNumber" column="`Item #`"/&gt;
    ...
&lt;/class&gt;</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-alternatives"></a>5.5.&nbsp;alternatives Metadata</h2></div></div><div></div></div><p>
            XML ne convient pas &agrave; tout le monde, il y a donc des moyens alternatifs pour d&eacute;finir des metatda 
            de mappings O/R dans Hibernate.
        </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-xdoclet"></a>5.5.1.&nbsp;utilisation de XDoclet</h3></div></div><div></div></div><p>
                De nombreux utilisateurs de Hibernate pr&eacute;f&egrave;rent embarquer les informations de mappings 
                directement au sein du code source en utilisant les tags XDoclet <tt class="literal">@hibernate.tags</tt>. 
                Nous ne couvrons pas cette approche dans ce document cependant, puisque c'est consid&eacute;r&eacute; comme faisant partie 
                de XDoclet. Cependant, nous pr&eacute;sentons l'exemple suivant de la classe <tt class="literal">Cat</tt> avec 
                des mappings XDoclet.
        </p><pre class="programlisting">package eg;
import java.util.Set;
import java.util.Date;

/**
 * @hibernate.class
 *  table="CATS"
 */
public class Cat {
    private Long id; // identifier
    private Date birthdate;
    private Cat mother;
    private Set kittens
    private Color color;
    private char sex;
    private float weight;

    /*
     * @hibernate.id
     *  generator-class="native"
     *  column="CAT_ID"
     */
    public Long getId() {
        return id;
    }
    private void setId(Long id) {
        this.id=id;
    }

    /**
     * @hibernate.many-to-one
     *  column="PARENT_ID"
     */
    public Cat getMother() {
        return mother;
    }
    void setMother(Cat mother) {
        this.mother = mother;
    }

    /**
     * @hibernate.property
     *  column="BIRTH_DATE"
     */
    public Date getBirthdate() {
        return birthdate;
    }
    void setBirthdate(Date date) {
        birthdate = date;
    }
    /**
     * @hibernate.property
     *  column="WEIGHT"
     */
    public float getWeight() {
        return weight;
    }
    void setWeight(float weight) {
        this.weight = weight;
    }

    /**
     * @hibernate.property
     *  column="COLOR"
     *  not-null="true"
     */
    public Color getColor() {
        return color;
    }
    void setColor(Color color) {
        this.color = color;
    }
    /**
     * @hibernate.set
     *  inverse="true"
     *  order-by="BIRTH_DATE"
     * @hibernate.collection-key
     *  column="PARENT_ID"
     * @hibernate.collection-one-to-many
     */
    public Set getKittens() {
        return kittens;
    }
    void setKittens(Set kittens) {
        this.kittens = kittens;
    }
    // addKitten not needed by Hibernate
    public void addKitten(Cat kitten) {
        kittens.add(kitten);
    }

    /**
     * @hibernate.property
     *  column="SEX"
     *  not-null="true"
     *  update="false"
     */
    public char getSex() {
        return sex;
    }
    void setSex(char sex) {
        this.sex=sex;
    }
}</pre><p>
            Voyez le site web de Hibernate pour plus d'exemples sur XDoclet et Hibernate.
        </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-annotations"></a>5.5.2.&nbsp;Utilisation des annotations JDK 5.0</h3></div></div><div></div></div><p>
                Le JDK 5.0 introduit des annotations proches de celles de XDoclet au niveau java, qui sont 
                type-safe et v&eacute;rifi&eacute;es &agrave; la compilation. Ce m&eacute;canisme est plus puissant que XDoclet et mieux 
                support&eacute; par les outils et IDE. IntelliJ IDEA, par exemple, supporte l'auto-compl&eacute;tion et le 
                surlignement syntaxique des annotations JDK 5.0. La nouvelle r&eacute;vision des sp&eacute;cifications des EJB 
                (JSR-220) utilise les annotations JDK 5.0 comme m&eacute;canisme primaire pour les meta-donn&eacute;es des beans entit&eacute;s. 
                Hibernate3 impl&eacute;mente l'<tt class="literal">EntityManager</tt> de la JSR-220 (API de persistance), 
                le support du mapping de meta-donn&eacute;es est disponible via le package <span class="emphasis"><em>Hibernate Annotations</em></span>, 
                en tant que module s&eacute;par&eacute; &agrave; t&eacute;l&eacute;charger. EJB3 (JSR-220) et les m&eacute;tadata Hibernate3 sont support&eacute;s.
             </p><p>
                Ceci est un exemple d'une classe POJO annot&eacute;e comme un EJB entit&eacute; :
            </p><pre class="programlisting">@Entity(access = AccessType.FIELD)
public class Customer implements Serializable {

    @Id;
    Long id;

    String firstName;
    String lastName;
    Date birthday;

    @Transient
    Integer age;

    @Embedded
    private Address homeAddress;

    @OneToMany(cascade=CascadeType.ALL)
    @JoinColumn(name="CUSTOMER_ID")
    Set&lt;Order&gt; orders;

    // Getter/setter and business methods
}</pre><p>
                Notez que le support des annotations JDK 5.0 (et de la JSR-220) est encore en cours et n'est pas termin&eacute;.
                R&eacute;f&eacute;rez vous au module Hibernate Annotation pour plus de d&eacute;tails.
            </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-generated"></a>5.6.&nbsp;Propri&eacute;t&eacute;s g&eacute;n&eacute;r&eacute;es</h2></div></div><div></div></div><p>
            Les propri&eacute;t&eacute;s g&eacute;n&eacute;r&eacute;es sont des propri&eacute;t&eacute;s dont les valeurs sont g&eacute;n&eacute;r&eacute;es par
            la base de donn&eacute;es. Typiquement, les applications Hibernate avaient besoin d'invoquer
            <tt class="literal">refresh</tt> sur les instances qui contenaient des propri&eacute;t&eacute;s pour lesquelles
            la base de donn&eacute;es g&eacute;n&eacute;rait des valeurs. Marquer les propri&eacute;t&eacute;s comme g&eacute;n&eacute;r&eacute;es permet &agrave;
            l'application de d&eacute;l&eacute;guer cette responsabilit&eacute; &agrave; Hibernate. Principalement, &agrave; chaque fois
            qu'Hibernate r&eacute;alise une insertion ou une mise &agrave; jour en base de donn&eacute;es pour une entit&eacute;
            marqu&eacute;e comme telle, cela provoque imm&eacute;diatement un select pour r&eacute;cup&eacute;rer les valeurs g&eacute;n&eacute;r&eacute;es.
        </p><p>
            Les propri&eacute;t&eacute;s marqu&eacute;es comme g&eacute;n&eacute;r&eacute;es doivent de plus ne pas &ecirc;tre ins&eacute;rables et modifiables 
            Seuls <a href="#mapping-declaration-version" title="5.1.7.&nbsp;version (optionnel)">Section&nbsp;5.1.7, &laquo;&nbsp;version (optionnel)&nbsp;&raquo;</a>,
            <a href="#mapping-declaration-timestamp" title="5.1.8.&nbsp;timestamp (optionnel)">Section&nbsp;5.1.8, &laquo;&nbsp;timestamp (optionnel)&nbsp;&raquo;</a>, et
            <a href="#mapping-declaration-property" title="5.1.9.&nbsp;property">Section&nbsp;5.1.9, &laquo;&nbsp;property&nbsp;&raquo;</a> peuvent &ecirc;tre marqu&eacute;s comme
            g&eacute;n&eacute;r&eacute;es.
        </p><p>
            <tt class="literal">never</tt> (par d&eacute;faut) - indique la valeur de la propri&eacute;t&eacute; n'est pas g&eacute;n&eacute;r&eacute;e
            dans la base de donn&eacute;es.
        </p><p>
            <tt class="literal">insert</tt> - indique que la valeur de la propri&eacute;t&eacute; donn&eacute;e est
            g&eacute;n&eacute;r&eacute;e &agrave; l'insertion mais pas lors des futures mises &agrave; jour de l'enregistrement.
            Les colonnes de type "date de cr&eacute;ation" sont le cas d'utilisation typique de cette option.
            Notez que m&ecirc;me les propri&eacute;t&eacute;s <a href="#mapping-declaration-version" title="5.1.7.&nbsp;version (optionnel)">Section&nbsp;5.1.7, &laquo;&nbsp;version (optionnel)&nbsp;&raquo;</a> et
            <a href="#mapping-declaration-timestamp" title="5.1.8.&nbsp;timestamp (optionnel)">Section&nbsp;5.1.8, &laquo;&nbsp;timestamp (optionnel)&nbsp;&raquo;</a> peuvent &ecirc;tre
            d&eacute;clar&eacute;es comme g&eacute;n&eacute;r&eacute;es, cette option n'est pas disponible &agrave; cet endroit...
        </p><p>
            <tt class="literal">always</tt> - indique que la valeur de la propri&eacute;t&eacute; est g&eacute;n&eacute;r&eacute;e &agrave; l'insert 
            comme aux updates.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-database-object"></a>5.7.&nbsp;Objets auxiliaires de la base de donn&eacute;es</h2></div></div><div></div></div><p>
            Permettent les ordres CREATE et DROP d'objets arbitraire de la base de donn&eacute;&eacute;es, en conjonction avec
            les outils Hibernate d'&eacute;volutions de sch&eacute;ma, pour permettre de d&eacute;finir compl&egrave;tement
            un sch&eacute;ma utilisateur au sein des fichiers de mapping Hibernate. Bien que con&ccedil;u sp&eacute;cifiquement
            pour cr&eacute;er et supprimer des objets tels que des triggers et des proc&eacute;dures stock&eacute;es,
            ou toute commande pouvant &ecirc;tre ex&eacute;cut&eacute;e via une m&eacute;thode de <tt class="literal">java.sql.Statement.execute()</tt>
            (ALTERs, INSERTS, etc). Il y a principalement deux modes pour d&eacute;finir les objets auxiliaires de base de donn&eacute;es...
        </p><p>
            Le premier mode est de lister explicitement les commandes CREATE et DROP dans le fichier
            de mapping:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    ...
    &lt;database-object&gt;
        &lt;create&gt;CREATE TRIGGER my_trigger ...&lt;/create&gt;
        &lt;drop&gt;DROP TRIGGER my_trigger&lt;/drop&gt;
    &lt;/database-object&gt;
&lt;/hibernate-mapping&gt;</pre><p>
            Le second mode est de fournir une classe particuli&egrave;re qui connait comment construire
            les commandes CREATE et DROP. Cette classe particuli&egrave;re doit impl&eacute;menter l'interface
            <tt class="literal">org.hibernate.mapping.AuxiliaryDatabaseObject</tt>.
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    ...
    &lt;database-object&gt;
        &lt;definition class="MyTriggerDefinition"/&gt;
    &lt;/database-object&gt;
&lt;/hibernate-mapping&gt;</pre><p>
            Additionnellement, ces objets de base de donn&eacute;es peuvent &ecirc;tre optionnellement trait&eacute;s
            selon l'utilisation de dialectes particuliers..
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    ...
    &lt;database-object&gt;
        &lt;definition class="MyTriggerDefinition"/&gt;
        &lt;dialect-scope name="org.hibernate.dialect.Oracle9Dialect"/&gt;
        &lt;dialect-scope name="org.hibernate.dialect.OracleDialect"/&gt;
    &lt;/database-object&gt;
&lt;/hibernate-mapping&gt;</pre></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="collections"></a>Chapitre&nbsp;6.&nbsp;Mapping des collections</h2></div></div><div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-persistent"></a>6.1.&nbsp;Collections persistantes</h2></div></div><div></div></div><p>
            Hibernate requiert que les champs contenant des collections persistantes soient d&eacute;clar&eacute;s
            comme des types d'interface, par exemple :
        </p><pre class="programlisting">public class Product {
    private String serialNumber;
    private Set parts = new HashSet();

    public Set getParts() { return parts; }
    void setParts(Set parts) { this.parts = parts; }
    public String getSerialNumber() { return serialNumber; }
    void setSerialNumber(String sn) { serialNumber = sn; }
}</pre><p>
            L'interface r&eacute;elle devrait &ecirc;tre <tt class="literal">java.util.Set</tt>,
            <tt class="literal">java.util.Collection</tt>, <tt class="literal">java.util.List</tt>,
            <tt class="literal">java.util.Map</tt>, <tt class="literal">java.util.SortedSet</tt>,
            <tt class="literal">java.util.SortedMap</tt> ou ... n'importe quoi d'autre ! (O&ugrave;
            "n'importe quoi d'autre" signifie que vous devrez &eacute;crire une impl&eacute;mentation de
            <tt class="literal">org.hibernate.usertype.UserCollectionType</tt>.)
        </p><p>
            Notez comment nous avons initialis&eacute; les variables d'instance avec une instance de
            <tt class="literal">HashSet</tt>. C'est le meilleur moyen pour initialiser les 
            collections d'instances nouvellement cr&eacute;&eacute;es (non persistantes). Quand
            nous fabriquons l'instance persistante - en appelant <tt class="literal">persist()</tt>,
            par exemple - Hibernate remplacera r&eacute;ellement le <tt class="literal">HashSet</tt>
            avec une instance d'une impl&eacute;mentation propre &agrave; Hibernate de <tt class="literal">Set</tt>.
            Prenez garde aux erreurs :
        </p><pre class="programlisting">Cat cat = new DomesticCat();
Cat kitten = new DomesticCat();
....
Set kittens = new HashSet();
kittens.add(kitten);
cat.setKittens(kittens);
session.persist(cat);
kittens = cat.getKittens(); // Ok, la collection kittens est un Set
(HashSet) cat.getKittens(); // Erreur !</pre><p>
            Les collections persistantes inject&eacute;es par Hibernate se comportent de la m&ecirc;me mani&egrave;re que
            <tt class="literal">HashMap</tt>, <tt class="literal">HashSet</tt>,
            <tt class="literal">TreeMap</tt>, <tt class="literal">TreeSet</tt> ou
            <tt class="literal">ArrayList</tt>, selon le type de l'interface.
        </p><p>
            Les instances des collections ont le comportement habituel des types des valeurs.
            Elles sont automatiquement persist&eacute;es quand elles sont r&eacute;f&eacute;renc&eacute;es par un objet persistant et
            automatiquement effac&eacute;es quand elles sont d&eacute;r&eacute;f&eacute;renc&eacute;es. Si une collection est pass&eacute;e
            d'un objet persistant &agrave; un autre, ses &eacute;l&eacute;ments pourraient &ecirc;tre d&eacute;plac&eacute;s d'une table
            &agrave; une autre. Deux entit&eacute;s ne peuvent pas partager une r&eacute;f&eacute;rence vers une m&ecirc;me instance
            d'une collection. D&ucirc; au mod&egrave;le relationnel sous-jacent, les propri&eacute;t&eacute;s contenant des
            collections ne supportent pas la s&eacute;mantique de la valeur null ; Hibernate ne distingue pas
            une r&eacute;f&eacute;rence vers une collection nulle d'une collection vide.
        </p><p>
            Vous ne devriez pas vous pr&eacute;occuper trop de &ccedil;a. Utilisez les collections persistantes de
            la m&ecirc;me mani&egrave;re que vous utilisez des collections Java ordinaires. Assurez-vous
            de comprendre la s&eacute;mantique des associations bidirectionnelles (trait&eacute;e plus loin).
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-mapping"></a>6.2.&nbsp;Mapper une collection</h2></div></div><div></div></div><p>
            L'&eacute;l&eacute;ment de mapping d'Hibernate utilis&eacute; pour mapper une collection d&eacute;pend du type de
            l'interface. Par exemple, un &eacute;l&eacute;ment <tt class="literal">&lt;set&gt;</tt> est utilis&eacute;
            pour mapper des propri&eacute;t&eacute;s de type <tt class="literal">Set</tt>.
        </p><pre class="programlisting">&lt;class name="Product"&gt;
    &lt;id name="serialNumber" column="productSerialNumber"/&gt;
    &lt;set name="parts"&gt;
        &lt;key column="productSerialNumber" not-null="true"/&gt;
        &lt;one-to-many class="Part"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
            &Agrave; part <tt class="literal">&lt;set&gt;</tt>, il y  aussi les &eacute;l&eacute;ments de mapping
            <tt class="literal">&lt;list&gt;</tt>, <tt class="literal">&lt;map&gt;</tt>,
            <tt class="literal">&lt;bag&gt;</tt>, <tt class="literal">&lt;array&gt;</tt> et
            <tt class="literal">&lt;primitive-array&gt;</tt>.
            L'&eacute;l&eacute;ment <tt class="literal">&lt;map&gt;</tt> est repr&eacute;sentatif :
        </p><div class="programlistingco"><pre class="programlisting">&lt;map
    name="nomDePropriete"                                       <span class="co">(1)</span>
    table="nom_de_table"                                        <span class="co">(2)</span>
    schema="nom_du_schema"                                      <span class="co">(3)</span>
    lazy="true|extra|false"                                     <span class="co">(4)</span>
    inverse="true|false"                                        <span class="co">(5)</span>
    cascade="all|none|save-update|delete|all-delete-orphan"     <span class="co">(6)</span>
    sort="unsorted|natural|ClasseDeComparateur"                 <span class="co">(7)</span>
    order-by="nom_de_column asc|desc"                           <span class="co">(8)</span>
    where="condition sql where quelcconque"                     <span class="co">(9)</span>
    fetch="join|select|subselect"                               <span class="co">(10)</span>
    batch-size="N"                                              <span class="co">(11)</span>
    access="field|property|NomDeClasse"                         <span class="co">(12)</span>
    optimistic-lock="true|false"                                <span class="co">(13)</span>
    mutable="true|false"                                        <span class="co">(14)</span>
    node="nom-d-element|."
    embed-xml="true|false"
&gt;

    &lt;key .... /&gt;
    &lt;map-key .... /&gt;
    &lt;element .... /&gt;
&lt;/map&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">name</tt> : le nom de la propri&eacute;t&eacute; contenant la collection
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">table</tt> (optionnel - par d&eacute;faut = nom de la propri&eacute;t&eacute;) : le
                        nom de la table de la collection (non utilis&eacute; pour les associations one-to-many)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">schema</tt> (optionnel) : le nom du sch&eacute;ma pour surcharger le
                        sch&eacute;ma d&eacute;clar&eacute; dans l'&eacute;l&eacute;ment racine
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                        <tt class="literal">lazy</tt> (optionnel - par d&eacute;faut = <tt class="literal">true</tt>) :
                        peut &ecirc;tre utilis&eacute; pour d&eacute;sactiver l'initialisation tardive et sp&eacute;cifier
                        que l'association est toujours rapport&eacute;e, ou pour activer la
                        r&eacute;cup&eacute;ration extra-paresseuse (NdT : extra-lazy) o&ugrave; la plupart des
                        op&eacute;rations n'initialisent pas la collection (appropri&eacute; pour de tr&egrave;s
                        grosses collections)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                        <tt class="literal">inverse</tt> (optionnel - par d&eacute;faut = <tt class="literal">false</tt>) :
                        d&eacute;finit cette collection comme l'extr&ecirc;mit&eacute; "inverse" de l'association
                        bidirectionnelle
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                        <tt class="literal">cascade</tt> (optionnel - par d&eacute;faut = <tt class="literal">none</tt>) :
                        active les op&eacute;rations de cascade vers les entit&eacute;s filles
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                        <tt class="literal">sort</tt> (optionnel) : sp&eacute;cifie une collection tri&eacute;e via un ordre
                        de tri <tt class="literal">naturel</tt>, ou via une classe comparateur donn&eacute;e (impl&eacute;mentant Comparator)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                        <tt class="literal">order-by</tt> (optionnel, seulement &agrave; partir du JDK1.4) :
                        sp&eacute;cifie une colonne de table
                        (ou des colonnes) qui d&eacute;finit l'ordre d'it&eacute;ration de <tt class="literal">Map</tt>, <tt class="literal">Set</tt>
                        ou Bag, avec en option <tt class="literal">asc</tt> ou <tt class="literal">desc</tt>
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                        <tt class="literal">where</tt> (optionnel) : sp&eacute;cifie une condition SQL arbitraire <tt class="literal">WHERE</tt>
                        &agrave; utiliser au chargement ou &agrave; la suppression d'une collection (utile si la collection
                        ne doit contenir qu'un sous ensemble des donn&eacute;es disponibles)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                        <tt class="literal">fetch</tt> (optionnel, par d&eacute;faut = <tt class="literal">select</tt>) :
                        &agrave; choisir entre r&eacute;cup&eacute;ration par jointures externes, r&eacute;cup&eacute;ration par
                        selects s&eacute;quentiels, et r&eacute;cup&eacute;ration par sous-selects s&eacute;quentiels
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(11)</td><td valign="top" align="left"><p>
                        <tt class="literal">batch-size</tt> (optionnel, par d&eacute;faut = <tt class="literal">1</tt>) : une taille
                        de batch (batch size) utilis&eacute;e pour charger plusieurs instances de cette collection en
                        initialisation tardive
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(12)</td><td valign="top" align="left"><p>
                        <tt class="literal">access</tt> (optionnel - par d&eacute;faut = <tt class="literal">property</tt>) : La
                        strat&eacute;gie qu'Hibernate doit utiliser pour acc&eacute;der &agrave; la valeur de la propri&eacute;t&eacute;
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(13)</td><td valign="top" align="left"><p>
                        <tt class="literal">optimistic-lock</tt> (optionnel - par d&eacute;faut = <tt class="literal">true</tt>) :
                        sp&eacute;cifie que changer l'&eacute;tat de la collection entra&icirc;ne l'incr&eacute;mentation
                        de la version appartenant &agrave; l'entit&eacute; (Pour une association un vers plusieurs,
                        il est souvent raisonnable de d&eacute;sactiver ce param&egrave;tre)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(14)</td><td valign="top" align="left"><p>
                        <tt class="literal">mutable</tt> (optionnel - par d&eacute;faut = <tt class="literal">true</tt>) :
                        une valeur &agrave; <tt class="literal">false</tt> sp&eacute;cifie que les &eacute;l&eacute;ments de la
                        collection ne changent jamais (une optimisation mineure dans certains cas)
                    </p></td></tr></table></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="collections-foreignkeys"></a>6.2.1.&nbsp;Les clefs &eacute;trang&egrave;res d'une collection</h3></div></div><div></div></div><p>
                Les instances d'une collection sont distingu&eacute;es dans la base par la clef &eacute;trang&egrave;re
                de l'entit&eacute; qui poss&egrave;de la collection. Cette clef &eacute;trang&egrave;re est r&eacute;f&eacute;renc&eacute;e comme la(es)
                <span class="emphasis"><em>colonne(s) de la clef de la collection</em></span> de la table de la collection.
                La colonne de la clef de la collection est mapp&eacute;e par l'&eacute;l&eacute;ment <tt class="literal">&lt;key&gt;</tt>.
            </p><p>
                Il peut y avoir une contrainte de nullit&eacute; sur la colonne de la clef &eacute;trang&egrave;re. Pour les
                associations unidirectionnelles un vers plusieurs, la colonne de la clef &eacute;trang&egrave;re
                peut &ecirc;tre nulle par d&eacute;faut, donc vous pourriez avoir besoin de sp&eacute;cifier
                <tt class="literal">not-null="true"</tt>.
            </p><pre class="programlisting">&lt;key column="productSerialNumber" not-null="true"/&gt;</pre><p>
                La contraite de la clef &eacute;trang&egrave;re peut utiliser <tt class="literal">ON DELETE CASCADE</tt>.
            </p><pre class="programlisting">&lt;key column="productSerialNumber" on-delete="cascade"/&gt;</pre><p>
                Voir le chapitre pr&eacute;c&eacute;dent pour une d&eacute;finition compl&egrave;te de l'&eacute;l&eacute;ment <tt class="literal">&lt;key&gt;</tt>.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="collections-elements"></a>6.2.2.&nbsp;Les &eacute;l&eacute;ments d'une collection</h3></div></div><div></div></div><p>
                Les collections peuvent contenir la plupart des autres types Hibernate, dont tous les types
                basiques, les types utilisateur, les composants, et bien s&ucirc;r, les r&eacute;f&eacute;rences vers
                d'autres entit&eacute;s. C'est une distinction importante : un objet dans une collection
                pourrait &ecirc;tre g&eacute;r&eacute; avec une s&eacute;mantique de "valeur" (sa dur&eacute;e de vie d&eacute;pend compl&egrave;tement
                du propri&eacute;taire de la collection) ou il pourrait avoir une r&eacute;f&eacute;rence vers une autre
                entit&eacute;, avec sa propre dur&eacute;e de vie. Dans le dernier cas, seul le "lien" entre les 2 objets
                est consid&eacute;r&eacute; &ecirc;tre l'&eacute;tat retenu par la collection.
            </p><p>
                Le type contenu est r&eacute;f&eacute;renc&eacute; comme le <span class="emphasis"><em>type de l'&eacute;l&eacute;ment de la collection</em></span>.
                Les &eacute;l&eacute;ments de la collections sont mapp&eacute;s par <tt class="literal">&lt;element&gt;</tt> ou
                <tt class="literal">&lt;composite-element&gt;</tt>, ou dans le cas des r&eacute;f&eacute;rences d'entit&eacute;, avec
                <tt class="literal">&lt;one-to-many&gt;</tt> ou <tt class="literal">&lt;many-to-many&gt;</tt>.
                Les deux premiers mappent des &eacute;l&eacute;ments avec un s&eacute;mantique de valeur, les deux suivants sont
                utilis&eacute;s pour mapper des associations d'entit&eacute;.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="collections-indexed"></a>6.2.3.&nbsp;Collections index&eacute;es</h3></div></div><div></div></div><p>
                Tous les mappings de collection, except&eacute;s ceux avec les s&eacute;mantiques d'ensemble (NdT : set) et
                de sac (NdT : bag), ont besoin d'une <span class="emphasis"><em>colonne d'index</em></span> dans la
                table de la collection - une colonne qui mappe un index de tableau, ou un index de
                <tt class="literal">List</tt>, ou une clef de <tt class="literal">Map</tt>. L'index d'une
                <tt class="literal">Map</tt> peut &ecirc;tre n'importe quel type basique, mapp&eacute; avec
                <tt class="literal">&lt;map-key&gt;</tt>, &ccedil;a peut &ecirc;tre une r&eacute;f&eacute;rence d'entit&eacute; mapp&eacute;e avec
                <tt class="literal">&lt;map-key-many-to-many&gt;</tt>, ou &ccedil;a peut &ecirc;tre un type compos&eacute;, mapp&eacute; avec
                <tt class="literal">&lt;composite-map-key&gt;</tt>. L'index d'un tableau ou d'une liste est toujours
                de type <tt class="literal">integer</tt> et est mapp&eacute; en utilisant l'&eacute;l&eacute;ment <tt class="literal">&lt;list-index&gt;</tt>.
                Les colonnes mapp&eacute;es contiennent des entiers s&eacute;quentiels (num&eacute;rot&eacute;s &agrave; partir de z&eacute;ro par d&eacute;faut).
            </p><div class="programlistingco"><pre class="programlisting">&lt;list-index
        column="nom_de_colonne"             <span class="co">(1)</span>
        base="0|1|..."/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">nom_de_colonne</tt> (requis) : le nom de la colonne contenant les valeurs de l'index de la collection
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">base</tt> (optionnel, par d&eacute;faut = <tt class="literal">0</tt>) : la valeur
                        de la colonne de l'index qui correspond au premier &eacute;l&eacute;ment de la liste ou du tableau
                    </p></td></tr></table></div></div><div class="programlistingco"><pre class="programlisting">&lt;map-key
        column="nom_de_colonne"             <span class="co">(1)</span>
        formula="n'importe quelle expression<span class="co">(2)</span> SQL"
        type="nom_du_type"                  <span class="co">(3)</span>
        node="@nom-d-attribut"
        length="N"/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (optionnel) :
                        le nom de la colonne contenant les valeurs de l'index de la collection
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">formula</tt> (optionnel) :
                        une formule SQL utilis&eacute;e pour &eacute;valuer la clef de la map
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">type</tt> (reguis): le type des clefs de la map
                    </p></td></tr></table></div></div><div class="programlistingco"><pre class="programlisting">&lt;map-key-many-to-many
        column="nom_de_colonne"             <span class="co">(1)</span>
        formula="n'importe quelle expression<span class="co">(2)</span><span class="co">(3)</span> SQL"
        class="NomDeClasse"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (optionnel) :
                        le nom de la colonne de la clef &eacute;trang&egrave;re pour les valeurs de l'index de la collection
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">formula</tt> (optionnel) :
                        une formulre SQL utilis&eacute;e pour &eacute;valuer la clef &eacute;trang&egrave;re de la clef de la map
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">class</tt> (requis): la classe de l'entit&eacute; utilis&eacute;e comme clef de la map
                    </p></td></tr></table></div></div><p>
                Si votre table n'a pas de colonne d'index, et que vous souhaitez tout de m&ecirc;me utiliser
                <tt class="literal">List</tt> comme type de propri&eacute;t&eacute;, vous devriez mapper la propri&eacute;t&eacute; comme un
                <span class="emphasis"><em>&lt;bag&gt;</em></span> Hibernate. Un sac (NdT : bag) ne garde pas son ordre quand
                il est r&eacute;cup&eacute;r&eacute; de la base de donn&eacute;es, mais il peut &ecirc;tre optionnellement tri&eacute; ou ordonn&eacute;.
            </p></div><p>
            Il y a pas mal de vari&eacute;t&eacute;s de mappings qui peuvent &ecirc;tre g&eacute;n&eacute;r&eacute;s pour les collections,
            couvrant beaucoup des mod&egrave;les relationnels communs. Nous vous sugg&eacute;rons d'exp&eacute;rimenter avec l'outil de
            g&eacute;n&eacute;ration de sch&eacute;ma pour avoir une id&eacute;e de comment traduire les diff&eacute;rentes d&eacute;clarations de mapping vers des table de la base de donn&eacute;es.
        </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="collections-ofvalues"></a>6.2.4.&nbsp;Collections de valeurs et associations plusieurs-vers-plusieurs</h3></div></div><div></div></div><p>
            N'importe quelle collection de valeurs ou association plusieurs-vers-plusieurs requiert une
            <span class="emphasis"><em>table de collection</em></span> avec une(des) colonne(s) de clef &eacute;trang&egrave;re, une(des)
            <span class="emphasis"><em>colonne(s) d'&eacute;l&eacute;ment de la collection</em></span> ou des colonnes et possiblement
            une(des) colonne(s) d'index.
        </p><p>
            Pour une collection de valeurs, nous utilisons la balise <tt class="literal">&lt;element&gt;</tt>.
        </p><div class="programlistingco"><pre class="programlisting">&lt;element
        column="nom_de_colonne"                  <span class="co">(1)</span>
        formula="n'importe quelle expression SQL"<span class="co">(2)</span>
        type="nomDeType"                         <span class="co">(3)</span>
        length="L"
        precision="P"
        scale="S"
        not-null="true|false"
        unique="true|false"
        node="nom-d-element"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (optionnel) : le nom de la colonne contenant les valeurs de l'&eacute;l&eacute;ment de la collection
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">formula</tt> (optionnel) : une formule SQL utilis&eacute;e pour &eacute;valuer l'&eacute;l&eacute;ment
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">type</tt> (requis) : le type de l'&eacute;l&eacute;ment de la collection
                    </p></td></tr></table></div></div><p>
            Une <span class="emphasis"><em>association plusieurs-vers-plusieurs</em></span> est sp&eacute;cifi&eacute;e en
            utilisant l'&eacute;l&eacute;ment <tt class="literal">&lt;many-to-many&gt;</tt>.
        </p><div class="programlistingco"><pre class="programlisting">&lt;many-to-many
        column="nom_de_colonne"                            <span class="co">(1)</span>
        formula="n'importe quelle expression SQL"          <span class="co">(2)</span>
        class="NomDeClasse"                                <span class="co">(3)</span>
        fetch="select|join"                                <span class="co">(4)</span>
        unique="true|false"                                <span class="co">(5)</span>
        not-found="ignore|exception"                       <span class="co">(6)</span>
        entity-name="NomDEntite"                           <span class="co">(7)</span>
        property-ref="nomDeProprieteDeLaClasseAssociee"    <span class="co">(8)</span>
        node="nom-d-element"
        embed-xml="true|false"
    /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (optionnel) : le nom de la colonne de la clef &eacute;trang&egrave;re de l'&eacute;l&eacute;ment
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">formula</tt> (optionnel) :
                        une formule SQL utilis&eacute;e pour &eacute;valuer la valeur de la clef &eacute;trang&egrave;re de l'&eacute;l&eacute;ment
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">class</tt> (requis) : le nom de la classe associ&eacute;e
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                        <tt class="literal">fetch</tt> (optionnel - par d&eacute;faut <tt class="literal">join</tt>) :
                        active les r&eacute;cup&eacute;rations par jointures externes ou par selects s&eacute;quentiels pour cette association.
                        C'est un cas sp&eacute;cial ; pour une r&eacute;cup&eacute;ration compl&egrave;te sans attente (dans un seul <tt class="literal">SELECT</tt>) d'une
                        entit&eacute; et de ses relations plusieurs-vers-plusieurs vers d'autres entit&eacute;s,
                        vous devriez activer la r&eacute;cup&eacute;ration <tt class="literal">join</tt> non seulement sur
                        la collection elle-m&ecirc;me, mais aussi avec cet attribut sur l'&eacute;l&eacute;ment imbriqu&eacute;
                        <tt class="literal">&lt;many-to-many&gt;</tt>.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                        <tt class="literal">unique</tt> (optionnel) : activer la g&eacute;n&eacute;ration DDL d'une
                        contrainte d'unicit&eacute; pour la colonne de la clef &eacute;trang&egrave;re. &Ccedil;a rend la pluralit&eacute;
                        de l'association effectivement un-vers-plusieurs.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
	                    <tt class="literal">not-found</tt> (optionnel - par d&eacute;faut <tt class="literal">exception</tt>) :
                            sp&eacute;cifie comment les clefs &eacute;trang&egrave;res qui r&eacute;f&eacute;rencent la lignes
                            manquantes seront g&eacute;r&eacute;es : <tt class="literal">ignore</tt> traitera
                            une ligne manquante comme une association nulle.
	                </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                        <tt class="literal">entity-name</tt> (optionnel) : le nom de l'entit&eacute; de la classe associ&eacute;e, comme une alternative &agrave; <tt class="literal">class</tt>
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                        <tt class="literal">property-ref</tt> (optionnel) : le nom d'une propri&eacute;t&eacute; de
                        la classe associ&eacute;e qui est jointe &agrave; cette clef &eacute;trang&egrave;re. Si non sp&eacute;cifi&eacute;e,
                        la clef primaire de la classe associ&eacute;e est utilis&eacute;e.
                    </p></td></tr></table></div></div><p>
            Quelques exemples, d'abord, un ensemble de cha&icirc;nes de caract&egrave;res :
        </p><pre class="programlisting">&lt;set name="names" table="person_names"&gt;
    &lt;key column="person_id"/&gt;
    &lt;element column="person_name" type="string"/&gt;
&lt;/set&gt;</pre><p>
            Un bag contenant des entiers (avec un ordre d'it&eacute;ration d&eacute;termin&eacute; par l'attribut <tt class="literal">order-by</tt>) :
        </p><pre class="programlisting">&lt;bag name="sizes"
        table="item_sizes"
        order-by="size asc"&gt;
    &lt;key column="item_id"/&gt;
    &lt;element column="size" type="integer"/&gt;
&lt;/bag&gt;</pre><p>
            Un tableau d'entit&eacute;s - dans ce cas, une association plusieurs-vers-plusieurs :
        </p><pre class="programlisting">&lt;array name="addresses"
        table="PersonAddress"
        cascade="persist"&gt;
    &lt;key column="personId"/&gt;
    &lt;list-index column="sortOrder"/&gt;
    &lt;many-to-many column="addressId" class="Address"/&gt;
&lt;/array&gt;</pre><p>
            Une map de cha&icirc;nes de caract&egrave;res vers des dates :
        </p><pre class="programlisting">&lt;map name="holidays"
        table="holidays"
        schema="dbo"
        order-by="hol_name asc"&gt;
    &lt;key column="id"/&gt;
    &lt;map-key column="hol_name" type="string"/&gt;
    &lt;element column="hol_date" type="date"/&gt;
&lt;/map&gt;</pre><p>
            Une liste de composants (discute dans le prochain chapitre) :
        </p><pre class="programlisting">&lt;list name="carComponents"
        table="CarComponents"&gt;
    &lt;key column="carId"/&gt;
    &lt;list-index column="sortOrder"/&gt;
    &lt;composite-element class="CarComponent"&gt;
        &lt;property name="price"/&gt;
        &lt;property name="type"/&gt;
        &lt;property name="serialNumber" column="serialNum"/&gt;
    &lt;/composite-element&gt;
&lt;/list&gt;</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="collections-onetomany"></a>6.2.5.&nbsp;Association un-vers-plusieurs</h3></div></div><div></div></div><p>
            Une <span class="emphasis"><em>association un vers plusieurs</em></span> lie les tables de deux classes
            par une clef &eacute;trang&egrave;re, sans l'intervention d'une table de collection. Ce mapping perd certaines s&eacute;mantiques des collections Java normales :
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Une instance de la classe de l'entit&eacute; contenue ne peut pas appartenir &agrave; plus d'une
                    instance de la collection
                </p></li><li><p>
                    Une instance de la classe de l'entit&eacute; contenue ne peut pas appara&icirc;tre plus plus d'une valeur d'index de la collection
                </p></li></ul></div><p>
            Une association de <tt class="literal">Product</tt> vers <tt class="literal">Part</tt> requiert l'existence d'une
            clef &eacute;trang&egrave;re et possiblement une colonne d'index pour la table <tt class="literal">Part</tt>. Une balise
            <tt class="literal">&lt;one-to-many&gt;</tt> indique que c'est une association un vers plusieurs.
        </p><div class="programlistingco"><pre class="programlisting">&lt;one-to-many
        class="NomDeClasse"                                <span class="co">(1)</span>
        not-found="ignore|exception"                       <span class="co">(2)</span>
        entity-name="NomDEntite"                           <span class="co">(3)</span>
        node="nom-d-element"
        embed-xml="true|false"
    /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">class</tt> (requis) : le nom de la classe associ&eacute;e
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">not-found</tt> (optionnel - par d&eacute;faut <tt class="literal">exception</tt>) :
                        sp&eacute;cifie comment les identifiants cach&eacute;s qui r&eacute;f&eacute;rencent des lignes manquantes seront g&eacute;r&eacute;s :
                        <tt class="literal">ignore</tt> traitera une ligne manquante comme une association nulle
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">entity-name</tt> (optionnel) : le nom de l'entit&eacute; de la
                        classe associ&eacute;e, comme une alternative &agrave; <tt class="literal">class</tt>.
                    </p></td></tr></table></div></div><p>
            Notez que l'&eacute;l&eacute;ment <tt class="literal">&lt;one-to-many&gt;</tt> n'a pas besoin de d&eacute;clarer de colonnes. Il n'est pas non plus n&eacute;cessaire de sp&eacute;cifier le nom de la table nulle part.
        </p><p>
            <span class="emphasis"><em>Note tr&egrave;s importante :</em></span> si la colonne de la clef d'une association
            <tt class="literal">&lt;one-to-many&gt;</tt> est d&eacute;clar&eacute;e <tt class="literal">NOT NULL</tt>, vous devez d&eacute;clarer le
            mapping de <tt class="literal">&lt;key&gt;</tt> avec <tt class="literal">not-null="true"</tt> ou
            <span class="emphasis"><em>utiliser une association bidirectionnelle</em></span> avec le mapping de la
            collection marqu&eacute; <tt class="literal">inverse="true"</tt>. Voir la discussion sur les associations bidirectionnelles plus tard dans ce chapitre.
        </p><p>
            Cet exemple montre une map d'entit&eacute;s <tt class="literal">Part</tt> par nom (o&ugrave;
            <tt class="literal">partName</tt> est une propri&eacute;t&eacute; persistante de <tt class="literal">Part</tt>).
            Notez l'utilisation d'un index bas&eacute; sur une formule.
        </p><pre class="programlisting">&lt;map name="parts"
        cascade="all"&gt;
    &lt;key column="productId" not-null="true"/&gt;
    &lt;map-key formula="partName"/&gt;
    &lt;one-to-many class="Part"/&gt;
&lt;/map&gt;</pre></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-advancedmappings"></a>6.3.&nbsp;Mappings de collection avanc&eacute;s</h2></div></div><div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="collections-sorted"></a>6.3.1.&nbsp;Collections tri&eacute;es</h3></div></div><div></div></div><p>
            Hibernate supporte des collections impl&eacute;mentant <tt class="literal">java.util.SortedMap</tt> et
            <tt class="literal">java.util.SortedSet</tt>. Vous devez sp&eacute;cifier un comparateur dans le fichier de mapping :
        </p><pre class="programlisting">&lt;set name="aliases"
            table="person_aliases"
            sort="natural"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="string"/&gt;
&lt;/set&gt;

&lt;map name="holidays" sort="my.custom.HolidayComparator"&gt;
    &lt;key column="year_id"/&gt;
    &lt;map-key column="hol_name" type="string"/&gt;
    &lt;element column="hol_date" type="date"/&gt;
&lt;/map&gt;</pre><p>
            Les valeurs permises pour l'attribut <tt class="literal">sort</tt> sont <tt class="literal">unsorted</tt>,
            <tt class="literal">natural</tt> et le nom d'une classe impl&eacute;mentant
            <tt class="literal">java.util.Comparator</tt>.
        </p><p>
            Les collections tri&eacute;es se comportent r&eacute;ellement comme <tt class="literal">java.util.TreeSet</tt> ou
            <tt class="literal">java.util.TreeMap</tt>.
        </p><p>
            Si vous voulez que la base de donn&eacute;es elle-m&ecirc;me ordonne les &eacute;l&eacute;ments de la collection, utilisez l'attribut
            <tt class="literal">order-by</tt> des mappings <tt class="literal">set</tt>, <tt class="literal">bag</tt>
            ou <tt class="literal">map</tt>. Cette solution est seulement disponible &agrave; partir du JDK 1.4 (c'est
            impl&eacute;ment&eacute; en utilisant <tt class="literal">LinkedHashSet</tt> ou
            <tt class="literal">LinkedHashMap</tt>). Ceci ex&eacute;cute le tri dans la requ&ecirc;te SQL, pas en m&eacute;moire.
        </p><pre class="programlisting">&lt;set name="aliases" table="person_aliases" order-by="lower(name) asc"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="string"/&gt;
&lt;/set&gt;

&lt;map name="holidays" order-by="hol_date, hol_name"&gt;
    &lt;key column="year_id"/&gt;
    &lt;map-key column="hol_name" type="string"/&gt;
    &lt;element column="hol_date type="date"/&gt;
&lt;/map&gt;</pre><p>
            Notez que la valeur de l'attribut <tt class="literal">order-by</tt> est un ordre SQL, pas un ordre HQL !
        </p><p>
            Les associations peuvent m&ecirc;me &ecirc;tre tri&eacute;es sur des crit&egrave;res arbitraires &agrave; l'ex&eacute;cution en utilisant un <tt class="literal">filter()</tt> de collection.
        </p><pre class="programlisting">sortedUsers = s.createFilter( group.getUsers(), "order by this.name" ).list();</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="collections-bidirectional"></a>6.3.2.&nbsp;Associations bidirectionnelles</h3></div></div><div></div></div><p>
            Une <span class="emphasis"><em>association bidirectionnelle</em></span> permet une navigation &agrave;
            partir de la "fin" de l'association. Deux sortes d'associations bidirectionnelles sont support&eacute;es :
            </p><div class="variablelist"><dl><dt><span class="term">un-vers-plusieurs (NdT : one-to-many)</span></dt><dd><p>
                            ensemble ou sac &agrave; une extr&eacute;mit&eacute;, une seule valeur &agrave; l'autre
                        </p></dd><dt><span class="term">plusieurs-vers-plusieurs (NdT : many-to-many)</span></dt><dd><p>
                            ensemble ou sac aux deux extr&eacute;mit&eacute;s
                        </p></dd></dl></div><p>
        </p><p>
            Vous pouvez sp&eacute;cifier une association plusieurs-vers-plusieurs bidirectionnelle simplement
            en mappant deux associations plusieurs-vers-plusieurs vers la m&ecirc;me table de base de donn&eacute;es et en d&eacute;clarant une extr&eacute;mit&eacute; comme <span class="emphasis"><em>inverse</em></span> (celle de votre choix, mais &ccedil;a ne peut pas &ecirc;tre une collection index&eacute;e).
        </p><p>
            Voici un exemple d'association bidirectionnelle plusieurs-vers-plusieurs ; chaque cat&eacute;gorie peut
            avoir plusieurs objets et chaque objet peut &ecirc;tre dans plusieurs cat&eacute;gories :
        </p><pre class="programlisting">&lt;class name="Category"&gt;
    &lt;id name="id" column="CATEGORY_ID"/&gt;
    ...
    &lt;bag name="items" table="CATEGORY_ITEM"&gt;
        &lt;key column="CATEGORY_ID"/&gt;
        &lt;many-to-many class="Item" column="ITEM_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;

&lt;class name="Item"&gt;
    &lt;id name="id" column="CATEGORY_ID"/&gt;
    ...

    &lt;!-- inverse end --&gt;
    &lt;bag name="categories" table="CATEGORY_ITEM" inverse="true"&gt;
        &lt;key column="ITEM_ID"/&gt;
        &lt;many-to-many class="Category" column="CATEGORY_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;</pre><p>
            Les changements faits uniquement sur l'extr&eacute;mint&eacute; inverse de l'association <span class="emphasis"><em>ne sont pas</em></span>
            persist&eacute;s. Ceci signifie qu'Hibernate a deux repr&eacute;sentations en m&eacute;moire pour chaque
            association bidirectionnelles, un lien de A vers B et un autre de B vers A. C'est
            plus facile &agrave; comprendre si vous pensez au mod&egrave;le objet de Java et comment nous
            cr&eacute;ons une relation plusieurs-vers-plusieurs en Java :
        </p><pre class="programlisting">
category.getItems().add(item);          // La cat&eacute;gorie est maintenant "au courant" de la relation
item.getCategories().add(category);     // L'objet est maintenant "au courant" de la relation

session.persist(item);                   // La relation ne sera pas sauvegard&eacute;e !
session.persist(category);               // La relation sera sauvegard&eacute;e</pre><p>
            La partie non-inverse est utilis&eacute;e pour sauvegarder la repr&eacute;sentation en m&eacute;moire dans la base de donn&eacute;es.
        </p><p>
            Vous pouvez d&eacute;finir une association un-vers-plusieurs bidirectionnelle en mappant une
            association un-vers-plusieurs vers la(es) m&ecirc;me(s) colonne(s) de table qu'une association
            plusieurs-vers-un et en d&eacute;clarant l'extr&eacute;mit&eacute; pluri-valu&eacute;e <tt class="literal">inverse="true"</tt>.
        </p><pre class="programlisting">&lt;class name="Parent"&gt;
    &lt;id name="id" column="parent_id"/&gt;
    ....
    &lt;set name="children" inverse="true"&gt;
        &lt;key column="parent_id"/&gt;
        &lt;one-to-many class="Child"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Child"&gt;
    &lt;id name="id" column="child_id"/&gt;
    ....
    &lt;many-to-one name="parent"
        class="Parent"
        column="parent_id"
        not-null="true"/&gt;
&lt;/class&gt;</pre><p>
            Mapper une extr&eacute;mit&eacute; d'une association avec <tt class="literal">inverse="true"</tt> n'affecte
            pas l'op&eacute;ration de cascades, ce sont des concepts orthogonaux !
        </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="collections-indexedbidirectional"></a>6.3.3.&nbsp;Associations bidirectionnelles avec des collections index&eacute;es</h3></div></div><div></div></div><p>
            Une association bidirectionnelle o&ugrave; une extr&eacute;mit&eacute; est repr&eacute;sent&eacute;e comme une <tt class="literal">&lt;list&gt;</tt>
            ou une <tt class="literal">&lt;map&gt;</tt> requiert une consid&eacute;ration sp&eacute;ciale. Si il y a une
            propri&eacute;t&eacute; de la classe enfant qui mappe la colonne de l'index, pas de probl&egrave;me, nous pouvons
            continuer &agrave; utiliser <tt class="literal">inverse="true"</tt> sur le mapping de la collection :
        </p><pre class="programlisting">&lt;class name="Parent"&gt;
    &lt;id name="id" column="parent_id"/&gt;
    ....
    &lt;map name="children" inverse="true"&gt;
        &lt;key column="parent_id"/&gt;
        &lt;map-key column="name"
            type="string"/&gt;
        &lt;one-to-many class="Child"/&gt;
    &lt;/map&gt;
&lt;/class&gt;

&lt;class name="Child"&gt;
    &lt;id name="id" column="child_id"/&gt;
    ....
    &lt;property name="name"
        not-null="true"/&gt;
    &lt;many-to-one name="parent"
        class="Parent"
        column="parent_id"
        not-null="true"/&gt;
&lt;/class&gt;</pre><p>
            Mais, si il n'y a pas de telle prorpri&eacute;t&eacute; sur la classe enfant, nous ne pouvons pas penser
            &agrave; l'association comme vraiment bidirectionnelle (il y a des informations disponibles &agrave; une
            extr&eacute;mit&eacute; de l'association qui ne sont pas disponibles &agrave; l'autre extr&eacute;mit&eacute;). Dans ce cas,
            nous ne pouvons pas mapper la collection <tt class="literal">inverse="true"</tt>. &Agrave; la place, nous
            pourrions utiliser le mapping suivant :
        </p><pre class="programlisting">&lt;class name="Parent"&gt;
    &lt;id name="id" column="parent_id"/&gt;
    ....
    &lt;map name="children"&gt;
        &lt;key column="parent_id"
            not-null="true"/&gt;
        &lt;map-key column="name"
            type="string"/&gt;
        &lt;one-to-many class="Child"/&gt;
    &lt;/map&gt;
&lt;/class&gt;

&lt;class name="Child"&gt;
    &lt;id name="id" column="child_id"/&gt;
    ....
    &lt;many-to-one name="parent"
        class="Parent"
        column="parent_id"
        insert="false"
        update="false"
        not-null="true"/&gt;
&lt;/class&gt;</pre><p>
           Notez que dans ce mapping, l'extr&eacute;mit&eacute; de l'association contenant la collection est responsable
           des mises &agrave; jour de la clef &eacute;trang&egrave;re. &Agrave; faire : cela entra&icirc;ne-t-il r&eacute;ellement des expressions
           updates inutiles ?
       </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="collections-ternary"></a>6.3.4.&nbsp;Associations ternaires</h3></div></div><div></div></div><p>
            Il y a trois approches possibles pour mapper une association ternaire. L'une est d'utiliser
            une <tt class="literal">Map</tt> avec une association en tant qu'index :
        </p><pre class="programlisting">&lt;map name="contracts"&gt;
    &lt;key column="employer_id" not-null="true"/&gt;
    &lt;map-key-many-to-many column="employee_id" class="Employee"/&gt;
    &lt;one-to-many class="Contract"/&gt;
&lt;/map&gt;</pre><pre class="programlisting">&lt;map name="connections"&gt;
    &lt;key column="incoming_node_id"/&gt;
    &lt;map-key-many-to-many column="outgoing_node_id" class="Node"/&gt;
    &lt;many-to-many column="connection_id" class="Connection"/&gt;
&lt;/map&gt;</pre><p>
            Une seconde approche est simplement de remodeler l'association comme une classe d'entit&eacute;. C'est
            l'approche la plus commune.
        </p><p>
            Une alternative finale est d'utiliser des &eacute;l&eacute;ments composites, dont nous discuterons plus tard.
        </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="collections-idbag"></a>6.3.5.&nbsp;Utiliser un <tt class="literal">&lt;idbag&gt;</tt></h3></div></div><div></div></div><p>
            Si vous embrassez pleinement notre vue que les clefs compos&eacute;es sont une mauvaise
            chose et que des entit&eacute;s devraient avoir des identifiants artificiels (des clefs
            subrog&eacute;es), alors vous pourriez trouver un peu curieux que les associations
            plusieurs-vers-plusieurs et les collections de valeurs que nous avons montr&eacute; jusqu'ici
            mappent toutes des tables avec des clefs compos&eacute;es ! Maintenant, ce point est assez
            discutable ; une table d'association pure ne semble pas beaucoup b&eacute;n&eacute;ficier d'une clef
            subrog&eacute;e (bien qu'une collection de valeur compos&eacute;es le <span class="emphasis"><em>pourrait</em></span>).
            N&eacute;anmoins, Hibernate fournit une foncionnalit&eacute; qui vous permet de mapper
            des associations plusieurs-vers-plusieurs et des collections de valeurs vers une
            table avec une clef subrog&eacute;e.
        </p><p>
            L'&eacute;l&eacute;ment <tt class="literal">&lt;idbag&gt;</tt> vous laisse mapper une <tt class="literal">List</tt>
            (ou une <tt class="literal">Collection</tt>) avec une s&eacute;mantique de sac.
        </p><pre class="programlisting">&lt;idbag name="lovers" table="LOVERS"&gt;
    &lt;collection-id column="ID" type="long"&gt;
        &lt;generator class="sequence"/&gt;
    &lt;/collection-id&gt;
    &lt;key column="PERSON1"/&gt;
    &lt;many-to-many column="PERSON2" class="Person" fetch="join"/&gt;
&lt;/idbag&gt;</pre><p>
            Comme vous pouvez voir, un <tt class="literal">&lt;idbag&gt;</tt> a un g&eacute;n&eacute;r&eacute;teur d'id
            artificiel, comme une classe d'entit&eacute; ! Une clef subrog&eacute;e diff&eacute;rente est assign&eacute;e
            &agrave; chaque ligne de la collection. Cependant, Hibernate ne fournit pas de m&eacute;canisme pour
            d&eacute;couvrir la valeur d'une clef subrog&eacute;e d'une ligne particuli&egrave;re.
        </p><p>
            Notez que les performances de la mise &agrave; jour d'un <tt class="literal">&lt;idbag&gt;</tt>
            sont <span class="emphasis"><em>bien</em></span> meilleures qu'un <tt class="literal">&lt;bag&gt;</tt> ordinaire !
            Hibernate peut localiser des lignes individuelles efficacement et les mettre &agrave; jour ou
            les effacer individuellement, comme une liste, une map ou un ensemble.
        </p><p>
            Dans l'impl&eacute;mentation actuelle, la strat&eacute;gie de la g&eacute;n&eacute;ration de l'identifiant <tt class="literal">native</tt>
            n'est pas support&eacute;e pour les identifiants de collection <tt class="literal">&lt;idbag&gt;</tt>.
        </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-example"></a>6.4.&nbsp;Exemples de collections</h2></div></div><div></div></div><p>
            Les sections pr&eacute;c&eacute;dentes sont assez confuses. Donc prenons un exemple. Cette classe :
        </p><pre class="programlisting">package eg;
import java.util.Set;

public class Parent {
    private long id;
    private Set children;

    public long getId() { return id; }
    private void setId(long id) { this.id=id; }

    private Set getChildren() { return children; }
    private void setChildren(Set children) { this.children=children; }

    ....
    ....
}</pre><p>
            a une collection d'instances de <tt class="literal">Child</tt>. Si chaque enfant
            a au plus un parent, le mapping le plus naturel est une association
            un-vers-plusieurs :
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            Ceci mappe les d&eacute;finitions de tables suivantes :
        </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null primary key, name varchar(255), parent_id bigint )
alter table child add constraint childfk0 (parent_id) references parent</pre><p>
            Si le parent est <span class="emphasis"><em>requis</em></span>, utilisez une association un-vers-plusieurs unidirectionnelle :
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" inverse="true"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
        &lt;many-to-one name="parent" class="Parent" column="parent_id" not-null="true"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            Notez la contrainte <tt class="literal">NOT NULL</tt> :
        </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null
                     primary key,
                     name varchar(255),
                     parent_id bigint not null )
alter table child add constraint childfk0 (parent_id) references parent</pre><p>
            Alternativement, si vous insistez absolument pour que cette association soit unidirectionnelle,
            vous pouvez d&eacute;clarer la contrainte <tt class="literal">NOT NULL</tt> sur le mapping <tt class="literal">&lt;key&gt;</tt> :
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children"&gt;
            &lt;key column="parent_id" not-null="true"/&gt;
            &lt;one-to-many class="Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            D'un autre c&ocirc;t&eacute;, si un enfant pouvait avoir plusieurs parent, une association
            plusieurs-vers-plusieurs est plus appropri&eacute;e :
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" table="childset"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;many-to-many class="Child" column="child_id"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            D&eacute;finitions des tables :
        </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null primary key, name varchar(255) )
create table childset ( parent_id bigint not null,
                        child_id bigint not null,
                        primary key ( parent_id, child_id ) )
alter table childset add constraint childsetfk0 (parent_id) references parent
alter table childset add constraint childsetfk1 (child_id) references child</pre><p>
            Pour plus d'exemples et une revue compl&egrave;te du mapping de la relation parent/enfant, voir
            see <a href="#example-parentchild" title="Chapitre&nbsp;21.&nbsp;Exemple : P&egrave;re/Fils">Chapitre&nbsp;21, <i>Exemple : P&egrave;re/Fils</i></a>.
        </p><p>
            Des mappings d'association plus exotiques sont possibles, nous cataloguerons toutes les possibilit&eacute;s
            dans le prochain chapitre.
        </p></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="associations"></a>Chapitre&nbsp;7.&nbsp;Mapper les associations</h2></div></div><div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="assoc-intro"></a>7.1.&nbsp;Introduction</h2></div></div><div></div></div><p>
            Correctement mapper les associations est souvent la t&acirc;che la plus difficile.
            Dans cette section nous traiterons les cas classiques les uns apr&egrave;s les autres.
            Nous commencerons d'abbord par les mappings unidirectionnels, puis nous aborderons
            la question des mappings bidirectionnels. Nous illustrerons tous nos exemples 
            avec les classes <tt class="literal">Person</tt> et <tt class="literal">Address</tt>.
        </p><p>
        	Nous utiliserons deux crit&egrave;res pour classer les associations : le premier 
        	sera de savoir si l'association est b&acirc;ti sur une table suppl&eacute;mentaire d'association
        	et le deuxieme sera bas&eacute; sur la multiplicit&eacute; de cette association.
        </p><p>
        	Autoriser une cl&eacute; &eacute;trang&egrave;re nulle est consid&eacute;r&eacute; comme un mauvais choix dans 
        	la construction d'un mod&egrave;le de donn&eacute;es. Nous supposerons donc que dans tous 
        	les exemples qui vont suivre on aura interdit la valeur nulle pour les cl&eacute;s 
        	&eacute;trang&egrave;res. Attention, ceci ne veut pas dire que Hibernate ne supporte pas 
        	les cl&eacute;s &eacute;trang&egrave;res pouvant prendre des valeurs nulles, les exemples qui suivent 
        	continueront de fonctionner si vous d&eacute;cidiez ne plus imposer la contrainte 
        	de non-nullit&eacute; sur les cl&eacute;s &eacute;trang&egrave;res.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="assoc-unidirectional"></a>7.2.&nbsp;Association unidirectionnelle</h2></div></div><div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-unidirectional-m21"></a>7.2.1.&nbsp;plusieurs &agrave; un</h3></div></div><div></div></div><p>
            Une <span class="emphasis"><em>association plusieurs-&agrave;-un (many-to-one) unidirectionnelle </em></span> 
            est le type que l'on rencontre le plus souvent dans les associations unidirectionnelles.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-unidirectional-121"></a>7.2.2.&nbsp;un &agrave; un</h3></div></div><div></div></div><p>
            une <span class="emphasis"><em>association un-&agrave;-un (one-to-one) sur une cl&eacute; &eacute;trang&egrave;re</em></span>
            est presque identique. La seule diff&eacute;rence est sur la contrainte d'unicit&eacute; que
            l'on impose &agrave; cette colonne.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId" 
        unique="true"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre><p>
            Une <span class="emphasis"><em>association un-&agrave;-un (one-to-one) unidirectionnelle sur une cl&eacute; primaire</em></span>
            utilise un g&eacute;n&eacute;rateur d'identifiant particulier. (Remarquez que nous avons invers&eacute; le sens de cette
            association dans cet exemple.)
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"&gt;person&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    &lt;one-to-one name="person" constrained="true"/&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table Address ( personId bigint not null primary key )
        </pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-unidirectional-12m"></a>7.2.3.&nbsp;un &agrave; plusieurs</h3></div></div><div></div></div><p>
            Une <span class="emphasis"><em>association un-&agrave;-plusieurs (one-to-many) unidirectionnelle sur une 
            cl&eacute; &eacute;trang&egrave;re</em></span> est vraiment inhabituelle, et n'est pas vraiment recommand&eacute;e.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses"&gt;
        &lt;key column="personId" 
            not-null="true"/&gt;
        &lt;one-to-many class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table Address ( addressId bigint not null primary key, personId bigint not null )
        </pre><p>
            Nous pensons qu'il est pr&eacute;f&eacute;rable d'utiliser une table de jointure pour ce type d'association.
        </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="assoc-unidirectional-join"></a>7.3.&nbsp;Associations unidirectionnelles avec tables de jointure</h2></div></div><div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-unidirectional-join-12m"></a>7.3.1.&nbsp;un &agrave; plusieurs</h3></div></div><div></div></div><p>
            Une <span class="emphasis"><em>association unidirectionnelle un-&agrave;-plusieurs (one-to-many) avec
            une table de jointure</em></span> est un bien meilleur choix. 
            Remarquez qu'en sp&eacute;cifiant <tt class="literal">unique="true"</tt>,
            on a chang&eacute; la multiplicit&eacute; plusieurs-&agrave;-plusieurs (many-to-many) pour 
            un-&agrave;-plusieurs (one-to-many).
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses" table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            unique="true"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId not null, addressId bigint not null primary key )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-unidirectional-join-m21"></a>7.3.2.&nbsp;plusieurs &agrave; un</h3></div></div><div></div></div><p>
            Une <span class="emphasis"><em>assiociation plusieurs-&agrave;-un (many-to-one) unidirectionnelle sur
            une table de jointure</em></span> est tr&egrave;s fr&eacute;quente quand l'association est optionnelle.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"&gt;
        &lt;key column="personId" unique="true"/&gt;
        &lt;many-to-one name="address"
            column="addressId" 
            not-null="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null primary key, addressId bigint not null )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-unidirectional-join-121"></a>7.3.3.&nbsp;un &agrave; un</h3></div></div><div></div></div><p>
            Une <span class="emphasis"><em>association unidirectionnelle un-&agrave;-un (one-to-one) sur une table
            de jointure</em></span> est extr&egrave;mement rare mais envisageable.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"&gt;
        &lt;key column="personId" 
            unique="true"/&gt;
        &lt;many-to-one name="address"
            column="addressId" 
            not-null="true"
            unique="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-unidirectional-join-m2m"></a>7.3.4.&nbsp;plusieurs &agrave; plusieurs</h3></div></div><div></div></div><p>
            Finallement, nous avons <span class="emphasis"><em>l'association unidirectionnelle plusieurs-&agrave;-plusieurs (many-to-many)</em></span>.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses" table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null, addressId bigint not null, primary key (personId, addressId) )
create table Address ( addressId bigint not null primary key )
        </pre></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="assoc-bidirectional"></a>7.4.&nbsp;Associations bidirectionnelles</h2></div></div><div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-bidirectional-m21"></a>7.4.1.&nbsp;un &agrave; plusieurs / plusieurs &agrave; un</h3></div></div><div></div></div><p>
            Une <span class="emphasis"><em>association bidirectionnelle plusieurs &agrave; un (many-to-one)</em></span>  
            est le type d'association que l'on rencontre le plus souvent. (c'est la fa&ccedil;on standard de cr&eacute;er
            des relations parents/enfants.)
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="people" inverse="true"&gt;
        &lt;key column="addressId"/&gt;
        &lt;one-to-many class="Person"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null )
create table Address ( addressId bigint not null primary key )
        </pre><p>
            Si vous utilisez une <tt class="literal">List</tt> (ou toute autre collection index&eacute;e) vous devez
            param&eacute;trer la colonne <tt class="literal">key</tt> de la cl&eacute; &eacute;trang&egrave;re &agrave; <tt class="literal">not null</tt>,
            et laisser Hibernate g&eacute;rer l'association depuis l'extr&eacute;mit&eacute; collection pour maintenir l'index
            de chaque &eacute;l&eacute;ment (rendant l'autre extr&eacute;mit&eacute; virtuellement inverse en param&eacute;trant
            <tt class="literal">update="false"</tt> et <tt class="literal">insert="false"</tt>):
        </p><pre class="programlisting">&lt;class name="Person"&gt;
   &lt;id name="id"/&gt;
   ...
   &lt;many-to-one name="address"
      column="addressId"
      not-null="true"
      insert="false"
      update="false"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
   &lt;id name="id"/&gt;
   ...
   &lt;list name="people"&gt;
      &lt;key column="addressId" not-null="true"/&gt;
      &lt;list-index column="peopleIdx"/&gt;
      &lt;one-to-many class="Person"/&gt;
   &lt;/list&gt;
&lt;/class&gt;</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-bidirectional-121"></a>7.4.2.&nbsp;Un &agrave; un</h3></div></div><div></div></div><p>
            Une <span class="emphasis"><em>association bidirectionnelle un &agrave; un (one-to-one) sur une cl&eacute; &eacute;trang&egrave;re</em></span>
            est aussi tr&egrave;s fr&eacute;quente.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId" 
        unique="true"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
   &lt;one-to-one name="person" 
        property-ref="address"/&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre><p>
            Une <span class="emphasis"><em>association bidirectionnelle un-&agrave;-un (one-to-one) sur une cl&eacute; primaire</em></span>
            utilise un g&eacute;n&eacute;rateur particulier d'id.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;one-to-one name="address"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"&gt;person&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    &lt;one-to-one name="person" 
        constrained="true"/&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table Address ( personId bigint not null primary key )
        </pre></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="assoc-bidirectional-join"></a>7.5.&nbsp;Associations bidirectionnelles avec table de jointure</h2></div></div><div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-bidirectional-join-12m"></a>7.5.1.&nbsp;un &agrave; plusieurs / plusieurs &agrave; un</h3></div></div><div></div></div><p>
            Une <span class="emphasis"><em>association bidirectionnelle un-&agrave;-plusieurs (one-to-many) sur une table de jointure </em></span>.
            Remarquez que <tt class="literal">inverse="true"</tt> peut s'appliquer sur les deux extr&eacute;mit&eacute;s de l'
            association, sur la collection, ou sur la jointure.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses" 
        table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            unique="true"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        inverse="true" 
        optional="true"&gt;
        &lt;key column="addressId"/&gt;
        &lt;many-to-one name="person"
            column="personId"
            not-null="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null, addressId bigint not null primary key )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-bidirectional-join-121"></a>7.5.2.&nbsp;Un &agrave; un</h3></div></div><div></div></div><p>
            Une <span class="emphasis"><em>association bidirectionnelle un-&agrave;-un (one-to-one) sur une table de jointure</em></span> 
            est extr&egrave;mement rare mais envisageable.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"&gt;
        &lt;key column="personId" 
            unique="true"/&gt;
        &lt;many-to-one name="address"
            column="addressId" 
            not-null="true"
            unique="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"
        inverse="true"&gt;
        &lt;key column="addressId" 
            unique="true"/&gt;
        &lt;many-to-one name="person"
            column="personId" 
            not-null="true"
            unique="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-bidirectional-join-m2m"></a>7.5.3.&nbsp;plusieurs &agrave; plusieurs</h3></div></div><div></div></div><p>
            Finallement nous avons <span class="emphasis"><em>l'association bidirectionnelle plusieurs &agrave; plusieurs</em></span>.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses" table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="people" inverse="true"  table="PersonAddress"&gt;
        &lt;key column="addressId"/&gt;
        &lt;many-to-many column="personId"
            class="Person"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null, addressId bigint not null, primary key (personId, addressId) )
create table Address ( addressId bigint not null primary key )
        </pre></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="assoc-complex"></a>7.6.&nbsp;Des mappings plus complexes</h2></div></div><div></div></div><p>
            Des associations encore plus complexes sont <span class="emphasis"><em>extr&ecirc;mement</em></span> rares. 
            Hibernate permet de g&eacute;rer des situations plus complexes en utilisant des
            parties SQL dans les fichiers de mapping. Par exemple, si une table
            avec l'historiques des informations d'un compte d&eacute;finit les colonnes
            <tt class="literal">accountNumber</tt>, <tt class="literal">effectiveEndDate</tt> 
            et <tt class="literal">effectiveStartDate</tt>, mapp&eacute;es de telle sorte:
        </p><pre class="programlisting">&lt;properties name="currentAccountKey"&gt;
    &lt;property name="accountNumber" type="string" not-null="true"/&gt;
    &lt;property name="currentAccount" type="boolean"&gt;
        &lt;formula&gt;case when effectiveEndDate is null then 1 else 0 end&lt;/formula&gt;
    &lt;/property&gt;
&lt;/properties&gt;
&lt;property name="effectiveEndDate" type="date"/&gt;
&lt;property name="effectiveStateDate" type="date" not-null="true"/&gt;</pre><p>
            alors nous pouvons mapper une association &agrave; l'instance <span class="emphasis"><em>courante</em></span>  
            (celle avec une <tt class="literal">effectiveEndDate</tt>) nulle en utilisant:
        </p><pre class="programlisting">&lt;many-to-one name="currentAccountInfo" 
        property-ref="currentAccountKey"
        class="AccountInfo"&gt;
    &lt;column name="accountNumber"/&gt;
    &lt;formula&gt;'1'&lt;/formula&gt;
&lt;/many-to-one&gt;</pre><p>
            Dans un exemple plus complexe, imaginez qu'une association entre
            <tt class="literal">Employee</tt> et <tt class="literal">Organization</tt> est g&eacute;r&eacute;e
            dans une table <tt class="literal">Employment</tt> pleines de donn&eacute;es historiques.
            Dans ce cas, une association vers l'employeur <span class="emphasis"><em>le plus r&eacute;cent</em></span>
            (celui avec la <tt class="literal">startDate</tt> la plus r&eacute;cente) pourrait &ecirc;tre mapp&eacute;e comme cela:
        </p><pre class="programlisting">&lt;join&gt;
    &lt;key column="employeeId"/&gt;
    &lt;subselect&gt;
        select employeeId, orgId 
        from Employments 
        group by orgId 
        having startDate = max(startDate)
    &lt;/subselect&gt;
    &lt;many-to-one name="mostRecentEmployer" 
            class="Organization" 
            column="orgId"/&gt;
&lt;/join&gt;</pre><p>
            Vous pouvez &ecirc;tre cr&eacute;atif grace &agrave; ces possibilit&eacute;s, mais il est g&eacute;n&eacute;ralement plus pratique
            d'utiliser des requ&ecirc;tes HQL ou criteria dans ce genre de situation.
        </p></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="components"></a>Chapitre&nbsp;8.&nbsp;Mapping de composants</h2></div></div><div></div></div><p>
        La notion de <span class="emphasis"><em>composants</em></span> est r&eacute;utilis&eacute; dans diff&eacute;rents contextes,
        avec diff&eacute;rents objectifs, &agrave; travers Hibernate.
    </p><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-dependentobjects"></a>8.1.&nbsp;Objects d&eacute;pendants</h2></div></div><div></div></div><p>
            Le composant est un objet inclu dans un autre qui est sauvegard&eacute; comme une valeur, et
            non pas comme une entit&eacute;.
            Le composant fait r&eacute;f&eacute;rence &agrave; la notion (au sens objet) de composition
            (et non pas de composant au sens d'architecture de composants).
            Par exemple on pourrait mod&eacute;lis&eacute; l'objet personne de cette fa&ccedil;on:
        </p><pre class="programlisting">public class Person {
    private java.util.Date birthday;
    private Name name;
    private String key;
    public String getKey() {
        return key;
    }
    private void setKey(String key) {
        this.key=key;
    }
    public java.util.Date getBirthday() {
        return birthday;
    }
    public void setBirthday(java.util.Date birthday) {
        this.birthday = birthday;
    }
    public Name getName() {
        return name;
    }
    public void setName(Name name) {
        this.name = name;
    }
    ......
    ......
}</pre><pre class="programlisting">public class Name {
    char initial;
    String first;
    String last;
    public String getFirst() {
        return first;
    }
    void setFirst(String first) {
        this.first = first;
    }
    public String getLast() {
        return last;
    }
    void setLast(String last) {
        this.last = last;
    }
    public char getInitial() {
        return initial;
    }
    void setInitial(char initial) {
        this.initial = initial;
    }
}</pre><p>
            Maintenant <tt class="literal">Name</tt> peut-&ecirc;tre sauvegard&eacute; comme un composant de 
            <tt class="literal">Person</tt>. Remarquer que <tt class="literal">Name</tt> d&eacute;finit des methodes 
            d'acc&egrave;s et de modification pour ses propri&eacute;t&eacute;s persistantes, mais il n'a pas besoin 
            des interfaces ou des propri&eacute;t&eacute;s d'identification ( par exemple getId() ) qui sont propres aux entit&eacute;s.
        </p><p>
            Nous serions alors amen&eacute; &agrave; mapper ce composant de cette fa&ccedil;on:
        </p><pre class="programlisting">&lt;class name="eg.Person" table="person"&gt;
    &lt;id name="Key" column="pid" type="string"&gt;
        &lt;generator class="uuid"/&gt;
    &lt;/id&gt;
    &lt;property name="birthday" type="date"/&gt;
    &lt;component name="Name" class="eg.Name"&gt; &lt;!-- class attribute optional --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/component&gt;
&lt;/class&gt;</pre><p>
            La table person aurai les colonnes <tt class="literal">pid</tt>,
            <tt class="literal">birthday</tt>,
            <tt class="literal">initial</tt>,
            <tt class="literal">first</tt> and
            <tt class="literal">last</tt>.
        </p><p>
            Comme tous les types valeurs, les composants ne supportent pas les r&eacute;f&eacute;rences partag&eacute;s.
            En d'autres mots, deux instances de person peuvent avoir un m&ecirc;me nom, mais ces noms sont
			ind&eacute;pendants, ils peuvent &ecirc;tre identiques si on les compare par valeur mais ils repr&eacute;sentent
			deux objets distincts en m&eacute;moire. La notion de nullit&eacute; pour un composant est 
            <span class="emphasis"><em>ad hoc</em></span>. Quand il recharge l'objet qui contient le composant, Hibernate 
            supposera que si tous les champs du composants sont nuls alors le composant sera positionn&eacute; 
            &agrave; la valeur null. Ce choix programmatif devrait &ecirc;tre satisfaisant dans la plupart des cas.
        </p><p>
            Les propri&eacute;t&eacute;s d'un composant peuvent &ecirc;tre de tous les types qu'Hibernate supporte habituellement
            (collections, many-to-one associations, autres composants, etc). Les composants inclus ne doivent <span class="emphasis"><em>pas</em></span> 
            &ecirc;tre vus comme quelque chose d'exotique. Hibernate a &eacute;t&eacute; con&ccedil;u pour supporter un mod&egrave;le objet tr&egrave;s granulaire.
        </p><p>
            Le  <tt class="literal">&lt;component&gt;</tt> peut inclure dans la liste de ses propri&eacute;t&eacute;s
            une r&eacute;f&eacute;rence au <tt class="literal">&lt;parent&gt;</tt> conteneur.
        </p><pre class="programlisting">&lt;class name="eg.Person" table="person"&gt;
    &lt;id name="Key" column="pid" type="string"&gt;
        &lt;generator class="uuid"/&gt;
    &lt;/id&gt;
    &lt;property name="birthday" type="date"/&gt;
    &lt;component name="Name" class="eg.Name" unique="true"&gt;
        &lt;parent name="namedPerson"/&gt; &lt;!-- r&eacute;f&eacute;rence arri&egrave;re &agrave; Person --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/component&gt;
&lt;/class&gt;</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-incollections"></a>8.2.&nbsp;Collection d'objets d&eacute;pendants</h2></div></div><div></div></div><p>
            Les collections d'objets d&eacute;pendants sont support&eacute;s (exemple: un tableau de type 
            <tt class="literal">Name</tt>). D&eacute;clarer la collection de composants en rempla&ccedil;ant le tag <tt class="literal">&lt;element&gt;</tt> 
            par le tag <tt class="literal">&lt;composite-element&gt;</tt>.
        </p><pre class="programlisting">&lt;set name="someNames" table="some_names" lazy="true"&gt;
    &lt;key column="id"/&gt;
    &lt;composite-element class="eg.Name"&gt; &lt;!-- class attribute required --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/composite-element&gt;
&lt;/set&gt;</pre><p>
            Remarque: Si vous d&eacute;finissez un <tt class="literal">Set</tt> d'&eacute;l&eacute;ment composite,
            il est tr&egrave;s important d'impl&eacute;menter la m&eacute;thode <tt class="literal">equals()</tt> et 
            <tt class="literal">hashCode()</tt> correctement.
        </p><p>
            Les &eacute;lements composite peuvent aussi contenir des composants mais pas des collections.
            Si votre &eacute;l&eacute;ment composite contient aussi des composants, utilisez l'&eacute;l&eacute;ment <tt class="literal">&lt;nested-composite-element&gt;</tt> 
            . Une collections de composants qui ccontiennent eux-m&ecirc;mes des composants est un cas tr&egrave;s exotique.
            A ce stade demandez-vous si une association un-&agrave;-plusieurs ne serait pas plus appropri&eacute;.
            Essayez de re remodeler votre &eacute;l&eacute;ment composite comme une entit&eacute; ( Dans ce cas m&ecirc;me si le mod&egrave;le
            Java est le m&ecirc;me la logique de persitence et de relation sont tout de m&ecirc;me diff&eacute;rentes)
        </p><p>
            Remarque, le mapping d'&eacute;l&eacute;ments composites ne supporte pas la nullit&eacute; des 
            propri&eacute;t&eacute;s lorsqu'on utilise un <tt class="literal">&lt;set&gt;</tt>. Hibernate
            lorsqu'il supprime un objet utilise chaque colonne pour identifier un objet
            (on ne peut pas utiliser des cl&eacute;s primaires distinctes dans une table d'&eacute;l&eacute;ments composites),
            ce qui n'est pas possible avec des valeurs nulles. Vous devez donc choisir d'interdire la nullit&eacute;
            des propri&eacute;t&eacute;s d'un &eacute;l&eacute;ment composite ou choisir un autre type de collection comme :
            <tt class="literal">&lt;list&gt;</tt>, <tt class="literal">&lt;map&gt;</tt>,
            <tt class="literal">&lt;bag&gt;</tt> ou <tt class="literal">&lt;idbag&gt;</tt>.
        </p><p>
            Un cas particulier d'&eacute;l&eacute;ment composite est un &eacute;l&eacute;ment composite qui inclut un &eacute;l&eacute;ment
            <tt class="literal">&lt;many-to-one&gt;</tt>. Un mapping comme celui-ci 
            vous permet d'associer les colonnes d'une table d'association plusieurs &agrave; plusieurs (many-to-many)
            &agrave; la classse de l'&eacute;l&eacute;ment composite. L'exemple suivant est une association plusieurs &agrave; plusieurs
            de <tt class="literal">Order</tt> &agrave; <tt class="literal">Item</tt> &agrave; 
            <tt class="literal">purchaseDate</tt>, <tt class="literal">price</tt> et
            <tt class="literal">quantity</tt> sont des propri&eacute;t&eacute;s de l'association.
        </p><pre class="programlisting">&lt;class name="eg.Order" .... &gt;
    ....
    &lt;set name="purchasedItems" table="purchase_items" lazy="true"&gt;
        &lt;key column="order_id"&gt;
        &lt;composite-element class="eg.Purchase"&gt;
            &lt;property name="purchaseDate"/&gt;
            &lt;property name="price"/&gt;
            &lt;property name="quantity"/&gt;
            &lt;many-to-one name="item" class="eg.Item"/&gt; &lt;!-- class attribute is optional --&gt;
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
            Bien s&ucirc;r, il ne peut pas y avoir de r&eacute;f&eacute;rence &agrave; l'achat (purchase) depuis l'article (item), pour 
            pouvoir naviguer de fa&ccedil;on bidirectionnelle dans l'association. N'oubliez pas que les composants 
            sont de type valeurs et n'autorise pas les r&eacute;f&eacute;rences partag&eacute;es. 
        </p><p>M&ecirc;me les associations ternaires ou quaternaires sont possibles:</p><pre class="programlisting">&lt;class name="eg.Order" .... &gt;
    ....
    &lt;set name="purchasedItems" table="purchase_items" lazy="true"&gt;
        &lt;key column="order_id"&gt;
        &lt;composite-element class="eg.OrderLine"&gt;
            &lt;many-to-one name="purchaseDetails class="eg.Purchase"/&gt;
            &lt;many-to-one name="item" class="eg.Item"/&gt;
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
            Les &eacute;l&eacute;ments composites peuvent appara&icirc;tre dans les requ&ecirc;tes en utilisant
            la m&ecirc;me syntaxe que associations
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-asmapindex"></a>8.3.&nbsp;Utiliser les composants comme index de map</h2></div></div><div></div></div><p>
            l'&eacute;l&eacute;ment <tt class="literal">&lt;composite-map-key&gt;</tt> 
            vous permet d'utiliser une classe de composant comme indice de 
            <tt class="literal">Map</tt>. Assurez-vous d'avoir surd&eacute;fini 
            <tt class="literal">hashCode()</tt> et <tt class="literal">equals()</tt> dans la 
            classe du composant.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-compositeid"></a>8.4.&nbsp;Utiliser un composant comme identifiant</h2></div></div><div></div></div><p>
            Vous pouvez utiliser un composant comme identifiant d'une entit&eacute;.
            Mais pour cela la classe du composant doit respecter certaines r&egrave;gles.
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Elle doit impl&eacute;menter <tt class="literal">java.io.Serializable</tt>.
                </p></li><li><p>
                    Elle doit red&eacute;finir <tt class="literal">equals()</tt> et
                    <tt class="literal">hashCode()</tt>, de fa&ccedil;on coh&eacute;rente avec le 
                    fait qu'elle d&eacute;finit une cl&eacute; composite dans la base de 
                    donn&eacute;es.
                </p></li></ul></div><p>
            <span class="emphasis"><em>
            Remarque: avec hibernate3, la seconde r&egrave;gle n'est plus absolument 
            necessaire mais fa&icirc;tes le quand m&ecirc;me.</em></span>
        </p><p>
        	Vous ne pouvez pas utiliser de <tt class="literal">IdentifierGenerator</tt> pour g&eacute;n&eacute;rer 
        	une cl&eacute; composite, l'application devra d&eacute;finir elle m&ecirc;me ses propres identifiants.
        </p><p>
            Utiliser l'&eacute;l&eacute;ment <tt class="literal">&lt;composite-id&gt;</tt>  (en incluant l'&eacute;l&eacute;ment 
            <tt class="literal">&lt;key-property&gt;</tt>) &agrave; la place de l'habituel d&eacute;claration 
            <tt class="literal">&lt;id&gt;</tt>. Par exemple la classe
            <tt class="literal">OrderLine</tt> qui d&eacute;pend de la cl&eacute; primaire 
             (composite) de  <tt class="literal">Order</tt>.
        </p><pre class="programlisting">&lt;class name="OrderLine"&gt;
    
    &lt;composite-id name="id" class="OrderLineId"&gt;
        &lt;key-property name="lineId"/&gt;
        &lt;key-property name="orderId"/&gt;
        &lt;key-property name="customerId"/&gt;
    &lt;/composite-id&gt;
    
    &lt;property name="name"/&gt;
    
    &lt;many-to-one name="order" class="Order"
            insert="false" update="false"&gt;
        &lt;column name="orderId"/&gt;
        &lt;column name="customerId"/&gt;
    &lt;/many-to-one&gt;
    ....
    
&lt;/class&gt;</pre><p>
            Maintenant toutes cl&eacute;s &eacute;trang&egrave;res r&eacute;f&eacute;ren&ccedil;ant la table <tt class="literal">OrderLine</tt> 
            devra aussi &ecirc;tre composite. Vous devez en tenir compte lorsque vous &eacute;crivez vos mapping d'association pour les autres classes.
            Une association &agrave; <tt class="literal">OrderLine</tt> devrait &ecirc;tre mapp&eacute; de la fa&ccedil;on suivante :
        </p><pre class="programlisting">&lt;many-to-one name="orderLine" class="OrderLine"&gt;
&lt;!-- the "class" attribute is optional, as usual --&gt;
    &lt;column name="lineId"/&gt;
    &lt;column name="orderId"/&gt;
    &lt;column name="customerId"/&gt;
&lt;/many-to-one&gt;</pre><p>
            (Remarque: l'&eacute;l&eacute;ment <tt class="literal">&lt;column&gt;</tt> est une alternative &agrave; l'attribut 
            <tt class="literal">column</tt> que l'on utilise partout.) 
        </p><p>
            Une association <tt class="literal">plusieurs-&agrave;-plusieurs</tt> (many-to-many) &agrave; <tt class="literal">OrderLine</tt> 
            utilisera aussi une cl&eacute; &eacute;trang&egrave;re composite:
        </p><pre class="programlisting">&lt;set name="undeliveredOrderLines"&gt;
    &lt;key column name="warehouseId"/&gt;
    &lt;many-to-many class="OrderLine"&gt;
        &lt;column name="lineId"/&gt;
        &lt;column name="orderId"/&gt;
        &lt;column name="customerId"/&gt;
    &lt;/many-to-many&gt;
&lt;/set&gt;</pre><p>
            La collection des <tt class="literal">OrderLine</tt>s dans <tt class="literal">Order</tt>
            utilisera:
        </p><pre class="programlisting">&lt;set name="orderLines" inverse="true"&gt;
    &lt;key&gt;
        &lt;column name="orderId"/&gt;
        &lt;column name="customerId"/&gt;
    &lt;/key&gt;
    &lt;one-to-many class="OrderLine"/&gt;
&lt;/set&gt;</pre><p>
            (L'&eacute;l&eacute;ment <tt class="literal">&lt;one-to-many&gt;</tt>, comme d'habitude, ne d&eacute;clare pas de colonne.)
        </p><p>
            Si <tt class="literal">OrderLine</tt> lui-m&ecirc;me poss&egrave;de une collection, celle-ci aura aussi 
            une cl&eacute; composite &eacute;trang&egrave;re.
        </p><pre class="programlisting">&lt;class name="OrderLine"&gt;
    ....
    ....
    &lt;list name="deliveryAttempts"&gt;
        &lt;key&gt;   &lt;!-- a collection inherits the composite key type --&gt;
            &lt;column name="lineId"/&gt;
            &lt;column name="orderId"/&gt;
            &lt;column name="customerId"/&gt;
        &lt;/key&gt;
        &lt;list-index column="attemptId" base="1"/&gt;
        &lt;composite-element class="DeliveryAttempt"&gt;
            ...
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-dynamic"></a>8.5.&nbsp;Composant Dynamique</h2></div></div><div></div></div><p>
            Vous pouvez m&ecirc;me mapper une propri&eacute;t&eacute; de type <tt class="literal">Map</tt>:
        </p><pre class="programlisting">&lt;dynamic-component name="userAttributes"&gt;
    &lt;property name="foo" column="FOO"/&gt;
    &lt;property name="bar" column="BAR"/&gt;
    &lt;many-to-one name="baz" class="Baz" column="BAZ_ID"/&gt;
&lt;/dynamic-component&gt;</pre><p>
            La s&eacute;mantique de l'association &agrave; un <tt class="literal">&lt;dynamic-component&gt;</tt>
            est identique &agrave; celle que l'on utilise pour les composants.
            L'avantage de ce type de mapping est qu'il pemet de d&eacute;terminer les v&eacute;ritables propri&eacute;t&eacute;s 
            du bean au moment su d&eacute;ploiement en &eacute;ditant simplement le document de mapping.
            La manipulation du document de mapping pendant l'execution de l'application est aussi 
            possible en utilisant un parser DOM. Il ya m&ecirc;me mieux, vous pouvez acc&eacute;der (et changer)
            le metamodel de configuration d'hibernate en utilisant l'objet <tt class="literal">Configuration</tt>            
        </p></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="inheritance"></a>Chapitre&nbsp;9.&nbsp;Mapping d'h&eacute;ritage de classe</h2></div></div><div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="inheritance-strategies"></a>9.1.&nbsp;Les trois strat&eacute;gies</h2></div></div><div></div></div><p>
            Hibernate supporte les trois strat&eacute;gies d'h&eacute;ritage de base :
        </p><div class="itemizedlist"><ul type="disc"><li><p>
            une table par hi&eacute;rarchie de classe (table per class hierarchy)
        </p></li><li><p>
            une table par classe fille (table per subclass)
        </p></li><li><p>
            une table par classe concr&egrave;te (table per concrete class)
        </p></li></ul></div><p>
            Hibernate supporte en plus une quatri&egrave;mestrat&eacute;gie, l&eacute;g&egrave;rement diff&eacute;rente, qui supporte le polymorphisme :
        </p><div class="itemizedlist"><ul type="disc"><li><p>
            le polymorphisme implicite
        </p></li></ul></div><p>
            Il est possible d'utiliser diff&eacute;rentes strat&eacute;gies de mapping pour diff&eacute;rentes branches d'une m&ecirc;me
            hi&eacute;rarchie d'h&eacute;ritage, et alors d'employer le polymorphisme implicite pour r&eacute;aliser le
            polymorphisme &agrave; travers toute la hi&eacute;rarchie. Pourtant, Hibernate ne supporte pas de m&eacute;langer
            des mappings <tt class="literal">&lt;subclass&gt;</tt> et
            <tt class="literal">&lt;joined-subclass&gt;</tt> et <tt class="literal">&lt;union-subclass&gt;</tt>
            pour le m&ecirc;me &eacute;l&eacute;ment <tt class="literal">&lt;class&gt;</tt> racine.
            Il est possible de m&eacute;langer ensemble les strat&eacute;gies d'une table par hi&eacute;rarchie et d'une
            table par sous-classe, pour le m&ecirc;me &eacute;l&eacute;ment <tt class="literal">&lt;class&gt;</tt>, en combinant
            les &eacute;l&eacute;ments <tt class="literal">&lt;subclass&gt;</tt> et <tt class="literal">&lt;join&gt;</tt> (voir dessous).
        </p><p>
            Il est possible de d&eacute;finir des mappings de <tt class="literal">subclass</tt>, <tt class="literal">union-subclass</tt>,
            et <tt class="literal">joined-subclass</tt> dans des documents de mapping s&eacute;par&eacute;s, directement sous
            <tt class="literal">hibernate-mapping</tt>. Ceci vous permet d'&eacute;tendre une hi&eacute;rarchie de classe juste en
            ajoutant un nouveau fichier de mapping. Vous devez sp&eacute;cifier un attribut <tt class="literal">extends</tt>
            dans le mapping de la sous-classe, en nommant une super-classe pr&eacute;c&eacute;demment mapp&eacute;e. Note :
            pr&eacute;c&eacute;demment cette foncionnalit&eacute; rendait l'ordre des documents de mapping important. Depuis
            Hibernate3, l'ordre des fichier de mapping n'importe plus lors de l'utilisation du mot-clef "extends".
            L'ordre &agrave; l'int&eacute;rieur d'un simple fichier de mapping impose encore de d&eacute;finir les classes m&egrave;res
            avant les classes filles.
         </p><pre class="programlisting">
 &lt;hibernate-mapping&gt;
     &lt;subclass name="DomesticCat" extends="Cat" discriminator-value="D"&gt;
          &lt;property name="name" type="string"/&gt;
     &lt;/subclass&gt;
 &lt;/hibernate-mapping&gt;</pre><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-tableperclass"></a>9.1.1.&nbsp;Une table par hi&eacute;rarchie de classe</h3></div></div><div></div></div><p>
            Supposons que nous ayons une interface <tt class="literal">Payment</tt>, impl&eacute;ment&eacute;e
            par <tt class="literal">CreditCardPayment</tt>, <tt class="literal">CashPayment</tt>,
            <tt class="literal">ChequePayment</tt>. La strat&eacute;gie une table par hi&eacute;rarchie serait :
        </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        &lt;property name="creditCardType" column="CCTYPE"/&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        ...
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
            Une seule table est requise. Une grande limitation de cette
            strat&eacute;gie est que les colonnes d&eacute;clar&eacute;es par les classes filles, telles que <tt class="literal">CCTYPE</tt>,
            ne peuvent avoir de contrainte <tt class="literal">NOT NULL</tt>.
        </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-tablepersubclass"></a>9.1.2.&nbsp;Une table par classe fille</h3></div></div><div></div></div><p>
            La strat&eacute;gie une table par classe fille serait :
        </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;joined-subclass name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="creditCardType" column="CCTYPE"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
&lt;/class&gt;</pre><p>
            Quatre tables sont requises. Les trois tables des classes filles ont
            une cl&eacute; primaire associ&eacute;e &agrave; la table classe m&egrave;re (le mod&egrave;le relationnel
            est une association un-vers-un).
        </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-tablepersubclass-discriminator"></a>9.1.3.&nbsp;Une table par classe fille, en utilisant un discriminant</h3></div></div><div></div></div><p>
            Notez que l'impl&eacute;mentation Hibernate de la strat&eacute;gie un table par
            classe fille ne n&eacute;cessite pas de colonne discriminante dans la table
            classe m&egrave;re. D'autres impl&eacute;mentations de mappers Objet/Relationnel utilisent
            une autre impl&eacute;mentation de la strat&eacute;gie une table par classe fille qui n&eacute;cessite
            une colonne de type discriminant dans la table de la classe m&egrave;re. L'approche
            prise par Hibernate est plus difficile &agrave; impl&eacute;menter mais plus correcte
        d'une point de vue relationnel. Si vous aimeriez utiliser
            une colonne discriminante avec la strat&eacute;gie d'une table par classe fille, vous pourriez combiner
            l'utilisation de <tt class="literal">&lt;subclass&gt;</tt> et
            <tt class="literal">&lt;join&gt;</tt>, comme suit :
        </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        &lt;join table="CREDIT_PAYMENT"&gt;
            &lt;key column="PAYMENT_ID"/&gt;
            &lt;property name="creditCardType" column="CCTYPE"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        &lt;join table="CASH_PAYMENT"&gt;
            &lt;key column="PAYMENT_ID"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        &lt;join table="CHEQUE_PAYMENT" fetch="select"&gt;
            &lt;key column="PAYMENT_ID"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
            La d&eacute;claration optionnelle <tt class="literal">fetch="select"</tt> indique &agrave; Hibernate
            de ne pas r&eacute;cup&eacute;rer les donn&eacute;es de la classe fille <tt class="literal">ChequePayment</tt> par une jointure externe lors des requ&ecirc;tes sur la classe m&egrave;re.
        </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-mixing-tableperclass-tablepersubclass"></a>9.1.4.&nbsp;M&eacute;lange d'une table par hi&eacute;rarchie de classe avec une table par classe fille</h3></div></div><div></div></div><p>
            Vous pouvez m&ecirc;me m&eacute;langer les strat&eacute;gies d'une table par hi&eacute;rarchie de classe et d'une table par classe fille en utilisant cette approche :
        </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        &lt;join table="CREDIT_PAYMENT"&gt;
            &lt;property name="creditCardType" column="CCTYPE"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        ...
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
            Pour importe laquelle de ces strat&eacute;gies, une association polymorphique vers la classe racine
            <tt class="literal">Payment</tt> est mapp&eacute;e en utilisant <tt class="literal">&lt;many-to-one&gt;</tt>.
        </p><pre class="programlisting">&lt;many-to-one name="payment" column="PAYMENT_ID" class="Payment"/&gt;</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-tableperconcrete"></a>9.1.5.&nbsp;Une table par classe concr&egrave;te</h3></div></div><div></div></div><p>
            Il y a deux mani&egrave;res d'utiliser la strat&eacute;gie d'une table par classe concr&egrave;te. La premi&egrave;re
            est d'employer <tt class="literal">&lt;union-subclass&gt;</tt>.
        </p><pre class="programlisting">&lt;class name="Payment"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="sequence"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;union-subclass name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
        &lt;property name="creditCardType" column="CCTYPE"/&gt;
        ...
    &lt;/union-subclass&gt;
    &lt;union-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        ...
    &lt;/union-subclass&gt;
    &lt;union-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        ...
    &lt;/union-subclass&gt;
&lt;/class&gt;</pre><p>
            Trois tables sont n&eacute;cessaires pour les classes filles. Chaque table d&eacute;finit des colonnes
            pour toutes les propri&eacute;t&eacute;s de la classe, incluant les propri&eacute;t&eacute;s h&eacute;rit&eacute;&eacute;s.
        </p><p>
            La limitation de cette approche est que si une propri&eacute;t&eacute; est mapp&eacute;e sur la classe m&egrave;re, le nom
            de la colonne doit &ecirc;tre le m&ecirc;me pour toutes les classes filles. (Nous pourrions &ecirc;tre plus souple
            dans une future version d'Hibernate).
            La strat&eacute;gie du g&eacute;n&eacute;rateur d'identifiant n'est pas permise dans l'h&eacute;ritage de classes filles par
            union, en effet la valeur (NdT : seed) de la clef primaire
            doit &ecirc;tre partag&eacute;e par toutes les classes filles "union" d'une hi&eacute;rarchie.
        </p><p>
            Si votre classe m&egrave;re est abstraite, mappez la avec <tt class="literal">abstract="true"</tt>.
            Bien s&ucirc;r, si elle n'est pas abstraite, une table suppl&eacute;mentaire (par d&eacute;faut,
            <tt class="literal">PAYMENT</tt> dans l'exemple ci-dessus) est requise pour contenir des instances
            de la classe m&egrave;re.
        </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-tableperconcreate-polymorphism"></a>9.1.6.&nbsp;Une table par classe concr&egrave;te, en utilisant le polymorphisme implicite</h3></div></div><div></div></div><p>
            Une approche alternative est l'emploi du polymorphisme implicite :
        </p><pre class="programlisting">&lt;class name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CREDIT_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CREDIT_AMOUNT"/&gt;
    ...
&lt;/class&gt;

&lt;class name="CashPayment" table="CASH_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CASH_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CASH_AMOUNT"/&gt;
    ...
&lt;/class&gt;

&lt;class name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CHEQUE_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CHEQUE_AMOUNT"/&gt;
    ...
&lt;/class&gt;</pre><p>
            Notez que nulle part nous ne mentionnons l'interface <tt class="literal">Payment</tt> explicitement.
            Notez aussi que des propri&eacute;t&eacute;s de <tt class="literal">Payment</tt> sont mapp&eacute;es dans
            chaque classe fille. Si vous voulez &eacute;viter des duplications, consid&eacute;rez l'utilisation des
            entit&eacute;s XML (cf. <tt class="literal">[ &lt;!ENTITY allproperties SYSTEM "allproperties.xml"&gt; ]</tt>
            dans la d&eacute;claration du <tt class="literal">DOCTYPE</tt> et <tt class="literal">&amp;allproperties;</tt> dans le mapping).
        </p><p>
            L'inconv&eacute;nient de cette approche est qu'Hibernate ne g&eacute;n&egrave;re pas d'<tt class="literal">UNION</tt>s SQL
            lors de l'ex&eacute;cution des requ&ecirc;tes polymorphiques.
        </p><p>
            Pour cette strat&eacute;gie de mapping, une association polymorphique pour <tt class="literal">Payment</tt>
            est habituellement mapp&eacute;e en utilisant <tt class="literal">&lt;any&gt;</tt>.
        </p><pre class="programlisting">&lt;any name="payment" meta-type="string" id-type="long"&gt;
    &lt;meta-value value="CREDIT" class="CreditCardPayment"/&gt;
    &lt;meta-value value="CASH" class="CashPayment"/&gt;
    &lt;meta-value value="CHEQUE" class="ChequePayment"/&gt;
    &lt;column name="PAYMENT_CLASS"/&gt;
    &lt;column name="PAYMENT_ID"/&gt;
&lt;/any&gt;</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="inheritace-mixingpolymorphism"></a>9.1.7.&nbsp;M&eacute;lange du polymorphisme implicite avec d'autres mappings d'h&eacute;ritage</h3></div></div><div></div></div><p>
            Il y a une chose suppl&eacute;mentaire &agrave; noter &agrave; propos de ce mapping. Puisque les classes filles sont
            chacune mapp&eacute;es avec leur propre &eacute;l&eacute;ment <tt class="literal">&lt;class&gt;</tt> (et puisque
            <tt class="literal">Payment</tt> est juste une interface), chaque classe fille pourrait
            facilement faire partie d'une autre hi&eacute;rarchie
            d'h&eacute;ritage ! (Et vous pouvez encore faire des requ&ecirc;tes polymorphiques pour l'interface <tt class="literal">Payment</tt>).
       </p><pre class="programlisting">&lt;class name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CREDIT_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="CREDIT_CARD" type="string"/&gt;
    &lt;property name="amount" column="CREDIT_AMOUNT"/&gt;
    ...
    &lt;subclass name="MasterCardPayment" discriminator-value="MDC"/&gt;
    &lt;subclass name="VisaPayment" discriminator-value="VISA"/&gt;
&lt;/class&gt;

&lt;class name="NonelectronicTransaction" table="NONELECTRONIC_TXN"&gt;
    &lt;id name="id" type="long" column="TXN_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    ...
    &lt;joined-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="amount" column="CASH_AMOUNT"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="amount" column="CHEQUE_AMOUNT"/&gt;
        ...
    &lt;/joined-subclass&gt;
&lt;/class&gt;</pre><p>
            Encore une fois, nous ne mentionnons pas explicitement <tt class="literal">Payment</tt>.
            Si nous ex&eacute;cutons une requ&ecirc;te sur l'interface <tt class="literal">Payment</tt> - par
            exemple, <tt class="literal">from Payment</tt> - Hibernate retournera
            automatiquement les instances de <tt class="literal">CreditCardPayment</tt>
            (et ses classes filles puisqu'elles impl&eacute;mentent aussi <tt class="literal">Payment</tt>),
            <tt class="literal">CashPayment</tt> et <tt class="literal">ChequePayment</tt> mais pas
            les instances de <tt class="literal">NonelectronicTransaction</tt>.
        </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="inheritance-limitations"></a>9.2.&nbsp;Limitations</h2></div></div><div></div></div><p>
            Il y a certaines limitations &agrave; l'approche du "polymorphisme implicite"
            pour la strat&eacute;gie de mapping d'une table par classe concr&egrave;te.
            Il y a plut&ocirc;t moins de limitations restrictives aux mappings <tt class="literal">&lt;union-subclass&gt;</tt>.
        </p><p>
            La table suivante montre les limitations des mappings d'une table par classe concr&egrave;te, et du polymorphisme implicite, dans Hibernate.
        </p><div class="table"><a name="d0e8670"></a><p class="title"><b>Tableau&nbsp;9.1.&nbsp;Caract&eacute;ristiques du mapping d'h&eacute;ritage</b></p><table summary="Caract&eacute;ristiques du mapping d'h&eacute;ritage" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Strat&eacute;gie d'h&eacute;ritage</th><th align="left">many-to-one polymorphique</th><th align="left">one-to-one polymorphique</th><th align="left">one-to-many polymorphique</th><th align="left">many-to-many polymorphique</th><th align="left"><tt class="literal">load()/get()</tt> polymorphique</th><th align="left">Requ&ecirc;tes polymorphiques</th><th align="left">Jointures polymorphiques</th><th align="left">R&eacute;cup&eacute;ration par jointure externe</th></tr></thead><tbody><tr><td align="left">une table par hi&eacute;rarchie de classe</td><td align="left"><tt class="literal">&lt;many-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-many&gt;</tt></td><td align="left"><tt class="literal">&lt;many-to-many&gt;</tt></td><td align="left"><tt class="literal">s.get(Payment.class, id)</tt></td><td align="left"><tt class="literal">from Payment p</tt></td><td align="left"><tt class="literal">from Order o join o.payment p</tt></td><td align="left"><span class="emphasis"><em>support&eacute;e</em></span></td></tr><tr><td align="left">une table par classe fille</td><td align="left"><tt class="literal">&lt;many-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-many&gt;</tt></td><td align="left"><tt class="literal">&lt;many-to-many&gt;</tt></td><td align="left"><tt class="literal">s.get(Payment.class, id)</tt></td><td align="left"><tt class="literal">from Payment p</tt></td><td align="left"><tt class="literal">from Order o join o.payment p</tt></td><td align="left"><span class="emphasis"><em>support&eacute;e</em></span></td></tr><tr><td align="left">une table par classe concr&egrave;te (union-subclass)</td><td align="left"><tt class="literal">&lt;many-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-many&gt;</tt> (pour <tt class="literal">inverse="true"</tt> seulement)</td><td align="left"><tt class="literal">&lt;many-to-many&gt;</tt></td><td align="left"><tt class="literal">s.get(Payment.class, id)</tt></td><td align="left"><tt class="literal">from Payment p</tt></td><td align="left"><tt class="literal">from Order o join o.payment p</tt></td><td align="left"><span class="emphasis"><em>support&eacute;e</em></span></td></tr><tr><td align="left">une table par classe concr&egrave;te (polymorphisme implicite)</td><td align="left"><tt class="literal">&lt;any&gt;</tt></td><td align="left"><span class="emphasis"><em>non support&eacute;</em></span></td><td align="left"><span class="emphasis"><em>non support&eacute;</em></span></td><td align="left"><tt class="literal">&lt;many-to-any&gt;</tt></td><td align="left"><tt class="literal">s.createCriteria(Payment.class).add( Restrictions.idEq(id) ).uniqueResult()</tt></td><td align="left"><tt class="literal">from Payment p</tt></td><td align="left"><span class="emphasis"><em>non support&eacute;es</em></span></td><td align="left"><span class="emphasis"><em>non support&eacute;e</em></span></td></tr></tbody></table></div></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="objectstate"></a>Chapitre&nbsp;10.&nbsp;Travailler avec des objets</h2></div></div><div></div></div><p>
        Hibernate est une solution de mapping objet/relationnel compl&egrave;te qui ne masque pas
        seulement au d&eacute;velopppeur les d&eacute;tails du syst&egrave;me de gestion de base de donn&eacute;es sous-jacent,
        mais offre aussi <span class="emphasis"><em>la gestion d'&eacute;tat</em></span> des objets. C'est, contrairement
        &agrave; la gestion de <tt class="literal">statements</tt> SQL dans les couches de persistance
        habituelles JDBC/SQL, une vue orient&eacute;e objet tr&egrave;s naturelle de la persistance dans les
        applications Java.
    </p><p>
        En d'autres mots, les d&eacute;veloppeurs d'applications Hibernate devrait toujours
        r&eacute;fl&eacute;chir &agrave; <span class="emphasis"><em>l'&eacute;tat</em></span> de leurs objets, et pas n&eacute;cessairement &agrave;
        l'ex&eacute;cution des expressions SQL. Cette part est prise en charge pas Hibernate et
        seulement importante pour les d&eacute;veloppeurs d'applications lors du r&eacute;glage de la
        performance de leur syst&egrave;me.
    </p><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-overview"></a>10.1.&nbsp;&Eacute;tats des objets Hibernate</h2></div></div><div></div></div><p>
            Hibernate d&eacute;finit et comprend les &eacute;tats suivants :
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <span class="emphasis"><em>&Eacute;ph&eacute;m&egrave;re</em></span> (NdT : transient) - un objet est &eacute;ph&eacute;m&egrave;re s'il a juste
                    &eacute;t&eacute; instanci&eacute; en utilisant l'op&eacute;rateur <tt class="literal">new</tt>. Il n'a aucune
                    repr&eacute;sentation persistante dans la base de donn&eacute;es et aucune valeur d'identifiant
                    n'a &eacute;t&eacute; assign&eacute;e. Les instances &eacute;ph&eacute;m&egrave;res seront d&eacute;truites par le ramasse-miettes
                    si l'application n'en conserve aucune r&eacute;f&eacute;rence. Utilisez la <tt class="literal">Session</tt>
                    d'Hibernate pour rendre un objet persistant (et laisser Hibernate s'occuper des
                    expressions SQL qui ont besoin d'&ecirc;tre ex&eacute;cut&eacute;es pour cette transistion).
                </p></li><li><p>
                    <span class="emphasis"><em>Persistant</em></span> - une instance persistante a une repr&eacute;sentation dans la
                    base de donn&eacute;es et une valeur d'identifiant. Elle pourrait avoir juste &eacute;t&eacute; sauvegard&eacute;e
                    ou charg&eacute;e, pourtant, elle est par d&eacute;finition dans la port&eacute;e d'une <tt class="literal">Session</tt>.
                    Hibernate d&eacute;tectera n'importe quels changements effectu&eacute;s sur un objet dans l'&eacute;tat
                    persistant et synchronisera l'&eacute;tat avec la base de donn&eacute;es lors de la fin l'unit&eacute; de travail.
                    Les d&eacute;veloppeurs n'ex&eacute;cutent pas d'expressions <tt class="literal">UPDATE</tt> ou
                    <tt class="literal">DELETE</tt> manuelles lorsqu'un objet devrait &ecirc;tre rendu &eacute;ph&eacute;m&egrave;re.
                </p></li><li><p>
                    <span class="emphasis"><em>D&eacute;tach&eacute;</em></span> - une instance d&eacute;tach&eacute;e est un objet qui a &eacute;t&eacute; persistant,
                    mais dont sa <tt class="literal">Session</tt> a &eacute;t&eacute; ferm&eacute;e. La r&eacute;f&eacute;rence &agrave; l'objet est
                    encore valide, bien s&ucirc;r, et l'instance d&eacute;tach&eacute;e pourrait m&ecirc;me &ecirc;tre modifi&eacute;e dans cet
                    &eacute;tat. Une instance d&eacute;tach&eacute;e peut &ecirc;tre r&eacute;attach&eacute;e &agrave; une nouvelle <tt class="literal">Session</tt>
                    plus tard dans le temps, la rendant (et toutes les modifications avec) de nouveau persistante.
                    Cette fonctionnalit&eacute; rend possible un mod&egrave;le de programmation pour de longues unit&eacute;s de travail
                    qui requi&egrave;rent un temps de r&eacute;flexion de l'utilisateur. Nous les appelons des <span class="emphasis"><em>conversations</em></span>,
                    c'est-&agrave;-dire une unit&eacute; de travail du point de vue de l'utilisateur.
                </p></li></ul></div><p>
            Nous alons maintenant dicuster des &eacute;tats et des transitions d'&eacute;tat (et des m&eacute;thodes
            d'Hibernate qui d&eacute;clenchent une transition) plus en d&eacute;tails.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-makingpersistent"></a>10.2.&nbsp;Rendre des objets persistants</h2></div></div><div></div></div><p>
            Les instances nouvellement instanci&eacute;es d'une classe persistante sont consid&eacute;r&eacute;es
            <span class="emphasis"><em>&eacute;ph&eacute;m&egrave;res</em></span> par Hibernate. Nous pouvons rendre une instance
            &eacute;ph&eacute;m&egrave;re <span class="emphasis"><em>persistante</em></span> en l'associant avec une session :
        </p><pre class="programlisting">DomesticCat fritz = new DomesticCat();
fritz.setColor(Color.GINGER);
fritz.setSex('M');
fritz.setName("Fritz");
Long generatedId = (Long) sess.save(fritz);</pre><p>
            Si <tt class="literal">Cat</tt> a un identifiant g&eacute;n&eacute;r&eacute;, l'identifiant est g&eacute;n&eacute;r&eacute; et assign&eacute;
            au <tt class="literal">cat</tt> lorsque <tt class="literal">save()</tt> est appel&eacute;e. Si <tt class="literal">Cat</tt>
            a un identifiant <tt class="literal">assigned</tt>, ou une clef compos&eacute;e, l'identifiant
            devrait &ecirc;tre assign&eacute; &agrave; l'instance de <tt class="literal">cat</tt> avant d'appeler <tt class="literal">save()</tt>.
            Vous pouvez aussi utiliser <tt class="literal">persist()</tt> &agrave; la place de<tt class="literal">save()</tt>,
            avec la s&eacute;mantique d&eacute;finie plus t&ocirc;t dans le brouillon d'EJB3.
        </p><p>
            Alternativement, vous pouvez assigner l'identifiant en utilisant une version
            surcharg&eacute;e de <tt class="literal">save()</tt>.
        </p><pre class="programlisting">DomesticCat pk = new DomesticCat();
pk.setColor(Color.TABBY);
pk.setSex('F');
pk.setName("PK");
pk.setKittens( new HashSet() );
pk.addKitten(fritz);
sess.save( pk, new Long(1234) );</pre><p>
            Si l'objet que vous rendez persistant a des objets associ&eacute;s (par exemple,
            la collection <tt class="literal">kittens</tt> dans l'exemple pr&eacute;c&eacute;dent), ces objets
            peuvent &ecirc;tre rendus persistants dans n'importe quel ordre que vous souhaitez
            &agrave; moins que vous ayez une contrainte <tt class="literal">NOT NULL</tt> sur la
            colonne de la clef &eacute;trang&egrave;re. Il n'y a jamais de risque de violer une
            contrainte de clef &eacute;trang&egrave;re. Cependant, vous pourriez violer une contrainte
            <tt class="literal">NOT NULL</tt> si vous appeliez <tt class="literal">save()</tt> sur
            les objets dans le mauvais ordre.
        </p><p>
            Habituellement, vous ne vous pr&eacute;occupez pas de ce d&eacute;tail, puisque vous
            utiliserez tr&egrave;s probablement la fonctionnalit&eacute; de <span class="emphasis"><em>persistance
            transitive</em></span> d'Hibernate pour sauvegarder les objets associ&eacute;s
            automatiquement. Alors, m&ecirc;me les violations de contrainte <tt class="literal">NOT NULL</tt>
            n'ont plus lieu - Hibernate prendra soin de tout. La persistance transitive est
            trait&eacute;e plus loin dans ce chapitre.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-loading"></a>10.3.&nbsp;Chargement d'un objet</h2></div></div><div></div></div><p>
            Les m&eacute;thodes <tt class="literal">load()</tt> de <tt class="literal">Session</tt> vous donnent
            un moyen de r&eacute;cup&eacute;rer une instance persistante si vous connaissez d&eacute;j&agrave; son identifiant.
            <tt class="literal">load()</tt> prend un objet de classe et chargera l'&eacute;tat dans une instance
            nouvellement instanci&eacute;e de cette classe, dans un &eacute;tat persistant.
        </p><pre class="programlisting">Cat fritz = (Cat) sess.load(Cat.class, generatedId);</pre><pre class="programlisting">// vous avez besoin d'envelopper les identiants primitifs
long pkId = 1234;
DomesticCat pk = (DomesticCat) sess.load( Cat.class, new Long(pkId) );</pre><p>
            Alternativement, vous pouvez charger un &eacute;tat dans une instance donn&eacute;e :
        </p><pre class="programlisting">Cat cat = new DomesticCat();
// load pk's state into cat
sess.load( cat, new Long(pkId) );
Set kittens = cat.getKittens();</pre><p>
            Notez que <tt class="literal">load()</tt> l&egrave;vera une exception irr&eacute;cup&eacute;rable s'il
            n'y a pas de ligne correspondante dans la base de donn&eacute;es. Si la classe est mapp&eacute;e
            avec un proxy, <tt class="literal">load()</tt> retourne juste un proxy non initialis&eacute; et
            n'acc&egrave;de en fait pas &agrave; la base de donn&eacute;es jusqu'&agrave; ce que vous invoquiez une
            m&eacute;thode du proxy. Ce comportement est tr&egrave;s utile si vous souhaitez cr&eacute;er
            une association vers un objet sans r&eacute;ellement le charger &agrave; partir de la base de
            donn&eacute;es. Cela permet aussi &agrave; de multiples instances d'&ecirc;tre charg&eacute;es comme un lot
            si <tt class="literal">batch-size</tt> est d&eacute;fini pour le mapping de la classe.
        </p><p>
            Si vous n'&ecirc;tes pas certain qu'une ligne correspondante existe, vous devriez
            utiliser la m&eacute;thode <tt class="literal">get()</tt>, laquelle acc&egrave;de &agrave; la base de
            donn&eacute;es imm&eacute;diatement et retourne null s'il n'y a pas de ligne correspondante.
        </p><pre class="programlisting">Cat cat = (Cat) sess.get(Cat.class, id);
if (cat==null) {
    cat = new Cat();
    sess.save(cat, id);
}
return cat;</pre><p>
            Vous pouvez m&ecirc;me charger un objet en employant un <tt class="literal">SELECT ... FOR UPDATE</tt> SQL,
            en utilisant un <tt class="literal">LockMode</tt>. Voir la documentation de l'API pour plus d'informations.
        </p><pre class="programlisting">Cat cat = (Cat) sess.get(Cat.class, id, LockMode.UPGRADE);</pre><p>
            Notez que n'importe quelles instances associ&eacute;es ou collections contenues
            <span class="emphasis"><em>ne sont pas</em></span> s&eacute;lectionn&eacute;es par <tt class="literal">FOR UPDATE</tt>,
            &agrave; moins que vous ne d&eacute;cidiez de sp&eacute;cifier <tt class="literal">lock</tt> ou <tt class="literal">all</tt>
            en tant que style de cascade pour l'association.
        </p><p>
            Il est possible de re-charger un objet et toutes ses collections &agrave; n'importe quel moment,
            en utilisant la m&eacute;thode <tt class="literal">refresh()</tt>. C'est utile lorsque des "triggers" de
            base de donn&eacute;es sont utilis&eacute;s pour initiliser certains propri&eacute;t&eacute;s de l'objet.
        </p><pre class="programlisting">sess.save(cat);
sess.flush(); //force the SQL INSERT
sess.refresh(cat); //re-read the state (after the trigger executes)</pre><p>
            Une question importante appara&icirc;t g&eacute;n&eacute;ralement &agrave; ce point : combien (NdT : de donn&eacute;es) Hibernate
            charge-t-il de la base de donn&eacute;es et combient de <tt class="literal">SELECT</tt>s utilisera-t-il ?
            Cela d&eacute;pent de la <span class="emphasis"><em>strat&eacute;gie de r&eacute;cup&eacute;ration</em></span> et cela est expliqu&eacute; dans
            <a href="#performance-fetching" title="19.1.&nbsp;Strat&eacute;gies de chargement">Section&nbsp;19.1, &laquo;&nbsp;Strat&eacute;gies de chargement&nbsp;&raquo;</a>.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-querying"></a>10.4.&nbsp;Requ&ecirc;tage</h2></div></div><div></div></div><p>
            Si vous ne connaissez par les identifiants des objets que vous recherchez, vous
            avez besoin d'une requ&ecirc;te. Hibernate supporte un langage de requ&ecirc;tes orient&eacute;es objet
            facile &agrave; utiliser mais puissant. Pour la cr&eacute;ation de requ&ecirc;tes par programmation,
            Hibernate supporte une fonction de requ&ecirc;tage sophistiqu&eacute; Criteria et Example (QBC et QBE).
            Vous pouvez aussi exprimez votre requ&ecirc;te dans le SQL natif de votre base de donn&eacute;es,
            avec un support optionnel d'Hibernate pour la conversion des ensembles de r&eacute;sultats en
            objets.
        </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="objectstate-querying-executing"></a>10.4.1.&nbsp;Ex&eacute;cution de requ&ecirc;tes</h3></div></div><div></div></div><p>
                Les requ&ecirc;tes HQL et SQL natives sont repr&eacute;sent&eacute;es avec une instance de <tt class="literal">org.hibernate.Query</tt>.
                L'interface offre des m&eacute;thodes pour la liaison des param&egrave;tres, la gestion des ensembles de resultats, et pour
                l'ex&eacute;cution de la requ&ecirc;te r&eacute;elle. Vous obtenez toujours une <tt class="literal">Query</tt> en utilisant la
                <tt class="literal">Session</tt> courante :
            </p><pre class="programlisting">List cats = session.createQuery(
    "from Cat as cat where cat.birthdate &lt; ?")
    .setDate(0, date)
    .list();

List mothers = session.createQuery(
    "select mother from Cat as cat join cat.mother as mother where cat.name = ?")
    .setString(0, name)
    .list();

List kittens = session.createQuery(
    "from Cat as cat where cat.mother = ?")
    .setEntity(0, pk)
    .list();

Cat mother = (Cat) session.createQuery(
    "select cat.mother from Cat as cat where cat = ?")
    .setEntity(0, izi)
    .uniqueResult();</pre><p>
                Une requ&ecirc;te est g&eacute;n&eacute;ralement ex&eacute;cut&eacute;e en invoquant <tt class="literal">list()</tt>,
                le r&eacute;sultat de la requ&ecirc;te sera charg&eacute;e compl&egrave;tement dans une collection en m&eacute;moire.
                Les intances d'entit&eacute;s recup&eacute;r&eacute;es par une requ&ecirc;te sont dans un &eacute;tat persistant.
                La m&eacute;thode <tt class="literal">uniqueResult()</tt> offre un raccourci si vous
                savez que votre requ&ecirc;te retournera seulement un seul objet.
            </p><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="objectstate-querying-executing-iterate"></a>10.4.1.1.&nbsp;It&eacute;ration de r&eacute;sultats</h4></div></div><div></div></div><p>
                    Occasionnellement, vous pourriez &ecirc;tre capable d'obtenir de meilleures
                    performances en ex&eacute;cutant la requ&ecirc;te avec la m&eacute;thode <tt class="literal">iterate()</tt>.
                    Ce sera g&eacute;n&eacute;ralement seulement le cas si vous esp&eacute;rez que les intances r&eacute;elles
                    d'entit&eacute; retourn&eacute;es par la requ&ecirc;te soient d&eacute;j&agrave; charg&eacute;es dans la session ou le
                    cache de second niveau. Si elles ne sont pas cach&eacute;es, <tt class="literal">iterate()</tt>
                    sera plus lent que <tt class="literal">list()</tt> et pourrait n&eacute;cessiter plusieurs
                    acc&egrave;s &agrave; la base de donn&eacute;es pour une simple requ&ecirc;te, g&eacute;n&eacute;ralement <span class="emphasis"><em>1</em></span>
                    pour le select initial qui retourne seulement les identifiants, et <span class="emphasis"><em>n</em></span>
                    selects suppl&eacute;mentaires pour initialiser les instances r&eacute;elles.
                </p><pre class="programlisting">// fetch ids
Iterator iter = sess.createQuery("from eg.Qux q order by q.likeliness").iterate();
while ( iter.hasNext() ) {
    Qux qux = (Qux) iter.next();  // fetch the object
    // something we couldnt express in the query
    if ( qux.calculateComplicatedAlgorithm() ) {
        // delete the current instance
        iter.remove();
        // dont need to process the rest
        break;
    }
}</pre></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="objectstate-querying-executing-tuples"></a>10.4.1.2.&nbsp;Requ&ecirc;tes qui retournent des tuples</h4></div></div><div></div></div><p>
                    Les requ&ecirc;tes d'Hibernate retournent parfois des tuples d'objets, auquel cas chaque tuple
                    est retourn&eacute; comme un tableau :
                </p><pre class="programlisting">Iterator kittensAndMothers = sess.createQuery(
            "select kitten, mother from Cat kitten join kitten.mother mother")
            .list()
            .iterator();

while ( kittensAndMothers.hasNext() ) {
    Object[] tuple = (Object[]) kittensAndMothers.next();
    Cat kitten  = tuple[0];
    Cat mother  = tuple[1];
    ....
}</pre></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="objectstate-querying-executing-scalar"></a>10.4.1.3.&nbsp;R&eacute;sultats scalaires</h4></div></div><div></div></div><p>
                    Des requ&ecirc;tes peuvent sp&eacute;cifier une propri&eacute;t&eacute; d'une classe dans la clause <tt class="literal">select</tt>.
                    Elles peuvent m&ecirc;me appeler des fonctions d'aggr&eacute;gat SQL. Les propri&eacute;t&eacute;s ou les aggr&eacute;gats sont
                    consid&eacute;r&eacute;s comme des r&eacute;sultats "scalaires" (et pas des entit&eacute;s dans un &eacute;tat persistant).
                </p><pre class="programlisting">Iterator results = sess.createQuery(
        "select cat.color, min(cat.birthdate), count(cat) from Cat cat " +
        "group by cat.color")
        .list()
        .iterator();

while ( results.hasNext() ) {
    Object[] row = (Object[]) results.next();
    Color type = (Color) row[0];
    Date oldest = (Date) row[1];
    Integer count = (Integer) row[2];
    .....
}</pre></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="objectstate-querying-executing-parameters"></a>10.4.1.4.&nbsp;Lier des param&egrave;tres</h4></div></div><div></div></div><p>
                    Des m&eacute;thodes de <tt class="literal">Query</tt> sont fournies pour lier des
                    valeurs &agrave; des param&egrave;tres nomm&eacute;s ou &agrave; des param&egrave;tres de style JDBC <tt class="literal">?</tt>.
                    <span class="emphasis"><em>Contrairement &agrave; JDBC, les num&eacute;ros des param&egrave;tres d'Hibernate commencent &agrave; z&eacute;ro.</em></span>
                    Les param&egrave;tres nomm&eacute;s sont des identifiants de la forme <tt class="literal">:nom</tt> dans la cha&icirc;ne de
                    caract&egrave;res de la requ&ecirc;te. Les avantages des param&egrave;tres nomm&eacute;s sont :
                </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                            les param&egrave;tres nomm&eacute;s sont insensibles &agrave; l'ordre de leur place dans la cha&icirc;ne
                            de la requ&ecirc;te
                        </p></li><li><p>
                            ils peuvent appara&icirc;tre plusieurs fois dans la m&ecirc;me requ&ecirc;te
                        </p></li><li><p>
                            ils sont auto-document&eacute;s
                        </p></li></ul></div><pre class="programlisting">//param&egrave;tre nomme (pr&eacute;f&eacute;r&eacute;)
Query q = sess.createQuery("from DomesticCat cat where cat.name = :name");
q.setString("name", "Fritz");
Iterator cats = q.iterate();</pre><pre class="programlisting">//param&egrave;tre positionnel
Query q = sess.createQuery("from DomesticCat cat where cat.name = ?");
q.setString(0, "Izi");
Iterator cats = q.iterate();</pre><pre class="programlisting">//liste de param&egrave;tres nomm&eacute;s
List names = new ArrayList();
names.add("Izi");
names.add("Fritz");
Query q = sess.createQuery("from DomesticCat cat where cat.name in (:namesList)");
q.setParameterList("namesList", names);
List cats = q.list();</pre></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="objectstate-querying-executing-pagination"></a>10.4.1.5.&nbsp;Pagination</h4></div></div><div></div></div><p>
                    Si vous avez besoin de sp&eacute;cifier des liens sur votre ensemble de r&eacute;sultats (le nombre
                    maximum de lignes que vous voulez r&eacute;cup&eacute;rez et/ou la premi&egrave;re ligne que vous voulez r&eacute;cup&eacute;rer)
                    vous devriez utiliser des m&eacute;thodes de l'interface <tt class="literal">Query</tt> :
                </p><pre class="programlisting">Query q = sess.createQuery("from DomesticCat cat");
q.setFirstResult(20);
q.setMaxResults(10);
List cats = q.list();</pre><p>
                    Hibernate sait comment traduite cette requ&ecirc;te de limite en SQL natif pour votre SGBD.
                </p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="objectstate-querying-executing-scrolling"></a>10.4.1.6.&nbsp;It&eacute;ration "scrollable"</h4></div></div><div></div></div><p>
                    Si votre connecteur JDBC supporte les <tt class="literal">ResultSet</tt>s "scrollables",
                    l'interface <tt class="literal">Query</tt> peut &ecirc;tre utilis&eacute;e pour obtenir un objet
                    <tt class="literal">ScrollableResults</tt>, lequel permet une navigation flexible dans les
                    r&eacute;sultats de la requ&ecirc;te.
                </p><pre class="programlisting">Query q = sess.createQuery("select cat.name, cat from DomesticCat cat " +
                            "order by cat.name");
ScrollableResults cats = q.scroll();
if ( cats.first() ) {

    // trouve le premier nom sur chaque page d'une liste alphab&eacute;tique de noms de chats
    firstNamesOfPages = new ArrayList();
    do {
        String name = cats.getString(0);
        firstNamesOfPages.add(name);
    }
    while ( cats.scroll(PAGE_SIZE) );

    // Maintenant, obtiens la premi&egrave;re page de chats
    pageOfCats = new ArrayList();
    cats.beforeFirst();
    int i=0;
    while( ( PAGE_SIZE &gt; i++ ) &amp;&amp; cats.next() ) pageOfCats.add( cats.get(1) );

}
cats.close()</pre><p>
                    Notez qu'une connexion ouverte (et un curseur) est requise pour cette fonctionnalit&eacute;,
                    utilisez <tt class="literal">setMaxResult()</tt>/<tt class="literal">setFirstResult()</tt> si vous
                    avez besoin d'une fonctionnalit&eacute; de pagination hors ligne.
                </p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="objectstate-querying-executing-named"></a>10.4.1.7.&nbsp;Externaliser des requ&ecirc;tes nomm&eacute;es</h4></div></div><div></div></div><p>
                    Vous pouvez aussi d&eacute;finir des requ&ecirc;tes nomm&eacute;es dans le document de mapping.
                    (Souvenez-vous d'utiliser une section <tt class="literal">CDATA</tt> si votre requ&ecirc;te
                    contient des caract&egrave;res qui pourraient &ecirc;tre interpr&eacute;t&eacute;s comme des &eacute;l&eacute;ments XML.)
                </p><pre class="programlisting">&lt;query name="eg.DomesticCat.by.name.and.minimum.weight"&gt;&lt;![CDATA[
    from eg.DomesticCat as cat
        where cat.name = ?
        and cat.weight &gt; ?
] ]&gt;&lt;/query&gt;</pre><p>
                    La liaison de param&egrave;tres et l'ex&eacute;cution sont fait par programmation :
                </p><pre class="programlisting">Query q = sess.getNamedQuery("eg.DomesticCat.by.name.and.minimum.weight");
q.setString(0, name);
q.setInt(1, minWeight);
List cats = q.list();</pre><p>
                    Notez que le code r&eacute;el du programme est ind&eacute;pendant du langage de requ&ecirc;te qui est
                    utilis&eacute;, vous pouvez aussi d&eacute;finir des requ&ecirc;tes SQL nativez dans les m&eacute;ta-donn&eacute;es, ou
                    migrer des requ&ecirc;tes existantes vers Hibernate en les pla&ccedil;ant dans les fichiers de mapping.
                </p></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="objectstate-filtering"></a>10.4.2.&nbsp;Filtrer des collections</h3></div></div><div></div></div><p>
                Un <span class="emphasis"><em>filtre</em></span> de collection est un type sp&eacute;cial de requ&ecirc;te qui peut &ecirc;tre
                appliqu&eacute; &agrave; une collection persistante ou &agrave; un tableau. La cha&icirc;ne de requ&ecirc;te peut se r&eacute;f&eacute;rer &agrave;
                <tt class="literal">this</tt>, correspondant &agrave; l'&eacute;l&eacute;ment de la collection courant.
            </p><pre class="programlisting">Collection blackKittens = session.createFilter(
    pk.getKittens(),
    "where this.color = ?")
    .setParameter( Color.BLACK, Hibernate.custom(ColorUserType.class) )
    .list()
);</pre><p>
                La collection retourn&eacute;e est consid&eacute;r&eacute;e comme un bag, et c'est une copie de la
                collection donn&eacute;e. La collection originale n'est pas modifi&eacute;e (c'est contraire
                &agrave; l'implication du nom "filtre"; mais coh&eacute;rent avec le comportement attendu).
            </p><p>
                Observez que les filtres ne n&eacute;cessitent pas une clause <tt class="literal">from</tt> (bien qu'ils
                puissent en avoir une si besoin est). Les filtres ne sont pas limit&eacute;s &agrave; retourner des
                &eacute;l&eacute;ments de la collection eux-m&ecirc;mes.
            </p><pre class="programlisting">Collection blackKittenMates = session.createFilter(
    pk.getKittens(),
    "select this.mate where this.color = eg.Color.BLACK.intValue")
    .list();</pre><p>
                M&ecirc;me une requ&ecirc;te de filtre vide est utile, par exemple pour charger un sous-ensemble
                d'&eacute;l&eacute;ments dans une &eacute;norme collection :
            </p><pre class="programlisting">Collection tenKittens = session.createFilter(
    mother.getKittens(), "")
    .setFirstResult(0).setMaxResults(10)
    .list();</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="objecstate-querying-criteria"></a>10.4.3.&nbsp;Requ&ecirc;tes Criteria</h3></div></div><div></div></div><p>
                HQL est extr&ecirc;mement puissant mais certains d&eacute;veloppeurs pr&eacute;f&egrave;rent construire des
                requ&ecirc;tes dynamiquement, en utilisant l'API orient&eacute;e objet, plut&ocirc;t que construire
                des cha&icirc;nes de requ&ecirc;tes. Hibernate fournit une API intuitive de requ&ecirc;te <tt class="literal">Criteria</tt>
                pour ces cas :
            </p><pre class="programlisting">Criteria crit = session.createCriteria(Cat.class);
crit.add( Expression.eq( "color", eg.Color.BLACK ) );
crit.setMaxResults(10);
List cats = crit.list();</pre><p>
                Les APIs <tt class="literal">Criteria</tt> et <tt class="literal">Example</tt> associ&eacute; sont
                trait&eacute;es plus en d&eacute;tail dans <a href="#querycriteria" title="Chapitre&nbsp;15.&nbsp;Requ&ecirc;tes par crit&egrave;res">Chapitre&nbsp;15, <i>Requ&ecirc;tes par crit&egrave;res</i></a>.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="objectstate-querying-nativesql"></a>10.4.4.&nbsp;Requ&ecirc;tes en SQL natif</h3></div></div><div></div></div><p>
                Vous pouvez exprimer une requ&ecirc;te en SQL, en utilisant <tt class="literal">createSQLQuery()</tt>
                et laisser Hibernate s'occuper du mapping des r&eacute;sultats vers des objets. Notez que vous
                pouvez n'importe quand appeler <tt class="literal">session.connection()</tt> et utiliser
                directement la <tt class="literal">Connection</tt> JDBC. Si vous choisissez d'utiliser
                l'API Hibernate, vous devez mettre les alias SQL entre accolades :
            </p><pre class="programlisting">List cats = session.createSQLQuery(
    "SELECT {cat.*} FROM CAT {cat} WHERE ROWNUM&lt;10",
    "cat",
    Cat.class
).list();</pre><pre class="programlisting">List cats = session.createSQLQuery(
    "SELECT {cat}.ID AS {cat.id}, {cat}.SEX AS {cat.sex}, " +
           "{cat}.MATE AS {cat.mate}, {cat}.SUBCLASS AS {cat.class}, ... " +
    "FROM CAT {cat} WHERE ROWNUM&lt;10",
    "cat",
    Cat.class
).list()</pre><p>
                Les requ&ecirc;tes SQL peuvent contenir des param&egrave;tres nomm&eacute;s et positionnels, comme des
                requ&ecirc;tes Hibernate. Plus d'informations &agrave; propos des requ&ecirc;tes SQL natives dans Hibernate
                peuvent &ecirc;tre trouv&eacute;es dans <a href="#querysql" title="Chapitre&nbsp;16.&nbsp;SQL natif">Chapitre&nbsp;16, <i>SQL natif</i></a>.
            </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-modifying"></a>10.5.&nbsp;Modifier des objets persistants</h2></div></div><div></div></div><p>
            Les <span class="emphasis"><em>instances persistantes transactionnelles</em></span> (c'est-&agrave;-dire des objets
            charg&eacute;s, sauvegard&eacute;s, cr&eacute;&eacute;s ou requ&ecirc;t&eacute;s par la <tt class="literal">Session</tt>) peuvent &ecirc;tre
            manipul&eacute;es par l'application et n'importe quel changement vers l'&eacute;tat persistant sera
            persist&eacute; lorsque la <tt class="literal">Session</tt> est <span class="emphasis"><em>"flush&eacute;e"</em></span> (trait&eacute;
            plus tard dans ce chapitre). Il n'y a pas besoin d'appeler une m&eacute;thode particuli&egrave;re
            (comme <tt class="literal">update()</tt>, qui a un but diff&eacute;rent) pour rendre vos modifications
            persistantes. Donc la mani&egrave;re la plus directe de mettre &agrave; jour l'&eacute;tat d'un objet est de
            le charger avec <tt class="literal">load()</tt>, et puis le manipuler directement, tant que la
            <tt class="literal">Session</tt> est ouverte :
        </p><pre class="programlisting">DomesticCat cat = (DomesticCat) sess.load( Cat.class, new Long(69) );
cat.setName("PK");
sess.flush();  // changes to cat are automatically detected and persisted</pre><p>
            Parfois ce mod&egrave;le de programmation est inefficace puisqu'il n&eacute;cessiterait un
            <tt class="literal">SELECT</tt> SQL (pour charger l'objet) et un <tt class="literal">UPDATE</tt>
            SQL (pour persister son &eacute;tat mis &agrave; jour) dans la m&ecirc;me session. Aussi Hibernate offre
            une autre approche, en utilisant des instances d&eacute;tach&eacute;es.
        </p><p>
            <span class="emphasis"><em>Notez que Hibernate n'offre par sa propre API pour l'ex&eacute;cution directe
            d'expressions <tt class="literal">UPDATE</tt> ou <tt class="literal">DELETE</tt>. Hibernate
            est un service de <span class="emphasis"><em>gestion d'&eacute;tat</em></span>, vous n'avez pas &agrave; penser
            aux <span class="emphasis"><em>expressions</em></span> pour l'utiliser. JDBC est une API parfaite
            pour ex&eacute;cuter des expressions SQL, vous pouvez obtenir une <tt class="literal">Connection</tt>
            JDBC n'importe quand en appelant <tt class="literal">session.connection()</tt>. En outre,
            la notion d'op&eacute;rations de masse entre en conflit avec le mapping objet/relationnel
            pour les applications orient&eacute;es processus de transactions en ligne. Les futures
            versions d'Hibernate peuvent cependant fournir des fonctions d'op&eacute;ration de masse.
            Voir <a href="#batch" title="Chapitre&nbsp;13.&nbsp;Traitement par paquet">Chapitre&nbsp;13, <i>Traitement par paquet</i></a> pour les astuces possibles d'op&eacute;rations group&eacute;es.</em></span>
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-detached"></a>10.6.&nbsp;Modifier des objets d&eacute;tach&eacute;s</h2></div></div><div></div></div><p>
            Beaucoup d'applications ont besoin de r&eacute;cup&eacute;rer un objet dans une transaction,
            l'envoyer &agrave; la couche interfac&eacute;e avec l'utilisateur pour les manipulations, puis
            sauvegarder les changements dans une nouvelle transaction. Les applications
            qui utilisent cette approche dans un environnement &agrave; haute concurrence utilisent
            g&eacute;n&eacute;ralement des donn&eacute;es versionn&eacute;es pour assurer l'isolation pour les "longues"
            unit&eacute;s de travail.
        </p><p>
            Hibernate supporte ce mod&egrave;le en permettant pour le r&eacute;attachement d'instances d&eacute;tach&eacute;es
            l'utilisation des m&eacute;thodes <tt class="literal">Session.update()</tt> ou <tt class="literal">Session.merge()</tt> :
        </p><pre class="programlisting">// dans la premi&egrave;re session
Cat cat = (Cat) firstSession.load(Cat.class, catId);
Cat potentialMate = new Cat();
firstSession.save(potentialMate);

// dans une couche plus haute de l'application
cat.setMate(potentialMate);

// plus tard, dans une nouvelle session
secondSession.update(cat);  // update cat
secondSession.update(mate); // update mate</pre><p>
            Si le <tt class="literal">Cat</tt> avec l'identifiant <tt class="literal">catId</tt> avait d&eacute;j&agrave;
            &eacute;t&eacute; charg&eacute; par <tt class="literal">secondSession</tt> lorsque l'application a essay&eacute; de le
            r&eacute;attacher, une exception aurait &eacute;t&eacute; lev&eacute;e.
        </p><p>
            Utilisez <tt class="literal">update()</tt> si vous &ecirc;tes sure que la session ne contient pas
            d&eacute;j&agrave; une instance persistante avec le m&ecirc;me identifiant, et <tt class="literal">merge()</tt>
            si vous voulez fusionner vos modifications n'importe quand sans consid&eacute;rer l'&eacute;tat de
            la session. En d'autres mots, <tt class="literal">update()</tt> est g&eacute;n&eacute;ralement la premi&egrave;re m&eacute;thode
            que vous devriez appeler dans une session fra&icirc;che, pour s'assurer que le r&eacute;attachement
            de vos instances d&eacute;tach&eacute;es est la premi&egrave;re op&eacute;ration qui est ex&eacute;cut&eacute;e.
        </p><p>
            L'application devrait individuellement <tt class="literal">update()</tt> (NdT : mettre &agrave; jour)
            les instances d&eacute;tach&eacute;es accessibles depuis l'instance d&eacute;tach&eacute;e donn&eacute;e si et
            <span class="emphasis"><em>seulement</em></span> si elle veut que leur &eacute;tat soit aussi mis &agrave; jour. Ceci
            peut &ecirc;tre automatis&eacute; bien s&ucirc;r, en utilisant la <span class="emphasis"><em>persistance transitive</em></span>,
            voir <a href="#objectstate-transitive" title="10.11.&nbsp;Persistance transitive">Section&nbsp;10.11, &laquo;&nbsp;Persistance transitive&nbsp;&raquo;</a>.
        </p><p>
            La m&eacute;thode <tt class="literal">lock()</tt> permet aussi &agrave; une application de r&eacute;associer un
            objet avec une nouvelle session. Pourtant, l'instance d&eacute;tach&eacute;e doit &ecirc;tre non modifi&eacute;e !
        </p><pre class="programlisting">//r&eacute;associe :
sess.lock(fritz, LockMode.NONE);
//fait une v&eacute;rification de version, puis r&eacute;associe :
sess.lock(izi, LockMode.READ);
//fait une v&eacute;rification de version, en utilisant SELECT ... FOR UPDATE, puis r&eacute;associe :
sess.lock(pk, LockMode.UPGRADE);</pre><p>
            Notez que <tt class="literal">lock()</tt> peut &ecirc;tre utilis&eacute; avec diff&eacute;rents
            <tt class="literal">LockMode</tt>s, voir la documentation de l'API documentation et le chapitre
            sur la gestion des transactions pour plus d'informations. Le r&eacute;attachement n'est pas le seul
            cas d'utilisation pour <tt class="literal">lock()</tt>.
        </p><p>
            D'autres mod&egrave;les pour de longues unit&eacute;s de travail sont trait&eacute;s dans <a href="#transactions-optimistic" title="11.3.&nbsp;Contr&ocirc;le de consurrence optimiste">Section&nbsp;11.3, &laquo;&nbsp;Contr&ocirc;le de consurrence optimiste&nbsp;&raquo;</a>.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-saveorupdate"></a>10.7.&nbsp;D&eacute;tection automatique d'un &eacute;tat</h2></div></div><div></div></div><p>
            Les utilisateurs d'Hibernate ont demand&eacute; une m&eacute;thode dont l'intention g&eacute;n&eacute;rale
            serait soit de sauvegarder une instance &eacute;ph&eacute;m&egrave;re en g&eacute;n&eacute;rant un nouvel identifiant,
            soit mettre &agrave; jour/r&eacute;attacher les instances d&eacute;tach&eacute;es associ&eacute;es &agrave; l'identifiant courant.
            La m&eacute;thode <tt class="literal">saveOrUpdate()</tt> impl&eacute;mente cette fonctionnalit&eacute;.
        </p><pre class="programlisting">// dans la premi&egrave;re session
Cat cat = (Cat) firstSession.load(Cat.class, catID);

// dans une partie plus haute de l'application
Cat mate = new Cat();
cat.setMate(mate);

// plus tard, dans une nouvelle session
secondSession.saveOrUpdate(cat);   // met &agrave; jour un &eacute;tat existant (cat a un identifiant non-null)
secondSession.saveOrUpdate(mate);  // sauvegarde les nouvelles instances (mate a un identiant null)</pre><p>
            L'usage et la s&eacute;mantique de <tt class="literal">saveOrUpdate()</tt> semble &ecirc;tre confuse pour les
            nouveaux utilisateurs. Premi&egrave;rement, aussi longtemps que vous n'essayez pas d'utiliser des
            instances d'une session dans une autre, vous ne devriez pas avoir besoin d'utiliser <tt class="literal">update()</tt>,
            <tt class="literal">saveOrUpdate()</tt>, ou <tt class="literal">merge()</tt>. Certaines applications
            n'utiliseront jamais ces m&eacute;thodes.
        </p><p>
            G&eacute;n&eacute;ralement <tt class="literal">update()</tt> ou <tt class="literal">saveOrUpdate()</tt> sont utilis&eacute;es dans
            le sc&eacute;nario suivant :
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    l'application charge un objet dans la premi&egrave;re session
                </p></li><li><p>
                    l'objet est pass&eacute; &agrave; la couche utilisateur
                </p></li><li><p>
                    certaines modifications sont effectu&eacute;es sur l'objet
                </p></li><li><p>
                    l'objet est retourn&eacute; &agrave; la couche logique m&eacute;tier
                </p></li><li><p>
                    l'application persiste ces modifications en appelant
                    <tt class="literal">update()</tt> dans une seconde sessin
                </p></li></ul></div><p>
            <tt class="literal">saveOrUpdate()</tt> s'utilise dans le cas suivant :
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    si l'objet est d&eacute;j&agrave; persistant dans cette session, ne rien faire
                </p></li><li><p>
                    si un autre objet associ&eacute; &agrave; la session a le m&ecirc;me identifiant, lever une exception
                </p></li><li><p>
                    si l'objet n'a pas de propri&eacute;t&eacute; d'identifiant, appeler <tt class="literal">save()</tt>
                </p></li><li><p>
                    si l'identifiant de l'objet a une valeur assign&eacute;e &agrave; un objet nouvellement instanci&eacute;,
                    appeler <tt class="literal">save()</tt>
                </p></li><li><p>
                    si l'objet est versionn&eacute; (par <tt class="literal">&lt;version&gt;</tt> ou
                    <tt class="literal">&lt;timestamp&gt;</tt>), et la valeur de la propri&eacute;t&eacute; de version
                    est la m&ecirc;me valeur que celle assign&eacute;e &agrave; un objet nouvellement instanci&eacute;, appeler
                    <tt class="literal">save()</tt>
                </p></li><li><p>
                    sinon mettre &agrave; jour l'objet avec <tt class="literal">update()</tt>
                </p></li></ul></div><p>
            et <tt class="literal">merge()</tt> est tr&egrave;s diff&eacute;rent :
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    s'il y a une instance persistante avec le m&ecirc;me identifiant couramment
                    associ&eacute;e &agrave; la session, copier l'&eacute;tat de l'objet donn&eacute; dans l'instance persistante
                </p></li><li><p>
                    s'il n'y a pas d'instance persistante associ&eacute;e &agrave; cette session, essayer de le charger
                    &agrave; partir de la base de donn&eacute;es, ou cr&eacute;er une nouvelle instance persistante
                </p></li><li><p>
                    l'instance persistante est retourn&eacute;e
                </p></li><li><p>
                    l'instance donn&eacute;e ne devient pas associ&eacute;e &agrave; la session, elle reste d&eacute;tach&eacute;e
                </p></li></ul></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-deleting"></a>10.8.&nbsp;Suppression d'objets persistants</h2></div></div><div></div></div><p>
            <tt class="literal">Session.delete()</tt> supprimera l'&eacute;tat d'un objet de la base de donn&eacute;es.
            Bien s&ucirc;r, votre application pourrait encore conserver une r&eacute;f&eacute;rence vers un objet effac&eacute;.
            Il est mieux de penser &agrave; <tt class="literal">delete()</tt> comme rendant une instance persistante
            &eacute;ph&eacute;m&egrave;re.
        </p><pre class="programlisting">sess.delete(cat);</pre><p>
            Vous pouvez effacer des objets dans l'ordre que vous voulez, sans risque de violations
            de contrainte de clef &eacute;trang&egrave;re. Il est encore possible de violer une contrainte <tt class="literal">NOT
            NULL</tt> sur une colonne de clef &eacute;trang&egrave;re en effa&ccedil;ant des objets dans le
            mauvais ordre, par exemple si vous effacer le parent, mais oubliez d'effacer les enfants.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-replicating"></a>10.9.&nbsp;R&eacute;plication d'objets entre deux entrep&ocirc;ts de donn&eacute;es</h2></div></div><div></div></div><p>
            Il est occasionnellement utile de pouvoir prendre un graphe d'instances persistantes
            et de les rendre persistantes dans un entrep&ocirc;t diff&eacute;rent, sans reg&eacute;n&eacute;rer les valeurs
            des identifiants.
        </p><pre class="programlisting">//r&eacute;cup&egrave;re un cat de la base de donn&eacute;es
Session session1 = factory1.openSession();
Transaction tx1 = session1.beginTransaction();
Cat cat = session1.get(Cat.class, catId);
tx1.commit();
session1.close();

// r&eacute;concilie la seconde base de donn&eacute;es
Session session2 = factory2.openSession();
Transaction tx2 = session2.beginTransaction();
session2.replicate(cat, ReplicationMode.LATEST_VERSION);
tx2.commit();
session2.close();</pre><p>
            Le <tt class="literal">ReplicationMode</tt> d&eacute;termine comment <tt class="literal">replicate()</tt>
            traitera les conflits avec les lignes existantes dans la base de donn&eacute;es.
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">ReplicationMode.IGNORE</tt> - ignore l'objet s'il y a une ligne
                    existante dans la base de donn&eacute;es avec le m&ecirc;me identifiant
                </p></li><li><p>
                    <tt class="literal">ReplicationMode.OVERWRITE</tt> - &eacute;crase n'importe quelle ligne existante
                    dans la base de donn&eacute;es avec le m&ecirc;me identifiant
                </p></li><li><p>
                    <tt class="literal">ReplicationMode.EXCEPTION</tt> - l&egrave;ve une exception s'il y une ligne dans
                    la base de donn&eacute;es avec le m&ecirc;me identifiant
                </p></li><li><p>
                    <tt class="literal">ReplicationMode.LATEST_VERSION</tt> - &eacute;crase la ligne si son num&eacute;ro de version
                    est plus petit que le num&eacute;ro de version de l'objet, ou ignore l'objet sinon
                </p></li></ul></div><p>
            Les cas d'utilisation de cette fonctionnalit&eacute; incluent la r&eacute;conciliation de donn&eacute;es
            entr&eacute;es dans diff&eacute;rentes base de donn&eacute;es, l'extension des informations de configuration
            du syst&egrave;me durant une mise &agrave; jour du produit, retour en arri&egrave;re sur les changements effectu&eacute;s
            durant des transactions non-ACID, et plus.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-flushing"></a>10.10.&nbsp;Flush de la session</h2></div></div><div></div></div><p>
            De temps en temps la <tt class="literal">Session</tt> ex&eacute;cutera les expressions SQL
            requises pour syncrhoniser l'&eacute;tat de la connexion JDBC avec l'&eacute;tat des objets
            retenus en m&eacute;moire. Ce processus, <span class="emphasis"><em>flush</em></span>, arrive par d&eacute;faut aux
            points suivants :
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    lors de certaines ex&eacute;cutions de requ&ecirc;te
                </p></li><li><p>
                    lors d'un appel &agrave; <tt class="literal">org.hibernate.Transaction.commit()</tt>
                </p></li><li><p>
                    lors d'un appel &agrave; <tt class="literal">Session.flush()</tt>
                </p></li></ul></div><p>
            Les expressions SQL sont effectu&eacute;es dans l'ordre suivant :
        </p><div class="orderedlist"><ol type="1" compact><li><p>
                    insertion des entit&eacute;s, dans le m&ecirc;me ordre que celui des
                    objets correspondants sauvegard&eacute;s par l'appel &agrave; <tt class="literal">Session.save()</tt>
                </p></li><li><p>
                    mise &agrave; jours des entit&eacute;s
                </p></li><li><p>
                    suppression des collections
                </p></li><li><p>
                    suppression, mise &agrave; jour et insertion des &eacute;l&eacute;ments des collections
                </p></li><li><p>
                    insertion des collections
                </p></li><li><p>
                    suppression des entit&eacute;s, dans le m&ecirc;me ordre que celui des objets
                    correspondants qui ont &eacute;t&eacute; supprim&eacute;s par l'appel &agrave; <tt class="literal">Session.delete()</tt>
                </p></li></ol></div><p>
            (Une exception est que des objets utilisant la g&eacute;n&eacute;ration <tt class="literal">native</tt>
            d'identifiants sont ins&eacute;r&eacute;s lorsqu'ils sont sauvegard&eacute;s.)
        </p><p>
            Except&eacute; lorsque vous appelez <tt class="literal">flush()</tt> explicitement, il n'y
            absolument aucune garantie &agrave; propos de <span class="emphasis"><em>quand</em></span> la <tt class="literal">Session</tt>
            ex&eacute;cute les appels JDBC, seulement sur l'<span class="emphasis"><em>ordre</em></span> dans lequel ils sont
            ex&eacute;cut&eacute;s. Cependant, Hibernate garantit que <tt class="literal">Query.list(..)</tt> ne
            retournera jamais de donn&eacute;es p&eacute;rim&eacute;es, ni des donn&eacute;es fausses.
        </p><p>
            Il est possible de changer le comportement par d&eacute;faut, donc que le flush se produise
            moins fr&eacute;quemment. La classe <tt class="literal">FlushMode</tt> d&eacute;finit trois modes diff&eacute;rents :
            flush seulement lors du commit (et seulement quand l'API <tt class="literal">Transaction</tt>
            d'Hibernate est utilis&eacute;e), flush automatiquement en utilisant la proc&eacute;dure expliqu&eacute;e, ou
            jamais de flush &agrave; moins que <tt class="literal">flush()</tt> soit appel&eacute;e explicitement.
            Le dernier mode est utile pour l'ex&eacute;cution de longues unit&eacute;s de travail, o&ugrave; une
            <tt class="literal">Session</tt> est gard&eacute;e ouverte et d&eacute;connect&eacute;e pour un long moment
            (voir <a href="#transactions-optimistic-longsession" title="11.3.2.&nbsp;Les sessions longues et le versionnage automatique.">Section&nbsp;11.3.2, &laquo;&nbsp;Les sessions longues et le versionnage automatique.&nbsp;&raquo;</a>).
        </p><pre class="programlisting">sess = sf.openSession();
Transaction tx = sess.beginTransaction();
sess.setFlushMode(FlushMode.COMMIT); // permet aux requ&ecirc;tes de retourner un &eacute;tat p&eacute;rim&eacute;

Cat izi = (Cat) sess.load(Cat.class, id);
izi.setName(iznizi);

// pourrait retourner des donn&eacute;es p&eacute;rim&eacute;es
sess.find("from Cat as cat left outer join cat.kittens kitten");

// le changement pour izi n'est pas flush&eacute; !
...
tx.commit(); // le flush se produit</pre><p>
            Durant le flush, une exception peut se produire (par exemple, si une op&eacute;ration de la
            DML viole une contrainte). Puisque les exceptions de gestion impliquent une certaine
            compr&eacute;hension du comportement transactionnel d'Hibernate, nous le traitons dans
            <a href="#transactions" title="Chapitre&nbsp;11.&nbsp;Transactions et acc&egrave;s concurrents">Chapitre&nbsp;11, <i>Transactions et acc&egrave;s concurrents</i></a>.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-transitive"></a>10.11.&nbsp;Persistance transitive</h2></div></div><div></div></div><p>
            Il est assez p&eacute;nible de sauvegarder, supprimer, ou r&eacute;attacher des objets
            un par un, surtout si vous traitez un graphe d'objets associ&eacute;s. Un cas habituel
            est une relation parent/enfant. Consid&eacute;rez l'exemple suivant :
        </p><p>
            Si les enfants de la relation parent/enfant &eacute;taient des types de valeur (par exemple,
            une collection d'adresses ou de cha&icirc;nes de caract&egrave;res), leur cycle de vie d&eacute;pendraient
            du parent et aucune action ne serait requise pour "cascader" facilement les
            changements d'&eacute;tat. Si le parent est sauvegard&eacute;, les objets enfants de type de valeur sont
            sauvegard&eacute;s &eacute;galement, si le parent est supprim&eacute;, les enfants sont supprim&eacute;s, etc. Ceci
            fonctionne m&ecirc;me pour des op&eacute;rations telles que la suppression d'un enfant de la collection ;
            Hibernate d&eacute;tectera cela et, puisque les objets de type de valeur ne peuvent pas avoir
            des r&eacute;f&eacute;rences partag&eacute;es, supprimera l'enfant de la base de donn&eacute;es.
        </p><p>
            Maintenant consid&eacute;rez le m&ecirc;me sc&eacute;nario avec un parent et dont les objets enfants
            sont des entit&eacute;s, et non des types de valeur (par exemple, des cat&eacute;gories et des
            objets, ou un parent et des chatons). Les entit&eacute;s ont leur propre cycle de vie,
            supportent les r&eacute;f&eacute;rences partag&eacute;es (donc supprimer une entit&eacute; de la collection
            ne signifie pas qu'elle peut &ecirc;tre supprim&eacute;e), et il n'y a par d&eacute;faut pas de
            cascade d'&eacute;tat d'une entit&eacute; vers n'importe quelle entit&eacute; associ&eacute;e. Hibernate
            n'impl&eacute;mente pas la <span class="emphasis"><em>persistance par accessibilit&eacute;</em></span> par d&eacute;faut.
        </p><p>
            Pour chaque op&eacute;ration basique de la session d'Hibernate - incluant <tt class="literal">persist(), merge(),
            saveOrUpdate(), delete(), lock(), refresh(), evict(), replicate()</tt> - il y a un
            style de cascade correspondant. Respectivement, les styles de cascade s'appellent <tt class="literal">persist,
            merge, save-update, delete, lock, refresh, evict, replicate</tt>. Si vous voulez qu'une
            op&eacute;ration soit cascad&eacute;e le long d'une association, vous devez l'indiquer dans le document de
            mapping. Par exemple :
        </p><pre class="programlisting">&lt;one-to-one name="person" cascade="persist"/&gt;</pre><p>
            Les styles de cascade peuvent &ecirc;tre combin&eacute;s :
        </p><pre class="programlisting">&lt;one-to-one name="person" cascade="persist,delete,lock"/&gt;</pre><p>
            Vous pouvez m&ecirc;me utiliser <tt class="literal">cascade="all"</tt> pour sp&eacute;cifier que <span class="emphasis"><em>toutes</em></span>
            les op&eacute;rations devraient &ecirc;tre cascad&eacute;es le long de l'association. La valeur par d&eacute;faut
            <tt class="literal">cascade="none"</tt> sp&eacute;cifie qu'aucune op&eacute;ration ne sera cascad&eacute;e.
        </p><p>
            Une style de cascade sp&eacute;cial, <tt class="literal">delete-orphan</tt>, s'applique seulement
            aux associations un-vers-plusieurs, et indique que l'op&eacute;ration <tt class="literal">delete()</tt>
            devrait &ecirc;tre appliqu&eacute;e &agrave; n'importe quel enfant qui est supprim&eacute; de l'association.
        </p><p>
            Recommandations :
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Cela n'a g&eacute;n&eacute;ralement aucun sens d'activer la cascade sur une association
                    <tt class="literal">&lt;many-to-one&gt;</tt> ou <tt class="literal">&lt;many-to-many&gt;</tt>. Les
                    cascades sont souvent utiles pour des associations
                    <tt class="literal">&lt;one-to-one&gt;</tt> et <tt class="literal">&lt;one-to-many&gt;</tt>.
                </p></li><li><p>
                    Si la dur&eacute;e de vie de l'objet enfant est li&eacute;e &agrave; la dur&eacute;e de vie de l'objet parent,
                    faites en un <span class="emphasis"><em>objet du cycle de vie</em></span> en sp&eacute;cifiant
                    <tt class="literal">cascade="all,delete-orphan"</tt>.
                </p></li><li><p>
                    Sinon, vous pourriez ne pas avoir besoin de cascade du tout. Mais si vous pensez que vous
                    travaillerez souvent avec le parent et les enfants ensemble dans la m&ecirc;me transaction, et
                    que vous voulez vous &eacute;viter quelques frappes, consid&eacute;rez l'utilisation de
                    <tt class="literal">cascade="persist,merge,save-update"</tt>.
                </p></li></ul></div><p>
            Mapper une association (soit une simple association valu&eacute;e, soit une collection) avec
            <tt class="literal">cascade="all"</tt> marque l'association comme une relation de style
            <span class="emphasis"><em>parent/enfant</em></span> o&ugrave; la sauvegarde/mise &agrave; jour/suppression du parent
            entra&icirc;ne la sauvegarde/mise &agrave; jour/suppression de l'enfant ou des enfants.
        </p><p>
            En outre, une simple r&eacute;f&eacute;rence &agrave; un enfant d'un parent persistant aura pour cons&eacute;quence
            la sauvegarde/mise &agrave; jour de l'enfant. Cette m&eacute;taphore est cependant incompl&egrave;te. Un enfant
            qui devient non r&eacute;f&eacute;renc&eacute; par son parent <span class="emphasis"><em>n'est pas</em></span> automatiquement
            supprim&eacute;e, except&eacute; dans le cas d'une association <tt class="literal">&lt;one-to-many&gt;</tt>
            mapp&eacute;e avec <tt class="literal">cascade="delete-orphan"</tt>. La s&eacute;mantique pr&eacute;cise des op&eacute;rations
            de cascade pour une relation parent/enfant est la suivante :
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Si un parent est pass&eacute; &agrave; <tt class="literal">persist()</tt>, tous les enfant sont pass&eacute;s &agrave;
                    <tt class="literal">persist()</tt>
                </p></li><li><p>
                    Si un parent est pass&eacute; &agrave; <tt class="literal">merge()</tt>, tous les enfants sont pass&eacute;s &agrave;
                    <tt class="literal">merge()</tt>
                </p></li><li><p>
                    Si un parent est pass&eacute; &agrave; <tt class="literal">save()</tt>, <tt class="literal">update()</tt> ou
                    <tt class="literal">saveOrUpdate()</tt>, tous les enfants sont pass&eacute;s &agrave; <tt class="literal">saveOrUpdate()</tt>
                </p></li><li><p>
                    Si un enfant d&eacute;tach&eacute; ou &eacute;ph&eacute;m&egrave;re devient r&eacute;f&eacute;renc&eacute; par un parent persistant,
                    il est pass&eacute; &agrave; <tt class="literal">saveOrUpdate()</tt>
                </p></li><li><p>
                    Si un parent est supprim&eacute;, tous les enfants sont pass&eacute;s &agrave; <tt class="literal">delete()</tt>
                </p></li><li><p>
                    Si un enfant est d&eacute;r&eacute;f&eacute;renc&eacute; par un parent persistant, <span class="emphasis"><em>rien de sp&eacute;cial
                    n'arrive</em></span> - l'application devrait explicitement supprimer l'enfant si n&eacute;cessaire -
                    &agrave; moins que <tt class="literal">cascade="delete-orphan"</tt> soit param&eacute;tr&eacute;,
                    au quel cas l'enfant "orphelin" est supprim&eacute;.
                </p></li></ul></div><p>
            Enfin, la cascade des op&eacute;rations peut &ecirc;tre effectu&eacute;e sur un graphe donn&eacute; lors
			de l'<span class="emphasis"><em>appel de l'op&eacute;ration</em></span> or lors du <span class="emphasis"><em>flush</em></span>
			suivant. Toutes les op&eacute;rations, lorsque cascad&eacute;es, le sont sur toutes les entit&eacute;s
			associ&eacute;es atteignables lorsque l'op&eacute;tation est ex&eacute;cut&eacute;e. Cependant 
			<tt class="literal">save-upate</tt> et <tt class="literal">delete-orphan</tt> sont cascad&eacute;es
            &agrave; toutes les entit&eacute;s associ&eacute;es atteignables lors du flush de la 
            <tt class="literal">Session</tt>.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-metadata"></a>10.12.&nbsp;Utilisation des m&eacute;ta-donn&eacute;es</h2></div></div><div></div></div><p>
            Hibernate requiert un mod&egrave;le de m&eacute;ta-niveau tr&egrave;s riche de toutes les entit&eacute;s et types valu&eacute;s.
            De temps en temps, ce mod&egrave;le est tr&egrave;s utile &agrave; l'application elle m&ecirc;me. Par exemple,
            l'application pourrait utiliser les m&eacute;ta-donn&eacute;es d'Hibernate pour impl&eacute;menter un algorithme
            de copie en profondeur "intelligent" qui comprendrait quels objets devraient copi&eacute;s
            (par exemple les types de valeur mutables) et lesquels ne devraient pas l'&ecirc;tre (par exemple
            les types de valeurs immutables et, possiblement, les entit&eacute;s associ&eacute;es).
        </p><p>
            Hibernate expose les m&eacute;ta-donn&eacute;es via les interfaces <tt class="literal">ClassMetadata</tt>
            et <tt class="literal">CollectionMetadata</tt> et la hi&eacute;rarchie <tt class="literal">Type</tt>.
            Les instances des interfaces de m&eacute;ta-donn&eacute;es peuvent &ecirc;tre obtenues &agrave; partir de la
            <tt class="literal">SessionFactory</tt>.
        </p><pre class="programlisting">Cat fritz = ......;
ClassMetadata catMeta = sessionfactory.getClassMetadata(Cat.class);

Object[] propertyValues = catMeta.getPropertyValues(fritz);
String[] propertyNames = catMeta.getPropertyNames();
Type[] propertyTypes = catMeta.getPropertyTypes();

// r&eacute;cup&egrave;re une Map de toutes les propri&eacute;t&eacute;s qui ne sont pas des collections ou des associations
Map namedValues = new HashMap();
for ( int i=0; i&lt;propertyNames.length; i++ ) {
    if ( !propertyTypes[i].isEntityType() &amp;&amp; !propertyTypes[i].isCollectionType() ) {
        namedValues.put( propertyNames[i], propertyValues[i] );
    }
}</pre></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="transactions"></a>Chapitre&nbsp;11.&nbsp;Transactions et acc&egrave;s concurrents</h2></div></div><div></div></div><p>
        L'un des principaux avantages du m&eacute;canisme de contr&ocirc;le des acc&egrave;s concurrents d'Hibernate est qu'il est tr&egrave;s
        facile &agrave; comprendre. Hibernate utilise directement les connexions JDBC ainsi que les ressources JTA sans y
        ajouter davantage de m&eacute;canisme de blocage. Nous vous recommandons de vous familiariser avec les sp&eacute;cifications
        JDBC, ANSI et d'isolement de transaction de la base de donn&eacute;es que vous utilisez.
    </p><p>
        Hibernate ne v&eacute;rouille pas vos objets en m&eacute;moire. Votre application peut suivre le
        comportement d&eacute;fini par le niveau d'isolation de vos transactions de base de donn&eacute;es.
        Notez que gr&acirc;ce &agrave; la <tt class="literal">Session</tt>, qui est aussi un cache de scope transaction, Hibernate
        fournit des lectures r&eacute;p&eacute;t&eacute;es pour les r&eacute;cup&eacute;ration par identifiants et les requ&ecirc;tes
        d'entit&eacute;s (pas celle de valeurs scalaires).
    </p><p>
        En addition au versionning pour le controle automatique de concurrence, Hibernate fournit
        une API (mineure) pour le verrouillage perssimiste des enregistrements, en g&eacute;n&eacute;rant
        une syntaxe <tt class="literal">SELECT FOR UPDATE</tt>. Le controle de concurrence optimiste
        et cette API seront d&eacute;taill&eacute;s plus tard dans ce chapitre.
    </p><p>
        Nous aborderons la gestion des acc&egrave;s concurrents en discutant de la granularit&eacute; des objets <tt class="literal">Configuration</tt>,
        <tt class="literal">SessionFactory</tt>, et <tt class="literal">Session</tt>, ainsi que de certains concepts relatifs &agrave; la base de donn&eacute;es
        et aux longues transactions applicatives.
    </p><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-basics"></a>11.1.&nbsp;Gestion de session et d&eacute;limitation de transactions</h2></div></div><div></div></div><p>Il est important de savoir qu'un objet <tt class="literal">SessionFactory</tt> est un objet complexe et optimis&eacute; pour
            fonctionner avec les threads(thread- safe). Il est co&ucirc;teux &agrave; cr&eacute;er et est ainsi pr&eacute;vu pour n'&ecirc;tre instanci&eacute; qu?une
            seule fois via un objet <tt class="literal">Configuration</tt> au d&eacute;marrage de l'application, 
            et &ecirc;tre partag&eacute; par tous les threads d'une application.
        </p><p>Un objet <tt class="literal">Session</tt> est relativement simple et n'est threadsafe. Il est &eacute;galement peu
            co&ucirc;teux &agrave; cr&eacute;er. Il devrait n'&ecirc;tre utilis&eacute; qu'une seule fois, pour un processus d'affaire ou une unit&eacute; de
            travail ou une conversation et ensuite &ecirc;tre rel&acirc;ch&eacute;. Un objet <tt class="literal">Session</tt> ne tentera pas 
            d'obtenir de connexion ( <tt class="literal">Connection</tt> ) 
            JDBC (ou de <tt class="literal">Datasource</tt> ) si ce n'est pas n&eacute;cessaire.             
        </p><p>Afin de compl&eacute;ter ce tableau, vous devez &eacute;galement penser aux transactions de base de donn&eacute;es. Une
            transaction de base de donn&eacute;es se doit d'&ecirc;tre la plus courte possible afin de r&eacute;duire les risques de
            collision sur des enregistrements verrouill&eacute;s. De longues transactions &agrave; la base de donn&eacute;es nuiront &agrave;
            l'extensibilit&eacute; de vos applications lorsque confront&eacute;es &agrave; de hauts niveaux de charge. Par cons&eacute;quent,
            il n'est jamais bon de maintenir une transaction ouverte pendant la dur&eacute;e de reflexion de l'utilisateur,
            jusqu'a ce que l'unit&eacute; de travail soit achev&eacute;e.
        </p><p>Maintenant, comment d&eacute;limiter une unit&eacute; de travail? Est-ce qu'une instance de <tt class="literal">Session</tt> peut avoir une dur&eacute;e
            de vie d&eacute;passant plusieurs transactions &agrave; la base de donn&eacute;es, ou bien est-ce que celles-ci doivent &ecirc;tre li&eacute;es une &agrave; une?
            Quand faut-il ouvrir et fermer une <tt class="literal">Session</tt> ? Comment d&eacute;finir la d&eacute;marcation de vos transactions &agrave; la base de donn&eacute;es?
        </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-basics-uow"></a>11.1.1.&nbsp;Unit&eacute; de travail</h3></div></div><div></div></div><p>
                Il est important de mentionner que d'utiliser un paradigme <span class="emphasis"><em>session-par-operation</em></span>
                est un anti-pattern. Autrement dit: n'ouvrez et ne fermez pas la
                <tt class="literal">Session</tt> &agrave; chacun de vos acc&egrave;s simples &agrave; la base de donn&eacute;es dans un m&ecirc;me thread! Bien s&ucirc;r, le m&ecirc;me raisonnement
                s'applique sur la gestion des transactions &agrave; la base de donn&eacute;es. Les appels &agrave; la base de donn&eacute;es
                devraient &ecirc;tre faits en ordre et selon une s&eacute;quence d&eacute;finie. Ils devraient &eacute;galement &ecirc;tre regroup&eacute;s en
                des unit&eacute;s de travail atomiques. (Notez que l?utilisation d?une connexion auto-commit constitue le m&ecirc;me
                anti-pattern. Ce mode de fonctionnement existe pour les applications &eacute;mettant des commandes SQL &agrave; partir
                d?une console. Hibernate d&eacute;sengage le mode auto-commit et s'attend &agrave; ce qu'un serveur d'applications le
                fasse &eacute;galement.)
                Les transactions avec la base de donn&eacute;es ne sont jamais optionnelles, toute communication
                avec une base de donn&eacute;es doit se d&eacute;rouler dans une transaction, peu importe si vous lisez
                ou &eacute;crivez des donn&eacute;es. Comme &eacute;voqu&eacute;, le comportement auto-commit pour lire les
                donn&eacute;es devrait &ecirc;tre &eacute;vit&eacute;, puisque plusieurs petites transactions ne seront jamais
                aussi efficaces qu'une seule plus grosse clairement d&eacute;finie comme unit&eacute; de travail.
                Ce dernier choix et en plus beaucoup plus facile a maintenir et &agrave; faire &eacute;voluer.
            </p><p>
                Le pattern d'utilisation le plus fr&eacute;quemment rencontr&eacute; dans des applications clients serveur
                multi-usagers est le <span class="emphasis"><em>session-per-request</em></span>
                (litt&eacute;ralement : Session par requ&ecirc;te). Dans ce mod&egrave;le, la requ&ecirc;te d'un client est envoy&eacute;e &agrave; un serveur
                (O&ugrave; la couche de persistance est impl&eacute;ment&eacute;e via Hibernate), une nouvelle
                <tt class="literal">Session</tt> est ouverte et toutes les op&eacute;rations d'acc&egrave;s &agrave; la base de donn&eacute;es sont ex&eacute;cut&eacute;es &agrave; l'int&eacute;rieur de
                celle-ci. Lorsque le travail est termin&eacute; (et que les r&eacute;ponses &agrave; envoyer au client ont &eacute;t&eacute; pr&eacute;par&eacute;es), la
                session est flush&eacute;e et ferm&eacute;e. Une seule transaction &agrave; la base de donn&eacute;es peut &ecirc;tre utilis&eacute;e pour r&eacute;pondre
                &agrave; la requ&ecirc;te du client. La transaction est d&eacute;marr&eacute;e et valid&eacute;e au m&ecirc;me moment o&ugrave; la Session est ouverte 
                et ferm&eacute;e. La relation entre la <tt class="literal">Session</tt> et la <tt class="literal">Transaction</tt> est donc one-to-one. 
                Ce mod&egrave;le permet de r&eacute;pondre parfaitement aux attentes de la grande majorit&eacute; des
                applications.
            </p><p>
                Le d&eacute;fi r&eacute;side dans l'impl&eacute;mentation. Hibernate fournit une fonction de gestion de
                la "session courante" pour simplifier ce pattern. Tout ce que vous devez faire
                est d&eacute;marrer une transaction lorsqu'une requ&ecirc;te est trait&eacute;e par le serveur, et
                la terminer avant que la r&eacute;ponse ne soit envoy&eacute;e au client. Vous pouvez le faire
                de la mani&egrave;re que vous voulez, les solutions communes sont un <tt class="literal">ServletFilter</tt>, 
                l'interception via AOP avec une pointcut sur les m&eacute;thodes de type "service", ou un conteneur
                avec interception/proxy. Un conteneur EJB est un moyen standard d'impl&eacute;menter ce genre d'acpect
                tranverse comme la d&eacute;marcation des transactions sur les EJBs session, de mani&egrave;re d&eacute;clarative
                avec CMT. Si vous d&eacute;cidez d'utiliser la d&eacute;marcation programmatique des transactions, pr&eacute;ferrez
                l'API Hibernate <tt class="literal">Transaction</tt> d&eacute;taill&eacute;e plus tard dans ce chapitre, afin de
                facilit&eacute; l'utilisation et la portabilit&eacute; du code.
            </p><p>
                Votre application peut acc&eacute;der la "session courante" pour ex&eacute;cuter une requ&ecirc;te
                en invoquant simplement <tt class="literal">sessionFactory.getCurrentSession()</tt> n'importe o&ugrave;
                et autant de fois que souhait&eacute;. Vous obtiendrez toujours une <tt class="literal">Session</tt> 
                dont le scope est la transaction courante avec la base de donn&eacute;es. Ceci doit &ecirc;tre configur&eacute; 
                soit dans les ressources local ou dans l'environnement JTA, voir <a href="#architecture-current-session" title="2.5.&nbsp;Sessions Contextuelles">Section&nbsp;2.5, &laquo;&nbsp;Sessions Contextuelles&nbsp;&raquo;</a>.
            </p><p>
                Il est parfois utile d'&eacute;tendre le scope d'une <tt class="literal">Session</tt> et d'une transaction
                &agrave; la base de donn&eacute;es jusqu'&agrave; ce que "la vue soit rendue". Ceci est particuli&egrave;rement
                utile dans des applications &agrave; base de servlet qui utilisent une phase de rendue s&eacute;par&eacute;e une fois
                que la r&eacute;ponse a &eacute;t&eacute; pr&eacute;par&eacute;e. Etendre la transaction avec la base de donn&eacute;es jusqu'&agrave; la fin du
                rendering de la vue est ais&eacute; si vous impl&eacute;mentez  votre propre intercepteur. Cependant,
                ce n'est pas facile si vous vous appuyez sur les EJBs avec CMT, puisqu'une transaction sera
                achev&eacute;e au retour de la m&eacute;thode EJB, avant le rendu de la vue. Rendez vous sur le site
                Hibernate et sur le forum pour des astuces et des exemples sur le pattern
                <span class="emphasis"><em>Open Session in View</em></span> pattern..
             </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-basics-apptx"></a>11.1.2.&nbsp;Longue conversation</h3></div></div><div></div></div><p>Le paradigme
                <span class="emphasis"><em>session-per-request</em></span>
                n'est pas le seul &eacute;l&eacute;ment &agrave; utiliser dans le design de vos unit&eacute;s de travail. Plusieurs processus
                d'affaire requi&egrave;rent toute une s&eacute;rie d'interactions avec l'utilisateur, entrelac&eacute;es d'acc&egrave;s &agrave; la base de
                donn&eacute;e. Dans une application Web ou une application d'entreprise, il serait inacceptable que la dur&eacute;e de
                vie d'une transaction s'&eacute;tale sur plusieurs interactions avec l'usager. Consid&eacute;rez l'exemple suivant:
            </p><div class="itemizedlist"><ul type="disc"><li><p>Un &eacute;cran s'affiche. Les donn&eacute;es vues par l'usager ont &eacute;t&eacute; charg&eacute;es dans l'instance d'un objet
                        <tt class="literal">Session</tt> , dans le cadre d'une transaction de base de donn&eacute;es. L'usager est libre de modifier ces objets.
                    </p></li><li><p>L'usager clique "Sauvegarder" apr&egrave;s 5 minutes et souhaite persister les modifications qu'il a
                        apport&eacute;es. Il s'attend &agrave; &ecirc;tre la seule personne a avoir modifi&eacute; ces donn&eacute;es et qu'aucune
                        modification conflictuelle ne se soit produite durant ce laps de temps.</p></li></ul></div><p>Ceci s'appelle une unit&eacute; de travail. Du point de vue de l'utilisateur: une
                <span class="emphasis"><em>conversation</em></span> (ou <span class="emphasis"><em>transaction d'application</em></span>).
                Il y a plusieurs fa&ccedil;on de mettre ceci en place dans votre application.
            </p><p>Une premi&egrave;re impl&eacute;mentation na&iuml;ve pourrait consister &agrave; garder la
                <tt class="literal">Session</tt> et la transaction &agrave; la base de donn&eacute;es ouvertes durant le temps de travail de l'usager, &agrave; maintenir les
                enregistrements verrouill&eacute;s dans la base de donn&eacute;es afin d'&eacute;viter des modifications concurrentes et de
                maintenir l'isolation et l'atomicit&eacute; de la transaction de l'usager. Ceci est un anti-pattern &agrave; &eacute;viter,
                puisque le verrouillage des enregistrements dans la base de donn&eacute;es ne permettrait pas &agrave; l'application
                de g&eacute;rer un grand nombre d'usagers concurrents.
            </p><p>Il appara&icirc;t donc &eacute;vident qu'il faille utiliser plusieurs transactions BDD afin d'impl&eacute;menter la
                conversation. Dans ce cas, maintenir l'isolation des processus d'affaire devient
                partiellement la responsabilit&eacute; de la couche applicative. Ainsi, la dur&eacute;e de vie d'une conversation
                devrait englober celle d'une ou de plusieurs transactions de base de donn&eacute;es. Celle-ci sera
                atomique seulement si l'&eacute;criture des donn&eacute;es mises &agrave; jour est faite exclusivement par la derni&egrave;re
                transaction BDD la composant. Toutes les autres sous transactions BD ne doivent faire que la lecture de
                donn&eacute;es. Ceci est relativement facile &agrave; mettre en place, surtout avec l'utilisation de certaines
                fonctionnalit&eacute;s d'Hibernate:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        <span class="emphasis"><em>Versionnage Automatique</em></span>
                        - Hibernate peut g&eacute;rer automatiquement les acc&egrave;s concurrents de mani&egrave;re optimiste et d&eacute;tecter si
                        une modification concurrente s'est produite durant le temps de r&eacute;flexion d'un usager.
                    </p></li><li><p>
                        <span class="emphasis"><em>Objets D&eacute;tach&eacute;s</em></span>
                        - Si vous d&eacute;cidez d'utiliser le paradigme
                        <span class="emphasis"><em>session-par-requ&ecirc;te</em></span>
                        discut&eacute; plus haut, toutes les entit&eacute;s charg&eacute;es en m&eacute;moire deviendront des objets d&eacute;tach&eacute;s durant
                        le temps de r&eacute;flexion de l'usager. Hibernate vous permet de rattacher ces objets et de persister
                        les modifications y ayant &eacute;t&eacute; apport&eacute;es. Ce pattern est appel&eacute;:
                        <span class="emphasis"><em>session-per- request-with-detached-objects</em></span>
                        (litt&eacute;ralement: session- par-requ&ecirc;te-avec-objets-d&eacute;tach&eacute;s). Le versionnage automatique est
                        utilis&eacute; afin d'isoler les modifications concurrentes.
                    </p></li><li><p>
                        <span class="emphasis"><em>Session Longues (conversation)</em></span>
                        - Une
                        <tt class="literal">Session</tt> Hibernate peut &ecirc;tre d&eacute;connect&eacute;e de la couche JDBC sous-jacente apr&egrave;s que commit() ait &eacute;t&eacute; appel&eacute;
                        sur une transaction &agrave; la base de donn&eacute;es et reconnect&eacute;e lors d'une nouvelle requ&ecirc;te-client. Ce
                        pattern s'appelle:
                        <span class="emphasis"><em>session-per-conversation</em></span>
                        (Litt&eacute;ralement: session-par- conversation) et rend superflu le rattachement des
                        objets. Le versionnage automatique est utilis&eacute; afin d'isoler les modifications concurrentes.
                    </p></li></ul></div><p>Les deux patterns
                <span class="emphasis"><em>session-per-request-with- detached- objects</em></span>
                (session-par-requ&ecirc;te-avec-objets- d&eacute;tach&eacute;s) et
                <span class="emphasis"><em>session-per-conversation</em></span>
                (session-par-conversation) ont chacun leurs avantages et d&eacute;savantages qui seront expos&eacute;s
                dans ce m&ecirc;me chapitre, dans la section au sujet du contr&ocirc;le optimiste de concurrence.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-basics-identity"></a>11.1.3.&nbsp;L'identit&eacute; des objets</h3></div></div><div></div></div><p>Une application peut acc&eacute;der &agrave; la m&ecirc;me entit&eacute; persistante de mani&egrave;re concurrente dans deux
                <tt class="literal">Session</tt> s diff&eacute;rentes. Toutefois, une instance d'une classe persistante n'est jamais partag&eacute;e par deux instances
                distinctes de la classe
                <tt class="literal">Session</tt> . Il existe donc deux notions de l'identit&eacute; d'un objet:
            </p><div class="variablelist"><dl><dt><span class="term">Identit&eacute; BD</span></dt><dd><p>
                            <tt class="literal">foo.getId().equals( bar.getId() )</tt> </p></dd><dt><span class="term">Identit&eacute; JVM</span></dt><dd><p>
                            <tt class="literal">foo==bar</tt> </p></dd></dl></div><p>Ainsi, pour des objets attach&eacute;s &agrave; une
                <tt class="literal">Session</tt> <span class="emphasis"><em>pr&eacute;cise</em></span>
                (dans la cadre d'ex&eacute;cution (scope) d'une instance de
                <tt class="literal">Session</tt> ), ces deux notions d'identit&eacute; sont &eacute;quivalentes et garanties par Hibernate. Par contre, si une
                application peut acc&eacute;der de mani&egrave;re concurrente &agrave; la m&ecirc;me entit&eacute; persistante dans deux sessions
                diff&eacute;rentes, les deux instances seront en fait diff&eacute;rentes (en ce qui a trait &agrave; l'identit&eacute; JVM). Les
                conflits sont r&eacute;solus automatiquement par approche optimiste gr&acirc;ce au syst&egrave;me de versionnage automatique
                lorsque
                <tt class="literal">Session.flush()</tt> ou
                <tt class="literal">Transaction.commit()</tt> est appel&eacute;.
            </p><p>Cette approche permet de rel&eacute;guer &agrave; Hibernate et &agrave; la base de donn&eacute;es sous-jacente le soin de g&eacute;rer
                les probl&egrave;mes d'acc&egrave;s concurrents. Cette mani&egrave;re de faire assure &eacute;galement une meilleure extensibilit&eacute;
                de l'application puisque assurer l'identit&eacute; JVM dans un thread ne n&eacute;cessite pas de m&eacute;canismes de
                verrouillage co&ucirc;teux ou d'autres dispositifs de synchronisation. Une application n'aura jamais le besoin
                de synchroniser des objets d'affaire tant qu'elle peut garantir qu'un seul thread aura acc&egrave;s &agrave; une
                instance de
                <tt class="literal">Session</tt> . Dans le cadre d'ex&eacute;cution d'un objet
                <tt class="literal">Session</tt> , l'application peut utiliser en toute s&eacute;curit&eacute; <tt class="literal">==
            </tt> pour comparer des objets.
        </p><p>
            Une application qui utiliserait <tt class="literal">==</tt> &agrave; l'ext&eacute;rieur du cadre d'ex&eacute;cution d'une <tt class="literal">Session</tt> 
            pourrait obtenir des r&eacute;sultats inattendus et causer certains effets de bords. Par exemple, si vous mettez 2
            objets dans le m&ecirc;me <tt class="literal">Set</tt> , ceux-ci pourraient avoir la m&ecirc;me identit&eacute; BD (i.e. ils repr&eacute;sentent le m&ecirc;me enregistrement), mais leur
            identit&eacute; JVM pourrait &ecirc;tre diff&eacute;rente (elle ne peut, par d&eacute;finition, pas &ecirc;tre garantie sur deux objets
            d&eacute;tach&eacute;s). Le d&eacute;veloppeur doit donc red&eacute;finir l'impl&eacute;mentation des m&eacute;thodes <tt class="literal">equals()</tt> et <tt class="literal">hashcode()</tt> 
            dans les classes persistantes et y adjoindre sa propre notion d'identit&eacute;. Il existe toutefois une
            restriction: Il ne faut jamais utiliser uniquement l'identifiant de la base de donn&eacute;es dans l'impl&eacute;mentation
            de l'&eacute;galit&eacute;; Il faut utiliser une cl&eacute; d'affaire, g&eacute;n&eacute;ralement une combinaison de plusieurs attributs
            uniques, si possible immuables. Les identifiants de base de donn&eacute;es vont changer si un objet transitoire
            (transient) devient persistant. Si une instance transitoire est contenue dans un <tt class="literal">Set</tt> ,
            changer le hashcode brisera le contrat du <tt class="literal">Set</tt> . Les attributs pour les cl&eacute;s d'affaire 
            n'ont pas &agrave; &ecirc;tre aussi stables que des cl&eacute;s primaires de bases de
            donn&eacute;es. Il suffit simplement qu'elles soient stables tant et aussi longtemps que les objets sont dans le
            m&ecirc;me <tt class="literal">Set</tt> . Veuillez consulter le site web Hibernate pour des discussions plus pointues &agrave; ce sujet. Notez que ce
            concept n'est pas propre &agrave; Hibernate mais bien g&eacute;n&eacute;ral &agrave; l'impl&eacute;mentation de l'identit&eacute; et de l'&eacute;galit&eacute; en
            Java.
        </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-basics-issues"></a>11.1.4.&nbsp;Probl&egrave;mes communs</h3></div></div><div></div></div><p>Bien qu'il puisse y avoir quelques rares exceptions &agrave; cette r&egrave;gle, il est recommand&eacute; de ne jamais utiliser
            les anti-patterns
            <span class="emphasis"><em>session-per- user-session</em></span>
            et
            <span class="emphasis"><em>session-per-application</em></span>
            . Vous trouverez ici- bas quelques probl&egrave;mes que vous risquez de rencontrer si vous en faite l?utilisation.
            (Ces probl&egrave;mes pourraient quand m&ecirc;me survenir avec des patterns recommand&eacute;s) Assurez-vous de bien comprendre
            les implications de chacun des patterns avant de prendre votre d&eacute;cision.
        </p><div class="itemizedlist"><ul type="disc"><li><p>L'objet
                    <tt class="literal">Session</tt> n?est pas con&ccedil;u pour &ecirc;tre utilis&eacute; par de multiples threads. En cons&eacute;quence, les objets
                    potentiellement multi-thread comme les requ&ecirc;tes HTTP, les EJB Session et Swing Worker, risquent de
                    provoquer des conditions de course dans la
                    <tt class="literal">Session</tt> si celle-ci est partag&eacute;e. Dans un environnement web classique, il serait pr&eacute;f&eacute;rable de synchroniser
                    les acc&egrave;s &agrave; la session http afin d?&eacute;viter qu?un usager ne recharge une page assez rapidement pour
                    que deux requ&ecirc;tes s?ex&eacute;cutant dans des threads concurrents n?utilisent la m&ecirc;me
                    <tt class="literal">Session</tt> .
                </p></li><li><p>Lorsque Hibernate lance une exception, le roll back de la transaction en cours doit &ecirc;tre effectu&eacute;
                    et la
                    <tt class="literal">Session</tt> doit &ecirc;tre imm&eacute;diatement ferm&eacute;e. (Ceci sera explor&eacute; plus tard dans le chapitre.) Si la
                    <tt class="literal">Session</tt> est directement associ&eacute;e &agrave; une application, il faut arr&ecirc;ter l?application. Le roll back de la
                    transaction ne remettra pas les objets dans leur &eacute;tat du d&eacute;but de la transaction. Ainsi, ceux-ci
                    pourraient &ecirc;tre d&eacute;synchronis&eacute;s d?avec les enregistrements. (G&eacute;n&eacute;ralement, cela ne cause pas de r&eacute;els
                    probl&egrave;mes puisque la plupart des exceptions sont non traitables et requi&egrave;rent la reprise du
                    processus d?affaire ayant &eacute;chou&eacute;.)
                </p></li><li><p>La
                    <tt class="literal">Session</tt> met en m&eacute;moire cache tous les objets persistants (les objets surveill&eacute;s et dont l'&eacute;tat est g&eacute;r&eacute; par
                    Hibernate.) Si la
                    <tt class="literal">Session</tt> est ouverte ind&eacute;finiment ou si une trop grande quantit&eacute; d'objets y est charg&eacute;e, l?utilisation de la
                    m&eacute;moire peut potentiellement cro&icirc;tre jusqu?&agrave; atteindre le maximum allouable &agrave; l?application
                    (java.lang.OutOfMemoryError.) Une solution &agrave; ce probl&egrave;me est d?appeler les m&eacute;thodes
                    <tt class="literal">Session.clear()</tt> et
                    <tt class="literal">Session.evict()</tt> pour g&eacute;rer la m&eacute;moire cache de la
                    <tt class="literal">Session</tt> . Vous pouvez &eacute;galement utiliser des stored procedures si vous devez lancer des traitements sur de
                    grandes quantit&eacute;s d?informations. Certaines solutions sont d&eacute;crites ici :
                    <a href="#batch" title="Chapitre&nbsp;13.&nbsp;Traitement par paquet">Chapitre&nbsp;13, <i>Traitement par paquet</i></a>
                    . Garder une
                    <tt class="literal">Session</tt> ouverte pour toute la dur&eacute;e d?une session usager augmente &eacute;galement consid&eacute;rablement le risque de
                    travailler avec de l?information p&eacute;rim&eacute;e.
                </p></li></ul></div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-demarcation"></a>11.2.&nbsp;D&eacute;marcation des transactions</h2></div></div><div></div></div><p>La d&eacute;marcation des transactions est importante dans le design d?une application. Aucune communication avec la
        base de donn&eacute;es ne peut &ecirc;tre effectu&eacute;e &agrave; l?ext&eacute;rieur du cadre d?une transaction. (Il semble que ce concept soit
        mal compris par plusieurs d&eacute;veloppeurs trop habitu&eacute;s &agrave; utiliser le mode auto-commit.) M&ecirc;me si certains niveaux
        d'isolation et certaines possibilit&eacute;s offertes par les bases de donn&eacute;es permettent de l?&eacute;viter, il n'est jamais
        d&eacute;savantageux de toujours explicitement indiquer les bornes de transaction pour les op&eacute;rations complexes comme
        pour les op&eacute;rations simples de lecture.</p><p>Une application utilisant Hibernate peut s'ex&eacute;cuter dans un environnement l&eacute;ger n?offrant pas la gestion
        automatique des transactions (application autonome, application web simple ou applications Swing) ou dans un
        environnement J2EE offrant des services de gestion automatique des transactions JTA. Dans un environnement
        simple, Hibernate a g&eacute;n&eacute;ralement la responsabilit&eacute; de la gestion de son propre pool de connexions &agrave; la base de
        donn&eacute;es. Le d&eacute;veloppeur de l'application doit manuellement d&eacute;limiter les transactions. En d'autres mots, il
        appartient au d&eacute;veloppeur de g&eacute;rer les appels &agrave;
        <tt class="literal">Transaction.begin()</tt>
        ,
        <tt class="literal">Transaction.commit()</tt>
        et
        <tt class="literal">Transaction.rollback()</tt>
        . Un environnement transactionnel J2EE (serveur d'application J2EE) doit offrir la gestion des transactions au
        niveau du container J2EE. Les bornes de transaction peuvent normalement &ecirc;tre d&eacute;finies de mani&egrave;re d&eacute;clarative
        dans les descripteurs de d&eacute;ploiement d'EJB Session, par exemple. La gestion programmatique des transactions n'y
        est donc pas n&eacute;cessaire. M&ecirc;me les appels &agrave;
        <tt class="literal">Session.flush()</tt>
        sont faits automatiquement.
    </p><p>Il peut &ecirc;tre requis d'avoir une couche de persistance portable. Hibernate offre donc une API appel&eacute;e
        <tt class="literal">Transaction</tt>
        qui sert d'enveloppe pour le syst&egrave;me de transaction natif de l'environnement de d&eacute;ploiement. Il n'est pas
        obligatoire d'utiliser cette API mais il est fortement conseill&eacute; de le faire, sauf lors de l'utilisation de CMT
        Session Bean (EJB avec transactions g&eacute;r&eacute;es automatiquement par le container EJB).
    </p><p>Il existe quatre &eacute;tapes disctinctes lors de la fermeture d'une
        <tt class="literal">Session</tt>
    </p><div class="itemizedlist"><ul type="disc" compact><li><p>flush de la session</p></li><li><p>commit de la transaction</p></li><li><p>Fermeture de la session (Close)</p></li><li><p>Gestion des exceptions</p></li></ul></div><p>La synchronisation de bdd depuis la session (flush) a d&eacute;j&agrave; &eacute;t&eacute; expliqu&eacute;, nous nous attarderons maintenant &agrave; la d&eacute;marcation des
        transactions et &agrave; la gestion des exceptions dans les environnements l&eacute;gers et les environnements J2EE.</p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-demarcation-nonmanaged"></a>11.2.1.&nbsp;Environnement non manag&eacute;</h3></div></div><div></div></div><p>
            Si la couche de persistance Hibernate s'ex&eacute;cute dans un environnement non manag&eacute;, les connexions &agrave; la base de
            donn&eacute;es seront g&eacute;n&eacute;ralement prises en charge par le m&eacute;canisme de pool d'Hibernate. La gestion de la session
            et de la transaction se fera donc de la mani&egrave;re suivante:</p><pre class="programlisting">// Non-managed environment idiom
Session sess = factory.openSession();
Transaction tx = null;
try {
    tx = sess.beginTransaction();

    // do some work
    ...

    tx.commit();
}
catch (RuntimeException e) {
    if (tx != null) tx.rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}</pre><p>
                Vous n'avez pas &agrave; invoquer <tt class="literal">flush()</tt> explicitement sur la <tt class="literal">Session</tt> -
                l'appel de <tt class="literal">commit()</tt> d&eacute;clenchera automatiquement la synchronisation (selon le <a href="#objectstate-flushing" title="10.10.&nbsp;Flush de la session">Section&nbsp;10.10, &laquo;&nbsp;Flush de la session&nbsp;&raquo;</a> 
                de la session. Un appel &agrave; <tt class="literal">close()</tt> marque la fin de la session.
                La cons&eacute;quence directe est que la connexion &agrave; la base de donn&eacute;es sera relach&eacute;e par la session.
                Ce code est portable est fonctionne dans les environnements non manag&eacute; ET les environnements JTA.
            </p><p>
                Une solution plus flexible est la gestion par contexte fourni par Hibernate que nous avons
                d&eacute;j&agrave; rencontr&eacute;:
            </p><pre class="programlisting">// Non-managed environment idiom with getCurrentSession()
try {
    factory.getCurrentSession().beginTransaction();

    // do some work
    ...

    factory.getCurrentSession().getTransaction().commit();
}
catch (RuntimeException e) {
    factory.getCurrentSession().getTransaction().rollback();
    throw e; // or display error message
}</pre><p>
                Vous ne verrez probablement jamais ces exemples de code dans les applications;
                les exceptions fatales (exceptions du syst&egrave;me) ne devraient &ecirc;tre trait&eacute;es que
                dans la couche la plus "haute". En d'autres termes, le code qui ex&eacute;cute les appels
                &agrave; Hibernate (&agrave; la couche de persistance) et le code qui g&egrave;re les
                <tt class="literal">RuntimeException</tt> (qui ne peut g&eacute;n&eacute;ralement effectuer qu'un nettoyage et une sortie) 
                sont dans des couches diff&eacute;rentes. La gestion du contexte courant par Hibernate peut
                simplifier notablement ce design, puisque vous devez acc&eacute;der &agrave; la gestion des exceptions
                de la <tt class="literal">SessionFactory</tt>, ce qui est d&eacute;crit plus tard dans ce chapitre.
            </p><p>
                Notez que vous devriez s&eacute;lectionner <tt class="literal">org.hibernate.transaction.JDBCTransactionFactory</tt>
                (le d&eacute;faut), pour le second exemple <tt class="literal">"thread"</tt> comme
                <tt class="literal">hibernate.current_session_context_class</tt>.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-demarcation-jta"></a>11.2.2.&nbsp;Utilisation de JTA</h3></div></div><div></div></div><p>Si votre couche de persistance s'ex&eacute;cute dans un serveur d'application (par exemple, derri&egrave;re un EJB
            Session Bean), toutes les datasource utilis&eacute;es par Hibernate feront automatiquement partie de transactions
            JTA globales. Hibernate propose deux strat&eacute;gies pour r&eacute;ussir cette int&eacute;gration.</p><p>
            Si vous utilisez des transactions g&eacute;r&eacute;es par un EJB (bean managed transactions - BMT), Hibernate informera
            le serveur d'application du d&eacute;but et de la fin des transactions si vous utilisez l'API <tt class="literal">Transaction</tt> . 
            Ainsi, le code de gestion des transactions sera identique dans les deux types d'environnements.
        </p><pre class="programlisting">// BMT idiom
Session sess = factory.openSession();
Transaction tx = null;
try {
    tx = sess.beginTransaction();

    // do some work
    ...

    tx.commit();
}
catch (RuntimeException e) {
    if (tx != null) tx.rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}</pre><p>Ou encore, avec la gestion automatique de contexte:</p><pre class="programlisting">// BMT idiom with getCurrentSession()
try {
    factory.getCurrentSession().beginTransaction();

    // do some work
    ...

    factory.getCurrentSession().getTransaction().commit();
}
catch (RuntimeException e) {
    factory.getCurrentSession().getTransaction().rollback();
    throw e; // or display error message
}</pre><p>
            Avec CMT, la d&eacute;marcation des transactions est faite dans les descripteurs de d&eacute;ploiement des Beans Sessions et non
            de mani&egrave;re programmmatique, ceci r&eacute;duit le code:
        </p><pre class="programlisting">// CMT idiom
 Session sess = factory.getCurrentSession();

 // do some work
 ...
</pre><p>
            Dans un EJB CMT m&ecirc;me le rollback intervient automatiquement, puisqu'une <tt class="literal">RuntimeException</tt>
            non trait&eacute;e et soulev&eacute;e par une m&eacute;thode d'un bean session indique au conteneur d'annuler la transaction
            globale. <span class="emphasis"><em>Ceci veut donc dire que vous n'avez pas &agrave; utiliser l'API <tt class="literal">Transaction</tt> d'Hibernate
            dans CMT.</em></span>
        </p><p>
            Notez que le fichier de configuration Hibernate devrait contenir les valeurs 
            <tt class="literal">org.hibernate.transaction.JTATransactionFactory</tt> dans un environnement BMT ou 
            <tt class="literal">org.hibernate.transaction.CMTTransactionFactory</tt> dans un environnement CMT l&agrave;  o&ugrave; vous
            configurez votre transaction factory Hibernate. 
            N'oubliez pas non plus de sp&eacute;cifier le param&egrave;tre <tt class="literal">org.hibernate.transaction.manager_lookup_class</tt> .
            De plus, assurez vous de fixez votre <tt class="literal">hibernate.current_session_context_class</tt> soit &agrave; <tt class="literal">"jta"</tt>
            ou de ne pas le configurer (compatibilit&eacute; avec les versions pr&eacute;c&eacute;dentes).
        </p><p>
            La m&eacute;thode <tt class="literal">getCurrentSession()</tt> a un inconv&eacute;nient dans les environnement JTA.
            Il y a une astuce qui est d'utiliser un mode de lib&eacute;ration de connexion <tt class="literal">after_statement</tt> ,
            qui est alors utilis&eacute; par d&eacute;faut. Du &agrave; une &eacute;trange limitation de la spec JTA, il n'est pas possible
            pour Hibernate de nettoyer et ferme automatiquement un <tt class="literal">ScrollableResults</tt> ouvert
            ou une instance d'<tt class="literal">Iterator</tt> retourn&eacute;s <tt class="literal">scroll()</tt> ou
            <tt class="literal">iterate()</tt>. Vous <span class="emphasis"><em>devez</em></span> lib&eacute;rer le curseur base de donn&eacute;es
            sous jacent ou invoquer <tt class="literal">Hibernate.close(Iterator)</tt> explicitement depuis un
            bloc <tt class="literal">finally</tt>. (Bien sur, la plupart des applications peuvent &eacute;viter
            d'uiliser <tt class="literal">scroll()</tt> ou <tt class="literal">iterate()</tt> dans un code CMT.)
        </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-demarcation-exceptions"></a>11.2.3.&nbsp;Gestion des exceptions</h3></div></div><div></div></div><p>
            Si une <tt class="literal">Session</tt> lance une exception (incluant les exceptions du type <tt class="literal">SQLException</tt> 
            ou d'un sous-type), vous devez imm&eacute;diatement faire le rollback de la transaction, appeler <tt class="literal">Session.close()</tt> 
            et rel&acirc;cher les r&eacute;f&eacute;rences sur l'objet <tt class="literal">Session</tt> . La <tt class="literal">Session</tt> contient des m&eacute;thodes 
            pouvant la mettre dans un &eacute;tat inutilisable. Vous devez consid&eacute;rer qu'<span class="emphasis"><em>aucune</em></span>
            exception lanc&eacute;e par Hibernate n'est traitable. Assurez-vous de fermer la session en faisant l'appel &agrave; 
            <tt class="literal">close()</tt> dans un bloc <tt class="literal">finally</tt> .
        </p><p>
            L'exception <tt class="literal">HibernateException</tt> , qui englobe la plupart des exceptions pouvant survenir dans la 
            couche de persistance Hibernate, est une exception non v&eacute;rifi&eacute;e (Ceci n'&eacute;tait pas le cas dans certaines versions ant&eacute;rieures de Hibernate.) Il est de
            notre avis que nous ne devrions pas forcer un d&eacute;veloppeur &agrave; g&eacute;rer une exception qu'il ne peut de toute fa&ccedil;on
            pas traiter dans une couche technique. Dans la plupart des applications, les exceptions non v&eacute;rifi&eacute;es et les
            exceptions fatales sont g&eacute;r&eacute;es en amont du processus (dans les couches hautes) et un message d'erreur est
            alors affich&eacute; &agrave; l'usager (ou un traitement alternatif est invoqu&eacute;.) Veuillez noter qu'Hibernate peut
            &eacute;galement lancer des exceptions non v&eacute;rifi&eacute;es d'un autre type que <tt class="literal">HibernateException</tt> . Celles-ci sont 
            &eacute;galement non traitables et vous devez les traiter comme telles.
        </p><p>
            Hibernate englobe les <tt class="literal">SQLException</tt> s lanc&eacute;es lors des interactions directes avec la base de donn&eacute;es 
            dans des exceptions de type: <tt class="literal">JDBCException</tt> . En fait, Hibernate essaiera de convertir l'exception dans 
            un sous-type plus significatif de <tt class="literal">JDBCException</tt> . L'exception <tt class="literal">SQLException</tt> sous-jacente 
            est toujours disponible via la m&eacute;thode <tt class="literal">JDBCException.getCause()</tt> . Cette conversion est faite par un objet 
            de type <tt class="literal">SQLExceptionConverter</tt> , qui est rattach&eacute; &agrave; l'objet <tt class="literal">SessionFactory</tt> . 
            Par d&eacute;faut, le <tt class="literal">SQLExceptionConverter</tt> est associ&eacute; au dialecte de BD configur&eacute; dans Hibernate. Toutefois, 
            il est possible de fournir sa propre impl&eacute;mentation de l'interface. (Veuillez vous r&eacute;f&eacute;rer &agrave; la javadoc sur la classe 
            <tt class="literal">SQLExceptionConverterFactory</tt> pour plus de d&eacute;tails. Les sous-types standard de <tt class="literal">JDBCException</tt> sont:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">JDBCConnectionException</tt> - Indique une erreur de communication avec la couche JDBC sous-jacente.
                </p></li><li><p>
                    <tt class="literal">SQLGrammarException</tt> - Indique un probl&egrave;me de grammaire ou de syntaxe avec la requ&ecirc;te SQL envoy&eacute;e.
                </p></li><li><p>
                    <tt class="literal">ConstraintViolationException</tt> - Indique une violation de contrainte d'int&eacute;grit&eacute;.
                </p></li><li><p>
                    <tt class="literal">LockAcquisitionException</tt> - Indique une erreur de verrouillage lors de l'&eacute;x&eacute;cution de la requ&ecirc;te.
                </p></li><li><p>
                    <tt class="literal">GenericJDBCException</tt> - Indique une erreur g&eacute;n&eacute;rique JDBC d'une autre cat&eacute;gorie.
                </p></li></ul></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-demarcation-timeout"></a>11.2.4.&nbsp;Timeout de transaction</h3></div></div><div></div></div><p>L'un des avantages fournis par les environnements transactionnels JTA (tels les containers EJB) est la
            gestion du timeout de transaction. La gestion des d&eacute;passements de temps de transaction vise &agrave; s'assurer
            qu'une transaction agissant incorrectement ne viendra pas bloquer ind&eacute;finiment les ressources de
            l'application. Hibernate ne peut fournir cette fonctionnalit&eacute; dans un environnement transactionnel non-JTA.
            Par contre, Hibernate g&egrave;re les op&eacute;rations d'acc&egrave;s aux donn&eacute;es en allouant un temps maximal aux requ&ecirc;tes pour
            s'ex&eacute;cuter. Ainsi, une requ&ecirc;te cr&eacute;ant de l'inter blocage ou retournant de tr&egrave;s grandes quantit&eacute;s
            d'information pourrait &ecirc;tre interrompue. Dans un environnement transactionnel JTA, Hibernate peut d&eacute;l&eacute;guer
            au gestionnaire de transaction le soin de g&eacute;rer les d&eacute;passements de temps. Cette fonctionnalit&eacute; est
            abstraite par l'objet <tt class="literal">Transaction</tt> .
        </p><pre class="programlisting">
        Session sess = factory.openSession();
        try {
            //mettre le timeout &agrave; 3 secondes.
            sess.getTransaction().setTimeout(3);
            sess.getTransaction().begin();

            // Effectuer le travail ...

            sess.getTransaction().commit()
        }
        catch (RuntimeException e) {
            if ( sess.getTransaction().isActive() ) {
                sess.getTransaction().rollback();
            }
            throw e;
            // ou afficher le message d'erreur.
        }
        finally {
            sess.close();
        }</pre><p>
            Notez que <tt class="literal">setTimeout()</tt> ne peut pas &ecirc;tre appel&eacute; d'un EJB CMT, puisque le timeout 
            des transaction doit &ecirc;tre sp&eacute;cifi&eacute; de mani&egrave;re d&eacute;clarative.
        </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-optimistic"></a>11.3.&nbsp;Contr&ocirc;le de consurrence optimiste</h2></div></div><div></div></div><p>La gestion optimiste des acc&egrave;s concurrents avec versionnage est la seule approche pouvant garantir
        l'extensibilit&eacute; des applications &agrave; haut niveau de charge. Le syst&egrave;me de versionnage utilise des num&eacute;ros de
        version ou l'horodatage pour d&eacute;tecter les mises &agrave; jour causant des conflits avec d'autres actualisations
        ant&eacute;rieures. Hibernate propose trois approches pour l'&eacute;criture de code applicatif utilisant la gestion optimiste
        d'acc&egrave;s concurrents. Le cas d'utilisation d&eacute;crit plus bas fait mention de conversation,
        mais le versionnage peut &eacute;galement am&eacute;liorer la qualit&eacute; d'une application en pr&eacute;venant la perte de mises &agrave;
        jour.</p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-manual"></a>11.3.1.&nbsp;Gestion du versionnage au niveau applicatif</h3></div></div><div></div></div><p>Dans cet exemple d'impl&eacute;mentation utilisant peu les fonctionnalit&eacute;s d'Hibernate, chaque interaction avec
            la base de donn&eacute;es se fait en utilisant une nouvelle <tt class="literal">Session</tt> et le d&eacute;veloppeur doit recharger 
            les donn&eacute;es persistantes &agrave; partir de la BD avant de les manipuler. Cette
            impl&eacute;mentation force l'application &agrave; v&eacute;rifier la version des objets afin de maintenir l'isolation
            transactionnelle. Cette approche, semblable &agrave; celle retrouv&eacute;e pour les EJB, est la moins efficace de celles
            pr&eacute;sent&eacute;es dans ce chapitre.
        </p><pre class="programlisting">
            // foo est une instance charg&eacute;e ant&eacute;rieurement par une autre
            Session session = factory.openSession();
            Transaction t = session.beginTransaction();

            int oldVersion = foo.getVersion();
            session.load( foo, foo.getKey() ); // Charger l'&eacute;tat courant

            if ( oldVersion!=foo.getVersion )
                throw new StaleObjectStateException();

            foo.setProperty("bar");
            t.commit();
            session.close();</pre><p>Le mapping de la propri&eacute;t&eacute; <tt class="literal">version</tt> est fait via <tt class="literal">&lt;version&gt;</tt> et 
        Hibernate l'incr&eacute;mentera automatiquement &agrave; chaque flush() si l'entit&eacute; doit &ecirc;tre mise &agrave; jour.
        </p><p>Bien s&ucirc;r, si votre application ne fait pas face &agrave; beaucoup d'acc&egrave;s concurrents et ne n&eacute;cessite pas
            l'utilisation du versionnage, cette approche peut &eacute;galement &ecirc;tre utilis&eacute;e, il n'y a qu'&agrave; ignorer le code
            reli&eacute; au versionnage. Dans ce cas, la strat&eacute;gie du
            <span class="emphasis"><em>last commit wins</em></span>
            (litt&eacute;ralement: le dernier commit l'emporte) sera utilis&eacute;e pour les conversations (longues transactions applicatives).
            Gardez &agrave; l'esprit que cette approche pourrait rendre perplexe les utilisateurs de l'application car ils
            pourraient perdre des donn&eacute;es mises &agrave; jour sans qu'aucun message d'erreur ne leur soit pr&eacute;sent&eacute; et sans
            avoir la possibilit&eacute; de fusionner les donn&eacute;es.
        </p><p>Il est clair que la gestion manuelle de la v&eacute;rification du versionnage des objets ne peut &ecirc;tre effectu&eacute;e
            que dans certains cas triviaux et que cette approche n'est pas valable pour la plupart des applications. De
            mani&egrave;re g&eacute;n&eacute;rale, les applications ne cherchent pas &agrave; actualiser de simples objets sans relations, elles le
            font g&eacute;n&eacute;ralement pour de larges graphes d'objets. Pour toute application utilisant le paradigme des conversations
             ou des objets d&eacute;tach&eacute;s, Hibernate peut g&eacute;rer automatiquement la v&eacute;rification des versions
            d'objets.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-longsession"></a>11.3.2.&nbsp;Les sessions longues et le versionnage automatique.</h3></div></div><div></div></div><p>Dans ce sc&eacute;nario, une seule instance de <tt class="literal">Session</tt> et des objets persistants est utilis&eacute;e 
            pour toute l'application. Hibernate v&eacute;rifie la version des objets
            persistants avant d'effectuer le flush() et lance une exception si une modification concurrente est
            d&eacute;tect&eacute;e. Il appartient alors au d&eacute;veloppeur de g&eacute;rer l'exception. Les traitements alternatifs g&eacute;n&eacute;ralement
            propos&eacute;s sont alors de permettre &agrave; l'usager de faire la fusion des donn&eacute;es ou de lui offrir de recommencer
            son travail &agrave; partie des donn&eacute;es les plus r&eacute;centes dans la BD.
        </p><p>Il est &agrave; noter que lorsqu'une application est en attente d'une action de la part de l?usager, La <tt class="literal">Session</tt> 
            n'est pas connect&eacute;e &agrave; la couche JDBC sous-jacente. C'est la mani&egrave;re la plus efficace de g&eacute;rer les acc&egrave;s &agrave; la
            base de donn&eacute;es. L'application ne devrait pas se pr&eacute;occuper du versionnage des objets, de la r&eacute;association
            des objets d&eacute;tach&eacute;s, ni du rechargement de tous les objets &agrave; chaque transaction.
        </p><pre class="programlisting">
            // foo est une instance charg&eacute;e ant&eacute;rieurement par une autre session

            session.reconnect();// Obtention d'une nouvelle connexion JDBC
            Transaction t = session.beginTransaction();
            foo.setProperty("bar");
            t.commit(); //Terminer la transaction, propager les changements et v&eacute;rifier les versions.
            session.disconnect(); // Retourner la connexion JDBC
            </pre><p>L'objet <tt class="literal">foo</tt> sait quel objet <tt class="literal">Session</tt> l'a charg&eacute;. <tt class="literal">Session.reconnect()</tt> 
            obtient une nouvelle connexion (celle-ci peut &ecirc;tre &eacute;galement fournie) et permet &agrave; la session de continuer
            son travail. La m&eacute;thode <tt class="literal">Session.disconnect()</tt> d&eacute;connecte la session de la connexion JDBC et 
            retourne celle-ci au pool de connexion (&agrave; moins que vous ne
            lui ayez fourni vous m&ecirc;me la connexion.) Apr&egrave;s la reconnexion, afin de forcer la v&eacute;rification du versionnage
            de certaines entit&eacute;s que vous ne cherchez pas &agrave; actualiser, vous pouvez faire un appel &agrave; <tt class="literal">Session.lock()</tt> 
            en mode <tt class="literal">LockMode.READ</tt> pour tout objet ayant pu &ecirc;tre modifi&eacute; par une autre transaction. Il n'est pas n&eacute;cessaire de verrouiller les
            donn&eacute;es que vous d&eacute;sirez mettre &agrave; jour.
        </p><p>Si des appels implicites aux m&eacute;thodes <tt class="literal">disconnect()</tt> et <tt class="literal">reconnect()</tt> sont trop 
        co&ucirc;teux, vous pouvez les &eacute;viter en utilisant <tt class="literal">hibernate.connection.release_mode</tt> .
        </p><p>Ce pattern peut pr&eacute;senter des probl&egrave;mes si la <tt class="literal">Session</tt> est trop volumineuse pour &ecirc;tre 
            stock&eacute;e entre les actions de l'usager. Plus sp&eacute;cifiquement, une session <tt class="literal">HttpSession</tt> se doit 
            d'&ecirc;tre la plus petite possible. Puisque la <tt class="literal">Session</tt> joue obligatoirement le r&ocirc;le de m&eacute;moire 
            cache de premier niveau et contient &agrave; ce titre tous les objets
            charg&eacute;s, il est pr&eacute;f&eacute;rable de n'utiliser cette strat&eacute;gie que pour quelques cycles de requ&ecirc;tes car les objets
            risquent d'y &ecirc;tre rapidement p&eacute;rim&eacute;s.
        </p><p>Notez que la <tt class="literal">Session</tt> d&eacute;connect&eacute;e devrait &ecirc;tre conserv&eacute;e pr&egrave;s de la couche de persistance. Autrement dit, utilisez un EJB stateful
            pour conserver la <tt class="literal">Session</tt> et &eacute;vitez de la s&eacute;rialiser et de la transf&eacute;rer &agrave; la couche de pr&eacute;sentation (i.e. Il est pr&eacute;f&eacute;rable de ne pas
            la conserver dans la session <tt class="literal">HttpSession</tt> .)
        </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-detached"></a>11.3.3.&nbsp;Les objets d&eacute;tach&eacute;s et le versionnage automatique</h3></div></div><div></div></div><p>Chaque interaction avec le syst&egrave;me de persistance se fait via une nouvelle <tt class="literal">Session</tt> . 
            Toutefois, les m&ecirc;mes instances d'objets persistants sont r&eacute;utilis&eacute;es pour chacune de ces interactions.
            L'application doit pouvoir manipuler l'&eacute;tat des instances d&eacute;tach&eacute;es ayant &eacute;t&eacute; charg&eacute;es ant&eacute;rieurement via
            une autre session. Pour ce faire, ces objets persistants doivent &ecirc;tre rattach&eacute;s &agrave; la <tt class="literal">Session</tt> 
            courante en utilisant <tt class="literal">Session.update()</tt> , <tt class="literal">Session.saveOrUpdate()</tt> , ou <tt class="literal">Session.merge()</tt> .
        </p><pre class="programlisting">
            // foo est une instance charg&eacute;e ant&eacute;rieurement par une autre session

            foo.setProperty("bar");
            session = factory.openSession();
            Transaction t = session.beginTransaction();
            session.saveOrUpdate(foo);  //Utiliser merge() si "foo" pourrait avoir &eacute;t&eacute; charg&eacute; pr&eacute;c&eacute;dement
            t.commit();
            session.close(); </pre><p>Encore une fois, Hibernate v&eacute;rifiera la version des instances devant &ecirc;tre actualis&eacute;es durant le flush().
            Une exception sera lanc&eacute;e si des conflits sont d&eacute;tect&eacute;s.</p><p>Vous pouvez &eacute;galement utiliser <tt class="literal">lock()</tt> au lieu de <tt class="literal">update()</tt> et 
            utiliser le mode <tt class="literal">LockMode.READ</tt> (qui lancera une v&eacute;rification de version, en ignorant tous les niveaux de m&eacute;moire cache) si vous &ecirc;tes
            certain que l'objet n'a pas &eacute;t&eacute; modifi&eacute;.
        </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-customizing"></a>11.3.4.&nbsp;Personnaliser le versionnage automatique</h3></div></div><div></div></div><p>Vous pouvez d&eacute;sactiver l'incr&eacute;mentation automatique du num&eacute;ro de version de certains attributs et
            collections en mettant la valeur du param&egrave;tre de mapping <tt class="literal">optimistic-lock</tt> &agrave;
            false. Hibernate cessera ainsi d'incr&eacute;menter leur num&eacute;ro de version s'ils sont mis &agrave; jour.
        </p><p>Certaines entreprises poss&egrave;dent de vieux syst&egrave;mes dont les sch&eacute;mas de bases de donn&eacute;es sont statiques et
            ne peuvent &ecirc;tre modifi&eacute;s. Il existe aussi des cas o&ugrave; plusieurs applications doivent acc&eacute;der &agrave; la m&ecirc;me base
            de donn&eacute;es, mais certaines d'entre elles ne peuvent g&eacute;rer les num&eacute;ros de version ou les champs horodat&eacute;s.
            Dans les deux cas, le versionnage ne peut &ecirc;tre implant&eacute; par le rajout d'une colonne dans la base de donn&eacute;es.
            Afin de forcer la v&eacute;rification de version dans un syst&egrave;me sans en faire le mapping, mais en for&ccedil;ant une
            comparaison des &eacute;tats de tous les attributs d'une entit&eacute;, vous pouvez utiliser l'attribut <tt class="literal">optimistic- lock="all"</tt> 
            sous l'&eacute;l&eacute;ment <tt class="literal">&lt;class&gt;</tt> . Veuillez noter que cette mani&egrave;re de g&eacute;rer le versionnage ne peut &ecirc;tre utilis&eacute;e que si l'application
            utilises de longues sessions, lui permettant de comparer l'ancien &eacute;tat et le nouvel &eacute;tat d'une entit&eacute;.
            L'utilisation d'un pattern <tt class="literal">session-per-request-with-detached- objects</tt> devient alors impossible.
        </p><p>Il peut &ecirc;tre souhaitable de permettre les modifications concurrentes lorsque des champs distincts sont
            modifi&eacute;s. En mettant la propri&eacute;t&eacute; <tt class="literal">optimistic-lock="dirty"</tt> dans l'&eacute;l&eacute;ment <tt class="literal">&lt;class&gt;</tt> , 
            Hibernate ne fera la comparaison que des champs devant &ecirc;tre actualis&eacute;s lors du flush().
        </p><p>Dans les deux cas: en utilisant une colonne de version/horodat&eacute;e ou via la comparaison de l'&eacute;tat complet
            de l'objet ou de ses champs modifi&eacute;s, Hibernate ne cr&eacute;era qu'une seule commande d'UPDATE par entit&eacute; avec la
            clause WHERE appropri&eacute;e pour mettre &agrave; jour l'entit&eacute;
            <span class="emphasis"><em>ET</em></span>
            en v&eacute;rifier la version. Si vous utilisez la persistance transitive pour propager l'&eacute;v&egrave;nement de rattachement
            &agrave; des entit&eacute;s associ&eacute;es, il est possible qu'Hibernate g&eacute;n&egrave;re des commandes d'UPDATE inutiles. Ceci n'est
            g&eacute;n&eacute;ralement pas un probl&egrave;me, mais certains d&eacute;clencheurs
            <span class="emphasis"><em>on update</em></span>
            dans la base de donn&eacute;es pourraient &ecirc;tre activ&eacute;s m&ecirc;me si aucun changement n'&eacute;tait r&eacute;ellement persist&eacute; sur des
            objets associ&eacute;s. Vous pouvez personnaliser ce comportement en indiquant <tt class="literal">select-before- update="true"</tt>
            dans l'&eacute;l&eacute;ment de mapping <tt class="literal">&lt;class&gt;</tt> . Ceci forcera Hibernate &agrave; faire le SELECT de l'instance 
            afin de s'assurer que l'entit&eacute; doit r&eacute;ellement &ecirc;tre
            actualis&eacute;e avant de lancer la commande d'UPDATE.
        </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-locking"></a>11.4.&nbsp;Verouillage pessimiste</h2></div></div><div></div></div><p>Il n'est n&eacute;cessaire de s'attarder &agrave; la strat&eacute;gie de verrouillage des entit&eacute;s dans une application utilisant
        Hibernate. Il est g&eacute;n&eacute;ralement suffisant de d&eacute;finir le niveau d'isolation pour les connexions JDBC et de laisser
        ensuite la base de donn&eacute;e effectuer son travail. Toutefois, certains utilisateurs avanc&eacute;s peuvent vouloir
        obtenir un verrouillage pessimiste exclusif sur un enregistrement et le r&eacute;obtenir au lancement d'une nouvelle
        transaction.</p><p>Hibernate utilisera toujours le m&eacute;canisme de verrouillage de la base de donn&eacute;es et ne verrouillera jamais les
        objets en m&eacute;moire!</p><p>La classe
        <tt class="literal">LockMode</tt>
        d&eacute;finit les diff&eacute;rents niveaux de verrouillage pouvant &ecirc;tre obtenus par Hibernate. Le verrouillage est obtenu
        par les m&eacute;canismes suivants:
    </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                <tt class="literal">LockMode.WRITE</tt> est obtenu automatiquement quand Hibernate actualise ou insert un enregistrement.
            </p></li><li><p>
                <tt class="literal">LockMode.UPGRADE</tt> peut &ecirc;tre obtenu de mani&egrave;re explicite via la requ&ecirc;te en utilisant
                <tt class="literal">SELECT ... FOR UPDATE</tt> sur une base de donn&eacute;es supportant cette syntaxe.
            </p></li><li><p>
                <tt class="literal">LockMode.UPGRADE_NOWAIT</tt> peut &ecirc;tre obtenu de mani&egrave;re explicite en utilisant
                <tt class="literal">SELECT ... FOR UPDATE NOWAIT</tt> sur Oracle.
            </p></li><li><p>
                <tt class="literal">LockMode.READ</tt> est obtenu automatiquement quand Hibernate lit des donn&eacute;es dans un contexte d'isolation
                <tt class="literal">Repeatable Read</tt> ou
                <tt class="literal">Serializable</tt> . Peut &ecirc;tre r&eacute;obtenu explicitement via une requ&ecirc;te.
            </p></li><li><p>
                <tt class="literal">LockMode.NONE</tt> repr&eacute;sente l'absence de verouillage. Tous les objets migrent vers ce mode a la fin d'une
                <tt class="literal">Transaction</tt> . Les objets associ&eacute;s &agrave; une session via un appel &agrave;
                <tt class="literal">saveOrUpdate()</tt> commencent &eacute;galement leur cycle de vie dans cet &eacute;tat.
            </p></li></ul></div><p>Les niveaux de verrouillage peuvent &ecirc;tre explicitement obtenus de l'une des mani&egrave;res suivantes:</p><div class="itemizedlist"><ul type="disc" compact><li><p>Un appel &agrave;
                <tt class="literal">Session.load()</tt> , en sp&eacute;cifiant un niveau verrouillage
                <tt class="literal">LockMode</tt> .
            </p></li><li><p>Un appel &agrave;
                <tt class="literal">Session.lock()</tt> .
            </p></li><li><p>Une appel &agrave;
                <tt class="literal">Query.setLockMode()</tt> .
            </p></li></ul></div><p>Si
        <tt class="literal">Session.load()</tt>
        est appel&eacute; avec le param&egrave;tre de niveau de verouillage
        <tt class="literal">UPGRADE</tt>
        ou
        <tt class="literal">UPGRADE_NOWAIT</tt>
        et que l'objet demand&eacute; n'est pas pr&eacute;sent dans la session, celui-ci sera charg&eacute; &agrave; l'aide d'une requ&ecirc;te
        <tt class="literal">SELECT ... FOR UPDATE</tt>
        . Si la m&eacute;thode
        <tt class="literal">load()</tt>
        est appel&eacute;e pour un objet d&eacute;j&agrave; en session avec un verrouillage moindre que celui demand&eacute;, Hibernate appellera la
        m&eacute;thode
        <tt class="literal">lock()</tt>
        pour cet objet.
    </p><p>
        <tt class="literal">Session.lock()</tt>
        effectue une v&eacute;rification de version si le niveau de verrouillage est
        <tt class="literal">READ</tt>
        ,
        <tt class="literal">UPGRADE</tt>
        ou
        <tt class="literal">UPGRADE_NOWAIT</tt>
        . (Dans le cas des niveaux
        <tt class="literal">UPGRADE</tt>
        ou
        <tt class="literal">UPGRADE_NOWAIT</tt>
        , une requ&ecirc;te
        <tt class="literal">SELECT ... FOR UPDATE</tt>
        sera utilis&eacute;e.)
    </p><p>Si une base de donn&eacute;es ne supporte pas le niveau de verrouillage demand&eacute;, Hibernate utilisera un niveau
        alternatif convenable au lieux de lancer une exception. Ceci assurera la portabilit&eacute; de votre
        application.</p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-connection-release"></a>11.5.&nbsp;Mode de lib&eacute;ration de Connection</h2></div></div><div></div></div><p>
            Le comportement original (2.x) d'Hibernate pour la gestion des connexions JDBC
            &eacute;tait que la <tt class="literal">Session</tt> obtenait une connexion d&egrave;s qu'elle en avait
            besoin et la lib&eacute;rait une fois la session ferm&eacute;e.
            Hibernate 3 a introduit les modes de lib&eacute;ration de connexion pour indiquer &agrave; la session
            comment g&eacute;rer les transactions JDBC. Notez que la discussion suivante n'est pertinente 
            que pour des connexions fournies par un <tt class="literal">ConnectionProvider</tt>, celles g&eacute;r&eacute;es 
            par l'utilisateur sont en dehors du scope de cette discussion. Les diff&eacute;rents modes
            sont d&eacute;finies par <tt class="literal">org.hibernate.ConnectionReleaseMode</tt>:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">ON_CLOSE</tt> - est essentiellement le comportement pass&eacute;.
                    La session Hibernate obtient une connexion lorsqu'elle en a besoin et la garde
                    jusqu'&agrave; ce que la session se ferme.
                </p></li><li><p>
                    <tt class="literal">AFTER_TRANSACTION</tt> - indique de relacher la connexion apr&egrave;s qu'une
                    <tt class="literal">org.hibernate.Transaction</tt> se soit achev&eacute;e.
                </p></li><li><p>
                    <tt class="literal">AFTER_STATEMENT</tt> (aussi appel&eacute; lib&eacute;ration brutale) - indique de relacher
                    les connexions apr&egrave;s chaque ex&eacute;cution d'un statement. Ce relachement aggressif est annul&eacute;
                    si ce statement laisse des ressources associ&eacute;es &agrave; une session donn&eacute;e ouvertes, actuellement
                    ceci n'arrive que lors de l'utilisation de <tt class="literal">org.hibernate.ScrollableResults</tt>.
                </p></li></ul></div><p>
            Le param&egrave;tre de configuration <tt class="literal">hibernate.connection.release_mode</tt> est utilis&eacute;
            pour sp&eacute;cifier quel mode de lib&eacute;ration doit &ecirc;tre utiliser. Les valeurs possibles sont:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">auto</tt> (valeur par d&eacute;faut) - ce choix d&eacute;l&egrave;gue le choix de lib&eacute;ration
                    &agrave; la m&eacute;thode <tt class="literal">org.hibernate.transaction.TransactionFactory.getDefaultReleaseMode()</tt>
                    Pour la JTATransactionFactory, elle retourne ConnectionReleaseMode.AFTER_STATEMENT; pour
                    JDBCTransactionFactory, elle retourne ConnectionReleaseMode.AFTER_TRANSACTION. C'est rarement
                    une bonne id&eacute;e de changer ce comportement par d&eacute;faut puisque les erreurs soulev&eacute;es par ce
                    param&eacute;trage tend &agrave; prouver une erreur dans le code de l'utilisateur.
                </p></li><li><p>
                    <tt class="literal">on_close</tt> - indique d'utiliser ConnectionReleaseMode.ON_CLOSE.  Ce param&eacute;trage
                    existe pour garantir la compatibilit&eacute; avec les versions pr&eacute;c&eacute;dentes, mais ne devrait plus &ecirc;tre utilis&eacute;.
                </p></li><li><p>
                    <tt class="literal">after_transaction</tt> - indique d'utiliser ConnectionReleaseMode.AFTER_TRANSACTION.
                    Ne devrait pas &ecirc;tre utilis&eacute; dans les environnements JTA. Notez aussi qu'avec 
                    ConnectionReleaseMode.AFTER_TRANSACTION, si une session est consid&eacute;r&eacute;e comme &eacute;tant en mode auto-commit
                    les connexions seront relach&eacute;es comme si le mode &eacute;tait AFTER_STATEMENT.
                </p></li><li><p>
                    <tt class="literal">after_statement</tt> - indique d'utiliser ConnectionReleaseMode.AFTER_STATEMENT.
                    Additonnellement, le <tt class="literal">ConnectionProvider</tt> utilis&eacute; est consult&eacute; pour savoir s'il supporte
                    ce param&eacute;trage (<tt class="literal">supportsAggressiveRelease()</tt>). Si ce n'est pas le cas, le mode de
                    lib&eacute;ration est r&eacute; initialis&eacute; &agrave; ConnectionReleaseMode.AFTER_TRANSACTION.  
                    Ce param&eacute;trage n'est s&ucirc;r que dans les environnements o&ugrave; il est possible d'obtenir &agrave; nouveau
                    la m&ecirc;me connexion JDBC &agrave; chaque fois que l'on fait un appel de <tt class="literal">ConnectionProvider.getConnection()</tt> 
                    ou dans les envrionnements auto-commit o&ugrave; il n'est pas important d'obtenir plusieurs fois la 
                    m&ecirc;me connexion.
                </p></li></ul></div></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="events"></a>Chapitre&nbsp;12.&nbsp;Les intercepteurs et les &eacute;v&eacute;nements</h2></div></div><div></div></div><p>
        Il est souvent utile pour l'application de r&eacute;agir &agrave; certains &eacute;v&eacute;nements
        qui surviennent dans Hibernate. Cela autorise l'impl&eacute;mentation de certaines sortes de
        fonctionnalit&eacute;s g&eacute;n&eacute;riques, et d'extensions de fonctionnalit&eacute;s d'Hibernate.
    </p><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-interceptors"></a>12.1.&nbsp;Intercepteurs</h2></div></div><div></div></div><p>
            L'interface <tt class="literal">Interceptor</tt> fournit des "callbacks" de la session vers l'application 
            et permettent &agrave; l'application de consulter et/ou de manipuler des propri&eacute;t&eacute;s
            d'un objet persistant avant qu'il soit sauvegard&eacute;, mis &agrave; jour, supprim&eacute; ou charg&eacute;.
            Une utilisation possible de cette fonctionnalit&eacute; est de tracer l'acc&egrave;s &agrave; l'information.
            Par exemple, l'<tt class="literal">Interceptor</tt> suivant positionne
            <tt class="literal">createTimestamp</tt> quand un <tt class="literal">Auditable</tt> est cr&eacute;&eacute;
            et met &agrave; jour la propri&eacute;t&eacute; <tt class="literal">lastUpdateTimestamp</tt> quand un
            <tt class="literal">Auditable</tt> est mis &agrave; jour.
        </p><p>
            Vous pouvez soit impl&eacute;menter <tt class="literal">Interceptor</tt> directement ou (mieux)
            &eacute;tendre <tt class="literal">EmptyInterceptor</tt>.
        </p><pre class="programlisting">package org.hibernate.test;

import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;

import org.hibernate.EmptyInterceptor;
import org.hibernate.Transaction;
import org.hibernate.type.Type;

public class AuditInterceptor extends EmptyInterceptor {

    private int updates;
    private int creates;
    private int loads;

    public void onDelete(Object entity,
                         Serializable id,
                         Object[] state,
                         String[] propertyNames,
                         Type[] types) {
        // ne fait rien
    }

    public boolean onFlushDirty(Object entity,
                                Serializable id,
                                Object[] currentState,
                                Object[] previousState,
                                String[] propertyNames,
                                Type[] types) {

        if ( entity instanceof Auditable ) {
            updates++;
            for ( int i=0; i &lt; propertyNames.length; i++ ) {
                if ( "lastUpdateTimestamp".equals( propertyNames[i] ) ) {
                    currentState[i] = new Date();
                    return true;
                }
            }
        }
        return false;
    }

    public boolean onLoad(Object entity,
                          Serializable id,
                          Object[] state,
                          String[] propertyNames,
                          Type[] types) {
        if ( entity instanceof Auditable ) {
            loads++;
        }
        return false;
    }

    public boolean onSave(Object entity,
                          Serializable id,
                          Object[] state,
                          String[] propertyNames,
                          Type[] types) {

        if ( entity instanceof Auditable ) {
            creates++;
            for ( int i=0; i&lt;propertyNames.length; i++ ) {
                if ( "createTimestamp".equals( propertyNames[i] ) ) {
                    state[i] = new Date();
                    return true;
                }
            }
        }
        return false;
    }

    public void postFlush(Iterator entities) {
        System.out.println("Creations: " + creates + ", Updates: " + updates);
    }

    public void afterTransactionCompletion(Transaction tx) {
        if ( tx.wasCommitted() ) {
            System.out.println("Creations: " + creates + ", Updates: " + updates, "Loads: " + loads);
        }
        updates=0;
        creates=0;
        loads=0;
    }

}</pre><p>
            L'intercepteur doit &ecirc;tre sp&eacute;cifi&eacute; quand une session est cr&eacute;&eacute;e.
        </p><pre class="programlisting">Session session = sf.openSession( new AuditInterceptor() );</pre><p>
            Vous pouvez aussi mettre un intercepteur au niveau global, en utilisant l'objet <tt class="literal">Configuration</tt>.
            Dans ce cas, l'intercepteur doit &ecirc;tre "threadsafe".
        </p><pre class="programlisting">new Configuration().setInterceptor( new AuditInterceptor() );</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-events"></a>12.2.&nbsp;Syst&egrave;me d'&eacute;v&eacute;nements</h2></div></div><div></div></div><p>
            Si vous devez r&eacute;agir &agrave; des &eacute;v&eacute;nements particuliers dans votre couche de persistance,
            vous pouvez aussi utiliser l'architecture d'<span class="emphasis"><em>&eacute;v&eacute;nements</em></span> d'Hibernate3.
            Le syst&egrave;me d'&eacute;v&eacute;nements peut &ecirc;tre utilis&eacute; en suppl&eacute;ment ou en remplacement des interceptors.
        </p><p>
            Essentiellement toutes les m&eacute;thodes de l'interface <tt class="literal">Session</tt> sont corr&eacute;l&eacute;es &agrave;
            un &eacute;v&eacute;nement. Vous avez un <tt class="literal">LoadEvent</tt>, un <tt class="literal">FlushEvent</tt>, etc
            (consultez la DTD du fichier de configuration XML ou le paquet <tt class="literal">org.hibernate.event</tt>
            pour avoir la liste compl&egrave;te des types d'&eacute;v&eacute;nement d&eacute;finis).
            Quand une requ&ecirc;te est faite &agrave; partir d'une de ces m&eacute;thodes, la
            <tt class="literal">Session</tt> Hibernate g&eacute;n&egrave;re un &eacute;v&eacute;nement appropri&eacute; et le passe
            au listener configur&eacute; pour ce type.
            Par d&eacute;faut, ces listeners impl&eacute;mentent le m&ecirc;me traitement dans lequel ces m&eacute;thodes
            aboutissent toujours.
            Cependant, vous &ecirc;tes libre d'impl&eacute;menter une version personnalis&eacute;e d'une de ces
            interfaces de listener (c'est-&agrave;-dire, le <tt class="literal">LoadEvent</tt> est trait&eacute; par
            l'impl&eacute;mentation de l'interface <tt class="literal">LoadEventListener</tt> d&eacute;clar&eacute;e), dans
            quel cas leur impl&eacute;mentation devrait &ecirc;tre responsable du traitement des
            requ&ecirc;tes <tt class="literal">load()</tt> faites par la <tt class="literal">Session</tt>.
        </p><p>
            Les listeners devraient effectivement &ecirc;tre consid&eacute;r&eacute;s comme des singletons ; dans le sens
            o&ugrave; ils sont partag&eacute;s entre des requ&ecirc;tes, et donc ne devraient pas sauvegarder des &eacute;tats
            de variables d'instance.
        </p><p>
            Un listener personnalis&eacute; devrait impl&eacute;menter l'interface appropri&eacute;e pour l'&eacute;v&eacute;nement
            qu'il veut traiter et/ou &eacute;tendre une des classes de base (ou m&ecirc;me l'&eacute;v&eacute;nement pr&ecirc;t &agrave;
            l'emploi utilis&eacute; par Hibernate comme ceux d&eacute;clar&eacute;s non-finaux &agrave; cette intention). Les
            listeners personnalis&eacute;s peuvent &ecirc;tre soit inscrits par programmation &agrave; travers l'objet
            <tt class="literal">Configuration</tt>, ou sp&eacute;cifi&eacute;s la configuration XML d'Hibernate
            (la configuration d&eacute;clarative &agrave; travers le fichier de propri&eacute;t&eacute;s n'est pas support&eacute;e).
            Voici un exemple de listener personnalis&eacute; pour l'&eacute;v&eacute;nement de chargement :
        </p><pre class="programlisting">public class MyLoadListener implements LoadEventListener {
    // C'est une simple m&eacute;thode d&eacute;finie par l'interface LoadEventListener
    public void onLoad(LoadEvent event, LoadEventListener.LoadType loadType)
            throws HibernateException {
        if ( !MySecurity.isAuthorized( event.getEntityClassName(), event.getEntityId() ) ) {
            throw MySecurityException("Unauthorized access");
        }
    }
}</pre><p>
            Vous avez aussi besoin d'une entr&eacute;e de configuration disant &agrave; Hibernate d'utiliser
            ce listener en plus du listener par d&eacute;faut :
        </p><pre class="programlisting">&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
        ...
        &lt;event type="load"&gt;
            &lt;listener class="com.eg.MyLoadListener"/&gt;
            &lt;listener class="org.hibernate.event.def.DefaultLoadEventListener"/&gt;
        &lt;/event&gt;
    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;</pre><p>
            Vous pouvez aussi l'inscrire par programmation :
        </p><pre class="programlisting">Configuration cfg = new Configuration();
LoadEventListener[] stack = { new MyLoadListener(), new DefaultLoadEventListener() };
cfg.EventListeners().setLoadEventListeners(stack);</pre><p>
            Les listeners inscrits d&eacute;clarativement ne peuvent pas partager d'instances. Si le m&ecirc;me
            nom de classe est utilis&eacute;e dans plusieurs &eacute;l&eacute;ments <tt class="literal">&lt;listener/&gt;</tt>,
            chaque r&eacute;f&eacute;rence sera une instance distincte de cette classe. Si vous avez besoin de la
            facult&eacute; de partager des instances de listener entre plusieurs types de listener, vous devez
            utiliser l'approche d'inscription par programmation.
        </p><p>
            Pourquoi impl&eacute;menter une interface et d&eacute;finir le type sp&eacute;cifique durant la configuration ?
            Une impl&eacute;mentation de listener pourrait impl&eacute;menter plusieurs interfaces de listener
            d'&eacute;v&eacute;nements. Avoir en plus le type d&eacute;fini durant l'inscription rend plus facile
            l'activation ou la d&eacute;sactivation pendant la configuration.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-decl-security"></a>12.3.&nbsp;S&eacute;curit&eacute; d&eacute;clarative d'Hibernate</h2></div></div><div></div></div><p>
            G&eacute;n&eacute;ralement, la s&eacute;curit&eacute; d&eacute;clarative dans les applications Hibernate est g&eacute;r&eacute;e dans la
            couche de session. Maintenant, Hibernate3 permet &agrave; certaines actions d'&ecirc;tre approuv&eacute;es
            via JACC, et autoris&eacute;es via JAAS. Cette fonctionnalit&eacute; optionnelle est construite
            au dessus de l'architecture d'&eacute;v&eacute;nements.
        </p><p>
            D'abord, vous devez configurer les listeners d'&eacute;v&eacute;nements appropri&eacute;s pour permettre
            l'utilisation d'autorisations JAAS.
        </p><pre class="programlisting">&lt;listener type="pre-delete" class="org.hibernate.secure.JACCPreDeleteEventListener"/&gt;
&lt;listener type="pre-update" class="org.hibernate.secure.JACCPreUpdateEventListener"/&gt;
&lt;listener type="pre-insert" class="org.hibernate.secure.JACCPreInsertEventListener"/&gt;
&lt;listener type="pre-load" class="org.hibernate.secure.JACCPreLoadEventListener"/&gt;</pre><p>
            Notez que <tt class="literal">&lt;listener type="..." class="..."/&gt;</tt> est juste un raccourci
            pour <tt class="literal">&lt;event type="..."&gt;&lt;listener class="..."/&gt;&lt;/event&gt;</tt>
            quand il y a exactement un listener pour un type d'&eacute;v&eacute;nement particulier.
        </p><p>
            Ensuite, toujours dans <tt class="literal">hibernate.cfg.xml</tt>, lier les permissions aux r&ocirc;les :
        </p><pre class="programlisting">&lt;grant role="admin" entity-name="User" actions="insert,update,read"/&gt;
&lt;grant role="su" entity-name="User" actions="*"/&gt;</pre><p>
            Les noms de r&ocirc;le sont les r&ocirc;les compris par votre fournisseur JAAC.
        </p></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="batch"></a>Chapitre&nbsp;13.&nbsp;Traitement par paquet</h2></div></div><div></div></div><p>
        Une approche na&iuml;ve pour ins&eacute;rer 100 000 lignes dans la base de donn&eacute;es en utilisant
        Hibernate pourrait ressembler &agrave; &ccedil;a :
    </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
for ( int i=0; i&lt;100000; i++ ) {
    Customer customer = new Customer(.....);
    session.save(customer);
}
tx.commit();
session.close();</pre><p>
        Ceci devrait s'&eacute;crouler avec une <tt class="literal">OutOfMemoryException</tt> quelque
        part aux alentours de la 50 000&egrave;me ligne. C'est parce qu'Hibernate cache toutes
        les instances de <tt class="literal">Customer</tt> nouvellement ins&eacute;r&eacute;es dans le cache
        de second niveau.
    </p><p>
        Dans ce chapitre nous montrerons comment &eacute;viter ce probl&egrave;me. D'abord, cependant,
        si vous faites des traitements par batch, il est absolument critique que vous
        activiez l'utilisation ds paquet JDBC (NdT : JDBC batching), si vous avez l'intention
        d'obtenir des performances raisonnables. Configurez la taille du paquet JDBC avec un
        nombre raisonnable (disons, 10-50) :
    </p><pre class="programlisting">hibernate.jdbc.batch_size 20</pre><p>
        Vous pourriez aussi vouloir faire cette sorte de travail dans un traitement o&ugrave;
        l'interaction avec le cache de second niveau est compl&egrave;tement d&eacute;sactiv&eacute; :
    </p><pre class="programlisting">hibernate.cache.use_second_level_cache false</pre><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="batch-inserts"></a>13.1.&nbsp;Insertions en paquet</h2></div></div><div></div></div><p>
            Lorsque vous rendez des nouveaux objets persistants, vous devez r&eacute;guli&egrave;rement appeler
            <tt class="literal">flush()</tt> et puis <tt class="literal">clear()</tt> sur la session,
            pour contr&ocirc;ler la taille du cache de premier niveau.
        </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

for ( int i=0; i&lt;100000; i++ ) {
    Customer customer = new Customer(.....);
    session.save(customer);
    if ( i % 20 == 0 ) { //20, m&ecirc;me taille que la taille du paquet JDBC
        //flush un paquet d'insertions et lib&egrave;re la m&eacute;moire :
        session.flush();
        session.clear();
    }
}

tx.commit();
session.close();</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="batch-update"></a>13.2.&nbsp;Paquet de mises &agrave; jour</h2></div></div><div></div></div><p>
            Pour r&eacute;cup&eacute;rer et mettre &agrave; jour des donn&eacute;es les m&ecirc;mes id&eacute;es s'appliquent. En plus,
            vous avez besoin d'utiliser <tt class="literal">scroll()</tt> pour tirer partie des
            curseurs c&ocirc;t&eacute; serveur pour les requ&ecirc;tes qui retournent beaucoup de lignes de donn&eacute;es.
        </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

ScrollableResults customers = session.getNamedQuery("GetCustomers")
    .setCacheMode(CacheMode.IGNORE)
    .scroll(ScrollMode.FORWARD_ONLY);
int count=0;
while ( customers.next() ) {
    Customer customer = (Customer) customers.get(0);
    customer.updateStuff(...);
    if ( ++count % 20 == 0 ) {
        //flush un paquet de mises &agrave; jour et lib&egrave;re la m&eacute;moire :
        session.flush();
        session.clear();
    }
}

tx.commit();
session.close();</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="batch-statelesssession"></a>13.3.&nbsp;L'interface StatelessSession</h2></div></div><div></div></div><p>
            Alternativement, Hibernate fournit une API orient&eacute;e commande qui peut &ecirc;tre
            utilis&eacute;e avec des flux de donn&eacute;es pour et en provenance de la base de donn&eacute;es
            sous la forme d'objets d&eacute;tach&eacute;s. Une <tt class="literal">StatelessSession</tt> n'a pas
            de contexte de persistance associ&eacute; et ne fournit pas beaucoup de s&eacute;mantique de
            dur&eacute;e de vie de haut niveau. En particulier, une session sans &eacute;tat n'impl&eacute;mente
            pas de cache de premier niveau et n'interagit pas non plus avec un cache de
            seconde niveau ou un cache de requ&ecirc;tes. Elle n'impl&eacute;mente pas les transactions
            ou la v&eacute;rification sale automatique (NdT : automatic dirty checking). Les
            op&eacute;rations r&eacute;alis&eacute;es avec une session sans &eacute;tat ne sont jamais r&eacute;percut&eacute;es
            en cascade sur les instances associ&eacute;es. Les collections sont ignor&eacute;es par une
            session sans &eacute;tat. Les op&eacute;rations ex&eacute;cut&eacute;es via une session sans &eacute;tat outrepasse
            le mod&egrave;le d'&eacute;v&eacute;nements d'Hibernate et les intercepteurs. Les sessions sans &eacute;tat sont
            vuln&eacute;rables aux effets de modification des donn&eacute;es, ceci est d&ucirc; au manque de cache
            de premier niveau. Une session sans &eacute;tat est une abstraction bas niveau, plus
            proche de la couche JDBC sous-jacente.
        </p><pre class="programlisting">StatelessSession session = sessionFactory.openStatelessSession();
Transaction tx = session.beginTransaction();

ScrollableResults customers = session.getNamedQuery("GetCustomers")
    .scroll(ScrollMode.FORWARD_ONLY);
while ( customers.next() ) {
    Customer customer = (Customer) customers.get(0);
    customer.updateStuff(...);
    session.update(customer);
}

tx.commit();
session.close();</pre><p>
            Notez que dans le code de l'exemple, les intances de <tt class="literal">Customer</tt>
            retourn&eacute;es par la requ&ecirc;te sont imm&eacute;diatement d&eacute;tach&eacute;es. Elles ne sont jamais
            associ&eacute;es &agrave; un contexte de persistance.
        </p><p>
            Les op&eacute;rations <tt class="literal">insert()</tt>, <tt class="literal">update()</tt> et
            <tt class="literal">delete()</tt> d&eacute;finies par l'interface <tt class="literal">StatelessSession</tt>
            sont consid&eacute;r&eacute;es comme des op&eacute;rations d'acc&egrave;s direct aux lignes de la base de donn&eacute;es,
            ce qui r&eacute;sulte en une ex&eacute;cution imm&eacute;diate du SQL <tt class="literal">INSERT</tt>, <tt class="literal">UPDATE</tt>
            ou <tt class="literal">DELETE</tt> respectif. De l&agrave;, elles ont des s&eacute;mantiques tres diff&eacute;rentes des
            op&eacute;rations <tt class="literal">save()</tt>, <tt class="literal">saveOrUpdate()</tt>
            et <tt class="literal">delete()</tt> d&eacute;finies par l'interface <tt class="literal">Session</tt>.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="batch-direct"></a>13.4.&nbsp;Op&eacute;rations de style DML</h2></div></div><div></div></div><p>
            Comme d&eacute;j&agrave; discut&eacute; avant, le mapping objet/relationnel automatique et transparent
            est int&eacute;ress&eacute; par la gestion de l'&eacute;tat de l'objet. Ceci implique que l'&eacute;tat de l'objet
            est disponible en m&eacute;moire, d'o&ugrave; manipuler (en utilisant des expressions du langage de
            manipulation de donn&eacute;es - <tt class="literal">Data Manipulation Language</tt> (DML) - SQL)
            les donn&eacute;es directement dans la base n'affectera pas l'&eacute;tat en m&eacute;moire. Pourtant, Hibernate
            fournit des m&eacute;thodes pour l'ex&eacute;cution d'expression DML de style SQL lesquelles sont
            r&eacute;alis&eacute;es &agrave; travers le langage de requ&ecirc;te d'Hibernate (<a href="#queryhql" title="Chapitre&nbsp;14.&nbsp;HQL: Langage de requ&ecirc;tage d'Hibernate">Chapitre&nbsp;14, <i>HQL: Langage de requ&ecirc;tage d'Hibernate</i></a>).
        </p><p>
            La pseudo-syntaxe pour les expressions <tt class="literal">UPDATE</tt> et <tt class="literal">DELETE</tt>
            est : <tt class="literal">( UPDATE | DELETE ) FROM? EntityName (WHERE where_conditions)?</tt>.
            Certains points sont &agrave; noter :
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Dans la clause from, le mot-clef FROM est optionnel
                </p></li><li><p>
                    Il ne peut y avoir qu'une seule entit&eacute; nomm&eacute;e dans la clause from ; elle peut
                    optionnellement avoir un alias. Si le nom de l'entit&eacute; a un alias, alors
                    n'importe quelle r&eacute;f&eacute;rence de propri&eacute;t&eacute; doit &ecirc;tre qualifi&eacute;e en ayant un alias ;
                    si le nom de l'entit&eacute; n'a pas d'alias, alors il est ill&eacute;gal pour n'importe quelle
                    r&eacute;f&eacute;rence de propri&eacute;t&eacute; d'&ecirc;tre qualifi&eacute;e.
                </p></li><li><p>
                    Aucune jointure (implicite ou explicite) ne peut &ecirc;tre sp&eacute;cifi&eacute;e dans une requ&ecirc;te HQL.
                    Les sous-requ&ecirc;tes peuvent &ecirc;tre utilis&eacute;es dans la clause where ; les sous-requ&ecirc;tes,
                    elles-m&ecirc;mes, peuvent contenir des jointures.
                </p></li><li><p>
                    La clause where est aussi optionnelle.
                </p></li></ul></div><p>
            Par exemple, pour ex&eacute;cuter un <tt class="literal">UPDATE</tt> HQL, utilisez la m&eacute;thode
            <tt class="literal">Query.executeUpdate()</tt> (la m&eacute;thode est donn&eacute;es pour ceux
            qui sont familiers avec <tt class="literal">PreparedStatement.executeUpdate()</tt> de
            JDBC) :
        </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

String hqlUpdate = "update Customer c set c.name = :newName where c.name = :oldName";
// ou String hqlUpdate = "update Customer set name = :newName where name = :oldName";
int updatedEntities = s.createQuery( hqlUpdate )
        .setString( "newName", newName )
        .setString( "oldName", oldName )
        .executeUpdate();
tx.commit();
session.close();</pre><p>
            Pour ex&eacute;cuter un <tt class="literal">DELETE</tt> HQL, utilisez la m&ecirc;me m&eacute;thode
            <tt class="literal">Query.executeUpdate()</tt> :
        </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

String hqlDelete = "delete Customer c where c.name = :oldName";
// or String hqlDelete = "delete Customer where name = :oldName";
int deletedEntities = s.createQuery( hqlDelete )
        .setString( "oldName", oldName )
        .executeUpdate();
tx.commit();
session.close();</pre><p>
            La valeur du <tt class="literal">int</tt> retourn&eacute; par la m&eacute;thode <tt class="literal">Query.executeUpdate()</tt>
            indique le nombre d'entit&eacute;s affect&eacute;es par l'op&eacute;ration. Consid&eacute;rez que cela peut ou pas
            corr&eacute;ler le nombre de lignes affect&eacute;s dans la base de donn&eacute;es. Une op&eacute;ration HQL
            pourrait entra&icirc;ner l'ex&eacute;cution de multiples expressions SQL r&eacute;elles, pour des classes
            filles mapp&eacute;es par jointure (NdT: join-subclass), par exemple. Le nombre retourn&eacute;
            indique le nombre d'entit&eacute;s r&eacute;elles affect&eacute;es par l'expression. Retour &agrave; l'exemple de la
            classe fille mapp&eacute;e par jointure, un effacement d'une des classes filles peut r&eacute;ellement
            entra&icirc;ner des suppressions pas seulement dans la table qui mappe la classe fille, mais
            aussi dans la table "racine" et potentillement dans les tables des classes filles plus bas
            dans la hi&eacute;rarchie d'h&eacute;ritage.
        </p><p>
            La pseudo-syntaxe pour l'expression <tt class="literal">INSERT</tt> est :
            <tt class="literal">INSERT INTO EntityName properties_list select_statement</tt>. Quelques
            points sont &agrave; noter :
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Seule la forme INSERT INTO ... SELECT ... est support&eacute;e ; pas la forme INSERT INTO ... VALUES ... .
                </p><p>
                    La properties_list est analogue &agrave; la <tt class="literal">sp&eacute;cification de la colonne</tt>

                    The properties_list is analogous to the <tt class="literal">column speficiation</tt> dans
                    l'expression SQL <tt class="literal">INSERT</tt>. Pour les entit&eacute;s impliqu&eacute;es dans
                    un h&eacute;ritage mapp&eacute;, seules les propri&eacute;t&eacute;s directement d&eacute;finies &agrave; ce niveau de classe
                    donn&eacute; peuvent &ecirc;tre utilis&eacute;es dans properties_list. Les propri&eacute;t&eacute;s de la classe m&egrave;re
                    ne sont pas permises ; et les propri&eacute;t&eacute;s des classes filles n'ont pas de sens. En
                    d'autres mots, les expressions <tt class="literal">INSERT</tt> par nature non polymorphiques.
                </p></li><li><p>
                    select_statement peut &ecirc;tre n'importe quelle requ&ecirc;te de s&eacute;lection HQl valide, avec
                    l'avertissement que les types de retour doivent correspondre aux types attendus par
                    l'insertion. Actuellement, c'est v&eacute;rifi&eacute; durant la compilation de la requ&ecirc;te plut&ocirc;t
                    que la v&eacute;rification soit rel&eacute;gu&eacute;e &agrave; la base de donn&eacute;es. Notez cependant que cela
                    pourrait poser des probl&egrave;mes entre les <tt class="literal">Type</tt>s d'Hibernate qui
                    sont <span class="emphasis"><em>&eacute;quivalents</em></span> oppos&eacute; &agrave; <span class="emphasis"><em>&eacute;gaux</em></span>. Cela
                    pourrait poser des probl&egrave;mes avec des disparit&eacute;s entre une propri&eacute;t&eacute; d&eacute;finie
                    comme un <tt class="literal">org.hibernate.type.DateType</tt> et une propri&eacute;t&eacute; d&eacute;finie
                    comme un <tt class="literal">org.hibernate.type.TimestampType</tt>, m&ecirc;me si la base de donn&eacute;es
                    ne ferait pas de distinction ou ne serait pas capable de g&eacute;rer la conversion.
                </p></li><li><p>
                    Pour la propri&eacute;te id, l'expression d'insertion vous donne deux options. Vous
                    pouvez soit sp&eacute;cifier explicitement la propri&eacute;t&eacute; id dans properties_list
                    (auquel cas sa valeur est extraite de l'expression de s&eacute;lection correspondante),
                    soit l'omettre de properties_list (auquel cas une valeur g&eacute;n&eacute;r&eacute;e est utilis&eacute;e).
                    Cette derni&egrave;re option est seulement disponible en utilisant le g&eacute;n&eacute;rateur d'identifiant
                    qui op&egrave;re dans la base de donn&eacute;es ; tenter d'utiliser cette option avec n'importe quel
                    type de g&eacute;n&eacute;rateur "en m&eacute;moire" causera une exception durant l'analyse. Notez
                    que pour les buts de cette discussion, les g&eacute;n&eacute;rateurs "en base" sont consid&eacute;r&eacute;s
                    &ecirc;tre <tt class="literal">org.hibernate.id.SequenceGenerator</tt> (et ses classes filles)
                    et n'importe quelles impl&eacute;mentations de
                    <tt class="literal">org.hibernate.id.PostInsertIdentifierGenerator</tt>.
                    L'exception la plus notable ici est <tt class="literal">org.hibernate.id.TableHiLoGenerator</tt>,
                    qu ne peut pas &ecirc;tre utilis&eacute;e parce qu'il ne propose pas un moyen de d'exposer ses valeurs
                    par un select.
                </p></li><li><p>
                    Pour des propri&eacute;t&eacute;s mapp&eacute;es comme <tt class="literal">version</tt> ou <tt class="literal">timestamp</tt>,
                    l'expression d'insertion vous donne deux options. Vous pouvez soit sp&eacute;cifier la propri&eacute;t&eacute; dans
                    properties_list (auquel cas sa valeur est extraite des expressions select correspondantes),
                    soit l'omettre de properties_list (auquel cas la <tt class="literal">valeur de graine</tt>
                    (NdT : seed value) d&eacute;finie par le <tt class="literal">org.hibernate.type.VersionType</tt> est utilis&eacute;e).
                </p></li></ul></div><p>
            Un exemple d'ex&eacute;cution d'une expression <tt class="literal">INSERT</tt> HQL :
        </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

String hqlInsert = "insert into DelinquentAccount (id, name) select c.id, c.name from Customer c where ...";
int createdEntities = s.createQuery( hqlInsert )
        .executeUpdate();
tx.commit();
session.close();</pre></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="queryhql"></a>Chapitre&nbsp;14.&nbsp;HQL: Langage de requ&ecirc;tage d'Hibernate</h2></div></div><div></div></div><p>
        Hibernate fourni un langage d'interrogation extr&ecirc;mement puissant qui
        ressemble (et c'est voulu) au SQL. Mais ne soyez pas distraits par la syntaxe ;
        HQL est totalement orient&eacute; objet, comprenant des notions d'h&eacute;ritage, de
        polymorphisme et d'association.
    </p><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-casesensitivity"></a>14.1.&nbsp;Sensibilit&eacute; &agrave; la casse</h2></div></div><div></div></div><p>
            Les requ&ecirc;tes sont insensibles &agrave; la casse, &agrave; l'exception des noms des classes Java
            et des propri&eacute;t&eacute;s.
            Ainsi, <tt class="literal">SeLeCT</tt> est identique &agrave;
            <tt class="literal">sELEct</tt> et &agrave;
            <tt class="literal">SELECT</tt> mais
            <tt class="literal">net.sf.hibernate.eg.FOO</tt> n'est pas identique
            <tt class="literal">net.sf.hibernate.eg.Foo</tt> et
            <tt class="literal">foo.barSet</tt> n'est pas identique &agrave;
            <tt class="literal">foo.BARSET</tt>.
        </p><p>
            Ce guide utilise les mots cl&eacute;s HQL en minuscule. Certains utilisateurs trouvent les
            requ&ecirc;tes &eacute;crites avec les mots cl&eacute;s en majuscule plus lisibles, mais nous trouvons
            cette convention p&eacute;nible lorsqu'elle est lue dans du code Java.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-from"></a>14.2.&nbsp;La clause from</h2></div></div><div></div></div><p>
            La requ&ecirc;te Hibernate la plus simple est de la forme :
        </p><pre class="programlisting">from eg.Cat</pre><p>
            qui retourne simplement toutes les instances de la classe <tt class="literal">eg.Cat</tt>. 
            Nous n'avons pas besoin d'habitude de qualifier le nom de la classe, 
            puisque <tt class="literal">auto-import</tt> est la valeur par d&eacute;faut. Donc nous &eacute;crivons presque toujours :
        </p><pre class="programlisting">from Cat</pre><p>
            La plupart du temps, vous devrez assigner un <span class="emphasis"><em>alias</em></span> puisque vous
            voudrez faire r&eacute;f&eacute;rence &agrave; <tt class="literal">Cat</tt> dans d'autres parties de la requ&ecirc;te.
        </p><pre class="programlisting">from Cat as cat</pre><p>
            Cette requ&ecirc;te assigne l'alias <tt class="literal">cat</tt> &agrave; l'instance <tt class="literal">Cat</tt>,
            nous pouvons donc utiliser cet alias ailleurs dans la requ&ecirc;te. Le mot cl&eacute; <tt class="literal">as</tt>
            est optionnel ; nous aurions pu &eacute;crire :
        </p><pre class="programlisting">from Cat cat</pre><p>
            Plusieurs classes peuvent appara&icirc;tre, ce qui conduira &agrave; un produit
            cart&eacute;sien (encore appel&eacute; jointures crois&eacute;es).
        </p><pre class="programlisting">from Formula, Parameter</pre><pre class="programlisting">from Formula as form, Parameter as param</pre><p>
            C'est une bonne pratique que de nommer les alias dans les requ&ecirc;tes en utilisant l'initiale
            en miniscule, ce qui a le m&eacute;rite d'&ecirc;tre en phase avec les standards de
            nommage Java pour les variables locales (<tt class="literal">domesticCat</tt>).
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-joins"></a>14.3.&nbsp;Associations et jointures</h2></div></div><div></div></div><p>
            On peut aussi assigner des alias &agrave; des entit&eacute;s associ&eacute;es, ou m&ecirc;me aux &eacute;l&eacute;ments d'une collection
            de valeurs, en utilisant un <tt class="literal">join</tt> (jointure).
        </p><pre class="programlisting">from Cat as cat
    inner join cat.mate as mate
    left outer join cat.kittens as kitten</pre><pre class="programlisting">from Cat as cat left join cat.mate.kittens as kittens</pre><pre class="programlisting">from Formula form full join form.parameter param</pre><p>
            Les types de jointures support&eacute;es sont celles de ANSI SQL
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">inner join</tt> (jointure ferm&eacute;e)
                </p></li><li><p>
                    <tt class="literal">left outer join</tt> (jointure ouverte par la gauche)
                </p></li><li><p>
                    <tt class="literal">right outer join</tt> (jointure ouverte par la droite)
                </p></li><li><p>
                    <tt class="literal">full join</tt> (jointure ouverte totalement - g&eacute;n&eacute;ralement inutile)
                </p></li></ul></div><p>
            Les constructions des jointures <tt class="literal">inner join</tt>, <tt class="literal">left outer join</tt>
            et <tt class="literal">right outer join</tt> peuvent &ecirc;tre abbr&eacute;g&eacute;es.
        </p><pre class="programlisting">from Cat as cat
    join cat.mate as mate
    left join cat.kittens as kitten</pre><p>
            Nous pouvons soumettre des conditions de jointure suppl&eacute;mentaires en utilisant le mot-clef HQL <tt class="literal">with</tt>.
        </p><pre class="programlisting">from Cat as cat
    left join cat.kittens as kitten
        with kitten.bodyWeight &gt; 10.0</pre><p>
            Par ailleurs, une jointure "fetch&eacute;e" (rapport&eacute;e) permet d'initialiser
            les associations ou collections de valeurs en m&ecirc;me temps que leur objet parent,
            le tout n'utilisant qu'un seul Select.
            Ceci est particuli&egrave;rement utile dans le cas des collections. Ce syst&egrave;me permet de surcharger
            les d&eacute;clarations "lazy" et "outer-join" des fichiers de mapping pour les associations et
            collections. Voir
            <a href="#performance-fetching" title="19.1.&nbsp;Strat&eacute;gies de chargement">Section&nbsp;19.1, &laquo;&nbsp;Strat&eacute;gies de chargement&nbsp;&raquo;</a> pour plus d'informations.
        </p><pre class="programlisting">from Cat as cat
    inner join fetch cat.mate
    left join fetch cat.kittens</pre><p>
            Une jointure "fetch&eacute;e" (rapport&eacute;e) n'a g&eacute;n&eacute;ralement pas besoin de se voir assigner
            un alias puisque les objets associ&eacute;s n'ont pas &agrave; &ecirc;tre utilis&eacute;s dans les autres clauses.
            Notez aussi que les objets associ&eacute;s ne sont pas retourn&eacute;s directement dans le r&eacute;sultat de
            la requ&ecirc;te mais l'on peut y acc&eacute;der via l'objet parent. La seule raison pour laquelle nous 
            pourrions avoir besoin d'un alias est si nous r&eacute;cup&eacute;rions r&eacute;cursivement une collection suppl&eacute;mentaire :
        </p><pre class="programlisting">from Cat as cat
    inner join fetch cat.mate
    left join fetch cat.kittens child
    left join fetch child.kittens</pre><p>
            Notez que la construction de <tt class="literal">fetch</tt> ne peut pas &ecirc;tre utilis&eacute;e dans les requ&ecirc;tes appel&eacute;es par
            <tt class="literal">scroll()</tt> ou <tt class="literal">iterate()</tt>.
            <tt class="literal">fetch</tt> ne devrait pas non plus &ecirc;tre utilis&eacute; avec <tt class="literal">setMaxResults()</tt> ou
            <tt class="literal">setFirstResult()</tt>. <tt class="literal">fetch</tt> ne peut pas non plus &ecirc;tre utilis&eacute; avec une 
            condition <tt class="literal">with</tt> ad hoc. Il est
            possible de cr&eacute;er un produit cart&eacute;sien par jointure en r&eacute;cup&eacute;rant plus d'une collection dans une requ&ecirc;te, 
            donc faites attention dans ce cas. R&eacute;cup&eacute;rer par jointure de multiples collections donne aussi parfois 
            des r&eacute;sultats inattendus pour des mappings de bag, donc soyez prudent lorsque vous formulez vos requ&ecirc;tes dans de tels cas.
            Finalement, notez que <tt class="literal">full join fetch</tt> et <tt class="literal">right join fetch</tt> ne sont pas utiles en g&eacute;n&eacute;ral.
        </p><p>
            Si vous utilisez un chargement retard&eacute; pour les propri&eacute;t&eacute;s (avec une instrumentation par bytecode), il est possible 
            de forcer Hibernate &agrave; r&eacute;cup&eacute;rer les propri&eacute;t&eacute;s non encore charg&eacute;es imm&eacute;diatement (dans la premi&egrave;re requ&ecirc;te) 
            en utilisant <tt class="literal">fetch all properties</tt>.
        </p><pre class="programlisting">from Document fetch all properties order by name</pre><pre class="programlisting">from Document doc fetch all properties where lower(doc.name) like '%cats%'</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-joins-forms"></a>14.4.&nbsp;Formes de syntaxes pour les jointures</h2></div></div><div></div></div><p>
            HQL supporte deux formes pour joindre les associations: <tt class="literal">implicite</tt> et <tt class="literal">explicite</tt>.
        </p><p>
            Les requ&ecirc;tes pr&eacute;sentes dans la section pr&eacute;c&eacute;dente utilisent la forme <tt class="literal">explicite</tt> 
            o&ugrave; le mode cl&eacute; join est explicitement utilis&eacute; dans la clause from. C'est la forme recommand&eacute;e.
        </p><p>
            La forme <tt class="literal">implicite</tt> n'utilise pas le mot cl&eacute; join.
            A la place, les associations sont "d&eacute;r&eacute;f&eacute;renc&eacute;es" en utilisant le notation '.'. Ces
            jointures peuvent apparaitre dans toutes les clauses. Les jointures <tt class="literal">implicites</tt> 
            r&eacute;sultent en des inner join dans le SQL g&eacute;n&eacute;r&eacute;.
        </p><pre class="programlisting">from Cat as cat where cat.mate.name like '%s%'</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-select"></a>14.5.&nbsp;La clause select</h2></div></div><div></div></div><p>
            La clause <tt class="literal">select</tt> s&eacute;lectionne les objets et propri&eacute;t&eacute;s
            qui doivent &ecirc;tre retourn&eacute;s dans le r&eacute;sultat de la requ&ecirc;te.
        Soit :
        </p><pre class="programlisting">select mate
from Cat as cat
    inner join cat.mate as mate</pre><p>
            La requ&ecirc;te recherchera les <tt class="literal">mate</tt>s li&eacute;s aux <tt class="literal">Cat</tt>s.
            Vous pouvez explimer la requ&ecirc;te d'une mani&egrave;re plus compacte :
        </p><pre class="programlisting">select cat.mate from Cat cat</pre><p>
            Les requ&ecirc;tes peuvent retourner des propri&eacute;t&eacute;s de n'importe quel type, m&ecirc;me celles de type
        composant (component) :
        </p><pre class="programlisting">select cat.name from DomesticCat cat
where cat.name like 'fri%'</pre><pre class="programlisting">select cust.name.firstName from Customer as cust</pre><p>
            Les requ&ecirc;tes peuvent retourner plusieurs objets et/ou propri&eacute;t&eacute;s sous la forme
        d'un tableau du type <tt class="literal">Object[]</tt>,
        </p><pre class="programlisting">select mother, offspr, mate.name
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>
            ou sous la forme d'une <tt class="literal">List</tt>,
        </p><pre class="programlisting">select new list(mother, offspr, mate.name)
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>
            ou sous la forme d'un objet Java typ&eacute;,
        </p><pre class="programlisting">select new Family(mother, mate, offspr)
from DomesticCat as mother
    join mother.mate as mate
    left join mother.kittens as offspr</pre><p>
            &agrave; condition que la classe <tt class="literal">Family</tt> poss&egrave;de le constructeur appropri&eacute;.
        </p><p>
            Vous pouvez assigner des alias aux expressions s&eacute;lectionn&eacute;es en utilisant <tt class="literal">as</tt> :
        </p><pre class="programlisting">select max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n
from Cat cat</pre><p>
            C'est surtout utile lorsque c'est utilis&eacute; avec
            <tt class="literal">select new map</tt> :
        </p><pre class="programlisting">select new map( max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n )
from Cat cat</pre><p>
            Cette requ&ecirc;te retourne une <tt class="literal">Map</tt> &agrave; partir des alias vers les valeurs s&eacute;lectionn&eacute;es.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-aggregation"></a>14.6.&nbsp;Fonctions d'aggr&eacute;gation</h2></div></div><div></div></div><p>
            Les requ&ecirc;tes HQL peuvent aussi retourner le r&eacute;sultat de fonctions d'aggr&eacute;gation
            sur les propri&eacute;t&eacute;s :
        </p><pre class="programlisting">select avg(cat.weight), sum(cat.weight), max(cat.weight), count(cat)
from Cat cat</pre><p>
            Les fonctions support&eacute;es sont
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">avg(...), sum(...), min(...), max(...)</tt>
                </p></li><li><p>
                    <tt class="literal">count(*)</tt>
                </p></li><li><p>
                    <tt class="literal">count(...), count(distinct ...), count(all...)</tt>
                </p></li></ul></div><p>
            Vous pouvez utiliser des op&eacute;rateurs arithm&eacute;tiques, la concat&eacute;nation, et des fonctions SQL reconnues dans la clause select :
        </p><pre class="programlisting">select cat.weight + sum(kitten.weight)
from Cat cat
    join cat.kittens kitten
group by cat.id, cat.weight</pre><pre class="programlisting">select firstName||' '||initial||' '||upper(lastName) from Person</pre><p>
            Les mots cl&eacute; <tt class="literal">distinct</tt> et <tt class="literal">all</tt> peuvent &ecirc;tre utilis&eacute;s et ont
        la m&ecirc;me signification qu'en SQL.
        </p><pre class="programlisting">select distinct cat.name from Cat cat

select count(distinct cat.name), count(cat) from Cat cat</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-polymorphism"></a>14.7.&nbsp;Requ&ecirc;tes polymorphiques</h2></div></div><div></div></div><p>
            Une requ&ecirc;te comme:
        </p><pre class="programlisting">from Cat as cat</pre><p>
            retourne non seuleument les instances de <tt class="literal">Cat</tt>, mais aussi celles des
            sous classes comme <tt class="literal">DomesticCat</tt>. Les requ&ecirc;tes Hibernate peuvent nommer n'importe
            quelle classe ou interface Java dans la clause <tt class="literal">from</tt>. La requ&ecirc;te retournera les
            instances de toutes les classes persistantes qui &eacute;tendent cette classe ou impl&eacute;mente cette interface.
        La requ&ecirc;te suivante retournera tous les objets persistants :
        </p><pre class="programlisting">from java.lang.Object o</pre><p>
            L'interface <tt class="literal">Named</tt> peut &ecirc;tre impl&eacute;ment&eacute;e par plusieurs classes persistantes :
        </p><pre class="programlisting">from Named n, Named m where n.name = m.name</pre><p>
            Notez que ces deux derni&egrave;res requ&ecirc;tes n&eacute;cessitent plus d'un <tt class="literal">SELECT</tt> SQL.
            Ce qui signifie que la clause <tt class="literal">order by</tt> ne trie pas correctement la totalit&eacute;
            des r&eacute;sultats (cela signifie aussi que vous ne pouvez ex&eacute;cuter ces requ&ecirc;tes en appelant
        <tt class="literal">Query.scroll()</tt>).
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-where"></a>14.8.&nbsp;La clause where</h2></div></div><div></div></div><p>
            La clause <tt class="literal">where</tt> vous permet de r&eacute;duire la liste des instances retourn&eacute;es. 
            Si aucun alias n'existe, vous pouvez vous r&eacute;f&eacute;rer aux propri&eacute;t&eacute;s par leur nom :
        </p><pre class="programlisting">from Cat where name='Fritz'</pre><p>
            S'il y a un alias, utilisez un nom de propri&eacute;t&eacute; qualifi&eacute; :
        </p><pre class="programlisting">from Cat as cat where cat.name='Fritz'</pre><p>
            retourne les instances de <tt class="literal">Cat</tt> dont name est &eacute;gale &agrave; 'Fritz'.
        </p><pre class="programlisting">select foo
from Foo foo, Bar bar
where foo.startDate = bar.date</pre><p>
            retournera les instances de <tt class="literal">Foo</tt> pour lesquelles
            il existe une instance de <tt class="literal">bar</tt> avec la
            propri&eacute;t&eacute; <tt class="literal">date</tt> est &eacute;gale &agrave; la
            propri&eacute;t&eacute; <tt class="literal">startDate</tt> de <tt class="literal">Foo</tt>.
            Les expressions utilisant la navigation rendent la clause <tt class="literal">where</tt>
        extr&ecirc;mement puissante. Soit :
        </p><pre class="programlisting">from Cat cat where cat.mate.name is not null</pre><p>
            Cette requ&ecirc;te se traduit en SQL par une jointure interne &agrave; une table.
        Si vous souhaitez &eacute;crire quelque chose comme :
        </p><pre class="programlisting">from Foo foo
where foo.bar.baz.customer.address.city is not null</pre><p>
            vous finiriez avec une requ&ecirc;te qui n&eacute;cessiterait quatre jointures en SQL.
        </p><p>
            L'op&eacute;rateur <tt class="literal">=</tt> peut &ecirc;tre utilis&eacute; pour comparer aussi bien des propri&eacute;t&eacute;s que des instances :
        </p><pre class="programlisting">from Cat cat, Cat rival where cat.mate = rival.mate</pre><pre class="programlisting">select cat, mate
from Cat cat, Cat mate
where cat.mate = mate</pre><p>
            La propri&eacute;t&eacute; sp&eacute;ciale (en minuscule) <tt class="literal">id</tt> peut &ecirc;tre utilis&eacute;e
            pour faire r&eacute;f&eacute;rence &agrave; l'identifiant d'un objet (vous pouvez aussi utiliser
        le nom de cette propri&eacute;t&eacute;).
        </p><pre class="programlisting">from Cat as cat where cat.id = 123

from Cat as cat where cat.mate.id = 69</pre><p>
            La seconde requ&ecirc;te est particuli&egrave;rement efficace. Aucune jointure n'est n&eacute;cessaire !
        </p><p>
            Les propri&eacute;t&eacute;s d'un identifiant compos&eacute; peuvent aussi &ecirc;tre utilis&eacute;es. Supposez que
            <tt class="literal">Person</tt> ait un identifiant compos&eacute; de <tt class="literal">country</tt> et
            <tt class="literal">medicareNumber</tt>.
        </p><pre class="programlisting">from bank.Person person
where person.id.country = 'AU'
    and person.id.medicareNumber = 123456</pre><pre class="programlisting">from bank.Account account
where account.owner.id.country = 'AU'
    and account.owner.id.medicareNumber = 123456</pre><p>
            Une fois de plus, la seconde requ&ecirc;te ne n&eacute;cessite pas de jointure.
        </p><p>
            De m&ecirc;me, la propri&eacute;t&eacute; sp&eacute;ciale <tt class="literal">class</tt> interroge la valeur discriminante
            d'une instance dans le cas d'une persistance polymorphique. Le nom d'une classe Java incorpor&eacute;e
        dans la clause where sera traduite par sa valeur discriminante.
        </p><pre class="programlisting">from Cat cat where cat.class = DomesticCat</pre><p>
            Vous pouvez aussi sp&eacute;cifier les propri&eacute;t&eacute;s des composants ou types utilisateurs compos&eacute;s
            (components, composite user types etc). N'essayez jamais d'utiliser un expression de navigation
            qui se terminerait par une propri&eacute;t&eacute; de type composant (qui est diff&eacute;rent d'une propri&eacute;t&eacute; d'un
            composant). Par exemple, si <tt class="literal">store.owner</tt> est une entit&eacute; avec un composant
        <tt class="literal">address</tt>
        </p><pre class="programlisting">store.owner.address.city    // okay
store.owner.address         // error!</pre><p>
            Un type "any" poss&egrave;de les propri&eacute;t&eacute;s sp&eacute;ciales <tt class="literal">id</tt> et <tt class="literal">class</tt>,
            qui nous permettent d'exprimer une jointure de la mani&egrave;re suivante (o&ugrave; <tt class="literal">AuditLog.item</tt>
            est une propri&eacute;t&eacute; mapp&eacute;e avec <tt class="literal">&lt;any&gt;</tt>).
        </p><pre class="programlisting">from AuditLog log, Payment payment
where log.item.class = 'Payment' and log.item.id = payment.id</pre><p>
            Dans la requ&ecirc;te pr&eacute;c&eacute;dente, notez que <tt class="literal">log.item.class</tt> et <tt class="literal">payment.class</tt>
            feraient r&eacute;f&eacute;rence &agrave; des valeurs de colonnes de la base de donn&eacute;es compl&egrave;tement diff&eacute;rentes.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-expressions"></a>14.9.&nbsp;Expressions</h2></div></div><div></div></div><p>
            Les expressions permises dans la clause <tt class="literal">where</tt> incluent
        la plupart des choses que vous pouvez utiliser en SQL :
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    op&eacute;rateurs math&eacute;matiques <tt class="literal">+, -, *, /</tt>
                </p></li><li><p>
                    op&eacute;rateur de comparaison binaire <tt class="literal">=, &gt;=, &lt;=, &lt;&gt;, !=, like</tt>
                </p></li><li><p>
                    op&eacute;rateurs logiques <tt class="literal">and, or, not</tt>
                </p></li><li><p>
                    Parenth&egrave;ses <tt class="literal">( )</tt>, indiquant un regroupement
                </p></li><li><p>
                    <tt class="literal">in</tt>,
                    <tt class="literal">not in</tt>,
                    <tt class="literal">between</tt>,
                    <tt class="literal">is null</tt>,
                    <tt class="literal">is not null</tt>,
                    <tt class="literal">is empty</tt>,
                    <tt class="literal">is not empty</tt>,
                    <tt class="literal">member of</tt> and
                    <tt class="literal">not member of</tt>
                </p></li><li><p>
                    "Simple" case, <tt class="literal">case ... when ... then ... else ... end</tt>, and
                    "searched" case, <tt class="literal">case when ... then ... else ... end</tt>
                </p></li><li><p>
                    concatenation de cha&icirc;ne de caract&egrave;res <tt class="literal">...||...</tt> ou <tt class="literal">concat(...,...)</tt>
                </p></li><li><p>
                    <tt class="literal">current_date()</tt>, <tt class="literal">current_time()</tt>,
                    <tt class="literal">current_timestamp()</tt>
                </p></li><li><p>
                    <tt class="literal">second(...)</tt>, <tt class="literal">minute(...)</tt>,
                    <tt class="literal">hour(...)</tt>, <tt class="literal">day(...)</tt>,
                    <tt class="literal">month(...)</tt>, <tt class="literal">year(...)</tt>,
                </p></li><li><p>
                    N'importe quel fonction ou op&eacute;rateur d&eacute;fini par EJB-QL 3.0 : <tt class="literal">substring(), trim(),
                    lower(), upper(), length(), locate(), abs(), sqrt(), bit_length(), mod()</tt>
                </p></li><li><p>
                    <tt class="literal">coalesce()</tt> et <tt class="literal">nullif()</tt>
                </p></li><li><p>
                    <tt class="literal">str()</tt> pour convertir des valeurs num&eacute;riques ou temporelles vers une cha&icirc;ne de caract&egrave;res lisible
                </p></li><li><p>
                    <tt class="literal">cast(... as ...)</tt>, o&ugrave; le second argument est le nom d'un type Hibernate, et <tt class="literal">extract(... from ...)</tt> si le
                    <tt class="literal">cast()</tt> ANSI et <tt class="literal">extract()</tt> sont support&eacute;s par la base de donn&eacute;es sous-jacente
                </p></li><li><p>
                    La fonction HQL <tt class="literal">index()</tt>, qui s'applique aux alias d'une collection index&eacute;e jointe
                </p></li><li><p>
                    Les fonctions HQL qui s'appliquent expressions repr&eacute;sentant des collections : <tt class="literal">size(),
                    minelement(), maxelement(), minindex(), maxindex()</tt>, ainsi que les fonctions sp&eacute;ciales <tt class="literal">elements()</tt> 
                    et <tt class="literal">indices</tt> qui peuvent &ecirc;tre quantifi&eacute;es en utilisant <tt class="literal">some, all, exists, any, in</tt>.
                </p></li><li><p>
                    N'importe quelle fonction scalaire support&eacute;e par la base de donn&eacute;es comme
                    <tt class="literal">sign()</tt>,
                    <tt class="literal">trunc()</tt>, <tt class="literal">rtrim()</tt>, <tt class="literal">sin()</tt>
                </p></li><li><p>
                    Les param&egrave;tres positionnels de JDBC
                    <tt class="literal">?</tt>
                </p></li><li><p>
                    param&egrave;tres nomm&eacute;s <tt class="literal">:name</tt>, <tt class="literal">:start_date</tt>, <tt class="literal">:x1</tt>
                </p></li><li><p>
                    litt&eacute;ral SQL <tt class="literal">'foo'</tt>, <tt class="literal">69</tt>, <tt class="literal">'1970-01-01 10:00:01.0'</tt>
                </p></li><li><p>
                    Constantes Java <tt class="literal">public static final</tt> <tt class="literal">eg.Color.TABBY</tt>
                </p></li></ul></div><p>
            <tt class="literal">in</tt> et <tt class="literal">between</tt> peuvent &ecirc;tre utilis&eacute;s comme suit :
        </p><pre class="programlisting">from DomesticCat cat where cat.name between 'A' and 'B'</pre><pre class="programlisting">from DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )</pre><p>
            et la forme n&eacute;gative peut &ecirc;tre &eacute;crite
        </p><pre class="programlisting">from DomesticCat cat where cat.name not between 'A' and 'B'</pre><pre class="programlisting">from DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )</pre><p>
            De m&ecirc;me, <tt class="literal">is null</tt> et <tt class="literal">is not null</tt> peuvent &ecirc;tre utilis&eacute;s pour tester
        les valeurs nulle.
        </p><p>
            Les bool&eacute;ens peuvent &ecirc;tre facilement utilis&eacute;s en d&eacute;clarant les substitutions de requ&ecirc;tes dans la
        configuration Hibernate :
        </p><pre class="programlisting">&lt;property name="hibernate.query.substitutions"&gt;true 1, false 0&lt;/property&gt;</pre><p>
            Ce qui remplacera les mots cl&eacute;s <tt class="literal">true</tt> et <tt class="literal">false</tt> par
            <tt class="literal">1</tt> et <tt class="literal">0</tt> dans la traduction SQL du HQL suivant :
        </p><pre class="programlisting">from Cat cat where cat.alive = true</pre><p>
            Vous pouvez tester la taille d'une collection par la propri&eacute;t&eacute; sp&eacute;ciale <tt class="literal">size</tt>, ou
            la fonction sp&eacute;ciale <tt class="literal">size()</tt>.
        </p><pre class="programlisting">from Cat cat where cat.kittens.size &gt; 0</pre><pre class="programlisting">from Cat cat where size(cat.kittens) &gt; 0</pre><p>
            Pour les collections index&eacute;es, vous pouvez faire r&eacute;f&eacute;rence aux indices minimum et maximum en
            utilisant les fonctions <tt class="literal">minindex</tt> and <tt class="literal">maxindex</tt>. De mani&egrave;re similaire,
            vous pouvez faire r&eacute;f&eacute;rence aux &eacute;l&eacute;ments minimum et maximum d'une collection de type basiques
        en utilisant les fonctions <tt class="literal">minelement</tt> et <tt class="literal">maxelement</tt>.
        </p><pre class="programlisting">from Calendar cal where maxelement(cal.holidays) &gt; current date</pre><pre class="programlisting">from Order order where maxindex(order.items) &gt; 100</pre><pre class="programlisting">from Order order where minelement(order.items) &gt; 10000</pre><p>
            Les fonctions SQL <tt class="literal">any, some, all, exists, in</tt> supportent que leur soient pass&eacute;es
            l'&eacute;l&eacute;ment, l'index d'une collection (fonctions <tt class="literal">elements</tt> et <tt class="literal">indices</tt>)
        ou le r&eacute;sultat d'une sous requ&ecirc;te (voir ci dessous).
        </p><pre class="programlisting">select mother from Cat as mother, Cat as kit
where kit in elements(foo.kittens)</pre><pre class="programlisting">select p from NameList list, Person p
where p.name = some elements(list.names)</pre><pre class="programlisting">from Cat cat where exists elements(cat.kittens)</pre><pre class="programlisting">from Player p where 3 &gt; all elements(p.scores)</pre><pre class="programlisting">from Show show where 'fizard' in indices(show.acts)</pre><p>
            Notez que l'&eacute;criture de - <tt class="literal">size</tt>, <tt class="literal">elements</tt>,
            <tt class="literal">indices</tt>, <tt class="literal">minindex</tt>, <tt class="literal">maxindex</tt>,
            <tt class="literal">minelement</tt>, <tt class="literal">maxelement</tt> - peuvent seulement &ecirc;tre utilis&eacute;e dans la clause where dans Hibernate3.
        </p><p>
            Les &eacute;l&eacute;ments de collections index&eacute;es (arrays, lists, maps) peuvent &ecirc;tre r&eacute;f&eacute;renc&eacute;s via index
        (dans une clause where seulement) :
        </p><pre class="programlisting">from Order order where order.items[0].id = 1234</pre><pre class="programlisting">select person from Person person, Calendar calendar
where calendar.holidays['national day'] = person.birthDay
    and person.nationality.calendar = calendar</pre><pre class="programlisting">select item from Item item, Order order
where order.items[ order.deliveredItemIndices[0] ] = item and order.id = 11</pre><pre class="programlisting">select item from Item item, Order order
where order.items[ maxindex(order.items) ] = item and order.id = 11</pre><p>
            L'expression entre <tt class="literal">[]</tt> peut m&ecirc;me &ecirc;tre une expression arithm&eacute;tique.
        </p><pre class="programlisting">select item from Item item, Order order
where order.items[ size(order.items) - 1 ] = item</pre><p>
            HQL propose aussi une fonction <tt class="literal">index()</tt> interne, pour les &eacute;l&eacute;ments
        d'une association one-to-many ou d'une collections de valeurs.
        </p><pre class="programlisting">select item, index(item) from Order order
    join order.items item
where index(item) &lt; 5</pre><p>
            Les fonctions SQL scalaires support&eacute;es par la base de donn&eacute;es utilis&eacute;e peuvent &ecirc;tre utilis&eacute;es
        </p><pre class="programlisting">from DomesticCat cat where upper(cat.name) like 'FRI%'</pre><p>
            Si vous n'&ecirc;tes pas encore convaincu par tout cela, imaginez la taille et l'illisibilit&eacute; qui caract&eacute;riseraient
        la transformation SQL de la requ&ecirc;te HQL suivante :
        </p><pre class="programlisting">select cust
from Product prod,
    Store store
    inner join store.customers cust
where prod.name = 'widget'
    and store.location.name in ( 'Melbourne', 'Sydney' )
    and prod = all elements(cust.currentOrder.lineItems)</pre><p>
            <span class="emphasis"><em>Un indice :</em></span> cela donnerait quelque chose comme
        </p><pre class="programlisting">SELECT cust.name, cust.address, cust.phone, cust.id, cust.current_order
FROM customers cust,
    stores store,
    locations loc,
    store_customers sc,
    product prod
WHERE prod.name = 'widget'
    AND store.loc_id = loc.id
    AND loc.name IN ( 'Melbourne', 'Sydney' )
    AND sc.store_id = store.id
    AND sc.cust_id = cust.id
    AND prod.id = ALL(
        SELECT item.prod_id
        FROM line_items item, orders o
        WHERE item.order_id = o.id
            AND cust.current_order = o.id
    )</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-ordering"></a>14.10.&nbsp;La clause order by</h2></div></div><div></div></div><p>
            La liste retoun&eacute;e par la requ&ecirc;te peut &ecirc;tre tri&eacute;e par n'importe quelle propri&eacute;t&eacute; de la classe ou
        du composant retourn&eacute; :
        </p><pre class="programlisting">from DomesticCat cat
order by cat.name asc, cat.weight desc, cat.birthdate</pre><p>
            Le mot optionnel <tt class="literal">asc</tt> ou <tt class="literal">desc</tt> indique respectivement si le tri
        doit &ecirc;tre croissant ou d&eacute;croissant.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-grouping"></a>14.11.&nbsp;La clause group by</h2></div></div><div></div></div><p>
            Si la requ&ecirc;te retourne des valeurs aggr&eacute;g&eacute;es, celles ci peuvent &ecirc;tre group&eacute;es par propri&eacute;t&eacute; ou composant :
        </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat)
from Cat cat
group by cat.color</pre><pre class="programlisting">select foo.id, avg(name), max(name)
from Foo foo join foo.names name
group by foo.id</pre><p>
            Une clause <tt class="literal">having</tt> est aussi permise.
        </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat)
from Cat cat
group by cat.color
having cat.color in (eg.Color.TABBY, eg.Color.BLACK)</pre><p>
            Les fonctions SQL et les fonctions d'aggr&eacute;gations sont permises dans les clauses <tt class="literal">having</tt>
            et <tt class="literal">order by</tt>, si elles sont support&eacute;es par la base de donn&eacute;es (ce que ne fait pas MySQL par exemple).
        </p><pre class="programlisting">select cat
from Cat cat
    join cat.kittens kitten
group by cat
having avg(kitten.weight) &gt; 100
order by count(kitten) asc, sum(kitten.weight) desc</pre><p>
            Notez que ni la clause <tt class="literal">group by</tt> ni la clause
            <tt class="literal">order by</tt> ne peuvent contenir d'expressions arithm&eacute;tiques.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-subqueries"></a>14.12.&nbsp;Sous-requ&ecirc;tes</h2></div></div><div></div></div><p>
            Pour les bases de donn&eacute;es le supportant, Hibernate supporte les sous requ&ecirc;tes dans les requ&ecirc;tes.
            Une sous requ&ecirc;te doit &ecirc;tre entre parenth&egrave;ses (souvent pour un appel &agrave; une fonction d'agr&eacute;gation SQL)
            M&ecirc;me les sous requ&ecirc;tes corr&eacute;l&eacute;es (celles qui font r&eacute;f&eacute;rence &agrave; un alias de la requ&ecirc;te principale) sont
        support&eacute;es.
        </p><pre class="programlisting">from Cat as fatcat
where fatcat.weight &gt; (
    select avg(cat.weight) from DomesticCat cat
)</pre><pre class="programlisting">from DomesticCat as cat
where cat.name = some (
    select name.nickName from Name as name
)</pre><pre class="programlisting">from Cat as cat
where not exists (
    from Cat as mate where mate.mate = cat
)</pre><pre class="programlisting">from DomesticCat as cat
where cat.name not in (
    select name.nickName from Name as name
)</pre><pre class="programlisting">select cat.id, (select max(kit.weight) from cat.kitten kit)
from Cat as cat</pre><p>
            Notez que les sous-requ&ecirc;tes HQL peuvent arriver seulememnt dans les clauses select ou where.
        </p><p>
            Pour des sous-requ&ecirc;tes avec plus d'une expression dans le select, vous pouvez utiliser un constructeur de tuples :
        </p><pre class="programlisting">from Cat as cat
where not ( cat.name, cat.color ) in (
    select cat.name, cat.color from DomesticCat cat
)</pre><p>
            Notez que sur certaines bases de donn&eacute;es (mais par Oracle ou HSQL), vous pouvez utiliser des constructeurs de tuples 
            dans d'autres contextes, par exemple lors du requ&ecirc;tage de composants ou de types utilisateur composites :
        </p><pre class="programlisting">from Person where name = ('Gavin', 'A', 'King')</pre><p>
            Ce qui est &eacute;quivalent &agrave; la forme plus verbeuse suivante :
        </p><pre class="programlisting">from Person where name.first = 'Gavin' and name.initial = 'A' and name.last = 'King')</pre><p>
            Il y a deux bonnes raisons que vous ne puissiez ne pas vouloir faire cette sorte de choses : d'abord, ce n'est
            pas compl&egrave;tement portable entre les plateformes de base de donn&eacute;es ; deuxi&egrave;mement, la requ&ecirc;te est maintenant
            d&eacute;pendante de l'ordre des propri&eacute;t&eacute;s dans le document de mapping.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-examples"></a>14.13.&nbsp;Exemples HQL</h2></div></div><div></div></div><p>
            Les requ&ecirc;tes Hibernate peuvent &ecirc;tre relativement puissantes et complexes. En fait, la puissance
            du langage de requ&ecirc;tage est l'un des avantages principaux d'Hibernate. Voici quelques exemples
            tr&egrave;s similaires aux requ&ecirc;tes que nous avons utilis&eacute;es lors d'un r&eacute;cent projet. Notez que la plupart
        des requ&ecirc;tes que vous &eacute;crirez seront plus simples que les exemples suivantes !
        </p><p>
            La requ&ecirc;te suivante retourne l'id de commande (order), le nombre d'articles (items) et la valeur
            totale de la commande (order) pour toutes les commandes non pay&eacute;es d'un client (customer) particulier
            pour un total minimum donn&eacute;, le tout tri&eacute; par la valeur totale. La requ&ecirc;te SQL g&eacute;n&eacute;r&eacute;e sur les tables
            <tt class="literal">ORDER</tt>, <tt class="literal">ORDER_LINE</tt>, <tt class="literal">PRODUCT</tt>,
            <tt class="literal">CATALOG</tt> et <tt class="literal">PRICE</tt> est compos&eacute;e de quatre jointures interne ainsi que
        d'une sous-requ&ecirc;te (non corr&eacute;l&eacute;e).
        </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog.effectiveDate &lt; sysdate
    and catalog.effectiveDate &gt;= all (
        select cat.effectiveDate
        from Catalog as cat
        where cat.effectiveDate &lt; sysdate
    )
group by order
having sum(price.amount) &gt; :minAmount
order by sum(price.amount) desc</pre><p>
            Quel monstre !
            En principe, nous ne sommes pas tr&egrave;s fan des sous-requ&ecirc;tes, la requ&ecirc;te ressemblait donc plut&ocirc;t
        &agrave; cela :
        </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog = :currentCatalog
group by order
having sum(price.amount) &gt; :minAmount
order by sum(price.amount) desc</pre><p>
            La requ&ecirc;te suivante compte le nombre de paiements (payments) pour chaque status, en excluant
            les paiements dans le status <tt class="literal">AWAITING_APPROVAL</tt> o&ugrave; le changement de status
            le plus r&eacute;cent &agrave; &eacute;t&eacute; fait par l'utilisateur courant. En SQL, cette requ&ecirc;te effectue deux
            jointures internes et des sous requ&ecirc;tes corr&eacute;l&eacute;es sur les tables <tt class="literal">PAYMENT</tt>,
        <tt class="literal">PAYMENT_STATUS</tt> et <tt class="literal">PAYMENT_STATUS_CHANGE</tt>.
        </p><pre class="programlisting">select count(payment), status.name
from Payment as payment
    join payment.currentStatus as status
    join payment.statusChanges as statusChange
where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL
    or (
        statusChange.timeStamp = (
            select max(change.timeStamp)
            from PaymentStatusChange change
            where change.payment = payment
        )
        and statusChange.user &lt;&gt; :currentUser
    )
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>
            Si nous avions mapp&eacute; la collection <tt class="literal">statusChanges</tt> comme une liste, au lieu d'un ensemble,
            la requ&ecirc;te aurait &eacute;t&eacute; plus facile &agrave; &eacute;crire.
        </p><pre class="programlisting">select count(payment), status.name
from Payment as payment
    join payment.currentStatus as status
where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL
    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user &lt;&gt; :currentUser
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>
            La requ&ecirc;te qui suit utilise la fonction de MS SQL <tt class="literal">isNull()</tt> pour retourner
            tous les comptes (accounts) et paiements (payments) impay&eacute;s pour l'organisation &agrave; laquelle
            l'uilisateur (user) courant appartient. Elle est traduite en SQL par trois jointures internes,
            une jointure externe ainsi qu'une sous requ&ecirc;te sur les tables <tt class="literal">ACCOUNT</tt>, <tt class="literal">PAYMENT</tt>,
            <tt class="literal">PAYMENT_STATUS</tt>, <tt class="literal">ACCOUNT_TYPE</tt>, <tt class="literal">ORGANIZATION</tt> et
            <tt class="literal">ORG_USER</tt>.
        </p><pre class="programlisting">select account, payment
from Account as account
    left outer join account.payments as payment
where :currentUser in elements(account.holder.users)
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre><p>
            Pour d'autres base de donn&eacute;es, nous aurions d&ucirc; faire sans la sous-requ&ecirc;te (corr&eacute;l&eacute;e).
        </p><pre class="programlisting">select account, payment
from Account as account
    join account.holder.users as user
    left outer join account.payments as payment
where :currentUser = user
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-bulk"></a>14.14.&nbsp;Mise &agrave; jour et suppression</h2></div></div><div></div></div><p>
            HQL supporte maintenant les expressions <tt class="literal">update</tt>, <tt class="literal">delete</tt> et
            <tt class="literal">insert ... select ...</tt>.
            Voir <a href="#batch-direct" title="13.4.&nbsp;Op&eacute;rations de style DML">Section&nbsp;13.4, &laquo;&nbsp;Op&eacute;rations de style DML&nbsp;&raquo;</a> pour les d&eacute;tails.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-tipstricks"></a>14.15.&nbsp;Trucs &amp; Astuces</h2></div></div><div></div></div><p>
            Vous pouvez compter le nombre de r&eacute;sultats d'une requ&ecirc;te sans les retourner :
        </p><pre class="programlisting">( (Integer) session.iterate("select count(*) from ....").next() ).intValue()</pre><p>
            Pour trier les r&eacute;sultats par la taille d'une collection, utilisez la requ&ecirc;te suivante :
        </p><pre class="programlisting">select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
order by count(msg)</pre><p>
            Si votre base de donn&eacute;es supporte les sous-requ&ecirc;tes, vous pouvez placer des
        conditions sur la taille de la s&eacute;lection dans la clause where de votre requ&ecirc;te:
        </p><pre class="programlisting">from User usr where size(usr.messages) &gt;= 1</pre><p>
            Si votre base de donn&eacute;es ne supporte pas les sous-requ&ecirc;tes, utilisez la requ&ecirc;te suivante :
        </p><pre class="programlisting">select usr.id, usr.name
from User usr.name
    join usr.messages msg
group by usr.id, usr.name
having count(msg) &gt;= 1</pre><p>
            Cette solution ne peut pas retourner un <tt class="literal">User</tt> avec z&eacute;ro message
            &agrave; cause de la jointure interne, la forme suivante peut donc &ecirc;tre utile :
        </p><pre class="programlisting">select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
having count(msg) = 0</pre><p>
            Les propri&eacute;t&eacute;s d'un JavaBean peuvent &ecirc;tre inject&eacute;es dans les param&egrave;tres nomm&eacute;s d'un requ&ecirc;te :
        </p><pre class="programlisting">Query q = s.createQuery("from foo Foo as foo where foo.name=:name and foo.size=:size");
q.setProperties(fooBean); // fooBean has getName() and getSize()
List foos = q.list();</pre><p>
            Les collections sont paginables via l'utilisation de l'interface <tt class="literal">Query</tt> avec un filtre :
        </p><pre class="programlisting">Query q = s.createFilter( collection, "" ); // the trivial filter
q.setMaxResults(PAGE_SIZE);
q.setFirstResult(PAGE_SIZE * pageNumber);
List page = q.list();</pre><p>
            Les &eacute;l&eacute;ments d'une collection peuvent &ecirc;tre tri&eacute;s ou group&eacute;s en utilisant un filtre de requ&ecirc;te :
        </p><pre class="programlisting">Collection orderedCollection = s.filter( collection, "order by this.amount" );
Collection counts = s.filter( collection, "select this.type, count(this) group by this.type" );</pre><p>
            Vous pouvez r&eacute;cup&eacute;rer la taille d'une collection sans l'initialiser :
        </p><pre class="programlisting">( (Integer) session.iterate("select count(*) from ....").next() ).intValue();</pre></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="querycriteria"></a>Chapitre&nbsp;15.&nbsp;Requ&ecirc;tes par crit&egrave;res</h2></div></div><div></div></div><p>
        Hibernate offre une API d'interrogation par crit&egrave;res intuitive et extensible.
    </p><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-creating"></a>15.1.&nbsp;Cr&eacute;er une instance de <tt class="literal">Criteria</tt></h2></div></div><div></div></div><p>
            L'interface <tt class="literal">net.sf.hibernate.Criteria</tt> repr&eacute;sente une requ&ecirc;te sur une
            classe persistente donn&eacute;e. La <tt class="literal">Session</tt> fournit les instances de
            <tt class="literal">Criteria</tt>.
        </p><pre class="programlisting">Criteria crit = sess.createCriteria(Cat.class);
crit.setMaxResults(50);
List cats = crit.list();</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-narrowing"></a>15.2.&nbsp;Restriction du r&eacute;sultat</h2></div></div><div></div></div><p>
            Un criterion (crit&egrave;re de recherche) est une instance de l'interface
            <tt class="literal">org.hibernate.criterion.Criterion</tt>. La classe
            <tt class="literal">org.hibernate.criterion.Restrictions</tt> d&eacute;finit
            des m&eacute;thodes pour obtenir des types de <tt class="literal">Criterion</tt>
            pr&eacute;-d&eacute;finis.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "Fritz%") )
    .add( Restrictions.between("weight", minWeight, maxWeight) )
    .list();</pre><p>
            Les restrictions peuvent &ecirc;tre goup&eacute;es de mani&egrave;re logique.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "Fritz%") )
    .add( Restrictions.or(
        Restrictions.eq( "age", new Integer(0) ),
        Restrictions.isNull("age")
    ) )
    .list();</pre><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.in( "name", new String[] { "Fritz", "Izi", "Pk" } ) )
    .add( Restrictions.disjunction()
        .add( Restrictions.isNull("age") )
        .add( Restrictions.eq("age", new Integer(0) ) )
        .add( Restrictions.eq("age", new Integer(1) ) )
        .add( Restrictions.eq("age", new Integer(2) ) )
    ) )
    .list();</pre><p>
            Il y a plusieurs types de criterion pr&eacute;-d&eacute;finis (sous classes de <tt class="literal">Restriction</tt>),
            mais l'une d'entre elle particuli&egrave;rement utile vous permet de sp&eacute;cifier directement
        du SQL.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.sql("lower({alias}.name) like lower(?)", "Fritz%", Hibernate.STRING) )
    .list();</pre><p>
            La zone <tt class="literal">{alias}</tt> sera remplac&eacute;e par l'alias de colonne de l'entit&eacute;
        que l'on souhaite int&eacute;rroger.
        </p><p>
            Une autre approche pour obtenir un criterion est de le r&eacute;cup&eacute;rer d'une instance de <tt class="literal">Property</tt>. 
            Vous pouvez cr&eacute;er une <tt class="literal">Property</tt> en appelant <tt class="literal">Property.forName()</tt>.
        </p><pre class="programlisting">
Property age = Property.forName("age");
List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.disjunction()
        .add( age.isNull() )
        .add( age.eq( new Integer(0) ) )
        .add( age.eq( new Integer(1) ) )
        .add( age.eq( new Integer(2) ) )
    ) )
    .add( Property.forName("name").in( new String[] { "Fritz", "Izi", "Pk" } ) )
    .list();</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-ordering"></a>15.3.&nbsp;Trier les r&eacute;sultats</h2></div></div><div></div></div><p>
            Vous pouvez trier les r&eacute;sultats en utilisant <tt class="literal">org.hibernate.criterion.Order</tt>.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "F%")
    .addOrder( Order.asc("name") )
    .addOrder( Order.desc("age") )
    .setMaxResults(50)
    .list();</pre><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Property.forName("name").like("F%") )
    .addOrder( Property.forName("name").asc() )
    .addOrder( Property.forName("age").desc() )
    .setMaxResults(50)
    .list();</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-associations"></a>15.4.&nbsp;Associations</h2></div></div><div></div></div><p>
            Vous pouvez facilement sp&eacute;cifier des contraintes sur des entit&eacute;s li&eacute;es,
        par des associations en utilisant <tt class="literal">createCriteria()</tt>.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "F%")
    .createCriteria("kittens")
        .add( Restrictions.like("name", "F%")
    .list();</pre><p>
            Notez que la seconde <tt class="literal">createCriteria()</tt> retourne une nouvelle
            instance de <tt class="literal">Criteria</tt>, qui se rapporte aux &eacute;l&eacute;ments de la
        collection <tt class="literal">kittens</tt>.
        </p><p>
            La forme alternative suivante est utile dans certains cas.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .createAlias("kittens", "kt")
    .createAlias("mate", "mt")
    .add( Restrictions.eqProperty("kt.name", "mt.name") )
    .list();</pre><p>
            (<tt class="literal">createAlias()</tt> ne cr&eacute;e pas de nouvelle instance de
            <tt class="literal">Criteria</tt>.)
        </p><p>
            Notez que les collections kittens contenues dans les instances de <tt class="literal">Cat</tt>
            retourn&eacute;es par les deux pr&eacute;c&eacute;dentes requ&ecirc;tes ne sont <span class="emphasis"><em>pas</em></span> pr&eacute;-filtr&eacute;es
            par les crit&egrave;res ! Si vous souhaitez r&eacute;cup&eacute;rer uniquement les kittens qui correspondent &agrave; la
            criteria, vous devez utiliser <tt class="literal">ResultTransformer</tt>.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .createCriteria("kittens", "kt")
        .add( Restrictions.eq("name", "F%") )
    .setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP)
    .list();
Iterator iter = cats.iterator();
while ( iter.hasNext() ) {
    Map map = (Map) iter.next();
    Cat cat = (Cat) map.get(Criteria.ROOT_ALIAS);
    Cat kitten = (Cat) map.get("kt");
}</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-dynamicfetching"></a>15.5.&nbsp;Peuplement d'associations de mani&egrave;re dynamique</h2></div></div><div></div></div><p>
            Vous pouvez sp&eacute;ficier au moment de l'ex&eacute;cution le peuplement d'une association en utilisant
            <tt class="literal">setFetchMode()</tt> (c'est-&agrave;-dire le chargement de celle-ci).
            Cela permet de surcharger les valeurs
            "lazy" et "outer-join" du mapping.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "Fritz%") )
    .setFetchMode("mate", FetchMode.EAGER)
    .setFetchMode("kittens", FetchMode.EAGER)
    .list();</pre><p>
            Cette requ&ecirc;te recherchera <tt class="literal">mate</tt> et <tt class="literal">kittens</tt>
            via les jointures externes. Voir <a href="#performance-fetching" title="19.1.&nbsp;Strat&eacute;gies de chargement">Section&nbsp;19.1, &laquo;&nbsp;Strat&eacute;gies de chargement&nbsp;&raquo;</a> pour plus d'informations.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-examples"></a>15.6.&nbsp;Requ&ecirc;tes par l'exemple</h2></div></div><div></div></div><p>
            La classe <tt class="literal">org.hibernate.criterion.Example</tt> vous permet de
            construire un crit&egrave;re suivant une instance d'objet donn&eacute;e.
        </p><pre class="programlisting">Cat cat = new Cat();
cat.setSex('F');
cat.setColor(Color.BLACK);
List results = session.createCriteria(Cat.class)
    .add( Example.create(cat) )
    .list();</pre><p>
            Les propri&eacute;t&eacute;s de type version, identifiant et association sont ignor&eacute;es.
       Par d&eacute;faut, les valeurs null sont exclues.
        </p><p>
            Vous pouvez ajuster la strat&eacute;gie d'utilisation de valeurs de
           l'<tt class="literal">Exemple</tt>.
        </p><pre class="programlisting">Example example = Example.create(cat)
    .excludeZeroes()           //exclude zero valued properties
    .excludeProperty("color")  //exclude the property named "color"
    .ignoreCase()              //perform case insensitive string comparisons
    .enableLike();             //use like for string comparisons
List results = session.createCriteria(Cat.class)
    .add(example)
    .list();</pre><p>
            Vous pouvez utiliser les "exemples" pour des crit&egrave;res sur les objets associ&eacute;s.
        </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .add( Example.create(cat) )
    .createCriteria("mate")
        .add( Example.create( cat.getMate() ) )
    .list();</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-projection"></a>15.7.&nbsp;Projections, agr&eacute;gation et regroupement</h2></div></div><div></div></div><p>
            La classe <tt class="literal">org.hibernate.criterion.Projections</tt> est une
            fabrique d'instances de <tt class="literal">Projection</tt>. Nous appliquons une
            projection sur une requ&ecirc;te en appelant <tt class="literal">setProjection()</tt>.
        </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.rowCount() )
    .add( Restrictions.eq("color", Color.BLACK) )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.projectionList()
        .add( Projections.rowCount() )
        .add( Projections.avg("weight") )
        .add( Projections.max("weight") )
        .add( Projections.groupProperty("color") )
    )
    .list();</pre><p>
            Il n'y a pas besoin de "group by" explicite dans une requ&ecirc;te par crit&egrave;re.
            Certains types de projection sont d&eacute;finis pour &ecirc;tre des <span class="emphasis"><em>projections
            de regroupement</em></span>, lesquels apparaissent aussi dans la clause
            <tt class="literal">group by</tt> SQL.
        </p><p>
            Un alias peut optionnellement &ecirc;tre assign&eacute; &agrave; une projection, ainsi la valeur
            projet&eacute;e peut &ecirc;tre r&eacute;f&eacute;renc&eacute;e dans des restrictions ou des tris. Voici deux fa&ccedil;ons
            diff&eacute;rentes de faire &ccedil;a :
        </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.alias( Projections.groupProperty("color"), "colr" ) )
    .addOrder( Order.asc("colr") )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.groupProperty("color").as("colr") )
    .addOrder( Order.asc("colr") )
    .list();</pre><p>
            Les m&eacute;thodes <tt class="literal">alias()</tt> et <tt class="literal">as()</tt> enveloppe simplement
            une instance de projection dans une autre instance (alias&eacute;e) de <tt class="literal">Projection</tt>.
            Comme un raccourci, vous pouvez assignez un alias lorsque vous ajoutez la projection &agrave; la
            liste de projections :
        </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.projectionList()
        .add( Projections.rowCount(), "catCountByColor" )
        .add( Projections.avg("weight"), "avgWeight" )
        .add( Projections.max("weight"), "maxWeight" )
        .add( Projections.groupProperty("color"), "color" )
    )
    .addOrder( Order.desc("catCountByColor") )
    .addOrder( Order.desc("avgWeight") )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Domestic.class, "cat")
    .createAlias("kittens", "kit")
    .setProjection( Projections.projectionList()
        .add( Projections.property("cat.name"), "catName" )
        .add( Projections.property("kit.name"), "kitName" )
    )
    .addOrder( Order.asc("catName") )
    .addOrder( Order.asc("kitName") )
    .list();</pre><p>
            Vous pouvez aussi utiliser <tt class="literal">Property.forName()</tt> pour formuler des projections :
        </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Property.forName("name") )
    .add( Property.forName("color").eq(Color.BLACK) )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.projectionList()
        .add( Projections.rowCount().as("catCountByColor") )
        .add( Property.forName("weight").avg().as("avgWeight") )
        .add( Property.forName("weight").max().as("maxWeight") )
        .add( Property.forName("color").group().as("color" )
    )
    .addOrder( Order.desc("catCountByColor") )
    .addOrder( Order.desc("avgWeight") )
    .list();</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-detachedqueries"></a>15.8.&nbsp;Requ&ecirc;tes et sous-requ&ecirc;tes d&eacute;tach&eacute;es</h2></div></div><div></div></div><p>
            La classe <tt class="literal">DetachedCriteria</tt> vous laisse cr&eacute;er une requ&ecirc;te en dehors de la
            port&eacute;e de la session, et puis l'ex&eacute;cuter plus tard en utilisant n'importe quelle <tt class="literal">Session</tt>
            arbitraire.
        </p><pre class="programlisting">DetachedCriteria query = DetachedCriteria.forClass(Cat.class)
    .add( Property.forName("sex").eq('F') );

Session session = ....;
Transaction txn = session.beginTransaction();
List results = query.getExecutableCriteria(session).setMaxResults(100).list();
txn.commit();
session.close();</pre><p>
            Une <tt class="literal">DetachedCriteria</tt> peut aussi &ecirc;tre utilis&eacute;e pour exprimer une
            sous-requ&ecirc;te. Des instances de criterion impliquant des sous-requ&ecirc;tes peuvent &ecirc;tre
            obtenues via <tt class="literal">Subqueries</tt> ou <tt class="literal">Property</tt>.
        </p><pre class="programlisting">DetachedCriteria avgWeight = DetachedCriteria.forClass(Cat.class)
    .setProjection( Property.forName("weight").avg() );
session.createCriteria(Cat.class)
    .add( Property.forName("weight).gt(avgWeight) )
    .list();</pre><pre class="programlisting">DetachedCriteria weights = DetachedCriteria.forClass(Cat.class)
    .setProjection( Property.forName("weight") );
session.createCriteria(Cat.class)
    .add( Subqueries.geAll("weight", weights) )
    .list();</pre><p>
            M&ecirc;me des requ&ecirc;tes corr&eacute;l&eacute;es sont possibles :
        </p><pre class="programlisting">DetachedCriteria avgWeightForSex = DetachedCriteria.forClass(Cat.class, "cat2")
    .setProjection( Property.forName("weight").avg() )
    .add( Property.forName("cat2.sex").eqProperty("cat.sex") );
session.createCriteria(Cat.class, "cat")
    .add( Property.forName("weight).gt(avgWeightForSex) )
    .list();</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="query-criteria-naturalid"></a>15.9.&nbsp;Requ&ecirc;tes par identifiant naturel</h2></div></div><div></div></div><p>
            Pour la plupart des requ&ecirc;tes, incluant les requ&ecirc;tes par crit&egrave;re, le cache de requ&ecirc;tes
            n'est pas tr&egrave;s efficace, parce que l'invalidation du cache de requ&ecirc;tes arrive trop
            souvent. Cependant, il y a une sorte sp&eacute;ciale de requ&ecirc;te o&ugrave; nous pouvons optimiser
            l'algorithme d'invalidation du cache : les recherches sur une clef naturelle constante.
            Dans certaines applications, cette sorte de requ&ecirc;te se produit fr&eacute;quemment. L'API de
            crit&egrave;re fournit une provision sp&eacute;ciale pour ce cas d'utilisation.
        </p><p>
            D'abord vous devriez mapper la clef naturelle de votre entit&eacute; en utilisant
            <tt class="literal">&lt;natural-id&gt;</tt>, et activer l'utilisation du cache de second niveau.
        </p><pre class="programlisting">&lt;class name="User"&gt;
    &lt;cache usage="read-write"/&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;natural-id&gt;
        &lt;property name="name"/&gt;
        &lt;property name="org"/&gt;
    &lt;/natural-id&gt;
    &lt;property name="password"/&gt;
&lt;/class&gt;</pre><p>
            Notez que cette fonctionnalit&eacute; n'est pas pr&eacute;vue pour l'utilisation avec des
            entit&eacute;s avec des clefs naturelles <span class="emphasis"><em>mutables</em></span>.
        </p><p>
            Ensuite, activez le cache de requ&ecirc;te d'Hibernate.
        </p><p>
            Maintenant <tt class="literal">Restrictions.naturalId()</tt> nous permet de rendre
            l'utilisation de l'algorithme de cache plus efficace.
        </p><pre class="programlisting">session.createCriteria(User.class)
    .add( Restrictions.naturalId()
        .set("name", "gavin")
        .set("org", "hb")
    ).setCacheable(true)
    .uniqueResult();</pre></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="querysql"></a>Chapitre&nbsp;16.&nbsp;SQL natif</h2></div></div><div></div></div><p>
        Vous pouvez aussi &eacute;crire vos requ&ecirc;tes dans le dialecte SQL natif de votre base de donn&eacute;es.
        Ceci est utile si vous souhaitez utiliser les fonctionnalit&eacute;s sp&eacute;cifiques de votre base de
        donn&eacute;es comme le mot cl&eacute; <tt class="literal">CONNECT</tt> d'Oracle. Cette fonctionnalit&eacute; offre par ailleurs un moyen
        de migration plus propre et doux d'une application bas&eacute;e sur SQL/JDBC vers
        une application Hibernate.
    </p><p>Hibernate3 vous permet de sp&eacute;cifier du SQL &eacute;crit &agrave; la main (incluant les proc&eacute;dures stock&eacute;es) 
  pour toutes les op&eacute;rations de cr&eacute;ation, mise &agrave; jour, suppression et chargement.</p><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-creating"></a>16.1.&nbsp;Utiliser une <tt class="literal">SQLQuery</tt></h2></div></div><div></div></div><p>L'ex&eacute;cution des requ&ecirc;tes en SQL natif est contr&ocirc;l&eacute;e par l'interface <tt class="literal">SQLQuery</tt>,
        laquelle est obtenue en appelant <tt class="literal">Session.createSQLQuery()</tt>.
        Dans des cas extr&ecirc;mement simples, nous pouvons utiliser la forme suivante :
    </p><pre class="programlisting">List cats = sess.createSQLQuery("select * from cats")
    .addEntity(Cat.class)
    .list();</pre><p>Cette requ&ecirc;te a sp&eacute;cifi&eacute; :</p><div class="itemizedlist"><ul type="disc"><li><p>la requ&ecirc;te SQL</p></li><li><p>l'entit&eacute; retourn&eacute;e par la requ&ecirc;te</p></li></ul></div><p>
        Ici, les noms de colonne des r&eacute;sultats sont suppos&eacute;s &ecirc;tre les m&ecirc;mes que les noms de colonne sp&eacute;cifi&eacute;s dans le
        document de mapping. Cela peut &ecirc;tre probl&eacute;matique pour des requ&ecirc;tes SQL qui joignent de multiple tables, puisque
        les m&ecirc;mes noms de colonne peuvent appara&icirc;tre dans plus d'une table. La forme suivante n'est pas vuln&eacute;rable &agrave; la
        duplication des noms de colonne :
    </p><pre class="programlisting">List cats = sess.createSQLQuery("select {cat.*} from cats cat")
    .addEntity("cat", Cat.class)
    .list();</pre><p>Cette requ&ecirc;te a sp&eacute;cifi&eacute; :</p><div class="itemizedlist"><ul type="disc"><li><p>la requ&ecirc;te SQL, avec un param&egrave;tre fictif pour Hibernate pour injecter les alias de colonne</p></li><li><p>l'entit&eacute; retourn&eacute;e par la requ&ecirc;te, et son alias de table SQL</p></li></ul></div><p>
        La m&eacute;thode <tt class="literal">addEntity()</tt> associe l'alias de la table SQL
        avec la classe de l'entit&eacute; retourn&eacute;e, et d&eacute;termine la forme de l'ensemble des r&eacute;sultats de la requ&ecirc;te.
    </p><p>
        La m&eacute;thode <tt class="literal">addJoin()</tt> peut &ecirc;tre utilis&eacute;e pour charger des associations vers d'autres
        entit&eacute;s et collections.
    </p><pre class="programlisting">List cats = sess.createSQLQuery(
        "select {cat.*}, {kitten.*} from cats cat, cats kitten where kitten.mother = cat.id"
    )
    .addEntity("cat", Cat.class)
    .addJoin("kitten", "cat.kittens")
    .list();</pre><p>
        Une requ&ecirc;te SQL native pourrait retourner une simple valeur scalaire ou une combinaison de scalaires et d'entit&eacute;s.
    </p><pre class="programlisting">Double max = (Double) sess.createSQLQuery("select max(cat.weight) as maxWeight from cats cat")
        .addScalar("maxWeight", Hibernate.DOUBLE);
        .uniqueResult();</pre><p>Vous pouvez alternativement d&eacute;crire les informations de mapping des r&eacute;sultats dans vos fichiers hbm 
    et les utiliser pour vos requ&ecirc;tes.</p><pre class="programlisting">List cats = sess.createSQLQuery(
        "select {cat.*}, {kitten.*} from cats cat, cats kitten where kitten.mother = cat.id"
    )
    .setResultSetMapping("catAndKitten")
    .list();</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-aliasreferences"></a>16.2.&nbsp;Alias et r&eacute;f&eacute;rences de propri&eacute;t&eacute;</h2></div></div><div></div></div><p>
        La notation <tt class="literal">{cat.*}</tt> utilis&eacute;e au-dessus est un raccourci pour "toutes les propri&eacute;t&eacute;s".
        Alternativement, vous pouvez lister explicitement les colonnes, mais m&ecirc;me ce cas que nous laissons &agrave; Hibernate
        injecte des alias de colonne SQL pour chaque propri&eacute;t&eacute;. Le rempla&ccedil;ant pour un alias de colonne 
        est juste le nom de la propri&eacute;t&eacute; qualifi&eacute; par l'alias de la table.
        Dans l'exemple suivant, nous r&eacute;cup&eacute;rons des <tt class="literal">Cat</tt>s &agrave; partir d'une table diff&eacute;rente
        (<tt class="literal">cat_log</tt>) de celle d&eacute;clar&eacute;e dans les m&eacute;ta-donn&eacute;es de mapping.
        Notez que nous pouvons m&ecirc;me utiliser les alias de propri&eacute;t&eacute; dans la clause "where" si nous le souhaitons.
    </p><p>
        La syntaxe <tt class="literal">{}</tt> <span class="emphasis"><em>n'est pas</em></span> requise pour le requ&ecirc;tes nomm&eacute;es. Voir
        <a href="#querysql-namedqueries" title="16.3.&nbsp;Requ&ecirc;tes SQL nomm&eacute;es">Section&nbsp;16.3, &laquo;&nbsp;Requ&ecirc;tes SQL nomm&eacute;es&nbsp;&raquo;</a>.
    </p><pre class="programlisting">String sql = "select cat.originalId as {cat.id}, " +
    "cat.mateid as {cat.mate}, cat.sex as {cat.sex}, " +
    "cat.weight*10 as {cat.weight}, cat.name as {cat.name} " +
    "from cat_log cat where {cat.mate} = :catId"

List loggedCats = sess.createSQLQuery(sql)
    .addEntity("cat", Cat.class)
    .setLong("catId", catId)
    .list();</pre><p>
        <span class="emphasis"><em>&Agrave; noter :</em></span> si vous listez chaque propri&eacute;t&eacute; explicitement, vous devez inclure 
        toutes les propri&eacute;t&eacute;s de la classe <span class="emphasis"><em>et ses sous-classes</em></span> !
    </p><p>
        La table suivante montre les diff&eacute;rentes possibilit&eacute;s d'utilisation de l'injection d'alias. &Agrave; noter : les noms
        des alias dans le r&eacute;sultat sont des exemples, chaque alias aura un nom unique et probablement diff&eacute;rent lors de l'utilisation.
    </p><div class="table"><a name="aliasinjection-summary"></a><p class="title"><b>Tableau&nbsp;16.1.&nbsp;Noms d'injection d'alias</b></p><table summary="Noms d'injection d'alias" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>Description</th><th>Syntaxe</th><th>Exemple</th><td class="auto-generated">&nbsp;</td></tr></thead><tbody><tr><td>Une simple propri&eacute;t&eacute;</td><td><tt class="literal">{[aliasname].[propertyname]}</tt></td><td><tt class="literal">A_NAME as {item.name}</tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td>Une propri&eacute;t&eacute; compos&eacute;e</td><td><tt class="literal">{[aliasname].[componentname].[propertyname]}</tt></td><td><tt class="literal">CURRENCY as {item.amount.currency}, VALUE as
            {item.amount.value}</tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td>Discriminant d'une entit&eacute;</td><td><tt class="literal">{[aliasname].class}</tt></td><td><tt class="literal">DISC as {item.class}</tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td>Toutes les propri&eacute;t&eacute;s d'une entit&eacute;</td><td><tt class="literal">{[aliasname].*}</tt></td><td><tt class="literal">{item.*}</tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td>Une clef de collection</td><td><tt class="literal">{[aliasname].key}</tt></td><td><tt class="literal">ORGID as {coll.key}</tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td>L'identifiant d'une collection</td><td><tt class="literal">{[aliasname].id}</tt></td><td><tt class="literal">EMPID as {coll.id}</tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td>L'&eacute;l&eacute;ment d'une collection</td><td><tt class="literal">{[aliasname].element}</tt></td><td><tt class="literal">XID as {coll.element}</tt></td><td>&nbsp;</td></tr><tr><td>Propri&eacute;t&eacute; de l'&eacute;l&eacute;ment dans la collection</td><td><tt class="literal">{[aliasname].element.[propertyname]}</tt></td><td><tt class="literal">NAME as {coll.element.name}</tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td>Toutes les propri&eacute;t&eacute;s de l'&eacute;l&eacute;ment dans la collection</td><td><tt class="literal">{[aliasname].element.*}</tt></td><td><tt class="literal">{coll.element.*}</tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td>Toutes les propri&eacute;t&eacute;s de la collection</td><td><tt class="literal">{[aliasname].*}</tt></td><td><tt class="literal">{coll.*}</tt></td><td class="auto-generated">&nbsp;</td></tr></tbody></table></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-namedqueries"></a>16.3.&nbsp;Requ&ecirc;tes SQL nomm&eacute;es</h2></div></div><div></div></div><p>
        Les requ&ecirc;tes SQL nomm&eacute;es peuvent &ecirc;tre d&eacute;finies dans le document de mapping
        et appel&eacute;es exactement de la m&ecirc;me mani&egrave;re qu'un requ&ecirc;te HQL nomm&eacute;e. Dans ce
        cas, nous <span class="emphasis"><em>n'avons pas besoin</em></span> d'appeler <tt class="literal">addEntity()</tt>.
    </p><pre class="programlisting">&lt;sql-query name="persons"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex}
    FROM PERSON person
    WHERE person.NAME LIKE :namePattern
&lt;/sql-query&gt;</pre><pre class="programlisting">List people = sess.getNamedQuery("persons")
    .setString("namePattern", namePattern)
    .setMaxResults(50)
    .list();</pre><p>
        Les &eacute;l&eacute;ments <tt class="literal">&lt;return-join&gt;</tt> et
        <tt class="literal">&lt;load-collection&gt;</tt> sont respectivement utilis&eacute;s pour lier
        des associations et d&eacute;finir des requ&ecirc;tes qui initialisent des collections.
    </p><pre class="programlisting">&lt;sql-query name="personsWith"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    &lt;return-join alias="address" property="person.mailingAddress"/&gt;
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex},
           adddress.STREET AS {address.street},
           adddress.CITY AS {address.city},
           adddress.STATE AS {address.state},
           adddress.ZIP AS {address.zip}
    FROM PERSON person
    JOIN ADDRESS adddress
        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'
    WHERE person.NAME LIKE :namePattern
&lt;/sql-query&gt;</pre><p>
        Une requ&ecirc;te SQL nomm&eacute;e peut retourner une valeur scalaire. Vous devez
        sp&eacute;cifier l'alias de colonne et le type Hibernate utilisant l'&eacute;l&eacute;ment
        <tt class="literal">&lt;return-scalar&gt;</tt> :</p><pre class="programlisting">&lt;sql-query name="mySqlQuery"&gt;
    &lt;return-scalar column="name" type="string"/&gt;
    &lt;return-scalar column="age" type="long"/&gt;
    SELECT p.NAME AS name,
           p.AGE AS age,
    FROM PERSON p WHERE p.NAME LIKE 'Hiber%'
&lt;/sql-query&gt;</pre><p>
        Vous pouvez externaliser les informations de mapping des r&eacute;sultats dans un
        &eacute;l&eacute;ment <tt class="literal">&lt;resultset&gt;</tt> pour soit les r&eacute;utiliser
        dans diff&eacute;rentes requ&ecirc;tes nomm&eacute;es, soit &agrave; travers l'API
        <tt class="literal">setResultSetMapping()</tt>.
    </p><pre class="programlisting">&lt;resultset name="personAddress"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    &lt;return-join alias="address" property="person.mailingAddress"/&gt;
&lt;/resultset&gt;

&lt;sql-query name="personsWith" resultset-ref="personAddress"&gt;
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex},
           adddress.STREET AS {address.street},
           adddress.CITY AS {address.city},
           adddress.STATE AS {address.state},
           adddress.ZIP AS {address.zip}
    FROM PERSON person
    JOIN ADDRESS adddress
        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'
    WHERE person.NAME LIKE :namePattern
&lt;/sql-query&gt;</pre><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="propertyresults"></a>16.3.1.&nbsp;Utilisation de return-property pour sp&eacute;cifier explicitement les noms des colonnes/alias</h3></div></div><div></div></div><p>
          Avec <tt class="literal">&lt;return-property&gt;</tt> vous pouvez explicitement dire
          &agrave; Hibernate quels alias de colonne utiliser, plutot que d'employer la syntaxe
          <tt class="literal">{}</tt> pour laisser Hibernate injecter ses propres alias.
      </p><pre class="programlisting">&lt;sql-query name="mySqlQuery"&gt;
    &lt;return alias="person" class="eg.Person"&gt;
        &lt;return-property name="name" column="myName"/&gt;
        &lt;return-property name="age" column="myAge"/&gt;
        &lt;return-property name="sex" column="mySex"/&gt;
    &lt;/return&gt;
    SELECT person.NAME AS myName,
           person.AGE AS myAge,
           person.SEX AS mySex,
    FROM PERSON person WHERE person.NAME LIKE :name
&lt;/sql-query&gt;
</pre><p>
          <tt class="literal">&lt;return-property&gt;</tt> fonctionne aussi avec de
          multiple colonnes. Cela r&eacute;sout une limitation de la syntaxe <tt class="literal">{}</tt>
          qui ne peut pas permettre une bonne granularit&eacute; des propri&eacute;t&eacute;s multi-colonnes.
      </p><pre class="programlisting">&lt;sql-query name="organizationCurrentEmployments"&gt;
    &lt;return alias="emp" class="Employment"&gt;
        &lt;return-property name="salary"&gt;
            &lt;return-column name="VALUE"/&gt;
            &lt;return-column name="CURRENCY"/&gt;
        &lt;/return-property&gt;
        &lt;return-property name="endDate" column="myEndDate"/&gt;
    &lt;/return&gt;
        SELECT EMPLOYEE AS {emp.employee}, EMPLOYER AS {emp.employer},
        STARTDATE AS {emp.startDate}, ENDDATE AS {emp.endDate},
        REGIONCODE as {emp.regionCode}, EID AS {emp.id}, VALUE, CURRENCY
        FROM EMPLOYMENT
        WHERE EMPLOYER = :id AND ENDDATE IS NULL
        ORDER BY STARTDATE ASC
&lt;/sql-query&gt;</pre><p>
          Notez que dans cet exemple nous avons utilis&eacute; <tt class="literal">&lt;return-property&gt;</tt>
          en combinaison avec la syntaxe <tt class="literal">{}</tt> pour l'injection. Cela autorise les
          utilisateurs &agrave; choisir comment ils veulent r&eacute;f&eacute;rencer les colonnes et les propri&eacute;t&eacute;s.
      </p><p>
          Si votre mapping a un discriminant vous devez utiliser
          <tt class="literal">&lt;return-discriminator&gt;</tt> pour sp&eacute;cifier la colonne
          discriminante.
      </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="sp_query"></a>16.3.2.&nbsp;Utilisation de proc&eacute;dures stock&eacute;es pour les requ&ecirc;tes</h3></div></div><div></div></div><p>
          Hibernate 3 introduit le support des requ&ecirc;tes via proc&eacute;dures stock&eacute;es et les fonctions. 
          La documentation suivante est valable pour les deux.
          Les proc&eacute;dures stock&eacute;es/fonctions doivent retourner l'ensemble de r&eacute;sultats en tant que
          premier param&egrave;tre sortant (NdT: "out-parameter") pour &ecirc;tre capable de fonctionner
          avec Hibernate. Un exemple d'une telle proc&eacute;dure stock&eacute;e en Oracle 9 et
          version sup&eacute;rieure :
      </p><pre class="programlisting">CREATE OR REPLACE FUNCTION selectAllEmployments
    RETURN SYS_REFCURSOR
AS
    st_cursor SYS_REFCURSOR;
BEGIN
    OPEN st_cursor FOR
 SELECT EMPLOYEE, EMPLOYER,
 STARTDATE, ENDDATE,
 REGIONCODE, EID, VALUE, CURRENCY
 FROM EMPLOYMENT;
      RETURN  st_cursor;
 END;</pre><p>Pour utiliser cette requ&ecirc;te dans Hibernate vous avez besoin de la mapper via une requ&ecirc;te nomm&eacute;e.</p><pre class="programlisting">&lt;sql-query name="selectAllEmployees_SP" callable="true"&gt;
    &lt;return alias="emp" class="Employment"&gt;
        &lt;return-property name="employee" column="EMPLOYEE"/&gt;
        &lt;return-property name="employer" column="EMPLOYER"/&gt;
        &lt;return-property name="startDate" column="STARTDATE"/&gt;
        &lt;return-property name="endDate" column="ENDDATE"/&gt;
        &lt;return-property name="regionCode" column="REGIONCODE"/&gt;
        &lt;return-property name="id" column="EID"/&gt;
        &lt;return-property name="salary"&gt;
            &lt;return-column name="VALUE"/&gt;
            &lt;return-column name="CURRENCY"/&gt;
        &lt;/return-property&gt;
    &lt;/return&gt;
    { ? = call selectAllEmployments() }
&lt;/sql-query&gt;</pre><p>
          Notez que les proc&eacute;dures stock&eacute;es retournent, pour le moment, seulement des
          scalaires et des entit&eacute;s. <tt class="literal">&lt;return-join&gt;</tt> et
          <tt class="literal">&lt;load-collection&gt;</tt> ne sont pas support&eacute;s.
      </p><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="querysql-limits-storedprocedures"></a>16.3.2.1.&nbsp;R&egrave;gles/limitations lors de l'utilisation des proc&eacute;dures stock&eacute;es</h4></div></div><div></div></div><p>
            Pur utiliser des proc&eacute;dures stock&eacute;es avec Hibernate, les proc&eacute;dures doivent
            suivre certaines r&egrave;gles. Si elles ne suivent pas ces r&egrave;gles, elles ne sont pas
            utilisables avec Hibernate. Si vous voulez encore utiliser ces proc&eacute;dures vous
            devez les ex&eacute;cuter via <tt class="literal">session.connection()</tt>. Les r&egrave;gles
            sont diff&eacute;rentes pour chaque base de donn&eacute;es, puisque les vendeurs de base
            de donn&eacute;es ont des s&eacute;mantiques/syntaxes diff&eacute;rentes pour les proc&eacute;dures stock&eacute;es.
        </p><p>Les requ&ecirc;tes de proc&eacute;dures stock&eacute;es ne peuvent pas &ecirc;tre pagin&eacute;es avec
            <tt class="literal">setFirstResult()/setMaxResults()</tt>.</p><p>Pour Oracle les r&egrave;gles suivantes s'appliquent :</p><div class="itemizedlist"><ul type="disc" compact><li><p>
                La proc&eacute;dure doit retourner un ensemble de r&eacute;sultats. Le
                prmeier param&egrave;tre d'une proc&eacute;dure doit &ecirc;tre un <tt class="literal">OUT</tt> 
                qui retourne un ensemble de r&eacute;sultats. Ceci est fait en
                retournant un <tt class="literal">SYS_REFCURSOR</tt> dans Oracle 9 ou 10. Dans
                Oracle vous avez besoin de d&eacute;finir un type <tt class="literal">REF CURSOR</tt>.</p></li></ul></div><p>Pour Sybase ou MS SQL server les r&egrave;gles suivantes s'appliquent :</p><div class="itemizedlist"><ul type="disc" compact><li><p>La proc&eacute;dure doit retourner un ensemble de r&eacute;sultats. Notez que comme
            ces serveurs peuvent retourner de multiples ensembles de r&eacute;sultats et mettre &agrave; jour
            des compteurs, Hibernate it&eacute;rera les r&eacute;sultats et prendra le premier r&eacute;sultat qui est
            un ensemble de r&eacute;sultat comme valeur de retour. Tout le reste sera ignor&eacute;.</p></li><li><p>Si vous pouvez activer <tt class="literal">SET NOCOUNT ON</tt> dans votre proc&eacute;dure,
                elle sera probablement plus efficace, mais ce n'est pas une obligation.</p></li></ul></div></div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-cud"></a>16.4.&nbsp;SQL personnalis&eacute; pour cr&eacute;er, mettre &agrave; jour et effacer</h2></div></div><div></div></div><p>
        Hibernate3 peut utiliser des expression SQL personnalis&eacute;es pour des op&eacute;rations de cr&eacute;ation,
        de mise &agrave; jour, et de suppression. Les objets persistants les classes et les collections
        dans Hibernate contiennent d&eacute;j&agrave; un ensemble de cha&icirc;nes de caract&egrave;res g&eacute;n&eacute;r&eacute;es lors de la
        configuration (insertsql, deletesql, updatesql, etc). Les tages de mapping
    <tt class="literal">&lt;sql-insert&gt;</tt>,
    <tt class="literal">&lt;sql-delete&gt;</tt>, et
    <tt class="literal">&lt;sql-update&gt;</tt> surchargent ces cha&icirc;nes de caract&egrave;res :</p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true"/&gt;
    &lt;sql-insert&gt;INSERT INTO PERSON (NAME, ID) VALUES ( UPPER(?), ? )&lt;/sql-insert&gt;
    &lt;sql-update&gt;UPDATE PERSON SET NAME=UPPER(?) WHERE ID=?&lt;/sql-update&gt;
    &lt;sql-delete&gt;DELETE FROM PERSON WHERE ID=?&lt;/sql-delete&gt;
&lt;/class&gt;</pre><p>Le SQL est directement ex&eacute;cut&eacute; dans votre base de donn&eacute;es, donc vous &ecirc;tes libre d'utiliser
        le dialecte que vous souhaitez. Cela r&eacute;duira bien s&ucirc;r la portabilit&eacute; de votre mapping si vous
        utilisez du SQL sp&eacute;cifique &agrave; votre base de donn&eacute;es.</p><p>Les proc&eacute;dures stock&eacute;es sont support&eacute;es si l'attribut <tt class="literal">callable</tt> est param&eacute;tr&eacute; :</p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true"/&gt;
    &lt;sql-insert callable="true"&gt;{call createPerson (?, ?)}&lt;/sql-insert&gt;
    &lt;sql-delete callable="true"&gt;{? = call deletePerson (?)}&lt;/sql-delete&gt;
    &lt;sql-update callable="true"&gt;{? = call updatePerson (?, ?)}&lt;/sql-update&gt;
&lt;/class&gt;</pre><p>L'ordre des param&egrave;tres positionnels est actuellement vital, car ils doivent &ecirc;tre dans la
        m&ecirc;me s&eacute;quence qu'Hibernate les attend.</p><p>
        Vous pouvez voir l'ordre attendu en activant les journaux de debug pour le
        niveau <tt class="literal">org.hibernate.persister.entity</tt> level. Avec ce niveau activ&eacute;,
        Hibernate imprimera le SQL statique qui est utilis&eacute; pour cr&eacute;er, mettre &agrave; jour,
        supprimer, etc. des entit&eacute;s. (Pour voir la s&eacute;quence attendue, rappelez-vous de ne pas
        inclure votre SQL personnalis&eacute; dans les fichiers de mapping de mani&egrave;re &agrave; surcharger le
        SQL statique g&eacute;n&eacute;r&eacute; par Hibernate.)</p><p>Les proc&eacute;dures stock&eacute;es sont dans la plupart des cas (lire : il vaut mieux le faire)
    requises pour retourner le nombre de lignes ins&eacute;r&eacute;es/mises &agrave; jour/supprim&eacute;es, puisque
    Hibernate fait quelques v&eacute;rifications de succ&egrave;s lors de l'ex&eacute;cution de l'expression.
    Hibernate inscrit toujours la premi&egrave;re expression comme un param&egrave;tre de sortie num&eacute;rique pour les
    op&eacute;rations CUD :</p><pre class="programlisting">CREATE OR REPLACE FUNCTION updatePerson (uid IN NUMBER, uname IN VARCHAR2)
    RETURN NUMBER IS
BEGIN

    update PERSON
    set
        NAME = uname,
    where
        ID = uid;

    return SQL%ROWCOUNT;

END updatePerson;</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-load"></a>16.5.&nbsp;SQL personnalis&eacute; pour le chargement</h2></div></div><div></div></div><p>Vous pouvez aussi d&eacute;clarer vos propres requ&ecirc;tes SQL (ou HQL) pour le chargement d'entit&eacute; :</p><pre class="programlisting">&lt;sql-query name="person"&gt;
    &lt;return alias="pers" class="Person" lock-mode="upgrade"/&gt;
    SELECT NAME AS {pers.name}, ID AS {pers.id}
    FROM PERSON
    WHERE ID=?
    FOR UPDATE
&lt;/sql-query&gt;</pre><p>Ceci est juste une d&eacute;claration de requ&ecirc;te nomm&eacute;e, comme vu plus t&ocirc;t. Vous pouvez r&eacute;f&eacute;rencer
    cette requ&ecirc;te nomm&eacute;e dans un mapping de classe :</p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true"/&gt;
    &lt;loader query-ref="person"/&gt;
&lt;/class&gt;</pre><p>Ceci fonctionne m&ecirc;me avec des proc&eacute;dures stock&eacute;es.</p><p>Vous pouvez m&ecirc;me d&eacute;finir une requ&ecirc;te pour le chargement d'une collection :</p><pre class="programlisting">&lt;set name="employments" inverse="true"&gt;
    &lt;key/&gt;
    &lt;one-to-many class="Employment"/&gt;
    &lt;loader query-ref="employments"/&gt;
&lt;/set&gt;</pre><pre class="programlisting">&lt;sql-query name="employments"&gt;
    &lt;load-collection alias="emp" role="Person.employments"/&gt;
    SELECT {emp.*}
    FROM EMPLOYMENT emp
    WHERE EMPLOYER = :id
    ORDER BY STARTDATE ASC, EMPLOYEE ASC
&lt;/sql-query&gt;</pre><p>Vous pourriez m&ecirc;me d&eacute;finir un chargeur d'entit&eacute; qui charge une collection par jointure :</p><pre class="programlisting">&lt;sql-query name="person"&gt;
    &lt;return alias="pers" class="Person"/&gt;
    &lt;return-join alias="emp" property="pers.employments"/&gt;
    SELECT NAME AS {pers.*}, {emp.*}
    FROM PERSON pers
    LEFT OUTER JOIN EMPLOYMENT emp
        ON pers.ID = emp.PERSON_ID
    WHERE ID=?
&lt;/sql-query&gt;</pre></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="filters"></a>Chapitre&nbsp;17.&nbsp;Filtrer les donn&eacute;es</h2></div></div><div></div></div><p>
        Hibernate3 fournit une nouvelle approche innovatrice pour g&eacute;rer des donn&eacute;es
        avec des r&egrave;gles de "visibilit&eacute;". Un <span class="emphasis"><em>filtre Hibernate</em></span> est un filtre
        global, nomm&eacute;, param&eacute;tr&eacute; qui peut &ecirc;tre activ&eacute; ou d&eacute;sactiv&eacute; pour une session Hibernate
        particuli&egrave;re.
    </p><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-filters"></a>17.1.&nbsp;Filtres Hibernate</h2></div></div><div></div></div><p>
            Hibernate3 ajoute la capacit&eacute; de pr&eacute;d&eacute;finir des crit&egrave;res de filtre et d'attacher ces
            filtres &agrave; une classe ou &agrave; une collection. Un crit&egrave;re de filtre est la facult&eacute; de d&eacute;finir
            une clause de restriction tr&egrave;s similaire &agrave; l'attribut "where" existant disponible sur
            une classe et divers &eacute;l&eacute;ments d'une collection. Mis &agrave; part que ces conditions de filtre
            peuvent &ecirc;tre param&eacute;tr&eacute;es. L'application peut alors prendre la d&eacute;cision &agrave; l'ex&eacute;cution
            si des filtres donn&eacute;s devraient &ecirc;tre activ&eacute;s et quels devraient &ecirc;tre leurs param&egrave;tres.
            Des filtres peuvent &ecirc;tre utilis&eacute;s comme des vues de base de donn&eacute;es, mais param&eacute;tr&eacute;es
            dans l'application.
        </p><p>
            Afin d'utiliser des filtres, ils doivent d'abord &ecirc;tre d&eacute;finis, puis attach&eacute;s aux &eacute;l&eacute;ments
            de mapping appropri&eacute;s. Pour d&eacute;finir un filtre, utilisez l'&eacute;l&eacute;ment <tt class="literal">&lt;filter-def/&gt;</tt>
            dans un &eacute;l&eacute;ment <tt class="literal">&lt;hibernate-mapping/&gt;</tt> :
        </p><pre class="programlisting">&lt;filter-def name="myFilter"&gt;
    &lt;filter-param name="myFilterParam" type="string"/&gt;
&lt;/filter-def&gt;</pre><p>
            Puis, ce filtre peut &ecirc;tre attach&eacute; &agrave; une classe :
        </p><pre class="programlisting">&lt;class name="myClass" ...&gt;
    ...
    &lt;filter name="myFilter" condition=":myFilterParam = MY_FILTERED_COLUMN"/&gt;
&lt;/class&gt;</pre><p>
            ou &agrave; une collection :
        </p><pre class="programlisting">&lt;set ...&gt;
    &lt;filter name="myFilter" condition=":myFilterParam = MY_FILTERED_COLUMN"/&gt;
&lt;/set&gt;</pre><p>
            ou m&ecirc;me aux deux (ou &agrave; plusieurs de chaque) en m&ecirc;me temps.
        </p><p>
            Les m&eacute;thodes sur <tt class="literal">Session</tt> sont : <tt class="literal">enableFilter(String filterName)</tt>,
            <tt class="literal">getEnabledFilter(String filterName)</tt>, et <tt class="literal">disableFilter(String filterName)</tt>.
            Par d&eacute;faut, les filtres <span class="emphasis"><em>ne sont pas</em></span> activ&eacute;s pour une session donn&eacute;e ;
            ils doivent &ecirc;tre explicitement activ&eacute;s en appelant la m&eacute;thode
            <tt class="literal">Session.enabledFilter()</tt>, laquelle retourne une instance de l'interface
            <tt class="literal">Filter</tt>. Utiliser le simple filtre d&eacute;fini au-dessus ressemblerait &agrave; :
        </p><pre class="programlisting">session.enableFilter("myFilter").setParameter("myFilterParam", "some-value");</pre><p>
            Notez que des m&eacute;thodes sur l'interface org.hibernate.Filter autorisent le cha&icirc;nage de beaucoup
            de m&eacute;thodes communes d'Hibernate.
        </p><p>
            Un exemple complet, utilisant des donn&eacute;es temporelles avec une structure de date
            d'enregistrement effectif :
        </p><pre class="programlisting">&lt;filter-def name="effectiveDate"&gt;
    &lt;filter-param name="asOfDate" type="date"/&gt;
&lt;/filter-def&gt;

&lt;class name="Employee" ...&gt;
...
    &lt;many-to-one name="department" column="dept_id" class="Department"/&gt;
    &lt;property name="effectiveStartDate" type="date" column="eff_start_dt"/&gt;
    &lt;property name="effectiveEndDate" type="date" column="eff_end_dt"/&gt;
...
    &lt;!--
        Note that this assumes non-terminal records have an eff_end_dt set to
        a max db date for simplicity-sake
    --&gt;
    &lt;filter name="effectiveDate"
            condition=":asOfDate BETWEEN eff_start_dt and eff_end_dt"/&gt;
&lt;/class&gt;

&lt;class name="Department" ...&gt;
...
    &lt;set name="employees" lazy="true"&gt;
        &lt;key column="dept_id"/&gt;
        &lt;one-to-many class="Employee"/&gt;
        &lt;filter name="effectiveDate"
                condition=":asOfDate BETWEEN eff_start_dt and eff_end_dt"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
            Puis, afin de s'assurer que vous pouvez toujours r&eacute;cup&eacute;rer les enregistrements actuellement
            effectifs, activez simplement le filtre sur la session avant de r&eacute;cup&eacute;rer des donn&eacute;es des
            employ&eacute;s :
        </p><pre class="programlisting">Session session = ...;
session.enabledFilter("effectiveDate").setParameter("asOfDate", new Date());
List results = session.createQuery("from Employee as e where e.salary &gt; :targetSalary")
         .setLong("targetSalary", new Long(1000000))
         .list();
</pre><p>
            Dans le HQL ci-dessus, bien que nous ayons seulement mentionn&eacute; une contrainte de
            salaire sur les resultats, &agrave; cause du filtre activ&eacute;, la requ&ecirc;te retournera seulement
            les employ&eacute;s actuellement actifs qui ont un salaire sup&eacute;rieur &agrave; un million de dollars.
        </p><p>
            A noter : si vous pr&eacute;voyez d'utiliser des filtres avec des jointures externes (soit
            &agrave; travers HQL, soit par le chargement) faites attention &agrave; la direction de l'expression
            de condition. Il est plus s&ucirc;r de la positionner pour les jointures externes &agrave; gauche ;
            en g&eacute;n&eacute;ral, placez le param&egrave;tre d'abord, suivi du(des) nom(s) de colonne apr&egrave;s l'op&eacute;rateur.
        </p></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="xml"></a>Chapitre&nbsp;18.&nbsp;Mapping XML</h2></div></div><div></div></div><p><span class="emphasis"><em>
        Notez que cette fonctionnalit&eacute; est exp&eacute;rimentale dans Hibernate 3.0 et
        est en d&eacute;veloppement extr&ecirc;mement actif.
    </em></span></p><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml-intro"></a>18.1.&nbsp;Travailler avec des donn&eacute;es XML</h2></div></div><div></div></div><p>
            Hibernate vous laisse travailler avec des donn&eacute;es XML persistantes de la
            m&ecirc;me mani&egrave;re que vous travaillez avec des POJOs persistants. Un arbre XML
            peut &ecirc;tre vu comme une autre mani&egrave;re de repr&eacute;senter les donn&eacute;es relationnelles
            au niveau objet, &agrave; la place des POJOs.
        </p><p>
            Hibernate supporte dom4j en tant qu'API pour la manipulation des arbres XML.
            Vous pouvez &eacute;crire des requ&ecirc;tes qui r&eacute;cup&egrave;rent des arbres dom4j &agrave; partie de la
            base de donn&eacute;es, et avoir toutes les modifications que vous faites sur l'arbre
            automatiquement synchronis&eacute;es dans la base de donn&eacute;es. Vous pouvez  m&ecirc;me prendre
            un document XML, l'analyser en utilisant dom4j, et l'&eacute;crire dans la base de
            donn&eacute;es via les op&eacute;rations basiques d'Hibernate :
            <tt class="literal">persist(), saveOrUpdate(), merge(), delete(), replicate()</tt>
            (merge() n'est pas encore support&eacute;).
        </p><p>
            Cette fonctionnalit&eacute; a plusieurs applications dont l'import/export de donn&eacute;es,
            l'externalisation d'entit&eacute;s via JMS ou SOAP et les rapports XSLT.
        </p><p>
            Un simple mapping peut &ecirc;tre utilis&eacute; pour simultan&eacute;ment mapper les propri&eacute;t&eacute;s
            d'une classe et les noeuds d'un document XML vers la base de donn&eacute;es, ou,
            si il n'y a pas de classe &agrave; mapper, il peut &ecirc;tre utilis&eacute; juste pour mapper
            le XML.
        </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="xml-intro-mapping"></a>18.1.1.&nbsp;Sp&eacute;cifier le mapping XML et le mapping d'une classe ensemble</h3></div></div><div></div></div><p>
                Voici un exemple de mapping d'un POJO et du XML simultan&eacute;ment :
            </p><pre class="programlisting">&lt;class name="Account"
        table="ACCOUNTS"
        node="account"&gt;

    &lt;id name="accountId"
            column="ACCOUNT_ID"
            node="@id"/&gt;

    &lt;many-to-one name="customer"
            column="CUSTOMER_ID"
            node="customer/@id"
            embed-xml="false"/&gt;

    &lt;property name="balance"
            column="BALANCE"
            node="balance"/&gt;

    ...

&lt;/class&gt;</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="xml-onlyxml"></a>18.1.2.&nbsp;Sp&eacute;cifier seulement un mapping XML</h3></div></div><div></div></div><p>
                Voici un exemple dans lequel il n'y a pas de class POJO :
            </p><pre class="programlisting">&lt;class entity-name="Account"
        table="ACCOUNTS"
        node="account"&gt;

    &lt;id name="id"
            column="ACCOUNT_ID"
            node="@id"
            type="string"/&gt;

    &lt;many-to-one name="customerId"
            column="CUSTOMER_ID"
            node="customer/@id"
            embed-xml="false"
            entity-name="Customer"/&gt;

    &lt;property name="balance"
            column="BALANCE"
            node="balance"
            type="big_decimal"/&gt;

    ...

&lt;/class&gt;</pre><p>
                Ce mapping vous permet d'acc&eacute;der aux donn&eacute;es comme un arbre dom4j, ou comme
                un graphe de paire nom de propri&eacute;t&eacute;/valeur (<tt class="literal">Map</tt>s java). Les
                noms des propri&eacute;t&eacute;s sont des constructions purement logiques qui peuvent &ecirc;tre
                r&eacute;f&eacute;r&eacute;es des dans requ&ecirc;tes HQL.
            </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml-mapping"></a>18.2.&nbsp;M&eacute;tadonn&eacute;es du mapping XML</h2></div></div><div></div></div><p>
            Plusieurs &eacute;l&eacute;ments du mapping Hibernate acceptent l'attribut <tt class="literal">node</tt>.
            Ceci vous permet de sp&eacute;cifier le nom d'un attribut XML ou d'un &eacute;l&eacute;ment qui
            contient la propri&eacute;t&eacute; ou les donn&eacute;es de l'entit&eacute;. Le format de l'attribut
            <tt class="literal">node</tt> doit &ecirc;tre un des suivants :
        </p><div class="itemizedlist"><ul type="disc" compact><li><p><tt class="literal">"element-name"</tt> - mappe vers l'&eacute;l&eacute;ment XML nomm&eacute;</p></li><li><p><tt class="literal">"@attribute-name"</tt> - mappe vers l'attribut XML nomm&eacute;</p></li><li><p><tt class="literal">"."</tt> - mappe vers le parent de l'&eacute;l&eacute;ment</p></li><li><p>
                <tt class="literal">"element-name/@attribute-name"</tt> -
                mappe vers l'&eacute;l&eacute;ment nomm&eacute; de l'attribut nomm&eacute;
            </p></li></ul></div><p>
            Pour des collections et de simples associations valu&eacute;es, il y a un attribut
            <tt class="literal">embed-xml</tt> suppl&eacute;mentaire. Si <tt class="literal">embed-xml="true"</tt>,
            qui est la valeur par d&eacute;faut, l'arbre XML pour l'entit&eacute; associ&eacute;e (ou la collection
            des types de valeurs) sera embarqu&eacute;e directement dans l'arbre XML pour l'entit&eacute; qui
            poss&egrave;de l'association. Sinon, si <tt class="literal">embed-xml="false"</tt>, alors
            seule la valeur de l'identifiant r&eacute;f&eacute;renc&eacute; appara&icirc;tra dans le XML pour de simples
            associations de points, et les collections n'appra&icirc;tront simplement pas.
        </p><p>
            Vous devriez faire attention &agrave; ne pas laisser <tt class="literal">embed-xml="true"</tt>
            pour trop d'associations, puisque XML ne traite pas bien les liens circurlaires.
        </p><pre class="programlisting">&lt;class name="Customer"
        table="CUSTOMER"
        node="customer"&gt;

    &lt;id name="id"
            column="CUST_ID"
            node="@id"/&gt;

    &lt;map name="accounts"
            node="."
            embed-xml="true"&gt;
        &lt;key column="CUSTOMER_ID"
                not-null="true"/&gt;
        &lt;map-key column="SHORT_DESC"
                node="@short-desc"
                type="string"/&gt;
        &lt;one-to-many entity-name="Account"
                embed-xml="false"
                node="account"/&gt;
    &lt;/map&gt;

    &lt;component name="name"
            node="name"&gt;
        &lt;property name="firstName"
                node="first-name"/&gt;
        &lt;property name="initial"
                node="initial"/&gt;
        &lt;property name="lastName"
                node="last-name"/&gt;
    &lt;/component&gt;

    ...

&lt;/class&gt;</pre><p>
            dans ce cas, nous avons d&eacute;cid&eacute; d'embarquer la collection d'identifiants de compte,
            mais pas les donn&eacute;es actuelles du compte. La requ&ecirc;te HQL suivante :
        </p><pre class="programlisting">from Customer c left join fetch c.accounts where c.lastName like :lastName</pre><p>
            devrait retourner l'ensemble de donn&eacute;es suivant :
        </p><pre class="programlisting">&lt;customer id="123456789"&gt;
    &lt;account short-desc="Savings"&gt;987632567&lt;/account&gt;
    &lt;account short-desc="Credit Card"&gt;985612323&lt;/account&gt;
    &lt;name&gt;
        &lt;first-name&gt;Gavin&lt;/first-name&gt;
        &lt;initial&gt;A&lt;/initial&gt;
        &lt;last-name&gt;King&lt;/last-name&gt;
    &lt;/name&gt;
    ...
&lt;/customer&gt;</pre><p>
            Si vous positionnez <tt class="literal">embed-xml="true"</tt> sur le mapping
            <tt class="literal">&lt;one-to-many&gt;</tt>, les donn&eacute;es pourraient
            ressembler plus &agrave; &ccedil;a :
        </p><pre class="programlisting">&lt;customer id="123456789"&gt;
    &lt;account id="987632567" short-desc="Savings"&gt;
        &lt;customer id="123456789"/&gt;
        &lt;balance&gt;100.29&lt;/balance&gt;
    &lt;/account&gt;
    &lt;account id="985612323" short-desc="Credit Card"&gt;
        &lt;customer id="123456789"/&gt;
        &lt;balance&gt;-2370.34&lt;/balance&gt;
    &lt;/account&gt;
    &lt;name&gt;
        &lt;first-name&gt;Gavin&lt;/first-name&gt;
        &lt;initial&gt;A&lt;/initial&gt;
        &lt;last-name&gt;King&lt;/last-name&gt;
    &lt;/name&gt;
    ...
&lt;/customer&gt;</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml-manipulation"></a>18.3.&nbsp;Manipuler des donn&eacute;es XML</h2></div></div><div></div></div><p>
            Relisons et mettons &agrave; jour des documents XML dans l'application. Nous faisons
            &ccedil;a en obtenant une session dom4j :
        </p><pre class="programlisting">Document doc = ....;

Session session = factory.openSession();
Session dom4jSession = session.getSession(EntityMode.DOM4J);
Transaction tx = session.beginTransaction();

List results = dom4jSession
    .createQuery("from Customer c left join fetch c.accounts where c.lastName like :lastName")
    .list();
for ( int i=0; i&lt;results.size(); i++ ) {
    //add the customer data to the XML document
    Element customer = (Element) results.get(i);
    doc.add(customer);
}

tx.commit();
session.close();</pre><pre class="programlisting">Session session = factory.openSession();
Session dom4jSession = session.getSession(EntityMode.DOM4J);
Transaction tx = session.beginTransaction();

Element cust = (Element) dom4jSession.get("Customer", customerId);
for ( int i=0; i&lt;results.size(); i++ ) {
    Element customer = (Element) results.get(i);
    //change the customer name in the XML and database
    Element name = customer.element("name");
    name.element("first-name").setText(firstName);
    name.element("initial").setText(initial);
    name.element("last-name").setText(lastName);
}

tx.commit();
session.close();</pre><p>
            Il est extr&ecirc;mement utile de combiner cette fonctionnalit&eacute; avec l'op&eacute;ration
            <tt class="literal">replicate()</tt> d'Hibernate pour impl&eacute;menter des imports/exports
            de donn&eacute;es XML.
        </p></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="performance"></a>Chapitre&nbsp;19.&nbsp;Am&eacute;liorer les performances</h2></div></div><div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-fetching"></a>19.1.&nbsp;Strat&eacute;gies de chargement</h2></div></div><div></div></div><p>
            Une <span class="emphasis"><em>strat&eacute;gie de chargement</em></span> est une strat&eacute;gie qu'Hibernate va
            utiliser pour r&eacute;cup&eacute;rer des objets associ&eacute;s si l'application &agrave; besoin de naviguer &agrave; 
            travers une association.
            Les strat&eacute;gies de chargement peuvent &ecirc;tre d&eacute;clar&eacute;es dans les m&eacute;ta-donn&eacute;es de l'outil
            de mapping objet relationnel ou surcharg&eacute;es par une requ&ecirc;te de type HQL ou <tt class="literal">Criteria</tt>
            particuli&egrave;re.
        </p><p>
            Hibernate3 d&eacute;finit les strat&eacute;gies de chargement suivantes :
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <span class="emphasis"><em>Chargement par jointure</em></span> - Hibernate r&eacute;cup&egrave;re 
                    l'instance associ&eacute;e ou la collection dans un m&ecirc;me <tt class="literal">SELECT</tt>,
                    en utilisant un <tt class="literal">OUTER JOIN</tt>.
                </p></li><li><p>
                    <span class="emphasis"><em>Chargement par select</em></span> - Un second <tt class="literal">SELECT</tt>
                    est utilis&eacute; pour r&eacute;cup&eacute;rer l'instance associ&eacute;e ou la collection. A moins
                    que vous ne d&eacute;sactiviez explicitement le chargement tardif en sp&eacute;cifiant
                    <tt class="literal">lazy="false"</tt>, ce second select ne sera ex&eacute;cut&eacute; que lorsque
                    vous acc&eacute;derez r&eacute;ellement &agrave; l'association.
                </p></li><li><p>
                    <span class="emphasis"><em>Chargement par sous-select</em></span> - Un second <tt class="literal">SELECT</tt>
                    est utilis&eacute; pour r&eacute;cup&eacute;rer les associations pour toutes les entit&eacute;s r&eacute;cup&eacute;r&eacute;es dans
                    une requ&ecirc;te ou un chargement pr&eacute;alable. A moins
                    que vous ne d&eacute;sactiviez explicitement le chargement tardif en sp&eacute;cifiant
                    <tt class="literal">lazy="false"</tt>, ce second select ne sera ex&eacute;cut&eacute; que lorsque
                    vous acc&eacute;derez r&eacute;ellement &agrave; l'association.
                </p></li><li><p>
                    <span class="emphasis"><em>Chargement par lot</em></span> - Il s'agit d'une strat&eacute;gie d'optimisation
                    pour le chargement par select - Hibernate r&eacute;cup&egrave;re un lot
                    d'instances ou de collections en un seul <tt class="literal">SELECT</tt> en sp&eacute;cifiant
                    une liste de cl&eacute; primaire ou de cl&eacute; &eacute;trang&egrave;re.
                </p></li></ul></div><p>
            Hibernate fait &eacute;galement la distinction entre :
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <span class="emphasis"><em>Chargement imm&eacute;diat</em></span> - Une association, une collection ou
                    un attribut est charg&eacute; imm&eacute;diatement lorsque l'objet auquel appartient cet
                    &eacute;l&eacute;ment est charg&eacute;.
                </p></li><li><p>
                    <span class="emphasis"><em>Chargement tardif d'une collection</em></span> - Une collection est
                    charg&eacute;e lorque l'application invoque une m&eacute;thode sur cette collection (il s'agit
                    du mode de chargement par d&eacute;faut pour les collections).
                </p></li><li><p>
                    <span class="emphasis"><em>Chargement "super tardif" d'une collection</em></span> - les
                    &eacute;l&eacute;ments de la collection sont r&eacute;cup&eacute;r&eacute;s individuellement depuis la base de donn&eacute;es
                    lorsque n&eacute;cessaire.
                    Hibernate essaie de ne pas charger toute la collection en m&eacute;moire sauf si cela est
                    absolument n&eacute;cessaire (bien adapt&eacute; aux tr&egrave;s grandes collections).
                </p></li><li><p>
                    <span class="emphasis"><em>Chargement par proxy</em></span> - une association vers un seul
                    objet est charg&eacute;e lorsqu'une m&eacute;thode autre que le getter sur l'identifiant est
                    appel&eacute;e sur l'objet associ&eacute;. 
                </p></li><li><p>
                    <span class="emphasis"><em>Chargement "sans proxy"</em></span> - une association vers un seul objet
                    est charg&eacute;e lorsque l'on acc&egrave;de &agrave; cet objet. Par rapport au chargement par proxy,
                    cette approche est moins tardif (l'association est quand m&ecirc;me charg&eacute;e m&ecirc;me
                    si on n'acc&egrave;de qu'&agrave; l'identifiant) mais plus transparente car il n'y a pas de proxy
                    visible dans l'application. Cette approche requiert une instrumentation du bytecode
                    &agrave; la compilation et est rarement n&eacute;cessaire.
                </p></li><li><p>
                    <span class="emphasis"><em>Chargement tardif des attributs</em></span> - Un attribut ou un
                    objet associ&eacute; seul est charg&eacute; lorsque l'on y acc&egrave;de. Cette approche requiert 
                    une instrumentation du bytecode &agrave; la compilation et est rarement n&eacute;cessaire.
                </p></li></ul></div><p>
            Nous avons ici deux notions orthogonales : <span class="emphasis"><em>quand</em></span> l'association est
            charg&eacute;e et <span class="emphasis"><em>comment</em></span> (quelle requ&ecirc;te SQL est utilis&eacute;e). Il ne faut
            pas confondre les deux. Le mode de chargement est utilis&eacute; pour am&eacute;liorer les performances.
            On peut utiliser le mode tardif pour d&eacute;finir un contrat sur quelles donn&eacute;es sont toujours
            accessibles sur une instance d&eacute;tach&eacute;e d'une classe particuli&egrave;re.
        </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-lazy"></a>19.1.1.&nbsp;Travailler avec des associations charg&eacute;es tardivement</h3></div></div><div></div></div><p>
                Par d&eacute;faut, Hibernate3 utilise le chargement tardif par select pour les collections
                et le chargement tardif par proxy pour les associations vers un seul objet.
                Ces valeurs par d&eacute;faut sont valables pour la plupart des associations dans la
                plupart des applications.
            </p><p>
                <span class="emphasis"><em>Note :</em></span> si vous d&eacute;finissez
                <tt class="literal">hibernate.default_batch_fetch_size</tt>, Hibernate va utiliser l'optimisation
                du chargement par lot pour le chargement tardif (cette optimisation peut aussi
                &ecirc;tre activ&eacute;e &agrave; un niveau de granularit&eacute; plus fin).
            </p><p>
                Cependant, le chargement tardif pose un probl&egrave;me qu'il faut connaitre. L'acc&egrave;s &agrave; 
                une association d&eacute;finie comme "tardive", hors du contexte d'une session hibernate
                ouverte, va conduire &agrave; une exception. Par exemple :
            </p><pre class="programlisting">s = sessions.openSession();
Transaction tx = s.beginTransaction();
            
User u = (User) s.createQuery("from User u where u.name=:userName")
    .setString("userName", userName).uniqueResult();
Map permissions = u.getPermissions();

tx.commit();
s.close();

Integer accessLevel = (Integer) permissions.get("accounts");  // Error!</pre><p>
                Etant donn&eacute; que la collection des permissions n'a pas &eacute;t&eacute; initialis&eacute;e
                avant que la <tt class="literal">Session</tt> soit ferm&eacute;e, la collection n'est
                pas capable de se charger. <span class="emphasis"><em>Hibernate ne supporte pas le chargement
                tardif pour des objets d&eacute;tach&eacute;s</em></span>. La solution &agrave; ce probl&egrave;me est de
                d&eacute;placer le code qui lit la collection avant le "commit" de la transaction.
            </p><p>
                Une autre alternative est d'utiliser une collection ou une association non
                "tardive" en sp&eacute;cifiant <tt class="literal">lazy="false"</tt> dans le mapping de
                l'association.
                Cependant il est pr&eacute;vu que le chargement tardif soit utilis&eacute; pour quasiment
                toutes les collections ou associations. Si vous d&eacute;finissez trop d'associtions
                non "tardives" dans votre mod&egrave;le objet, Hibernate va finir par devoir charger
                toute la base de donn&eacute;es en m&eacute;moire &agrave; chaque transaction !
            </p><p>
                D'un autre c&ocirc;t&eacute;, on veut souvent choisir un chargement par jointure (qui est par
                d&eacute;faut non tardif) &agrave; la place du chargement par select dans une transaction particuli&egrave;re.
                Nous allons maintenant voir comment adapter les strat&eacute;gies de chargement. Dans Hibernate3
                les m&eacute;canismes pour choisir une strat&eacute;gie de chargement sont identiques que
                l'on ait une association vers un objet simple ou vers une collection.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-custom"></a>19.1.2.&nbsp;Personnalisation des strat&eacute;gies de chargement</h3></div></div><div></div></div><p>
                Le chargement par select (mode par d&eacute;faut) est tr&egrave;s vuln&eacute;rable au probl&egrave;me du
                N+1 selects, du coup vous pouvez avoir envie d'activer le chargement par jointure
                dans les fichiers de mapping :
            </p><pre class="programlisting">&lt;set name="permissions" 
            fetch="join"&gt;
    &lt;key column="userId"/&gt;
    &lt;one-to-many class="Permission"/&gt;
&lt;/set</pre><pre class="programlisting">&lt;many-to-one name="mother" class="Cat" fetch="join"/&gt;</pre><p>
                La strat&eacute;gie de chargement d&eacute;finie &agrave; l'aide du mot <tt class="literal">fetch</tt> dans les fichiers
                de mapping affecte :
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                    La r&eacute;cup&eacute;ration via <tt class="literal">get()</tt> ou <tt class="literal">load()</tt>
                </p></li><li><p>
                    La r&eacute;cup&eacute;ration implicite lorsque l'on navigue &agrave; travers une association
                </p></li><li><p>
                    Les requ&ecirc;tes de type <tt class="literal">Criteria</tt>
                </p></li><li><p>
                    Les requ&ecirc;tes HQL si l'on utilise le chargement par <tt class="literal">subselect</tt>
                </p></li></ul></div><p>
                Quelle que soit la strat&eacute;gie de chargement que vous utilisez, la partie du graphe
                d'objets qui est d&eacute;finie comme non "tardive" sera charg&eacute;e en m&eacute;moire. Cela peut
                mener &agrave; l'ex&eacute;cution de plusieurs selects successifs pour une seule requ&ecirc;te HQL.
            </p><p>
                On n'utilise pas souvent les documents de mapping pour adapter le chargement.
                Au lieu de cela, on conserve le comportement par d&eacute;faut et on le surcharge pour
                une transaction particuli&egrave;re en utilisant <tt class="literal">left join fetch</tt>
                dans les requ&ecirc;tes HQL. Cela indique &agrave; hibernate &agrave; Hibernate de charger l'association
                de mani&egrave;re agressive lors du premier select en utilisant une jointure externe.
                Dans l'API Criteria vous pouvez utiliser la m&eacute;thode 
                <tt class="literal">setFetchMode(FetchMode.JOIN)</tt>
            </p><p>
                Si vous ne vous sentez pas pr&ecirc;t &agrave; modifier la strat&eacute;gie de chargement utilis&eacute;
                par <tt class="literal">get()</tt> ou <tt class="literal">load()</tt>, vous pouvez juste
                utiliser une requ&ecirc;te de type <tt class="literal">Criteria</tt>  comme par exemple :
            </p><pre class="programlisting">User user = (User) session.createCriteria(User.class)
                .setFetchMode("permissions", FetchMode.JOIN)
                .add( Restrictions.idEq(userId) )
                .uniqueResult();</pre><p>
                (Il s'agit de l'&eacute;quivalent pour Hibernate de ce que d'autres outils de mapping
                appellent un "fetch plan" ou "plan de chargement")
            </p><p>
                Une autre mani&egrave;re compl&egrave;tement diff&eacute;rente d'&eacute;viter le probl&egrave;me des N+1 selects
                est d'utiliser le cache de second niveau.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-proxies"></a>19.1.3.&nbsp;Proxys pour des associations vers un seul objet</h3></div></div><div></div></div><p>
                Le chargement tardif des collections est impl&eacute;ment&eacute; par Hibernate en utilisant
                ses propres impl&eacute;mentations pour des collections persistantes. Si l'on veut un
                chargement tardif pour des associations vers un seul objet m&eacute;tier il faut utiliser
                un autre m&eacute;canisme. L'entit&eacute; qui est point&eacute;e par l'association doit &ecirc;tre masqu&eacute;e
                derri&egrave;re un proxy. Hibernate impl&eacute;mente l'initialisation tardive des proxys sur des
                objets persistents via une mise &agrave; jour &agrave; chaud du bytecode (&agrave; l'aide de l'excellente
                librairie CGLIB).
            </p><p>
                Par d&eacute;faut, Hibernate g&eacute;n&egrave;re des proxys (au d&eacute;marrage) pour toutes les classes
                persistantes et les utilise pour activer le chargement tardif des associations
                <tt class="literal">many-to-one</tt> et <tt class="literal">one-to-one</tt>.
            </p><p>
                Le fichier de mapping peut d&eacute;clarer une interface qui sera utilis&eacute;e par le proxy
                d'interfa&ccedil;age pour cette classe &agrave; l'aide de l'attribut <tt class="literal">proxy</tt>.
                Par d&eacute;faut Hibernate utilises une sous classe de la classe persistante.
                <span class="emphasis"><em>Il faut que les classes pour lesquelles on ajoute un proxy impl&eacute;mentent
                un constructeur par d&eacute;faut de visibilit&eacute; au moins package. Ce constructeur est
                recommand&eacute; pour toutes les classes persistantes !</em></span>
            </p><p>
                Il y a quelques pr&eacute;cautions &agrave; prendre lorsque l'on &eacute;tend cette approche &agrave; des classes
          polymorphiques, exemple :
            </p><pre class="programlisting">&lt;class name="Cat" proxy="Cat"&gt;
        ......
        &lt;subclass name="DomesticCat" proxy="DomesticCat"&gt;
            .....
        &lt;/subclass&gt;
    &lt;/class&gt;</pre><p>
            Tout d'abord, les instances de <tt class="literal">Cat</tt> ne pourront jamais &ecirc;tre "cast&eacute;es"
        en <tt class="literal">DomesticCat</tt>, m&ecirc;me si l'instance sous jacente est une instance 
        de <tt class="literal">DomesticCat</tt> :
        </p><pre class="programlisting">Cat cat = (Cat) session.load(Cat.class, id);  // instancie un proxy (n'interroge pas la base de donn&eacute;es)
if ( cat.isDomesticCat() ) {                  // interroge la base de donn&eacute;es pour initialiser le proxy
    DomesticCat dc = (DomesticCat) cat;       // Erreur !
    ....
}</pre><p>
            Deuxi&egrave;mement, il est possible de casser la notion d'<tt class="literal">==</tt> des proxy.
        </p><pre class="programlisting">Cat cat = (Cat) session.load(Cat.class, id);            // instancie un proxy Cat
DomesticCat dc = 
    (DomesticCat) session.load(DomesticCat.class, id);  // acquiert un nouveau proxy DomesticCat
System.out.println(cat==dc);                            // faux</pre><p>
            Cette situation n'est pas si mauvaise qu'il n'y parait. M&ecirc;me si nous avons deux
        r&eacute;f&eacute;rences &agrave; deux objets proxys diff&eacute;rents, l'instance de base sera quand m&ecirc;me le m&ecirc;me objet :
        </p><pre class="programlisting">cat.setWeight(11.0);  // interroge la base de donn&eacute;es pour initialiser le proxy
System.out.println( dc.getWeight() );  // 11.0</pre><p>
            Troisi&egrave;mement, vous ne pourrez pas utiliser un proxy CGLIB pour une classe <tt class="literal">final</tt>
        ou pour une classe contenant la moindre m&eacute;thode <tt class="literal">final</tt>.
        </p><p>
            Enfin, si votre objet persistant obtient une ressource &agrave; l'instanciation (par
        example dans les initialiseurs ou dans le contructeur par d&eacute;faut), alors ces ressources
        seront aussi obtenues par le proxy. La classe proxy est vraiment une sous classe de la classe
        persistante.
        </p><p>
            Ces probl&egrave;mes sont tous dus aux limitations fondamentales du mod&egrave;le d'h&eacute;ritage unique de Java.
        Si vous souhaitez &eacute;viter ces probl&egrave;mes, vos classes persistantes doivent chacune impl&eacute;menter
        une interface qui d&eacute;clare ses m&eacute;thodes m&eacute;tier. Vous devriez alors sp&eacute;cifier ces interfaces
        dans le fichier de mapping :
        </p><pre class="programlisting">&lt;class name="CatImpl" proxy="Cat"&gt;
    ......
    &lt;subclass name="DomesticCatImpl" proxy="DomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
            o&ugrave; <tt class="literal">CatImpl</tt> impl&eacute;mente l'interface <tt class="literal">Cat</tt> et <tt class="literal">DomesticCatImpl</tt> 
        impl&eacute;mente l'interface <tt class="literal">DomesticCat</tt>. Ainsi, des proxys pour les instances de 
        <tt class="literal">Cat</tt> et <tt class="literal">DomesticCat</tt> pourraient &ecirc;tre retourn&eacute;es par <tt class="literal">load()</tt> 
        ou <tt class="literal">iterate()</tt> (Notez que <tt class="literal">list()</tt> ne retourne g&eacute;n&eacute;ralement pas de proxy).
        </p><pre class="programlisting">Cat cat = (Cat) session.load(CatImpl.class, catid);
Iterator iter = session.iterate("from CatImpl as cat where cat.name='fritz'");
Cat fritz = (Cat) iter.next();</pre><p>
            Les relations sont aussi initialis&eacute;es tardivement. Ceci signifie que vous 
        devez d&eacute;clarer chaque propri&eacute;t&eacute; comme &eacute;tant de type <tt class="literal">Cat</tt>, 
        et non <tt class="literal">CatImpl</tt>.
        </p><p>
            Certaines op&eacute;rations ne n&eacute;cessitent pas l'initialisation du proxy
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">equals()</tt>, si la classe persistante ne surcharge pas
                    <tt class="literal">equals()</tt>
                </p></li><li><p>
                    <tt class="literal">hashCode()</tt>, si la classe persistante ne surcharge pas
                    <tt class="literal">hashCode()</tt>
                </p></li><li><p>
                    Le getter de l'identifiant
                </p></li></ul></div><p>
            Hibernate d&eacute;tectera les classes qui surchargent <tt class="literal">equals()</tt> ou
            <tt class="literal">hashCode()</tt>.
        </p><p>
            Eh choisissant <tt class="literal">lazy="no-proxy"</tt> au lieu de <tt class="literal">lazy="proxy"</tt>
            qui est la valeur par d&eacute;faut, il est possible d'&eacute;viter les probl&egrave;mes li&eacute;s au transtypage.
            Il faudra alors une instrumentation du bytecode &agrave; la compilation et toutes les op&eacute;rations
            r&eacute;sulterons imm&eacute;diatement en une initialisation du proxy.
        </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-initialization"></a>19.1.4.&nbsp;Initialisation des collections et des proxys</h3></div></div><div></div></div><p>
                Une exception de type <tt class="literal">LazyInitializationException</tt> sera renvoy&eacute;e par hibernate
                si une collection ou un proxy non initialis&eacute; est acc&eacute;d&eacute; en dehors de la port&eacute;e de la <tt class="literal">Session</tt>,
                e.g. lorsque l'entit&eacute; &agrave; laquelle appartient la collection ou qui a une r&eacute;f&eacute;rence vers le proxy est
                dans l'&eacute;tat "d&eacute;tach&eacute;e".
            </p><p>
            Parfois, nous devons nous assurer qu'un proxy ou une collection est initialis&eacute;e avant de 
            fermer la <tt class="literal">Session</tt>. Bien s&ucirc;r, nous pouvons toujours forcer l'initialisation
            en appelant par exemple <tt class="literal">cat.getSex()</tt> ou <tt class="literal">cat.getKittens().size()</tt>.
            Mais ceci n'est pas tr&egrave;s lisible pour les personnes parcourant le code et n'est pas tr&egrave;s g&eacute;n&eacute;rique.
        </p><p>
            Les m&eacute;thodes statiques <tt class="literal">Hibernate.initialize()</tt> et <tt class="literal">Hibernate.isInitialized()</tt>
            fournissent &agrave; l'application un moyen de travailler avec des proxys ou des collections initialis&eacute;s.
            <tt class="literal">Hibernate.initialize(cat)</tt> forcera l'initialisation d'un proxy de <tt class="literal">cat</tt>, 
            si tant est que sa <tt class="literal">Session</tt> est ouverte. <tt class="literal">Hibernate.initialize( cat.getKittens() )</tt> 
            a le m&ecirc;me effet sur la collection kittens. 
        </p><p>
                Une autre option est de conserver la <tt class="literal">Session</tt> ouverte jusqu'&agrave;
                ce que toutes les collections et tous les proxys aient &eacute;t&eacute; charg&eacute;s. Dans certaines
                architectures applicatives, particuli&egrave;rement celles ou le code d'acc&egrave;s aux donn&eacute;es
                via hiberante et le code qui utilise ces donn&eacute;es sont dans des couches applicatives
                diff&eacute;rentes ou des processus physiques diff&eacute;rents, il peut devenir probl&eacute;matique
                de garantir que la <tt class="literal">Session</tt> est ouverte lorsqu'une collection
                est initialis&eacute;e. Il y a deux moyens de traiter ce probl&egrave;me :
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        Dans une application web, un filtre de servlet peut &ecirc;tre utilis&eacute; pour
                        fermer la <tt class="literal">Session</tt> uniquement lorsque la requ&ecirc;te
                        a &eacute;t&eacute; enti&egrave;rement trait&eacute;e, lorsque le rendu de la vue est fini
                        (il s'agit du pattern <span class="emphasis"><em>Open Session in View</em></span>).
                        Bien s&ucirc;r, cela demande plus d'attention &agrave; la bonne gestion des exceptions
                        de l'application. Il est d'une importance vitale que la <tt class="literal">Session</tt>
                        soit ferm&eacute;e et la transaction termin&eacute;e avant que l'on rende la main &agrave; l'utilisateur
                        m&ecirc;me si une exception survient durant le traitement de la vue. 
                        Voir le wiki Hibernate pour des exemples sur le pattern
                        "Open Session in View".
                    </p></li><li><p>
                        Dans une application avec une couche m&eacute;tier s&eacute;par&eacute;e, la couche contenant
                        la logique m&eacute;tier doit "pr&eacute;parer" toutes les collections qui seront
                        n&eacute;cessaires &agrave; la couche web avant de retourner les donn&eacute;es. Cela signifie
                        que la couche m&eacute;tier doit charger toutes les donn&eacute;es et retourner toutes
                        les donn&eacute;es d&eacute;j&agrave; initialis&eacute;es &agrave; la couche de pr&eacute;sentation/web pour un
                        cas d'utilisation donn&eacute;. En g&eacute;n&eacute;ral l'application appelle la m&eacute;thode
                        <tt class="literal">Hibernate.initialize()</tt> pour chaque collection n&eacute;cessaire
                        dans la couche web (cet appel doit &ecirc;tre fait avant la fermeture de la session)
                        ou bien r&eacute;cup&egrave;re les collections de mani&egrave;re agressive &agrave; l'aide d'une requ&ecirc;te
                        HQL avec une clause <tt class="literal">FETCH</tt> ou &agrave; l'aide du mode
                        <tt class="literal">FetchMode.JOIN</tt> pour une requ&ecirc;te de type <tt class="literal">Criteria</tt>.
                        Cela est en g&eacute;n&eacute;ral plus facile si vous utilisez le pattern <span class="emphasis"><em>Command</em></span>
                        plut&ocirc;t que <span class="emphasis"><em>Session Facade</em></span>.
                    </p></li><li><p>
                        Vous pouvez &eacute;galement attacher &agrave; une <tt class="literal">Session</tt> un objet charg&eacute;
                        au pr&eacute;alable &agrave; l'aide des m&eacute;thodes <tt class="literal">merge()</tt> ou <tt class="literal">lock()</tt>
                        avant d'acc&eacute;der aux collections (ou aux proxys) non initialis&eacute;s. Non, Hibernate ne
                        fait pas, et ne doit pas faire, cela automatiquement car cela pourrait introduire
                        une s&eacute;mantique transactionnelle ad hoc.
                    </p></li></ul></div><p>
                Parfois, vous ne voulez pas initialiser une grande collection mais vous avez quand m&ecirc;me
                besoin d'informations sur elle (comme sa taille) ou un sous ensemble de ses donn&eacute;es
            </p><p>
                Vous pouvez utiliser un filtre de collection pour r&eacute;cup&eacute;rer sa taille sans l'initialiser :
            </p><pre class="programlisting">( (Integer) s.createFilter( collection, "select count(*)" ).list().get(0) ).intValue()</pre><p>
                La m&eacute;thode <tt class="literal">createFilter()</tt> est &eacute;galement utilis&eacute;e pour r&eacute;cup&eacute;rer
                de mani&egrave;re efficace des sous ensembles d'une collection sans avoir besoin de l'initialiser
                dans son ensemble.
            </p><pre class="programlisting">s.createFilter( lazyCollection, "").setFirstResult(0).setMaxResults(10).list();</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-batch"></a>19.1.5.&nbsp;Utiliser le chargement par lot</h3></div></div><div></div></div><p>
            Pour am&eacute;liorer les performances, Hibernate peut utiliser le chargement par lot
            ce qui veut dire qu'Hibernate peut charger plusieurs proxys (ou collections) non initialis&eacute;s en une seule 
            requ&ecirc;te lorsque l'on acc&egrave;de &agrave; l'un de ces proxys. Le chargement par lot est une optimisation 
            intimement li&eacute;e &agrave; la strat&eacute;gie de chargement tardif par select. Il y a deux moyens d'activer le  
            chargement par lot : au niveau de la classe et au niveau de la collection.
        </p><p>
            Le chargement par lot pour les classes/entit&eacute;s est plus simple &agrave; comprendre. Imaginez que vous ayez la
            situation suivante &agrave; l'ex&eacute;cution : vous avez 25 instances de <tt class="literal">Cat</tt> 
            charg&eacute;es dans une <tt class="literal">Session</tt>, chaque <tt class="literal">Cat</tt> a une r&eacute;f&eacute;rence 
            &agrave; son <tt class="literal">owner</tt>, une <tt class="literal">Person</tt>.
            La classe <tt class="literal">Person</tt> est mapp&eacute;e avec un proxy, <tt class="literal">lazy="true"</tt>. 
            Si vous it&eacute;rez sur tous les cats et appelez <tt class="literal">getOwner()</tt> sur chacun d'eux, 
            Hibernate ex&eacute;cutera par d&eacute;faut 25 <tt class="literal">SELECT</tt>, pour charger les owners
            (initialiser le proxy). Vous pouvez param&eacute;trer ce comportement en sp&eacute;cifiant une 
            <tt class="literal">batch-size</tt> (taille du lot) dans le mapping de <tt class="literal">Person</tt> :
        </p><pre class="programlisting">&lt;class name="Person" batch-size="10"&gt;...&lt;/class&gt;</pre><p>
            Hibernate ex&eacute;cutera d&eacute;sormais trois requ&ecirc;tes, en chargeant respectivement 10, 
            10, et 5 entit&eacute;s.
        </p><p>
            Vous pouvez aussi activer le chargement par lot pour les collections. Par exemple, 
            si chaque <tt class="literal">Person</tt> a une collection charg&eacute;e tardivement de 
            <tt class="literal">Cat</tt>s, et que 10 personnes sont actuellement charg&eacute;es dans la 
            <tt class="literal">Session</tt>, it&eacute;rer sur toutes les persons g&eacute;n&eacute;rera 10 <tt class="literal">SELECT</tt>s,
            un pour chaque appel de <tt class="literal">getCats()</tt>. Si vous activez le chargement par lot pour la
            collection <tt class="literal">cats</tt> dans le mapping de <tt class="literal">Person</tt>, Hibernate pourra
            pr&eacute;charger les collections :
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;set name="cats" batch-size="3"&gt;
        ...
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
            Avec une taille de lot (<tt class="literal">batch-size</tt>) de 8, Hibernate chargera 
        respectivement 3, 3, 3, et 1 collections en quatre <tt class="literal">SELECT</tt>s. 
        Encore une fois, la valeur de l'attribut d&eacute;pend du nombre de collections
        non initialis&eacute;es dans une <tt class="literal">Session</tt> particuli&egrave;re.
        </p><p>
            Le chargement par lot de collections est particuli&egrave;rement utile si vous avez des 
        arborescenses r&eacute;cursives d'&eacute;l&eacute;ments (typiquement, le sch&eacute;ma facture de 
        mat&eacute;riels). (Bien qu'un <span class="emphasis"><em>sous ensemble</em></span> ou un 
        <span class="emphasis"><em>chemin mat&eacute;rialis&eacute;</em></span> est sans doute une meilleure option pour
        des arbres principalement en lecture.)
        </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-subselect"></a>19.1.6.&nbsp;Utilisation du chargement par sous select</h3></div></div><div></div></div><p>
                Si une collection ou un proxy vers un objet doit &ecirc;tre charg&eacute;, Hibernate va tous les
                charger en r&eacute;-ex&eacute;cutant la requ&ecirc;te orignial dans un sous select. Cela fonctionne de la
                m&ecirc;me mani&egrave;re que le chargement par lot sans la possibilit&eacute; de fragmenter le chargement.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-lazyproperties"></a>19.1.7.&nbsp;Utiliser le chargement tardif des propri&eacute;t&eacute;s</h3></div></div><div></div></div><p>
                Hibernate3 supporte le chargement tardif de propri&eacute;t&eacute;s individuelles. La technique
                d'optimisation est &eacute;galement connue sous le nom de <span class="emphasis"><em>fetch groups</em></span> (groupes
                de chargement). Il faut noter qu'il s'agit principalement d'une fonctionnalit&eacute; marketing
                car en pratique l'optimisation de la lecture d'un enregistrement est beaucoup plus importante
                que l'optimisation de la lecture d'une colonne. Cependant, la restriction du chargement &agrave;
                certaines colonnes peut &ecirc;tre pratique dans des cas extr&egrave;mes, lorsque des tables "legacy"
                poss&egrave;dent des centaines de colonnes et que le mod&egrave;le de donn&eacute;es ne peut pas &ecirc;tre am&eacute;lior&eacute;.
            </p><p>
                Pour activer le chargement tardif d'une propri&eacute;t&eacute;, il faut mettre l'attribut <tt class="literal">lazy</tt>
                sur une propri&eacute;t&eacute; particuli&egrave;re du mapping :
            </p><pre class="programlisting">&lt;class name="Document"&gt;
       &lt;id name="id"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true" length="50"/&gt;
    &lt;property name="summary" not-null="true" length="200" lazy="true"/&gt;
    &lt;property name="text" not-null="true" length="2000" lazy="true"/&gt;
&lt;/class&gt;</pre><p>
                Le chargement tardif des propri&eacute;t&eacute;s requiert une instrumentation du bytecode lors de la
                compilation ! Si les classes persistantes ne sont pas instrument&eacute;es, Hibernate ignorera de
                mani&egrave;re silencieuse le mode tardif et retombera dans le mode de chargement imm&eacute;diat.
            </p><p>
                Pour l'instrumentation du bytecode vous pouvez utiliser la t&acirc;che Ant suivante :
            </p><pre class="programlisting">&lt;target name="instrument" depends="compile"&gt;
    &lt;taskdef name="instrument" classname="org.hibernate.tool.instrument.InstrumentTask"&gt;
        &lt;classpath path="${jar.path}"/&gt;
        &lt;classpath path="${classes.dir}"/&gt;
        &lt;classpath refid="lib.class.path"/&gt;
    &lt;/taskdef&gt;

    &lt;instrument verbose="true"&gt;
        &lt;fileset dir="${testclasses.dir}/org/hibernate/auction/model"&gt;
            &lt;include name="*.class"/&gt;
        &lt;/fileset&gt;
    &lt;/instrument&gt;
&lt;/target&gt;</pre><p>
                Une autre fa&ccedil;on (meilleure ?) pour &eacute;viter de lire plus de colonnes que
                n&eacute;cessaire au moins pour des transactions en lecture seule est d'utiliser
                les fonctionnalit&eacute;s de projection des requ&ecirc;tes HQL ou Criteria. Cela &eacute;vite
                de devoir instrumenter le bytecode &agrave; la compilation et est certainement une
                solution pr&eacute;f&eacute;rable.
            </p><p>
                Vous pouvez forcer le mode de chargement agressif des propri&eacute;t&eacute;s en utilisant
                <tt class="literal">fetch all properties</tt> dans les requ&ecirc;ts HQL.
            </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-cache"></a>19.2.&nbsp;Le cache de second niveau</h2></div></div><div></div></div><p>
            Une <tt class="literal">Session</tt> Hibernate est un cache de niveau transactionnel 
        des donn&eacute;es persistantes. Il est possible de configurer un cache de cluster ou de JVM 
        (de niveau <tt class="literal">SessionFactory</tt> pour &ecirc;tre exact) d&eacute;fini classe par classe 
        et collection par collection. Vous pouvez m&ecirc;me utiliser votr choix de cache
        en impl&eacute;mentant le pourvoyeur (provider) associ&eacute;.
        Faites attention, les caches ne sont jamais avertis des modifications faites 
        dans la base de donn&eacute;es par d'autres applications (ils peuvent cependant &ecirc;tre 
        configur&eacute;s pour r&eacute;guli&egrave;rement expirer les donn&eacute;es en cache).
        </p><p>
            Par d&eacute;faut, Hibernate utilise EHCache comme cache de niveau JVM (le support 
        de JCS est d&eacute;sormais d&eacute;pr&eacute;ci&eacute; et sera enlev&eacute; des futures versions d'Hibernate).
        Vous pouvez choisir une autre impl&eacute;mentation en sp&eacute;cifiant le nom de la classe qui 
        impl&eacute;mente <tt class="literal">org.hibernate.cache.CacheProvider</tt> en utilisant 
        la propri&eacute;t&eacute; <tt class="literal">hibernate.cache.provider_class</tt>.
        </p><div class="table"><a name="cacheproviders"></a><p class="title"><b>Tableau&nbsp;19.1.&nbsp;Fournisseur de cache</b></p><table summary="Fournisseur de cache" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Cache</th><th align="left">Classe pourvoyeuse</th><th align="left">Type</th><th align="left">Support en Cluster</th><th align="left">Cache de requ&ecirc;tes support&eacute;</th></tr></thead><tbody><tr><td align="left">Hashtable (ne pas utiliser en production)</td><td align="left"><tt class="literal">org.hibernate.cache.HashtableCacheProvider</tt></td><td align="left">m&eacute;moire</td><td align="left">&nbsp;</td><td align="left">oui</td></tr><tr><td align="left">EHCache</td><td align="left"><tt class="literal">org.hibernate.cache.EhCacheProvider</tt></td><td align="left">m&eacute;moire, disque</td><td align="left">&nbsp;</td><td align="left">oui</td></tr><tr><td align="left">OSCache</td><td align="left"><tt class="literal">org.hibernate.cache.OSCacheProvider</tt></td><td align="left">m&eacute;moire, disque</td><td align="left">&nbsp;</td><td align="left">oui</td></tr><tr><td align="left">SwarmCache</td><td align="left"><tt class="literal">org.hibernate.cache.SwarmCacheProvider</tt></td><td align="left">en cluster (multicast ip)</td><td align="left">oui (invalidation de cluster)</td><td align="left">&nbsp;</td></tr><tr><td align="left">JBoss TreeCache</td><td align="left"><tt class="literal">org.hibernate.cache.TreeCacheProvider</tt></td><td align="left">en cluster (multicast ip), transactionnel</td><td align="left">oui (replication)</td><td align="left">oui (horloge sync. n&eacute;cessaire)</td></tr></tbody></table></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-mapping"></a>19.2.1.&nbsp;Mapping de Cache</h3></div></div><div></div></div><p>
                L'&eacute;l&eacute;ment <tt class="literal">&lt;cache&gt;</tt> d'une classe ou d'une collection &agrave;
        la forme suivante :
            </p><div class="programlistingco"><pre class="programlisting">&lt;cache 
    usage="transactional|read-write|nonstrict-read-write|read-only"  <span class="co">(1)</span>
    region="RegionName"                                              <span class="co">(2)</span>
    include="all|non-lazy"                                           <span class="co">(3)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">usage</tt> (requis) sp&eacute;cifie la strat&eacute;gie de cache :
                            <tt class="literal">transactionel</tt>,
                            <tt class="literal">lecture-&eacute;criture</tt>,
                            <tt class="literal">lecture-&eacute;criture non stricte</tt> ou
                            <tt class="literal">lecture seule</tt>
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">region</tt> (optionnel, par d&eacute;faut il s'agit du nom
                            de la classe ou du nom de role de la collection) sp&eacute;cifie le nom de la
                            r&eacute;gion du cache de second niveau
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">include</tt> (optionnel, par d&eacute;faut <tt class="literal">all</tt>)
                            <tt class="literal">non-lazy</tt> sp&eacute;cifie que les propri&eacute;t&eacute;s des entit&eacute;s mapp&eacute;es avec 
                            <tt class="literal">lazy="true"</tt> ne doivent pas &ecirc;tre mises en cache lorsque
                            le chargement tardif des attributs est activ&eacute;.
                        </p></td></tr></table></div></div><p>
                Alternativement (voir pr&eacute;f&eacute;rentiellement), vous pouvez sp&eacute;cifier les &eacute;l&eacute;ments 
        <tt class="literal">&lt;class-cache&gt;</tt> et <tt class="literal">&lt;collection-cache&gt;</tt> 
        dans <tt class="literal">hibernate.cfg.xml</tt>.
            </p><p>
                L'attribut <tt class="literal">usage</tt> sp&eacute;cifie une <span class="emphasis"><em>strat&eacute;gie de concurrence d'acc&egrave;s au cache</em></span>.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-readonly"></a>19.2.2.&nbsp;Strategie : lecture seule</h3></div></div><div></div></div><p>
                Si votre application a besoin de lire mais ne modifie jamais les instances d'une classe,
        un cache <tt class="literal">read-only</tt> peut &ecirc;tre utilis&eacute;. C'est la strat&eacute;gie la plus simple
        et la plus performante. Elle est m&ecirc;me parfaitement s&ucirc;re dans un cluster.
            </p><pre class="programlisting">&lt;class name="eg.Immutable" mutable="false"&gt;
    &lt;cache usage="read-only"/&gt;
    ....
&lt;/class&gt;</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-readwrite"></a>19.2.3.&nbsp;Strat&eacute;gie : lecture/&eacute;criture</h3></div></div><div></div></div><p>
                Si l'application a besoin de mettre &agrave; jour des donn&eacute;es, un cache <tt class="literal">read-write</tt> peut
        &ecirc;tre appropri&eacute;. Cette strat&eacute;gie ne devrait jamais &ecirc;tre utilis&eacute;e si votre application
        n&eacute;cessite un niveau d'isolation transactionnelle s&eacute;rialisable. Si le cache est utilis&eacute; 
        dans un environnement JTA, vous devez sp&eacute;cifier 
        <tt class="literal">hibernate.transaction.manager_lookup_class</tt>, fournissant une strat&eacute;gie pour obtenir
        le <tt class="literal">TransactionManager</tt> JTA. Dans d'autres environnements, vous devriez vous assurer
        que la transation est termin&eacute;e &agrave; l'appel de <tt class="literal">Session.close()</tt> 
        ou <tt class="literal">Session.disconnect()</tt>. Si vous souhaitez utiliser cette strat&eacute;gie 
        dans un cluster, vous devriez vous assurer que l'impl&eacute;mentation de cache utilis&eacute;e supporte 
        le v&eacute;rrouillage. Ce que ne font <span class="emphasis"><em>pas</em></span> les pourvoyeurs caches fournis.
            </p><pre class="programlisting">&lt;class name="eg.Cat" .... &gt;
    &lt;cache usage="read-write"/&gt;
    ....
    &lt;set name="kittens" ... &gt;
        &lt;cache usage="read-write"/&gt;
        ....
    &lt;/set&gt;
&lt;/class&gt;</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-nonstrict"></a>19.2.4.&nbsp;Strat&eacute;gie : lecture/&eacute;criture non stricte</h3></div></div><div></div></div><p>
                Si l'application besoin de mettre &agrave; jour les donn&eacute;es de mani&egrave;re occasionnelle 
        (qu'il est tr&egrave;s peu probable que deux transactions essaient de mettre &agrave; jour le m&ecirc;me 
        &eacute;l&eacute;ment simultan&eacute;ment) et qu'une isolation transactionnelle stricte n'est pas n&eacute;cessaire, 
        un cache <tt class="literal">nonstrict-read-write</tt> peut &ecirc;tre appropri&eacute;. Si le cache est 
        utilis&eacute; dans un environnement JTA, vous devez sp&eacute;cifier
        <tt class="literal">hibernate.transaction.manager_lookup_class</tt>. Dans d'autres 
        environnements, vous devriez vous assurer que la transation est termin&eacute;e &agrave; l'appel 
        de <tt class="literal">Session.close()</tt> ou <tt class="literal">Session.disconnect()</tt> 
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-transactional"></a>19.2.5.&nbsp;Strat&eacute;gie : transactionelle</h3></div></div><div></div></div><p>
                La strat&eacute;gie de cache <tt class="literal">transactional</tt> supporte un cache 
        compl&egrave;tement transactionnel comme, par exemple, JBoss TreeCache. Un tel cache ne 
        peut &ecirc;tre utilis&eacute; que dans un environnement JTA et vous devez sp&eacute;cifier 
        <tt class="literal">hibernate.transaction.manager_lookup_class</tt>. 
            </p></div><p>
            Aucun des caches livr&eacute;s ne supporte toutes les strat&eacute;gies de concurrence. Le tableau suivant montre
        quels caches sont compatibles avec quelles strat&eacute;gies de concurrence.       
        </p><div class="table"><a name="d0e14029"></a><p class="title"><b>Tableau&nbsp;19.2.&nbsp;Strat&eacute;gie de concurrence du cache</b></p><table summary="Strat&eacute;gie de concurrence du cache" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Cache</th><th align="left">read-only (lecture seule)</th><th align="left">nonstrict-read-write (lecture-&eacute;criture non stricte)</th><th align="left">read-write (lecture-&eacute;riture)</th><th align="left">transactional (transactionnel)</th></tr></thead><tbody><tr><td align="left">Hashtable (ne pas utilser en production)</td><td align="left">oui</td><td align="left">oui</td><td align="left">oui</td><td align="left">&nbsp;</td></tr><tr><td align="left">EHCache</td><td align="left">oui</td><td align="left">oui</td><td align="left">oui</td><td align="left">&nbsp;</td></tr><tr><td align="left">OSCache</td><td align="left">oui</td><td align="left">oui</td><td align="left">oui</td><td align="left">&nbsp;</td></tr><tr><td align="left">SwarmCache</td><td align="left">oui</td><td align="left">oui</td><td align="left">&nbsp;</td><td align="left">&nbsp;</td></tr><tr><td align="left">JBoss TreeCache</td><td align="left">oui</td><td align="left">&nbsp;</td><td align="left">&nbsp;</td><td align="left">oui</td></tr></tbody></table></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-sessioncache"></a>19.3.&nbsp;G&eacute;rer les caches</h2></div></div><div></div></div><p>
            A chaque fois que vous passez un objet &agrave; la m&eacute;thode <tt class="literal">save()</tt>, 
            <tt class="literal">update()</tt> ou <tt class="literal">saveOrUpdate()</tt> et &agrave; chaque fois
            que vous r&eacute;cup&eacute;rez un objet avec <tt class="literal">load()</tt>, <tt class="literal">get()</tt>,
            <tt class="literal">list()</tt>, <tt class="literal">iterate()</tt> or <tt class="literal">scroll()</tt>, 
            cet objet est ajout&eacute; au cache interne de la <tt class="literal">Session</tt>. 
        </p><p>
            Lorsqu'il y a un appel &agrave; la m&eacute;thode <tt class="literal">flush()</tt>, l'&eacute;tat de cet objet
            va &ecirc;tre synchronis&eacute; avec la base de donn&eacute;es. Si vous ne voulez pas que cette synchronisation
            ait lieu ou si vous traitez un grand nombre d'objets et que vous avez besoin de g&eacute;rer
            la m&eacute;moire de mani&egrave;re efficace, vous pouvez utiliser la m&eacute;thode <tt class="literal">evict()</tt>
            pour supprimer l'objet et ses collections d&eacute;pendantes du cache de la session
        </p><pre class="programlisting">ScrollableResult cats = sess.createQuery("from Cat as cat").scroll(); //a huge result set
while ( cats.next() ) {
    Cat cat = (Cat) cats.get(0);
    doSomethingWithACat(cat);
    sess.evict(cat);
}</pre><p>
          La <tt class="literal">Session</tt> dispose aussi de la m&eacute;thode <tt class="literal">contains()</tt> pour d&eacute;terminer
            si une instance appartient au cache de la session.
        </p><p>
            Pour retirer tous les objets du cache session, appelez <tt class="literal">Session.clear()</tt>
        </p><p>
            Pour le cache de second niveau, il existe des m&eacute;thodes d&eacute;finies dans 
        <tt class="literal">SessionFactory</tt> pour retirer des instances du cache, 
        la classe enti&egrave;re, une instance de collection ou
        le r&ocirc;le entier d'une collection.
        </p><pre class="programlisting">sessionFactory.evict(Cat.class, catId); //evict a particular Cat
sessionFactory.evict(Cat.class);  //evict all Cats
sessionFactory.evictCollection("Cat.kittens", catId); //evict a particular collection of kittens
sessionFactory.evictCollection("Cat.kittens"); //evict all kitten collections</pre><p>
            Le <tt class="literal">CacheMode</tt> contr&ocirc;le comme une session particuli&egrave;re interragit avec le
            cache de second niveau
        </p><div class="itemizedlist"><ul type="disc"><li><p>
            <tt class="literal">CacheMode.NORMAL</tt> - lit et &eacute;crit les items dans le cache de second niveau
        </p></li><li><p>
            <tt class="literal">CacheMode.GET</tt> - lit les items dans le cache de second niveau mais ne
            les &eacute;crit pas sauf dans le cache d'une mise &agrave; jour d'une donn&eacute;e
        </p></li><li><p>
            <tt class="literal">CacheMode.PUT</tt> -  &eacute;crit les items dans le cache de second niveau mais ne les
            lit pas dans le cache de second niveau
        </p></li><li><p>
            <tt class="literal">CacheMode.REFRESH</tt> - &eacute;crit les items dans le cache de second niveau mais ne les
            lit pas dans le cache de second niveau, outrepasse l'effet de<tt class="literal">hibernate.cache.use_minimal_puts</tt>, 
            en for&ccedil;ant un rafra&icirc;chissement du cache de second niveau pour chaque item lu dans la base
        </p></li></ul></div><p>
            Pour parcourir le contenu du cache de second niveau ou la r&eacute;gion du cache d&eacute;di&eacute;e au requ&ecirc;tes, vous
            pouvez utiliser l'API <tt class="literal">Statistics</tt>
            API:
        </p><pre class="programlisting">Map cacheEntries = sessionFactory.getStatistics()
        .getSecondLevelCacheStatistics(regionName)
        .getEntries();</pre><p>
          Vous devez pour cela activer les statistiques et optionnellement forcer Hibernate &agrave; conserver les entr&eacute;es dans le
          cache sous un format plus compr&eacute;hensible pour l'utilisateur :
        </p><pre class="programlisting">hibernate.generate_statistics true
hibernate.cache.use_structured_entries true</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-querycache"></a>19.4.&nbsp;Le cache de requ&ecirc;tes</h2></div></div><div></div></div><p>
          Les r&eacute;sultats d'une requ&ecirc;te peuvent aussi &ecirc;tre plac&eacute;s en cache. Ceci n'est utile
            que pour les requ&ecirc;tes qui sont ex&eacute;cut&eacute;es avec les m&ecirc;mes param&egrave;tres. Pour utiliser
            le cache de requ&ecirc;tes, vous devez d'abord l'activer :
        </p><pre class="programlisting">hibernate.cache.use_query_cache true</pre><p>
          Ce param&egrave;tre am&egrave;ne la cr&eacute;ation de deux nouvelles r&eacute;gions dans le cache, une qui va conserver
          le r&eacute;sultat des requ&ecirc;tes mises en cache (<tt class="literal">org.hibernate.cache.StandardQueryCache</tt>)
          et l'autre qui va conserver l'horodatage des mises &agrave; jour les plus r&eacute;centes effectu&eacute;es sur les
          tables requ&ecirc;tables (<tt class="literal">org.hibernate.cache.UpdateTimestampsCache</tt>).
          Il faut noter que le cache de requ&ecirc;te ne conserve pas l'&eacute;tat des entit&eacute;s, il met en cache
          uniquement les valeurs de l'identifiant et les valeurs de types de base (?). Le cache
          de requ&ecirc;te doit toujours &ecirc;tre utilis&eacute; avec le cache de second niveau pour &ecirc;tre efficace.
        </p><p>
          La plupart des requ&ecirc;tes ne retirent pas de b&eacute;n&eacute;fice pas du cache, 
          donc par d&eacute;faut les requ&ecirc;tes ne sont pas mises en cache. Pour activer le cache, 
          appelez <tt class="literal">Query.setCacheable(true)</tt>. 
            Cet appel permet de v&eacute;rifier si les r&eacute;sultats sont en cache ou non, voire
          d'ajouter ces r&eacute;sultats si la requ&ecirc;te est ex&eacute;cut&eacute;e.
        </p><p>
          Si vous avez besoin de contr&ocirc;ler finement les d&eacute;lais d'expiration du cache, vous
            pouvez sp&eacute;cifier une r&eacute;gion de cache nomm&eacute;e pour une requ&ecirc;te particuli&egrave;re en
            appelant <tt class="literal">Query.setCacheRegion()</tt>.
        </p><pre class="programlisting">List blogs = sess.createQuery("from Blog blog where blog.blogger = :blogger")
    .setEntity("blogger", blogger)
    .setMaxResults(15)
    .setCacheable(true)
    .setCacheRegion("frontpages")
    .list();</pre><p>
          Si une requ&ecirc;te doit forcer le rafra&icirc;chissement de sa r&eacute;gion de cache, vous devez
          appeler <tt class="literal">Query.setCacheMode(CacheMode.REFRESH)</tt>. C'est particuli&egrave;rement
          utile lorsque les donn&eacute;es peuvent avoir &eacute;t&eacute; mises &agrave; jour par un processus s&eacute;par&eacute; (e.g. elles
          n'ont pas &eacute;t&eacute; modifi&eacute;es par Hibernate). Cela permet &agrave; l'application de rafra&icirc;chir de
          mani&egrave;re s&eacute;lective les r&eacute;sultats d'une requ&ecirc;te particuli&egrave;re. Il s'agit d'une alternative plus
          efficace &agrave; l'&eacute;viction d'une r&eacute;gion du cache &agrave; l'aide de la m&eacute;thode 
          <tt class="literal">SessionFactory.evictQueries()</tt>.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-collections"></a>19.5.&nbsp;Comprendre les performances des Collections</h2></div></div><div></div></div><p>
            Nous avons d&eacute;j&agrave; pass&eacute; du temps &agrave; discuter des collections.
        Dans cette section, nous allons traiter du comportement des
        collections &agrave; l'ex&eacute;cution.
        </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-taxonomy"></a>19.5.1.&nbsp;Classification</h3></div></div><div></div></div><p>Hibernate d&eacute;finit trois types de collections :</p><div class="itemizedlist"><ul type="disc"><li><p>les collections de valeurs</p></li><li><p>les associations un-vers-plusieurs</p></li><li><p>les associations plusieurs-vers-plusieurs</p></li></ul></div><p>
                Cette classification distingue les diff&eacute;rentes relations entre les tables
        et les cl&eacute;s &eacute;trang&egrave;res mais ne nous apprend rien de ce que nous devons savoir
        sur le mod&egrave;le relationnel. Pour comprendre parfaitement la structure relationnelle
        et les caract&eacute;ristiques des performances, nous devons consid&eacute;rer la structure
        de la cl&eacute; primaire qui est utilis&eacute;e par Hibernate pour mettre &agrave; jour ou supprimer
        les &eacute;l&eacute;ments des collections. Cel&agrave; nous am&egrave;ne aux classifications suivantes :
            </p><div class="itemizedlist"><ul type="disc"><li><p>collections index&eacute;es</p></li><li><p>sets</p></li><li><p>bags</p></li></ul></div><p>
                Toutes les collections index&eacute;es (maps, lists, arrays) ont une cl&eacute; primaire constitu&eacute;e 
        des colonnes cl&eacute; (<tt class="literal">&lt;key&gt;</tt>) et <tt class="literal">&lt;index&gt;</tt>.
        Avec ce type de cl&eacute; primaire, la mise &agrave; jour de collection est en g&eacute;n&eacute;ral tr&egrave;s performante - la cl&eacute;
        primaire peut &ecirc;tre index&eacute;es efficacement et un &eacute;l&eacute;ment particulier peut &ecirc;tre 
        localis&eacute; efficacement lorsqu'Hibernate essaie de le mettre &agrave; jour ou de le supprimer.
            </p><p>
              Les Sets ont une cl&eacute; primaire compos&eacute;e de <tt class="literal">&lt;key&gt;</tt> et des
              colonnes repr&eacute;sentant l'&eacute;l&eacute;ment. Elle est donc moins efficace pour certains 
              types de collections d'&eacute;l&eacute;ments, en particulier les &eacute;l&eacute;ments composites, 
              les textes volumineux ou les champs binaires ; la base de donn&eacute;es
                  peut ne pas &ecirc;tre capable d'indexer aussi efficacement une cl&eacute; primaire 
              aussi complexe. Cependant, pour les associations un-vers-plusieurs 
              ou plusieurs-vers-plusieurs, sp&eacute;cialement lorsque l'on utilise des entit&eacute;s
              ayant des identifiants techniques, il est probable que cela soit aussi efficace
                  (note : si vous voulez que <tt class="literal">SchemaExport</tt> cr&eacute;&eacute; effectivement
              la cl&eacute; primaire   d'un <tt class="literal">&lt;set&gt;</tt> pour vous, vous devez 
              d&eacute;clarer toutes les colonnes avec <tt class="literal">not-null="true"</tt>).
            </p><p>
              Le mapping &agrave; l'aide d'<tt class="literal">&lt;idbag&gt;</tt> d&eacute;finit une cl&eacute;
              de substitution ce qui leur permet d'&ecirc;tre tr&egrave;s efficaces lors de la
              mise &agrave; jour. En fait il s'agit du meilleur cas de mise &agrave; jour d'une collection
            </p><p>
              Le pire cas intervient pour les Bags. Dans la mesure o&ugrave; un bag permet 
              la duplications des &eacute;l&eacute;ments et n'a pas de colonne d'index, aucune cl&eacute; primaire 
              ne peut &ecirc;tre d&eacute;finie. Hibernate   n'a aucun moyen de distinguer des enregistrements 
              dupliqu&eacute;s. Hibernate r&eacute;sout ce probl&egrave;me en supprimant compl&egrave;tement les 
              enregistrements (via un simple <tt class="literal">DELETE</tt>), puis en recr&eacute;ant
                  la collection chaque fois qu'elle change. Ce qui peut &ecirc;tre tr&egrave;s inefficace.
            </p><p>
              Notez que pour une relation un-vers-plusieurs, la "cl&eacute; primaire" 
              peut ne pas &ecirc;tre la cl&eacute;   primaire de la table en base de donn&eacute;es - 
              mais m&ecirc;me dans ce cas, la classification ci-dessus reste utile 
              (Elle explique comment Hibernate "localise" chaque enregistrement
                  de la collection).
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-mostefficientupdate"></a>19.5.2.&nbsp;Les lists, les maps, les idbags et les sets sont les collections les plus efficaces pour la mise &agrave; jour</h3></div></div><div></div></div><p>
              La discussion pr&eacute;c&eacute;dente montre clairement que les collections index&eacute;es 
              et (la plupart du temps) les sets, permettent de r&eacute;aliser le plus efficacement 
              les op&eacute;rations d'ajout, de suppression ou de modification d'&eacute;l&eacute;ments.     
            </p><p>
              Il existe un autre avantage qu'ont les collections index&eacute;es sur les Sets 
                  dans le cadre d'une association plusieurs vers plusieurs ou d'une collection de valeurs.
                  A cause de la structure inh&eacute;rente d'un <tt class="literal">Set</tt>, Hibernate n'effectue jamais  
                  d'<tt class="literal">UPDATE</tt> quand un enregistrement est modifi&eacute;. Les modifications
                  apport&eacute;es &agrave; un <tt class="literal">Set</tt> se font via un <tt class="literal">INSERT</tt> et <tt class="literal">DELETE</tt> 
                  (de chaque enregistrement). Une fois de plus, ce cas ne s'applique pas aux associations
                un vers plusieurs.
            </p><p>
              Apr&egrave;s s'&ecirc;tre rappel&eacute; que les tableaux ne peuvent pas &ecirc;tre charg&eacute;s tardivement,
              nous pouvons conclure que les lists, les maps et les idbags sont les types de collections
              (non invers&eacute;es) les plus performants, avec les sets pas loin derri&egrave;res.
              Les sets son le type de collection le plus courant dans les applications Hibernate. Cela
              est du au fait que la s&eacute;mantique des "set" est la plus naturelle dans le mod&egrave;le
              relationnel.
            </p><p>
                Cependant, dans des mod&egrave;les objet bien con&ccedil;us avec Hibernate, on voit souvent que
                la plupart des collections sont en fait des associations "un-vers-plusieurs" avec
                <tt class="literal">inverse="true"</tt>. Pour ces associations, les mises &agrave; jour sont g&eacute;r&eacute;es
                au niveau de l'association "plusieurs-vers-un" et les consid&eacute;rations de performance de
                mise &agrave; jour des collections ne s'appliquent tout simplement pas dans ces cas l&agrave;.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-mostefficentinverse"></a>19.5.3.&nbsp;Les Bags et les lists sont les plus efficaces pour les collections inverse</h3></div></div><div></div></div><p>
                Avant que vous n'oubliez les bags pour toujours, il y a un cas pr&eacute;cis o&ugrave; les bags 
        (et les lists) sont bien plus performants que les sets. Pour une collection marqu&eacute;e
        comme <tt class="literal">inverse="true"</tt> (le choix le plus courant pour un relation
        un vers plusieurs bidirectionnelle), nous pouvons ajouter des &eacute;l&eacute;ments &agrave; un bag 
        ou une list sans avoir besoin de l'initialiser (fetch) les &eacute;l&eacute;ments du sac! 
        Ceci parce que <tt class="literal">Collection.add()</tt> ou <tt class="literal">Collection.addAll()</tt> 
        doit toujours retourner vrai pour un bag ou une <tt class="literal">List</tt>
        (contrairement au <tt class="literal">Set</tt>). 
        Cela peut rendre le code suivant beaucoup plus rapide.
            </p><pre class="programlisting">Parent p = (Parent) sess.load(Parent.class, id);
    Child c = new Child();
    c.setParent(p);
    p.getChildren().add(c);  //pas besoin de charger la collection !
    sess.flush();</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-oneshotdelete"></a>19.5.4.&nbsp;Suppression en un coup</h3></div></div><div></div></div><p>
                Parfois, effacer les &eacute;l&eacute;ments d'une collection un par un peut &ecirc;tre extr&ecirc;mement inefficace.
        Hibernate n'est pas totalement stupide, il sait qu'il ne faut pas le faire dans le cas d'une
        collection compl&egrave;tement vid&eacute;e (lorsque vous appellez <tt class="literal">list.clear()</tt>, par exemple).
        Dans ce cas, Hibernate fera un simple <tt class="literal">DELETE</tt> et le travail est fait !
            </p><p>
                Supposons que nous ajoutions un &eacute;l&eacute;ment dans une collection de taille vingt et que nous
        enlevions ensuite deux &eacute;l&eacute;ments. Hibernate effectuera un <tt class="literal">INSERT</tt> puis
        deux <tt class="literal">DELETE</tt> (&agrave; moins que la collection ne soit un bag). Ce qui est
        souhaitable.
            </p><p>
                Cependant, supposons que nous enlevions dix huit &eacute;l&eacute;ments, laissant ainsi deux &eacute;l&eacute;ments, puis
        que nous ajoutions trois nouveaux &eacute;l&eacute;ments. Il y a deux moyens de proc&eacute;der.
            </p><div class="itemizedlist"><ul type="disc"><li><p>effacer dix huit enregistrements un &agrave; un puis en ins&eacute;rer trois</p></li><li><p>effacer la totalit&eacute; de la collection (en un <tt class="literal">DELETE</tt> SQL) puis ins&eacute;rer
                les cinq &eacute;l&eacute;ments restant un &agrave; un</p></li></ul></div><p>
                Hibernate n'est pas assez intelligent pour savoir que, dans ce cas, la seconde m&eacute;thode est plus
        rapide (Il plut&ocirc;t heureux qu'Hibernate ne soit pas trop intelligent ; un tel comportement
        pourrait rendre l'utilisation de triggers de bases de donn&eacute;es plut&ocirc;t al&eacute;atoire, etc...).
            </p><p>
                Heureusement, vous pouvez forcer ce comportement lorsque vous le souhaitez, en liberant 
        (c'est-&agrave;-dire en d&eacute;r&eacute;f&eacute;ren&ccedil;ant) la collection initiale et en retournant une collection
        nouvellement instanci&eacute;e avec les &eacute;l&eacute;ments restants. Ceci peut &ecirc;tre tr&egrave;s pratique et 
        tr&egrave;s puissant de temps en temps.
            </p><p>
              Bien s&ucirc;r, la suppression en un coup ne s'applique pas pour les collections qui sont mapp&eacute;es
              avec <tt class="literal">inverse="true"</tt>.
            </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-monitoring"></a>19.6.&nbsp;Moniteur de performance</h2></div></div><div></div></div><p>
          L'optimisation n'est pas d'un grand int&eacute;r&ecirc;t sans le suivi et l'acc&egrave;s aux donn&eacute;es de
          performance. Hibernate fournit toute une panoplie de rapport sur ses op&eacute;rations internes.
          Les statistiques dans Hibernate sont fournies par <tt class="literal">SessionFactory</tt>.
        </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-monitoring-sf"></a>19.6.1.&nbsp;Suivi d'une SessionFactory</h3></div></div><div></div></div><p>
              Vous pouvez acc&eacute;der au m&eacute;triques d'une <tt class="literal">SessionFactory</tt> de deux
              mani&egrave;res. La premi&egrave;re option est d'appeler <tt class="literal">sessionFactory.getStatistics()</tt>
              et de lire ou d'afficher les <tt class="literal">Statistics</tt> vous m&ecirc;me.
            </p><p>
              Hibernate peut &eacute;galement utiliser JMX pour publier les m&eacute;triques si vous activez
              le MBean <tt class="literal">StatisticsService</tt>. Vous pouvez activer un seul MBean
              pour toutes vos <tt class="literal">SessionFactory</tt> ou un par factory. Voici un code
              qui montre un exemple de configuration minimaliste :
            </p><pre class="programlisting">// MBean service registration for a specific SessionFactory
Hashtable tb = new Hashtable();
tb.put("type", "statistics");
tb.put("sessionFactory", "myFinancialApp");
ObjectName on = new ObjectName("hibernate", tb); // MBean object name

StatisticsService stats = new StatisticsService(); // MBean implementation
stats.setSessionFactory(sessionFactory); // Bind the stats to a SessionFactory
server.registerMBean(stats, on); // Register the Mbean on the server</pre><pre class="programlisting">// MBean service registration for all SessionFactory's
Hashtable tb = new Hashtable();
tb.put("type", "statistics");
tb.put("sessionFactory", "all");
ObjectName on = new ObjectName("hibernate", tb); // MBean object name

StatisticsService stats = new StatisticsService(); // MBean implementation
server.registerMBean(stats, on); // Register the MBean on the server</pre><p>
              TODO: Cela n'a pas de sens : dans le premier cs on r&eacute;cup&egrave;re et on utilise le MBean directement.
              Dans le second, on doit fournir le nom JNDI sous lequel est retenu la fabrique de session avant de
              l'utiliser. Pour cela il faut utiliser
                <tt class="literal">hibernateStatsBean.setSessionFactoryJNDIName("my/JNDI/Name")</tt>
            </p><p>
              Vous pouvez (d&eacute;s)activer le suivi pour une <tt class="literal">SessionFactory</tt>
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        au moment de la configuration en mettant <tt class="literal">hibernate.generate_statistics</tt> &agrave; <tt class="literal">false</tt>
                    </p></li></ul></div><div class="itemizedlist"><ul type="disc"><li><p>
                        &agrave; chaud avec <tt class="literal">sf.getStatistics().setStatisticsEnabled(true)</tt>
                        ou <tt class="literal">hibernateStatsBean.setStatisticsEnabled(true)</tt>
                    </p></li></ul></div><p>
              Les statistiques peuvent &ecirc;tre remises &agrave; z&eacute;ro de mani&egrave;re programmatique &agrave; l'aide de la m&eacute;thode
              <tt class="literal">clear()</tt>
              Un r&eacute;sum&eacute; peut &ecirc;tre envoy&eacute; &agrave; un logger (niveau info) &agrave; l'aide de la m&eacute;thode <tt class="literal">logSummary()</tt>
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-monitoring-metrics"></a>19.6.2.&nbsp;M&eacute;triques</h3></div></div><div></div></div><p>
              Hibernate fournit un certain nombre de m&eacute;triques, qui vont des informations tr&egrave;s basiques
              aux informations tr&egrave;s sp&eacute;cialis&eacute;es qui ne sont appropri&eacute;es que dans certains scenarii.
              Tous les compteurs accessibles sont d&eacute;crits dans l'API de l'interface
              <tt class="literal">Statistics</tt> dans trois cat&eacute;gories :
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                      Les m&eacute;triques relatives &agrave; l'usage g&eacute;n&eacute;ral de la <tt class="literal">Session</tt>
                      comme le nombre de sessions ouvertes, le nombre de connexions JDBC r&eacute;cup&eacute;r&eacute;es, etc...
                    </p></li><li><p>
                      Les m&eacute;triques relatives aux entit&eacute;s, collections, requ&ecirc;tes et caches dans
                      leur ensemble (m&eacute;triques globales),
                    </p></li><li><p>
                      Les m&eacute;triques d&eacute;taill&eacute;es relatives &agrave; une entit&eacute;, une collection, une requ&ecirc;te
                      ou une r&eacute;gion de cache particuli&egrave;re.
                    </p></li></ul></div><p>
              Par exemple, vous pouvez v&eacute;rifier l'acc&egrave;s au cache ainsi que le taux d'&eacute;l&eacute;ments manquants et
              de mise &agrave; jour des entit&eacute;s, collections et requ&ecirc;tes et le temps moyen que met une requ&ecirc;te.
              Il faut faire attention au fait que le nombre de millisecondes est sujet &agrave; approximation en
              Java. Hibernate est li&eacute; &agrave; la pr&eacute;cision de la machine virtuelle, sur certaines plateformes,
              cela n'offre qu'une pr&eacute;cision de l'ordre de 10 secondes.
            </p><p>
              Des accesseurs simples sont utilis&eacute;s pour acc&eacute;der aux m&eacute;triques globales (e.g. celles qui ne
              sont pas li&eacute;es &agrave; une entit&eacute;, collection ou r&eacute;gion de cache particuli&egrave;re). Vous pouvez acc&eacute;der
              aux m&eacute;triques d'une entit&eacute;, collection, r&eacute;gion de cache particuli&egrave;re &agrave; l'aide de son nom et &agrave; l'aide
              de sa repr&eacute;sentation HQL ou SQL pour une requ&ecirc;te. R&eacute;f&eacute;rez vous &agrave; la javadoc des APIS 
              <tt class="literal">Statistics</tt>, <tt class="literal">EntityStatistics</tt>,
              <tt class="literal">CollectionStatistics</tt>, <tt class="literal">SecondLevelCacheStatistics</tt>,
              and <tt class="literal">QueryStatistics</tt> pour plus d'informations. Le code ci-dessous montre
              un exemple simple :
            </p><pre class="programlisting">Statistics stats = HibernateUtil.sessionFactory.getStatistics();

double queryCacheHitCount  = stats.getQueryCacheHitCount();
double queryCacheMissCount = stats.getQueryCacheMissCount();
double queryCacheHitRatio =
  queryCacheHitCount / (queryCacheHitCount + queryCacheMissCount);

log.info("Query Hit ratio:" + queryCacheHitRatio);

EntityStatistics entityStats =
  stats.getEntityStatistics( Cat.class.getName() );
long changes =
        entityStats.getInsertCount()
        + entityStats.getUpdateCount()
        + entityStats.getDeleteCount();
log.info(Cat.class.getName() + " changed " + changes + "times"  );</pre><p>
              Pour travailler sur toutes les entit&eacute;s, collections, requ&ecirc;tes et r&eacute;gions de cache, vous pouvez
              r&eacute;cup&eacute;rer la liste des noms des entit&eacute;s, collections, requ&ecirc;tes et r&eacute;gions de cache avec les
              m&eacute;thodes : <tt class="literal">getQueries()</tt>, <tt class="literal">getEntityNames()</tt>,
                <tt class="literal">getCollectionRoleNames()</tt>, et
                <tt class="literal">getSecondLevelCacheRegionNames()</tt>.
            </p></div></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="toolsetguide"></a>Chapitre&nbsp;20.&nbsp;Guide des outils</h2></div></div><div></div></div><p>
        Des outils en ligne de commande, des plugins Eclipse ainsu que des t&acirc;ches Ant permettent de g&eacute;rer de cycles de d&eacute;veloppement complet
    de projets utilisant Hibernate.
    </p><p>
        Les <span class="emphasis"><em>outils Hibernate</em></span> actuels incluent des plugins pour l'IDE Eclipse ainsi que des t&acirc;ches Ant pour l'ing&eacute;nierie 
        inverse de bases de donn&eacute;es existantes :
    </p><div class="itemizedlist"><ul type="disc"><li><p>
            <span class="emphasis"><em>Mapping Editor :</em></span> un &eacute;diteur pour les fichiers de mapping XML Hibernate, supportant l'auto-compl&eacute;tion et la mise en valeur de la syntaxe.
            Il supporte aussi l'auto-compl&eacute;tion automatique pour les noms de classes et les noms de propri&eacute;t&eacute;/champ,
            le rendant beaucoup plus polyvalent qu'un &eacute;diteurXML normal.
        </p></li><li><p>
            <span class="emphasis"><em>Console :</em></span> la console est une nouvelle vue d'Eclipse. En plus de la vue d'ensemble
            arborescente de vos configurations de console, vous obtenez aussi une vue interactive de vos classes persistantes et de leurs relations.
            La console vous permet d'ex&eacute;cuter des requ&ecirc;te HQL dans votre base de donn&eacute;es et de parcourir les r&eacute;sultats directement dans Eclipse.
        </p></li><li><p>
            <span class="emphasis"><em>Development Wizards :</em></span> plusieurs assistants sont fournis avec les outils d'Hibernate
            pour Eclipse ; vous pouvez utiliser un assistant pour g&eacute;n&eacute;rer rapidement les fichiers de configuration d'Hibernate (cfg.xml),
            ou vous pouvez m&ecirc;me compl&egrave;tement g&eacute;n&eacute;rer les fichiers de mapping Hibernate et les sources des POJOs &agrave; partir d'un sch&eacute;ma de base de donn&eacute;es existant.
            L'assistant d'ing&eacute;nierie inverse supporte les mod&egrave;les utilisateur.
        </p></li><li><p>
            <span class="emphasis"><em>T&acirc;ches Ant :</em></span>
        </p></li></ul></div><p>
        Veuillez-vous r&eacute;f&eacute;rer au paquet <span class="emphasis"><em>outils Hibernate</em></span> et sa documentation pour plus d'informations.
    </p><p>
        Pourtant, le paquet principal d'Hibernate arrive avec un lot d'outils int&eacute;gr&eacute;s (il peut m&ecirc;me &ecirc;tre utilis&eacute; de "l'int&eacute;rieur" d'Hibernate &agrave; la vol&eacute;e) :
        <span class="emphasis"><em>SchemaExport</em></span> aussi connu comme
        <tt class="literal">hbm2ddl</tt>.
    </p><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="toolsetguide-s1"></a>20.1.&nbsp;G&eacute;n&eacute;ration automatique du sch&eacute;ma</h2></div></div><div></div></div><p>
            La DDL peut &ecirc;tre g&eacute;n&eacute;r&eacute;e &agrave; partir de vos fichiers de mapping par un utilitaire d'Hibernate. Le sch&eacute;ma g&eacute;n&eacute;r&eacute;
            inclut les contraintes d'int&eacute;grit&eacute; r&eacute;f&eacute;rentielle (clefs primaires et &eacute;trang&egrave;res) pour les tables d'entit&eacute;s
            et de collections. Les tables et les s&eacute;quences sont aussi cr&eacute;&eacute;es pour les g&eacute;n&eacute;rateurs d'identifiant mapp&eacute;s.
        </p><p>
            Vous <span class="emphasis"><em>devez</em></span> sp&eacute;cifier un <tt class="literal">Dialect</tt> SQL via la propri&eacute;t&eacute;
            <tt class="literal">hibernate.dialect</tt> lors de l'utilisation de cet outils, puisque la DDL est
            fortement d&eacute;pendante de la base de donn&eacute;es.
        </p><p>
            D'abord, personnalisez vos fichiers de mapping pour am&eacute;liorer le sch&eacute;ma g&eacute;n&eacute;r&eacute;.
        </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-2"></a>20.1.1.&nbsp;Personnaliser le sch&eacute;ma</h3></div></div><div></div></div><p>
                Plusieurs &eacute;l&eacute;ments du mapping hibernate d&eacute;finissent des attributs optionnels
                nomm&eacute;s <tt class="literal">length</tt>, <tt class="literal">precision</tt> et <tt class="literal">scale</tt>.
                Vous pouvez param&eacute;trer la longueur, la pr&eacute;cision,...  d'une colonne avec ces attributs.
            </p><pre class="programlisting">&lt;property name="zip" length="5"/&gt;</pre><pre class="programlisting">&lt;property name="balance" precision="12" scale="2"/&gt;</pre><p>
                Certains &eacute;l&eacute;ments acceptent aussi un attribut <tt class="literal">not-null</tt>
                (utilis&eacute; pour g&eacute;n&eacute;rer les contraintes de colonnes <tt class="literal">NOT NULL</tt>) et
                un attribut <tt class="literal">unique</tt> (pour g&eacute;n&eacute;rer une contrainte de colonne
                <tt class="literal">UNIQUE</tt>).
            </p><pre class="programlisting">&lt;many-to-one name="bar" column="barId" not-null="true"/&gt;</pre><pre class="programlisting">&lt;element column="serialNumber" type="long" not-null="true" unique="true"/&gt;</pre><p>
                Un attribut <tt class="literal">unique-key</tt> peut &ecirc;tre utilis&eacute; pour grouper les colonnes
                en une seule contrainte d'unicit&eacute;. Actuellement, la valeur sp&eacute;cifi&eacute;e par
                l'attribut <tt class="literal">unique-key</tt> n'est <span class="emphasis"><em>pas</em></span> utilis&eacute;e pour
                nommer la contrainte dans le DDL g&eacute;n&eacute;r&eacute;, elle sert juste &agrave; grouper les colonnes
                dans le fichier de mapping.
            </p><pre class="programlisting">&lt;many-to-one name="org" column="orgId" unique-key="OrgEmployeeId"/&gt;
            &lt;property name="employeeId" unique-key="OrgEmployee"/&gt;</pre><p>
                Un attribut <tt class="literal">index</tt> indique le nom d'un index qui sera
                cr&eacute;&eacute;  en utilisant la ou les colonnes mapp&eacute;es. Plusieurs colonnes
                peuvent &ecirc;tre group&eacute;es dans un m&ecirc;me index, en sp&eacute;cifiant le m&ecirc;me
                nom d'index. 
            </p><pre class="programlisting">&lt;property name="lastName" index="CustName"/&gt;
&lt;property name="firstName" index="CustName"/&gt;</pre><p>
                Un attribut <tt class="literal">foreign-key</tt> peut &ecirc;tre utilis&eacute; pour surcharger le nom
                des cl&eacute;s &eacute;trang&egrave;res g&eacute;n&eacute;r&eacute;es.
            </p><pre class="programlisting">&lt;many-to-one name="bar" column="barId" foreign-key="FKFooBar"/&gt;</pre><p>
                Plusieurs &eacute;l&eacute;ments de mapping acceptent aussi un &eacute;l&eacute;ment fils <tt class="literal">&lt;column&gt;</tt>. 
                Ceci est utile pour les type multi-colonnes:
            </p><pre class="programlisting">&lt;property name="name" type="my.customtypes.Name"/&gt;
    &lt;column name="last" not-null="true" index="bar_idx" length="30"/&gt;
    &lt;column name="first" not-null="true" index="bar_idx" length="20"/&gt;
    &lt;column name="initial"/&gt;
&lt;/property&gt;</pre><p>
                L'attribut <tt class="literal">default</tt> vous laisse sp&eacute;cifier une valeur par d&eacute;faut pour
                une colonnes (vous devriez assigner la m&ecirc;me valeur &agrave; la propri&eacute;t&eacute; mapp&eacute;e avant de sauvegarder une nouvelle instance
                de la classe mapp&eacute;e).
            </p><pre class="programlisting">&lt;property name="credits" type="integer" insert="false"&gt;
    &lt;column name="credits" default="10"/&gt;
&lt;/property&gt;</pre><pre class="programlisting">&lt;version name="version" type="integer" insert="false"&gt;
    &lt;column name="version" default="0"/&gt;
&lt;/property&gt;</pre><p>
                L'attribut <tt class="literal">sql-type</tt> laisse l'utilisateur surcharger le mapping
                par d&eacute;faut du type Hibernate vers un type SQL.
            </p><pre class="programlisting">&lt;property name="balance" type="float"&gt;
    &lt;column name="balance" sql-type="decimal(13,3)"/&gt;
&lt;/property&gt;</pre><p>
                L'attribut <tt class="literal">check</tt> permet de sp&eacute;cifier une contrainte de v&eacute;rification.
            </p><pre class="programlisting">&lt;property name="foo" type="integer"&gt;
    &lt;column name="foo" check="foo &gt; 10"/&gt;
&lt;/property&gt;</pre><pre class="programlisting">&lt;class name="Foo" table="foos" check="bar &lt; 100.0"&gt;
    ...
    &lt;property name="bar" type="float"/&gt;
&lt;/class&gt;</pre><div class="table"><a name="schemattributes-summary"></a><p class="title"><b>Tableau&nbsp;20.1.&nbsp;Summary</b></p><table summary="Summary" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Attribut</th><th>Valeur</th><th>Interpr&eacute;tation</th></tr></thead><tbody><tr><td><tt class="literal">length</tt></td><td>num&eacute;rique</td><td>taille d'une colonne</td></tr><tr><td><tt class="literal">precision</tt></td><td>num&eacute;rique</td><td>pr&eacute;cision d&eacute;cimale de la colonne</td></tr><tr><td><tt class="literal">scale</tt></td><td>num&eacute;rique</td><td>scale d&eacute;cimale de la colonne</td></tr><tr><td><tt class="literal">not-null</tt></td><td><tt class="literal">true|false</tt></td><td>sp&eacute;cifie que la colonne doit &ecirc;tre non-nulle</td></tr><tr><td><tt class="literal">unique</tt></td><td><tt class="literal">true|false</tt></td><td>sp&eacute;cifie que la colonne doit avoir une contrainte d'unicit&eacute;</td></tr><tr><td><tt class="literal">index</tt></td><td><tt class="literal">index_name</tt></td><td>sp&eacute;cifie le nom d'un index (multi-colonnes)</td></tr><tr><td><tt class="literal">unique-key</tt></td><td><tt class="literal">unique_key_name</tt></td><td>sp&eacute;cifie le nom d'une contrainte d'unicit&eacute; multi-colonnes</td></tr><tr><td><tt class="literal">foreign-key</tt></td><td><tt class="literal">foreign_key_name</tt></td><td>
                                sp&eacute;cifie le nom d'une contrainte de cl&eacute; &eacute;trang&egrave;re g&eacute;n&eacute;r&eacute;e pour
                                une association, utilisez-la avec les &eacute;l&eacute;ments de mapping
                                &lt;one-to-one&gt;, &lt;many-to-one&gt;, &lt;key&gt;, et &lt;many-to-many&gt;
                                Notez que les extr&ecirc;mit&eacute;s <tt class="literal">inverse="true"</tt>
                                se seront pas prises en compte par <tt class="literal">SchemaExport</tt>.
                            </td></tr><tr><td><tt class="literal">sql-type</tt></td><td><tt class="literal">SQL column_type</tt></td><td>
                                surcharge le type par d&eacute;faut (attribut de
                                l'&eacute;l&eacute;ment <tt class="literal">&lt;column&gt;</tt> uniquement)
                            </td></tr><tr><td><tt class="literal">default</tt></td><td>expression SQL</td><td>
                                sp&eacute;cifie une valeur par d&eacute;faut pour la colonne
                            </td></tr><tr><td><tt class="literal">check</tt></td><td>SQL expression</td><td>
                                cr&eacute;e une contrainte de v&eacute;rification sur la table ou la colonne
                            </td></tr></tbody></table></div><p>
                L'&eacute;l&eacute;ment <tt class="literal">&lt;comment&gt;</tt> vous permet de sp&eacute;cifier un commentaire pour le sch&eacute;ma g&eacute;n&eacute;r&eacute;.
            </p><pre class="programlisting">&lt;class name="Customer" table="CurCust"&gt;
    &lt;comment&gt;Current customers only&lt;/comment&gt;
    ...
&lt;/class&gt;</pre><pre class="programlisting">&lt;property name="balance"&gt;
    &lt;column name="bal"&gt;
        &lt;comment&gt;Balance in USD&lt;/comment&gt;
    &lt;/column&gt;
&lt;/property&gt;</pre><p>
                Ceci a pour r&eacute;sultat une expression
                <tt class="literal">comment on table</tt> ou
                <tt class="literal">comment on column</tt> dans la DDL g&eacute;n&eacute;r&eacute;e (o&ugrave; support&eacute;e).
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-3"></a>20.1.2.&nbsp;Ex&eacute;cuter l'outil</h3></div></div><div></div></div><p>
                L'outil <tt class="literal">SchemaExport</tt> g&eacute;n&egrave;re un script DDL vers
                la sortie standard et/ou ex&eacute;cute les ordres DDL.
            </p><p>
                <tt class="literal">java -cp </tt><span class="emphasis"><em>classpath_hibernate</em></span>
                <tt class="literal">net.sf.hibernate.tool.hbm2ddl.SchemaExport</tt> <span class="emphasis"><em>options fichiers_de_mapping</em></span>
            </p><div class="table"><a name="d0e14843"></a><p class="title"><b>Tableau&nbsp;20.2.&nbsp;<tt class="literal">SchemaExport</tt> Options de la ligne de commande</b></p><table summary="SchemaExport Options de la ligne de commande" border="1"><colgroup><col><col></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">--quiet</tt></td><td>ne pas &eacute;crire le script vers la sortie standard</td></tr><tr><td><tt class="literal">--drop</tt></td><td>supprime seuleument les tables</td></tr><tr><td><tt class="literal">--create</tt></td><td>ne cr&eacute;&eacute; que les tables</td></tr><tr><td><tt class="literal">--text</tt></td><td>ne pas ex&eacute;cuter sur la base de donn&eacute;es</td></tr><tr><td><tt class="literal">--output=my_schema.ddl</tt></td><td>&eacute;crit le script ddl vers un fichier</td></tr><tr><td><tt class="literal">--naming=eg.MyNamingStrategy</tt></td><td>s&eacute;lectionne une <tt class="literal">NamingStrategy</tt></td></tr><tr><td><tt class="literal">--config=hibernate.cfg.xml</tt></td><td>lit la configuration Hibernate &agrave; partir d'un fichier XML</td></tr><tr><td><tt class="literal">--properties=hibernate.properties</tt></td><td>lit les propri&eacute;t&eacute;s de la base de donn&eacute;es &agrave; partir d'un fichier</td></tr><tr><td><tt class="literal">--format</tt></td><td>formatte proprement le SQL g&eacute;n&eacute;r&eacute; dans le script</td></tr><tr><td><tt class="literal">--delimiter=x</tt></td><td>param&egrave;tre un d&eacute;limiteur de fin de ligne pour le script</td></tr></tbody></table></div><p>
                Vous pouvez m&ecirc;me int&eacute;grer <tt class="literal">SchemaExport</tt> dans votre application :
            </p><pre class="programlisting">Configuration cfg = ....;
new SchemaExport(cfg).create(false, true);</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-4"></a>20.1.3.&nbsp;Propri&eacute;t&eacute;s</h3></div></div><div></div></div><p>
                Les propri&eacute;t&eacute;s de la base de donn&eacute;es peuvent &ecirc;tre sp&eacute;cifi&eacute;es
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>comme propri&eacute;t&eacute;s syst&egrave;me avec <tt class="literal">-D</tt><span class="emphasis"><em>&lt;property&gt;</em></span></p></li><li><p>dans <tt class="literal">hibernate.properties</tt></p></li><li><p>dans un fichier de propri&eacute;t&eacute;s d&eacute;clar&eacute; avec <tt class="literal">--properties</tt></p></li></ul></div><p>
                Les propri&eacute;t&eacute;s n&eacute;cessaires sont :
            </p><div class="table"><a name="d0e14952"></a><p class="title"><b>Tableau&nbsp;20.3.&nbsp;SchemaExport Connection Properties</b></p><table summary="SchemaExport Connection Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Nom de la propri&eacute;t&eacute;</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.connection.driver_class</tt></td><td>classe du driver JDBC</td></tr><tr><td><tt class="literal">hibernate.connection.url</tt></td><td>URL JDBC</td></tr><tr><td><tt class="literal">hibernate.connection.username</tt></td><td>utilisateur de la base de donn&eacute;es</td></tr><tr><td><tt class="literal">hibernate.connection.password</tt></td><td>mot de passe de l'utilisateur</td></tr><tr><td><tt class="literal">hibernate.dialect</tt></td><td>dialecte</td></tr></tbody></table></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-5"></a>20.1.4.&nbsp;Utiliser Ant</h3></div></div><div></div></div><p>
                Vous pouvez appeler <tt class="literal">SchemaExport</tt> depuis votre script
                de construction Ant :
            </p><pre class="programlisting">&lt;target name="schemaexport"&gt;
    &lt;taskdef name="schemaexport"
        classname="org.hibernate.tool.hbm2ddl.SchemaExportTask"
        classpathref="class.path"/&gt;

    &lt;schemaexport
        properties="hibernate.properties"
        quiet="no"
        text="no"
        drop="no"
        delimiter=";"
        output="schema-export.sql"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemaexport&gt;
&lt;/target&gt;</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-6"></a>20.1.5.&nbsp;Mises &agrave; jour incr&eacute;mentales du sch&eacute;ma</h3></div></div><div></div></div><p>
                L'outil <tt class="literal">SchemaUpdate</tt> mettra &agrave; jour un sch&eacute;ma existant
                en effectuant les changement par "incr&eacute;ment".
                Notez que <tt class="literal">SchemaUpdate</tt> d&eacute;pends beaucoup de l'API JDBC
                metadata, il ne fonctionnera donc pas avec tous les drivers JDBC.
            </p><p>
                <tt class="literal">java -cp </tt><span class="emphasis"><em>classpath_hibernate</em></span>
                <tt class="literal">net.sf.hibernate.tool.hbm2ddl.SchemaUpdate</tt> <span class="emphasis"><em>options fichiers_de_mapping</em></span>
            </p><div class="table"><a name="d0e15029"></a><p class="title"><b>Tableau&nbsp;20.4.&nbsp;<tt class="literal">SchemaUpdate</tt> Options de ligne de commande</b></p><table summary="SchemaUpdate Options de ligne de commande" border="1"><colgroup><col><col></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">--quiet</tt></td><td>ne pas &eacute;crire vers la sortie standard</td></tr><tr><td><tt class="literal">--text</tt></td><td>ne pas exporter vers la base de donn&eacute;es</td></tr><tr><td><tt class="literal">--naming=eg.MyNamingStrategy</tt></td><td>choisit une <tt class="literal">NamingStrategy</tt></td></tr><tr><td><tt class="literal">--properties=hibernate.properties</tt></td><td>lire les propri&eacute;t&eacute;s de la base de donn&eacute;es &agrave; partir d'un fichier</td></tr></tbody></table></div><p>
                Vous pouvez int&eacute;grer <tt class="literal">SchemaUpdate</tt> dans votre application :
            </p><pre class="programlisting">Configuration cfg = ....;
new SchemaUpdate(cfg).execute(false);</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-7"></a>20.1.6.&nbsp;Utiliser Ant pour des mises &agrave; jour de sch&eacute;ma par incr&eacute;ment</h3></div></div><div></div></div><p>
                Vous pouvez appeler <tt class="literal">SchemaUpdate</tt> depuis le script Ant :
            </p><pre class="programlisting">&lt;target name="schemaupdate"&gt;
    &lt;taskdef name="schemaupdate"
        classname="org.hibernate.tool.hbm2ddl.SchemaUpdateTask"
        classpathref="class.path"/&gt;

    &lt;schemaupdate
        properties="hibernate.properties"
        quiet="no"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemaupdate&gt;
&lt;/target&gt;</pre><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-8"></a>20.1.6.1.&nbsp;Validation du sch&eacute;ma</h3></div></div><div></div></div><p>
                L'outil <tt class="literal">SchemaValidator</tt> validera que le sch&eacute;ma existant correspond &agrave; vos documents de mapping.
                Notez que le <tt class="literal">SchemaValidator</tt> d&eacute;pends de l'API metadata de JDBC, il ne fonctionnera
                donc pas avec tous les drivers JDBC. Cet outil est extr&ecirc;mement utile pour tester.
            </p><p>
                <tt class="literal">java -cp </tt><span class="emphasis"><em>hibernate_classpaths</em></span>
                <tt class="literal">org.hibernate.tool.hbm2ddl.SchemaValidator</tt> <span class="emphasis"><em>options mapping_files</em></span>
            </p><div class="table"><a name="d0e15111"></a><p class="title"><b>Tableau&nbsp;20.5.&nbsp;<tt class="literal">SchemaValidator</tt> Options de ligne de commande</b></p><table summary="SchemaValidator Options de ligne de commande" border="1"><colgroup><col><col></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">--naming=eg.MyNamingStrategy</tt></td><td>Indique une <tt class="literal">NamingStrategy</tt></td></tr><tr><td><tt class="literal">--properties=hibernate.properties</tt></td><td>lit les propri&eacute;t&eacute;s dela base de donn&eacute;es depuis un fichier de propri&eacute;t&eacute;s</td></tr><tr><td><tt class="literal">--config=hibernate.cfg.xml</tt></td><td>indique un fichier <tt class="literal">.cfg.xml</tt></td></tr></tbody></table></div><p>
                Vous pouvez inclure <tt class="literal">SchemaValidator</tt> dans votre application:
            </p><pre class="programlisting">Configuration cfg = ....;
new SchemaValidator(cfg).validate();</pre></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-9"></a>20.1.7.&nbsp;Utiliser Ant pour la validation du Sch&eacute;ma</h3></div></div><div></div></div><p>
                Vous pouvez appeler <tt class="literal">SchemaValidator</tt> depuis le script Ant:
            </p><pre class="programlisting">&lt;target name="schemavalidate"&gt;
    &lt;taskdef name="schemavalidator"
        classname="org.hibernate.tool.hbm2ddl.SchemaValidatorTask"
        classpathref="class.path"/&gt;
    
    &lt;schemavalidator
        properties="hibernate.properties"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemaupdate&gt;
&lt;/target&gt;</pre></div></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="example-parentchild"></a>Chapitre&nbsp;21.&nbsp;Exemple : P&egrave;re/Fils</h2></div></div><div></div></div><p>
        L'une des premi&egrave;res choses que les nouveaux utilisateurs essaient de faire avec Hibernate est de mod&eacute;liser
        une relation p&egrave;re/fils. Il y a deux approches diff&eacute;rentes pour cela. Pour un certain nombre de raisons, la m&eacute;thode la
        plus courante, en particulier pour les nouveaux utilisateurs, est de mod&eacute;liser les deux relations <tt class="literal">P&egrave;re</tt>
        et <tt class="literal">Fils</tt> comme des classes entit&eacute;s li&eacute;es par une association <tt class="literal">&lt;one-to-many&gt;</tt> du
        <tt class="literal">P&egrave;re</tt> vers le <tt class="literal">Fils</tt> (l'autre approche est de d&eacute;clarer le <tt class="literal">Fils</tt>
        comme un <tt class="literal">&lt;composite-element&gt;</tt>). Il est &eacute;vident que le sens de l'association un vers plusieurs
        (dans Hibernate) est bien moins proche du sens habituel d'une relation p&egrave;re/fils que ne l'est celui d'un
        &eacute;l&eacute;ment cmposite. Nous allons vous expliquer comment utiliser une association <span class="emphasis"><em>un vers plusieurs bidirectionnelle
        avec cascade</em></span> afin de mod&eacute;liser efficacement et &eacute;l&eacute;gamment une relation p&egrave;re/fils, ce n'est vraiment
        pas difficile !
    </p><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-collections"></a>21.1.&nbsp;Une note &agrave; propos des collections</h2></div></div><div></div></div><p>
            Les collections Hibernate sont consid&eacute;r&eacute;es comme &eacute;tant une partie logique
            de l'entit&eacute; dans laquelle elles sont contenues ; jamais des entit&eacute;s qu'elle
            contient. C'est une distinction crutiale ! Les cons&eacute;quences sont les suivantes :
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    Quand nous ajoutons / retirons un objet d'une collection, le num&eacute;ro de version du
                    propri&eacute;taire de la collection est incr&eacute;ment&eacute;.
                </p></li><li><p>
                    Si un objet qui a &eacute;t&eacute; enlev&eacute; d'une collection est une instance de type valeur (ex :
                    &eacute;l&eacute;ment composite), cet objet cessera d'&ecirc;tre persistant et son &eacute;tat sera compl&egrave;tement effac&eacute;
                    de la base de donn&eacute;es. Par ailleurs, ajouter une instance de type valeur dans une collection
                    aura pour cons&eacute;quence que son &eacute;tat sera imm&eacute;diatement persistant.
                </p></li><li><p>
                    Si une entit&eacute; est enlev&eacute;e d'une collection (association un-vers-plusieurs
                    ou plusieurs-vers-plusieurs), par d&eacute;faut, elle ne sera pas effac&eacute;e. Ce comportement
                    est compl&egrave;tement logique - une modification de l'un des &eacute;tats internes d'une entit&eacute;
                    ne doit pas causer la disparition de l'entit&eacute; associ&eacute;e !
                    De m&ecirc;me, l'ajout d'une entit&eacute; dans une collection n'engendre pas,
                    par d&eacute;faut, la persistence de cette entit&eacute;.
                </p></li></ul></div><p>
            Le comportement par d&eacute;faut est donc que l'ajout d'une entit&eacute; dans une collection cr&eacute;&eacute;
            simplement le lien entre les deux entit&eacute;s, et qu'effacer une entit&eacute; supprime ce lien.
            C'est le comportement le plus appropri&eacute; dans la plupart des cas. Ce comportement n'est
            cependant pas appropri&eacute; lorsque la vie du fils est li&eacute;e au cycle de vie du p&egrave;re.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-bidir"></a>21.2.&nbsp;un-vers-plusieurs bidirectionnel</h2></div></div><div></div></div><p>
            Supposons que nous ayons une simple association <tt class="literal">&lt;one-to-many&gt;</tt>
            de <tt class="literal">Parent</tt> vers <tt class="literal">Child</tt>.
        </p><pre class="programlisting">&lt;set name="children"&gt;
                &lt;key column="parent_id"/&gt;
                &lt;one-to-many class="Child"/&gt;
            &lt;/set&gt;</pre><p>
            Si nous executions le code suivant
        </p><pre class="programlisting">Parent p = .....;
Child c = new Child();
p.getChildren().add(c);
session.save(c);
session.flush();</pre><p>
            Hibernate ex&eacute;cuterait deux ordres SQL:
        </p><div class="itemizedlist"><ul type="disc"><li><p>un <tt class="literal">INSERT</tt> pour cr&eacute;er l'enregistrement pour <tt class="literal">c</tt></p></li><li><p>
                    un <tt class="literal">UPDATE</tt> pour cr&eacute;er le lien de <tt class="literal">p</tt> vers
                    <tt class="literal">c</tt>
                </p></li></ul></div><p>
            Ceci est non seuleument inefficace, mais viole aussi toute contrainte <tt class="literal">NOT NULL</tt> sur
            la colonne <tt class="literal">parent_id</tt>. Nous pouvons r&eacute;parer la contrainte de nullit&eacute;
            en sp&eacute;cifiant <tt class="literal">not-null="true"</tt> dans le mapping de la collection :
        </p><pre class="programlisting">&lt;set name="children"&gt;
    &lt;key column="parent_id" not-null="true"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
            Cependant ce n'est pas la solution recommand&eacute;e.
        </p><p>
            La cause sous jacente &agrave; ce comportement est que le lien (la cl&eacute; &eacute;trang&egrave;re <tt class="literal">parent_id</tt>) de
            <tt class="literal">p</tt> vers <tt class="literal">c</tt> n'est pas consid&eacute;r&eacute;e comme faisant partie de l'&eacute;tat
            de l'objet <tt class="literal">Child</tt> et n'est donc pas cr&eacute;&eacute; par l'<tt class="literal">INSERT</tt>.
            La solution est donc que ce lien fasse partie du mapping de <tt class="literal">Child</tt>.
        </p><pre class="programlisting">&lt;many-to-one name="parent" column="parent_id" not-null="true"/&gt;</pre><p>
            (Nous avons aussi besoin d'ajouter la propri&eacute;t&eacute; <tt class="literal">parent</tt> dans la classe <tt class="literal">Child</tt>).
        </p><p>
            Maintenant que l'&eacute;tat du lien est g&eacute;r&eacute; par l'entit&eacute; <tt class="literal">Child</tt>, nous sp&eacute;cifions &agrave; la
            collection de ne pas mettre &agrave; jour le lien. Nous utilisons l'attribut <tt class="literal">inverse</tt>.
        </p><pre class="programlisting">&lt;set name="children" inverse="true"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
            Le code suivant serait utilis&eacute; pour ajouter un nouveau <tt class="literal">Child</tt>
        </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
c.setParent(p);
p.getChildren().add(c);
session.save(c);
session.flush();</pre><p>
            Maintenant, seul un <tt class="literal">INSERT</tt> SQL est n&eacute;cessaire !
        </p><p>
            Pour all&eacute;ger encore un peu les choses, nous devrions cr&eacute;er une m&eacute;thode <tt class="literal">addChild()</tt>
            dans <tt class="literal">Parent</tt>.
        </p><pre class="programlisting">public void addChild(Child c) {
    c.setParent(this);
    children.add(c);
}</pre><p>
            Le code d'ajout d'un <tt class="literal">Child</tt> serait alors
        </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
p.addChild(c);
session.save(c);
session.flush();</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-cascades"></a>21.3.&nbsp;Cycle de vie en cascade</h2></div></div><div></div></div><p>
            L'appel explicite de <tt class="literal">save()</tt> est un peu fastidieux. Nous pouvons
            simplifier cela en utilisant les cascades.
        </p><pre class="programlisting">&lt;set name="children" inverse="true" cascade="all"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
            Simplifie le code pr&eacute;c&eacute;dent en
        </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
p.addChild(c);
session.flush();</pre><p>
            De la m&ecirc;me mani&egrave;re, nous n'avons pas &agrave; it&eacute;rer sur les fils lorsque nous sauvons
            ou effacons un <tt class="literal">Parent</tt>. Le code suivant efface <tt class="literal">p</tt>
            et tous ses fils de la base de donn&eacute;es.
        </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
session.delete(p);
session.flush();</pre><p>
             Par contre, ce code
         </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = (Child) p.getChildren().iterator().next();
p.getChildren().remove(c);
c.setParent(null);
session.flush();</pre><p>
             n'effacera pas <tt class="literal">c</tt> de la base de donn&eacute;es, il enl&egrave;vera seulement
             le lien vers  <tt class="literal">p</tt> (et causera une violation de contrainte
             <tt class="literal">NOT NULL</tt>, dans ce cas).
             Vous devez explicitement utiliser <tt class="literal">delete()</tt> sur <tt class="literal">Child</tt>.
         </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = (Child) p.getChildren().iterator().next();
p.getChildren().remove(c);
session.delete(c);
session.flush();</pre><p>
            Dans notre cas, un <tt class="literal">Child</tt> ne peut pas vraiment exister sans son p&egrave;re. Si nous
            effacons un <tt class="literal">Child</tt> de la collection, nous voulons vraiment qu'il soit effac&eacute;.
            Pour cela, nous devons utiliser <tt class="literal">cascade="all-delete-orphan"</tt>.
        </p><pre class="programlisting">&lt;set name="children" inverse="true" cascade="all-delete-orphan"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
            A noter : m&ecirc;me si le mapping de la collection sp&eacute;cifie <tt class="literal">inverse="true"</tt>, les cascades
            sont toujours assur&eacute;es par l'it&eacute;ration sur les &eacute;l&eacute;ments de la collection. Donc, si vous avez besoin
            qu'un objet soit enregistr&eacute;, effac&eacute; ou mis &agrave; jour par cascade, vous devez l'ajouter dans la colleciton.
            Il ne suffit pas d'appeler explicitement <tt class="literal">setParent()</tt>.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-update"></a>21.4.&nbsp;Cascades et <tt class="literal">unsaved-value</tt></h2></div></div><div></div></div><p>
            Supposons que nous ayons charg&eacute; un <tt class="literal">Parent</tt> dans une <tt class="literal">Session</tt>,
            que nous l'ayons ensuite modifi&eacute; et que voulions persiter ces modifications dans une nouvelle session
            en appelant <tt class="literal">update()</tt>.
            Le <tt class="literal">Parent</tt> contiendra une collection de fils et, puisque la cascade est activ&eacute;e,
            Hibernate a besoin de savoir quels fils viennent d'&ecirc;tre instanci&eacute;s et quels fils proviennent de la base
            de donn&eacute;es. Supposons aussi que <tt class="literal">Parent</tt> et <tt class="literal">Child</tt> ont tous deux
            des identifiants du type <tt class="literal">Long</tt>.
            Hibernate utilisera la propri&eacute;t&eacute; de l'identifiant et la propri&eacute;t&eacute; de la version/horodatage pour d&eacute;terminer quels fils sont nouveaux
            (vous pouvez aussi utiliser la propri&eacute;t&eacute; version ou timestamp, voir
            ???).
            <span class="emphasis"><em>Dans Hibernate3, il n'est plus n&eacute;cessaire de sp&eacute;cifier
            une <tt class="literal">unsaved-value</tt> explicitement.</em></span>
        </p><p>
            Le code suivant mettra &agrave; jour <tt class="literal">parent</tt> et <tt class="literal">child</tt>
            et ins&eacute;rera <tt class="literal">newChild</tt>.
        </p><pre class="programlisting">//parent et child ont &eacute;t&eacute; charg&eacute;s dans une session pr&eacute;c&eacute;dente
parent.addChild(child);
Child newChild = new Child();
parent.addChild(newChild);
session.update(parent);
session.flush();</pre><p>
            Ceci est tr&egrave;s bien pour des identifiants g&eacute;n&eacute;r&eacute;s, mais qu'en est-il des identifiants assign&eacute;s et des
            identifiants compos&eacute;s ? C'est plus difficile,
            puisqu'Hibernate ne peut pas utiliser la propri&eacute;t&eacute; de l'identifiant pour distinguer un objet
            nouvellement instanci&eacute; (avec un identifiant assign&eacute; par l'utilisateur) d'un objet charg&eacute; dans une session pr&eacute;c&eacute;dente.
            Dans ce cas, Hibernate utilisera soit la propri&eacute;t&eacute; de version ou d'horodatage, soit effectuera vraiment une requ&ecirc;te au cache
            de second niveau, soit, dans le pire des cas, &agrave; la base de donn&eacute;es, pour voir si la ligne existe.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-conclusion"></a>21.5.&nbsp;Conclusion</h2></div></div><div></div></div><p>
            Il y a quelques principes &agrave; ma&icirc;triser dans ce chapitre et tout cela peut para&icirc;tre d&eacute;routant la premi&egrave;re fois.
            Cependant, dans la pratique, tout fonctionne parfaitement. La plupart des applications Hibernate utilisent
            le pattern p&egrave;re / fils.
        </p><p>
            Nous avons &eacute;voqu&eacute; une alternative dans le premier paragraphe. Aucun des points trait&eacute;s pr&eacute;c&eacute;demment n'existe
            dans le cas d'un mapping <tt class="literal">&lt;composite-element&gt;</tt> qui poss&egrave;de exactement la s&eacute;mantique
            d'une relation p&egrave;re / fils. Malheureusement, il y a deux grandes limitations pour les classes &eacute;l&eacute;ments
            composites : les &eacute;l&eacute;ments composites ne peuvent contenir de collections, et ils ne peuvent &ecirc;tre les fils
            d'entit&eacute;s autres que l'unique parent.
        </p></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="example-weblog"></a>Chapitre&nbsp;22.&nbsp;Exemple : application Weblog</h2></div></div><div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-weblog-classes"></a>22.1.&nbsp;Classes persistantes</h2></div></div><div></div></div><p>
            Les classes persistantes representent un weblog, et un article post&eacute;
            dans un weblog. Il seront mod&eacute;lis&eacute;s comme une relation p&egrave;re/fils
            standard, mais nous allons utiliser un "bag" tri&eacute; au lieu d'un set.

        </p><pre class="programlisting">package eg;

import java.util.List;

public class Blog {
    private Long _id;
    private String _name;
    private List _items;

    public Long getId() {
        return _id;
    }
    public List getItems() {
        return _items;
    }
    public String getName() {
        return _name;
    }
    public void setId(Long long1) {
        _id = long1;
    }
    public void setItems(List list) {
        _items = list;
    }
    public void setName(String string) {
        _name = string;
    }
}</pre><pre class="programlisting">package eg;

import java.text.DateFormat;
import java.util.Calendar;

public class BlogItem {
    private Long _id;
    private Calendar _datetime;
    private String _text;
    private String _title;
    private Blog _blog;

    public Blog getBlog() {
        return _blog;
    }
    public Calendar getDatetime() {
        return _datetime;
    }
    public Long getId() {
        return _id;
    }
    public String getText() {
        return _text;
    }
    public String getTitle() {
        return _title;
    }
    public void setBlog(Blog blog) {
        _blog = blog;
    }
    public void setDatetime(Calendar calendar) {
        _datetime = calendar;
    }
    public void setId(Long long1) {
        _id = long1;
    }
    public void setText(String string) {
        _text = string;
    }
    public void setTitle(String string) {
        _title = string;
    }
}</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-weblog-mappings"></a>22.2.&nbsp;Mappings Hibernate</h2></div></div><div></div></div><p>
            Le mapping XML doit maintenant &ecirc;tre relativement simple &agrave; vos yeux.
        </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

    &lt;class
        name="Blog"
        table="BLOGS"&gt;

        &lt;id
            name="id"
            column="BLOG_ID"&gt;

            &lt;generator class="native"/&gt;

        &lt;/id&gt;

        &lt;property
            name="name"
            column="NAME"
            not-null="true"
            unique="true"/&gt;

        &lt;bag
            name="items"
            inverse="true"
            order-by="DATE_TIME"
            cascade="all"&gt;

            &lt;key column="BLOG_ID"/&gt;
            &lt;one-to-many class="BlogItem"/&gt;

        &lt;/bag&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

    &lt;class
        name="BlogItem"
        table="BLOG_ITEMS"
        dynamic-update="true"&gt;

        &lt;id
            name="id"
            column="BLOG_ITEM_ID"&gt;

            &lt;generator class="native"/&gt;

        &lt;/id&gt;

        &lt;property
            name="title"
            column="TITLE"
            not-null="true"/&gt;

        &lt;property
            name="text"
            column="TEXT"
            not-null="true"/&gt;

        &lt;property
            name="datetime"
            column="DATE_TIME"
            not-null="true"/&gt;

        &lt;many-to-one
            name="blog"
            column="BLOG_ID"
            not-null="true"/&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-weblog-code"></a>22.3.&nbsp;Code Hibernate</h2></div></div><div></div></div><p>
            La classe suivante montre quelques utilisations que nous pouvons faire
            de ces classes.
        </p><pre class="programlisting">package eg;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Iterator;
import java.util.List;

import org.hibernate.HibernateException;
import org.hibernate.Query;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;
import org.hibernate.tool.hbm2ddl.SchemaExport;

public class BlogMain {

    private SessionFactory _sessions;

    public void configure() throws HibernateException {
        _sessions = new Configuration()
            .addClass(Blog.class)
            .addClass(BlogItem.class)
            .buildSessionFactory();
    }

    public void exportTables() throws HibernateException {
        Configuration cfg = new Configuration()
            .addClass(Blog.class)
            .addClass(BlogItem.class);
        new SchemaExport(cfg).create(true, true);
    }

    public Blog createBlog(String name) throws HibernateException {

        Blog blog = new Blog();
        blog.setName(name);
        blog.setItems( new ArrayList() );

        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.persist(blog);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return blog;
    }

    public BlogItem createBlogItem(Blog blog, String title, String text)
                        throws HibernateException {

        BlogItem item = new BlogItem();
        item.setTitle(title);
        item.setText(text);
        item.setBlog(blog);
        item.setDatetime( Calendar.getInstance() );
        blog.getItems().add(item);

        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.update(blog);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return item;
    }

    public BlogItem createBlogItem(Long blogid, String title, String text)
                        throws HibernateException {

        BlogItem item = new BlogItem();
        item.setTitle(title);
        item.setText(text);
        item.setDatetime( Calendar.getInstance() );

        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            Blog blog = (Blog) session.load(Blog.class, blogid);
            item.setBlog(blog);
            blog.getItems().add(item);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return item;
    }

    public void updateBlogItem(BlogItem item, String text)
                    throws HibernateException {

        item.setText(text);

        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.update(item);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
    }

    public void updateBlogItem(Long itemid, String text)
                    throws HibernateException {

        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            BlogItem item = (BlogItem) session.load(BlogItem.class, itemid);
            item.setText(text);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
    }

    public List listAllBlogNamesAndItemCounts(int max)
                    throws HibernateException {

        Session session = _sessions.openSession();
        Transaction tx = null;
        List result = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "select blog.id, blog.name, count(blogItem) " +
                "from Blog as blog " +
                "left outer join blog.items as blogItem " +
                "group by blog.name, blog.id " +
                "order by max(blogItem.datetime)"
            );
            q.setMaxResults(max);
            result = q.list();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return result;
    }

    public Blog getBlogAndAllItems(Long blogid)
                    throws HibernateException {

        Session session = _sessions.openSession();
        Transaction tx = null;
        Blog blog = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "from Blog as blog " +
                "left outer join fetch blog.items " +
                "where blog.id = :blogid"
            );
            q.setParameter("blogid", blogid);
            blog  = (Blog) q.uniqueResult();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return blog;
    }

    public List listBlogsAndRecentItems() throws HibernateException {

        Session session = _sessions.openSession();
        Transaction tx = null;
        List result = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "from Blog as blog " +
                "inner join blog.items as blogItem " +
                "where blogItem.datetime &gt; :minDate"
            );

            Calendar cal = Calendar.getInstance();
            cal.roll(Calendar.MONTH, false);
            q.setCalendar("minDate", cal);

            result = q.list();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return result;
    }
}</pre></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="example-mappings"></a>Chapitre&nbsp;23.&nbsp;Exemple : quelques mappings</h2></div></div><div></div></div><p>
        Ce chapitre montre quelques mappings plus complexes.
    </p><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-mappings-emp"></a>23.1.&nbsp;Employeur/Employ&eacute; (Employer/Employee)</h2></div></div><div></div></div><p>
            Le mod&egrave;le suivant de relation entre <tt class="literal">Employer</tt> et
            <tt class="literal">Employee</tt> utilise une vraie classe entit&eacute; (<tt class="literal">Employment</tt>)
            pour repr&eacute;senter l'association. On a fait cela parce qu'il peut y avoir plus d'une p&eacute;riode
            d'emploi pour les deux m&ecirc;mes parties. Des composants sont utilis&eacute;s pour mod&eacute;liser les
            valeurs mon&eacute;taires et les noms des employ&eacute;s.
        </p><div class="mediaobject" align="center"><img src="../shared/images/EmployerEmployee.gif" align="middle"></div><p>
            Voici un document de mapping possible :
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Employer" table="employers"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employer_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

    &lt;class name="Employment" table="employment_periods"&gt;

        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employment_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="startDate" column="start_date"/&gt;
        &lt;property name="endDate" column="end_date"/&gt;

        &lt;component name="hourlyRate" class="MonetaryAmount"&gt;
            &lt;property name="amount"&gt;
                &lt;column name="hourly_rate" sql-type="NUMERIC(12, 2)"/&gt;
            &lt;/property&gt;
            &lt;property name="currency" length="12"/&gt;
        &lt;/component&gt;

        &lt;many-to-one name="employer" column="employer_id" not-null="true"/&gt;
        &lt;many-to-one name="employee" column="employee_id" not-null="true"/&gt;

    &lt;/class&gt;

    &lt;class name="Employee" table="employees"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employee_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="taxfileNumber"/&gt;
        &lt;component name="name" class="Name"&gt;
            &lt;property name="firstName"/&gt;
            &lt;property name="initial"/&gt;
            &lt;property name="lastName"/&gt;
        &lt;/component&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
        Et voici le sch&eacute;ma des tables g&eacute;n&eacute;r&eacute;es par <tt class="literal">SchemaExport</tt>.
    </p><pre class="programlisting">create table employers (
    id BIGINT not null,
    name VARCHAR(255),
    primary key (id)
)

create table employment_periods (
    id BIGINT not null,
    hourly_rate NUMERIC(12, 2),
    currency VARCHAR(12),
    employee_id BIGINT not null,
    employer_id BIGINT not null,
    end_date TIMESTAMP,
    start_date TIMESTAMP,
    primary key (id)
)

create table employees (
    id BIGINT not null,
    firstName VARCHAR(255),
    initial CHAR(1),
    lastName VARCHAR(255),
    taxfileNumber VARCHAR(255),
    primary key (id)
)

alter table employment_periods
    add constraint employment_periodsFK0 foreign key (employer_id) references employers
alter table employment_periods
    add constraint employment_periodsFK1 foreign key (employee_id) references employees
create sequence employee_id_seq
create sequence employment_id_seq
create sequence employer_id_seq</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-mappings-authorwork"></a>23.2.&nbsp;Auteur/Travail (Author/Work)</h2></div></div><div></div></div><p>
            Soit le mod&egrave;le de la relation entre <tt class="literal">Work</tt>, <tt class="literal">Author</tt>
            et <tt class="literal">Person</tt>. Nous repr&eacute;sentons la relation entre <tt class="literal">Work</tt>
            et <tt class="literal">Author</tt> comme une association plusieurs-vers-plusieurs. Nous avons choisi de
            repr&eacute;senter la relation entre <tt class="literal">Author</tt> et <tt class="literal">Person</tt>
            comme une association un-vers-un. Une autre possibilit&eacute; aurait &eacute;t&eacute; que
            <tt class="literal">Author</tt> h&eacute;rite de <tt class="literal">Person</tt>.
        </p><div class="mediaobject" align="center"><img src="../shared/images/AuthorWork.gif" align="middle"></div><p>
            Le mapping suivant repr&eacute;sente exactement ces relations :
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Work" table="works" discriminator-value="W"&gt;

        &lt;id name="id" column="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;discriminator column="type" type="character"/&gt;

        &lt;property name="title"/&gt;
        &lt;set name="authors" table="author_work"&gt;
            &lt;key column name="work_id"/&gt;
            &lt;many-to-many class="Author" column name="author_id"/&gt;
        &lt;/set&gt;

        &lt;subclass name="Book" discriminator-value="B"&gt;
            &lt;property name="text"/&gt;
        &lt;/subclass&gt;

        &lt;subclass name="Song" discriminator-value="S"&gt;
            &lt;property name="tempo"/&gt;
            &lt;property name="genre"/&gt;
        &lt;/subclass&gt;

    &lt;/class&gt;

    &lt;class name="Author" table="authors"&gt;

        &lt;id name="id" column="id"&gt;
            &lt;!-- The Author must have the same identifier as the Person --&gt;
            &lt;generator class="assigned"/&gt;
        &lt;/id&gt;

        &lt;property name="alias"/&gt;
        &lt;one-to-one name="person" constrained="true"/&gt;

        &lt;set name="works" table="author_work" inverse="true"&gt;
            &lt;key column="author_id"/&gt;
            &lt;many-to-many class="Work" column="work_id"/&gt;
        &lt;/set&gt;

    &lt;/class&gt;

    &lt;class name="Person" table="persons"&gt;
        &lt;id name="id" column="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
        Il y a quatre tables dans ce mapping. <tt class="literal">works</tt>,
        <tt class="literal">authors</tt> et <tt class="literal">persons</tt> qui contiennent
        respectivement les donn&eacute;es de work, author et person.
        <tt class="literal">author_work</tt> est une table d'association qui lie authors
        &agrave; works. Voici le sch&eacute;ma de tables, g&eacute;n&eacute;r&eacute; par <tt class="literal">SchemaExport</tt>.
    </p><pre class="programlisting">create table works (
    id BIGINT not null generated by default as identity,
    tempo FLOAT,
    genre VARCHAR(255),
    text INTEGER,
    title VARCHAR(255),
    type CHAR(1) not null,
    primary key (id)
)

create table author_work (
    author_id BIGINT not null,
    work_id BIGINT not null,
    primary key (work_id, author_id)
)

create table authors (
    id BIGINT not null generated by default as identity,
    alias VARCHAR(255),
    primary key (id)
)

create table persons (
    id BIGINT not null generated by default as identity,
    name VARCHAR(255),
    primary key (id)
)

alter table authors
    add constraint authorsFK0 foreign key (id) references persons
alter table author_work
    add constraint author_workFK0 foreign key (author_id) references authors
alter table author_work
    add constraint author_workFK1 foreign key (work_id) references works</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-mappings-customerorderproduct"></a>23.3.&nbsp;Client/Commande/Produit (Customer/Order/Product)</h2></div></div><div></div></div><p>
            Imaginons maintenant le mod&egrave;le de relation entre <tt class="literal">Customer</tt>,
            <tt class="literal">Order</tt>, <tt class="literal">LineItem</tt> et <tt class="literal">Product</tt>.
            Il y a une association un-vers-plusieurs entre <tt class="literal">Customer</tt> et
            <tt class="literal">Order</tt>, mais comment devrions nous repr&eacute;senter <tt class="literal">Order</tt> /
            <tt class="literal">LineItem</tt> / <tt class="literal">Product</tt>? J'ai choisi de mapper
            <tt class="literal">LineItem</tt> comme une classe d'association repr&eacute;sentant l'association
            plusieurs-vers-plusieurs entre <tt class="literal">Order</tt> et <tt class="literal">Product</tt>. Dans
            Hibernate, on appelle cela un &eacute;l&eacute;ment composite.
        </p><div class="mediaobject" align="center"><img src="../shared/images/CustomerOrderProduct.gif" align="middle"></div><p>
            Le document de mapping :
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Customer" table="customers"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
        &lt;set name="orders" inverse="true"&gt;
            &lt;key column="customer_id"/&gt;
            &lt;one-to-many class="Order"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Order" table="orders"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="date"/&gt;
        &lt;many-to-one name="customer" column="customer_id"/&gt;
        &lt;list name="lineItems" table="line_items"&gt;
            &lt;key column="order_id"/&gt;
            &lt;list-index column="line_number"/&gt;
            &lt;composite-element class="LineItem"&gt;
                &lt;property name="quantity"/&gt;
                &lt;many-to-one name="product" column="product_id"/&gt;
            &lt;/composite-element&gt;
        &lt;/list&gt;
    &lt;/class&gt;

    &lt;class name="Product" table="products"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="serialNumber"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
        <tt class="literal">customers</tt>, <tt class="literal">orders</tt>, <tt class="literal">line_items</tt> et
        <tt class="literal">products</tt> contiennent les donn&eacute;es de customer, order, order line item et product.
        <tt class="literal">line_items</tt> est aussi la table d'association liant orders &agrave; products.
    </p><pre class="programlisting">create table customers (
    id BIGINT not null generated by default as identity,
    name VARCHAR(255),
    primary key (id)
)

create table orders (
    id BIGINT not null generated by default as identity,
    customer_id BIGINT,
    date TIMESTAMP,
    primary key (id)
)

create table line_items (
    line_number INTEGER not null,
    order_id BIGINT not null,
    product_id BIGINT,
    quantity INTEGER,
    primary key (order_id, line_number)
)

create table products (
    id BIGINT not null generated by default as identity,
    serialNumber VARCHAR(255),
    primary key (id)
)

alter table orders
    add constraint ordersFK0 foreign key (customer_id) references customers
alter table line_items
    add constraint line_itemsFK0 foreign key (product_id) references products
alter table line_items
    add constraint line_itemsFK1 foreign key (order_id) references orders</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="misc"></a>23.4.&nbsp;Divers mappings d'exemple</h2></div></div><div></div></div><p>
            Ces exemples sont tous pris de la suite de tests d'Hibernate. Vous en trouverez beaucoup d'autres.
            Regardez dans le dossier <tt class="literal">test</tt> de la distribution d'Hibernate.
        </p><p>TODO: put words around this stuff</p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="example-mappings-typed-onetone"></a>23.4.1.&nbsp;"Typed" one-to-one association</h3></div></div><div></div></div><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="name"/&gt;
    &lt;one-to-one name="address"
            cascade="all"&gt;
        &lt;formula&gt;name&lt;/formula&gt;
        &lt;formula&gt;'HOME'&lt;/formula&gt;
    &lt;/one-to-one&gt;
    &lt;one-to-one name="mailingAddress"
            cascade="all"&gt;
        &lt;formula&gt;name&lt;/formula&gt;
        &lt;formula&gt;'MAILING'&lt;/formula&gt;
    &lt;/one-to-one&gt;
&lt;/class&gt;

&lt;class name="Address" batch-size="2"
        check="addressType in ('MAILING', 'HOME', 'BUSINESS')"&gt;
    &lt;composite-id&gt;
        &lt;key-many-to-one name="person"
                column="personName"/&gt;
        &lt;key-property name="type"
                column="addressType"/&gt;
    &lt;/composite-id&gt;
    &lt;property name="street" type="text"/&gt;
    &lt;property name="state"/&gt;
    &lt;property name="zip"/&gt;
&lt;/class&gt;</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="example-mappings-composite-key"></a>23.4.2.&nbsp;Exemple de clef compos&eacute;e</h3></div></div><div></div></div><pre class="programlisting">&lt;class name="Customer"&gt;

    &lt;id name="customerId"
        length="10"&gt;
        &lt;generator class="assigned"/&gt;
    &lt;/id&gt;

    &lt;property name="name" not-null="true" length="100"/&gt;
    &lt;property name="address" not-null="true" length="200"/&gt;

    &lt;list name="orders"
            inverse="true"
            cascade="save-update"&gt;
        &lt;key column="customerId"/&gt;
        &lt;index column="orderNumber"/&gt;
        &lt;one-to-many class="Order"/&gt;
    &lt;/list&gt;

&lt;/class&gt;

&lt;class name="Order" table="CustomerOrder" lazy="true"&gt;
    &lt;synchronize table="LineItem"/&gt;
    &lt;synchronize table="Product"/&gt;

    &lt;composite-id name="id"
            class="Order$Id"&gt;
        &lt;key-property name="customerId" length="10"/&gt;
        &lt;key-property name="orderNumber"/&gt;
    &lt;/composite-id&gt;

    &lt;property name="orderDate"
            type="calendar_date"
            not-null="true"/&gt;

    &lt;property name="total"&gt;
        &lt;formula&gt;
            ( select sum(li.quantity*p.price)
            from LineItem li, Product p
            where li.productId = p.productId
                and li.customerId = customerId
                and li.orderNumber = orderNumber )
        &lt;/formula&gt;
    &lt;/property&gt;

    &lt;many-to-one name="customer"
            column="customerId"
            insert="false"
            update="false"
            not-null="true"/&gt;

    &lt;bag name="lineItems"
            fetch="join"
            inverse="true"
            cascade="save-update"&gt;
        &lt;key&gt;
            &lt;column name="customerId"/&gt;
            &lt;column name="orderNumber"/&gt;
        &lt;/key&gt;
        &lt;one-to-many class="LineItem"/&gt;
    &lt;/bag&gt;

&lt;/class&gt;

&lt;class name="LineItem"&gt;

    &lt;composite-id name="id"
            class="LineItem$Id"&gt;
        &lt;key-property name="customerId" length="10"/&gt;
        &lt;key-property name="orderNumber"/&gt;
        &lt;key-property name="productId" length="10"/&gt;
    &lt;/composite-id&gt;

    &lt;property name="quantity"/&gt;

    &lt;many-to-one name="order"
            insert="false"
            update="false"
            not-null="true"&gt;
        &lt;column name="customerId"/&gt;
        &lt;column name="orderNumber"/&gt;
    &lt;/many-to-one&gt;

    &lt;many-to-one name="product"
            insert="false"
            update="false"
            not-null="true"
            column="productId"/&gt;

&lt;/class&gt;

&lt;class name="Product"&gt;
    &lt;synchronize table="LineItem"/&gt;

    &lt;id name="productId"
        length="10"&gt;
        &lt;generator class="assigned"/&gt;
    &lt;/id&gt;

    &lt;property name="description"
        not-null="true"
        length="200"/&gt;
    &lt;property name="price" length="3"/&gt;
    &lt;property name="numberAvailable"/&gt;

    &lt;property name="numberOrdered"&gt;
        &lt;formula&gt;
            ( select sum(li.quantity)
            from LineItem li
            where li.productId = productId )
        &lt;/formula&gt;
    &lt;/property&gt;

&lt;/class&gt;</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="example-mappings-composite-key-manytomany"></a>23.4.3.&nbsp;Many-to-many avec une clef compos&eacute;e partag&eacute;e</h3></div></div><div></div></div><pre class="programlisting">&lt;class name="User" table="`User`"&gt;
    &lt;composite-id&gt;
        &lt;key-property name="name"/&gt;
        &lt;key-property name="org"/&gt;
    &lt;/composite-id&gt;
    &lt;set name="groups" table="UserGroup"&gt;
        &lt;key&gt;
            &lt;column name="userName"/&gt;
            &lt;column name="org"/&gt;
        &lt;/key&gt;
        &lt;many-to-many class="Group"&gt;
            &lt;column name="groupName"/&gt;
            &lt;formula&gt;org&lt;/formula&gt;
        &lt;/many-to-many&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Group" table="`Group`"&gt;
    &lt;composite-id&gt;
        &lt;key-property name="name"/&gt;
        &lt;key-property name="org"/&gt;
    &lt;/composite-id&gt;
    &lt;property name="description"/&gt;
    &lt;set name="users" table="UserGroup" inverse="true"&gt;
        &lt;key&gt;
            &lt;column name="groupName"/&gt;
            &lt;column name="org"/&gt;
        &lt;/key&gt;
        &lt;many-to-many class="User"&gt;
            &lt;column name="userName"/&gt;
            &lt;formula&gt;org&lt;/formula&gt;
        &lt;/many-to-many&gt;
    &lt;/set&gt;
&lt;/class&gt;
</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="example-mappings-content-discrimination"></a>23.4.4.&nbsp;Contenu bas&eacute; sur une discrimination</h3></div></div><div></div></div><pre class="programlisting">&lt;class name="Person"
    discriminator-value="P"&gt;

    &lt;id name="id"
        column="person_id"
        unsaved-value="0"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;


    &lt;discriminator
        type="character"&gt;
        &lt;formula&gt;
            case
                when title is not null then 'E'
                when salesperson is not null then 'C'
                else 'P'
            end
        &lt;/formula&gt;
    &lt;/discriminator&gt;

    &lt;property name="name"
        not-null="true"
        length="80"/&gt;

    &lt;property name="sex"
        not-null="true"
        update="false"/&gt;

    &lt;component name="address"&gt;
        &lt;property name="address"/&gt;
        &lt;property name="zip"/&gt;
        &lt;property name="country"/&gt;
    &lt;/component&gt;

    &lt;subclass name="Employee"
        discriminator-value="E"&gt;
            &lt;property name="title"
                length="20"/&gt;
            &lt;property name="salary"/&gt;
            &lt;many-to-one name="manager"/&gt;
    &lt;/subclass&gt;

    &lt;subclass name="Customer"
        discriminator-value="C"&gt;
            &lt;property name="comments"/&gt;
            &lt;many-to-one name="salesperson"/&gt;
    &lt;/subclass&gt;

&lt;/class&gt;</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="example-mappings-association-alternatekeys"></a>23.4.5.&nbsp;Associations sur des clefs altern&eacute;es</h3></div></div><div></div></div><pre class="programlisting">&lt;class name="Person"&gt;

    &lt;id name="id"&gt;
        &lt;generator class="hilo"/&gt;
    &lt;/id&gt;

    &lt;property name="name" length="100"/&gt;

    &lt;one-to-one name="address"
        property-ref="person"
        cascade="all"
        fetch="join"/&gt;

    &lt;set name="accounts"
        inverse="true"&gt;
        &lt;key column="userId"
            property-ref="userId"/&gt;
        &lt;one-to-many class="Account"/&gt;
    &lt;/set&gt;

    &lt;property name="userId" length="8"/&gt;

&lt;/class&gt;

&lt;class name="Address"&gt;

    &lt;id name="id"&gt;
        &lt;generator class="hilo"/&gt;
    &lt;/id&gt;

    &lt;property name="address" length="300"/&gt;
    &lt;property name="zip" length="5"/&gt;
    &lt;property name="country" length="25"/&gt;
    &lt;many-to-one name="person" unique="true" not-null="true"/&gt;

&lt;/class&gt;

&lt;class name="Account"&gt;
    &lt;id name="accountId" length="32"&gt;
        &lt;generator class="uuid"/&gt;
    &lt;/id&gt;

    &lt;many-to-one name="user"
        column="userId"
        property-ref="userId"/&gt;

    &lt;property name="type" not-null="true"/&gt;

&lt;/class&gt;</pre></div></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="best-practices"></a>Chapitre&nbsp;24.&nbsp;Meilleures pratiques</h2></div></div><div></div></div><div class="variablelist"><dl><dt><span class="term">D&eacute;coupez finement vos classes et mappez les en utilisant <tt class="literal">&lt;component&gt;</tt>.</span></dt><dd><p>
                    Utilisez une classe <tt class="literal">Adresse</tt> pour encapsuler <tt class="literal">Rue</tt>,
                    <tt class="literal">Region</tt>, <tt class="literal">CodePostal</tt>.
                    Ceci permet la r&eacute;utilisation du code et simplifie la maintenance.
                </p></dd><dt><span class="term">D&eacute;clarez des propri&eacute;t&eacute;s d'identifiants dans les classes persistantes.</span></dt><dd><p>
                    Hibernate rend les propri&eacute;t&eacute;s d'identifiants optionnelles. Il existe beaucoup de raisons
                    pour lesquelles vous devriez les utiliser. Nous recommandons que vous utilisiez des identifiants
		    techniques (g&eacute;n&eacute;r&eacute;s, et sans connotation m&eacute;tier).
                </p></dd><dt><span class="term">Identifiez les clefs naturelles.</span></dt><dd><p>
                    Identifiez les clefs naturelles pour toutes les entit&eacute;s, et mappez les avec
                    <tt class="literal">&lt;natural-id&gt;</tt>. Impl&eacute;mentez <tt class="literal">equals()</tt> et
                    <tt class="literal">hashCode()</tt> pour comparer les propri&eacute;t&eacute;s qui composent la clef naturelle.
                </p></dd><dt><span class="term">Placez chaque mapping de classe dans son propre fichier.</span></dt><dd><p>
                    N'utilisez pas un unique document de mapping. Mappez <tt class="literal">com.eg.Foo</tt> dans
                    le fichier <tt class="literal">com/eg/Foo.hbm.xml</tt>. Cela prend tout son sens lors
                    d'un travail en &eacute;quipe.
                </p></dd><dt><span class="term">Chargez les mappings comme des ressources.</span></dt><dd><p>
                    D&eacute;ployez les mappings en m&ecirc;me temps que les classes qu'ils mappent.
                </p></dd><dt><span class="term">Pensez &agrave; externaliser les cha&icirc;nes de caract&egrave;res.</span></dt><dd><p>
                    Ceci est une bonne habitude si vos requ&ecirc;tes appellent des fonctions SQL qui ne sont
                    pas au standard ANSI. Cette externalisation dans les fichiers de mapping rendra votre
		    application plus portable.
                </p></dd><dt><span class="term">Utilisez les variables "bind&eacute;es".</span></dt><dd><p>
                    Comme en JDBC, remplacez toujours les valeurs non constantes par "?". N'utilisez jamais
                    la manipulation des cha&icirc;nes de caract&egrave;res pour remplacer des valeurs non constantes dans
		     une requ&ecirc;te ! Encore mieux, utilisez les param&egrave;tres nomm&eacute;s dans les requ&ecirc;tes.
                </p></dd><dt><span class="term">Ne g&eacute;rez pas vous m&ecirc;me les connexions JDBC.</span></dt><dd><p>
                    Hibernate laisse l'application g&eacute;rer les connexions JDBC. Vous ne devriez g&eacute;rer vos connexions
                    qu'en dernier recours. Si vous ne pouvez pas utiliser les syst&egrave;mes de connexions livr&eacute;s,
		    r&eacute;fl&eacute;chissez &agrave; l'id&eacute;e de fournir votre propre impl&eacute;mentation de <tt class="literal">org.hibernate.connection.ConnectionProvider</tt>.
                </p></dd><dt><span class="term">Pensez &agrave; utiliser les types utilisateurs.</span></dt><dd><p>
                    Supposez que vous ayez une type Java, de telle biblioth&egrave;que, qui a besoin d'&ecirc;tre persist&eacute; mais
                    qui ne fournit pas les accesseurs n&eacute;cessaires pour le mapper comme composant. Vous devriez
		    impl&eacute;menter
                    <tt class="literal">org.hibernate.UserType</tt>.Cette approche lib&egrave;re le code de l'application
                    de l'impl&eacute;mentation des transformations vers / depuis les types Hibernate.
                </p></dd><dt><span class="term">Utilisez du JDBC pur dans les goulets d'&eacute;tranglement.</span></dt><dd><p>
                    Dans certaines parties critiques de votre syst&egrave;me d'un point de vue performance, quelques op&eacute;rations
                    peuvent tirer partie d'un appel JDBC natif.
                    Mais attendez de <span class="emphasis"><em>savoir</em></span>
                    que c'est un goulet d'&eacute;tranglement. Ne supposez jamais qu'un appel JDBC sera forc&eacute;ment plus
                    rapide. Si vous avez besoin d'utiliser JDBC directement, ouvrez une <tt class="literal">Session</tt>
                    Hibernate et utilisez la connexion SQL sous-jacente. Ainsi vous pourrez utiliser la m&ecirc;me strat&eacute;gie
                    de transation et la m&ecirc;me gestion des connexions.
                </p></dd><dt><span class="term">Comprendre le flush de <tt class="literal">Session</tt>.</span></dt><dd><p>
                    De temps en temps la Session synchronise ses &eacute;tats persistants avec la base de donn&eacute;es.
                    Les performances seront affect&eacute;es si ce processus arrive trop souvent. Vous pouvez parfois
                    minimiser les flush non n&eacute;cessaires en d&eacute;sactivant le flush automatique ou m&ecirc;me en changeant
                    l'ordre des op&eacute;rations men&eacute;es dans une transaction particuli&egrave;re.
                </p></dd><dt><span class="term">Dans une architecture &agrave; trois couches, pensez &agrave; utiliser <tt class="literal">saveOrUpdate()</tt>.</span></dt><dd><p>
                    Quand vous utilisez une architecture &agrave; base de servlet / session bean, vous pourriez passer
                    des objets charg&eacute;s dans le bean session vers et depuis la couche servlet / JSP. Utilisez
		    une nouvelle session pour traiter chaque requ&ecirc;te.
                    Utilisez <tt class="literal">Session.merge()</tt> ou <tt class="literal">Session.saveOrUpdate()</tt> pour
                    synchroniser les objets avec la base de donn&eacute;es.
                </p></dd><dt><span class="term">Dans une architecture &agrave; deux couches, pensez &agrave; utiliser la d&eacute;connexion de session.</span></dt><dd><p>
                    Les transactions de bases de donn&eacute;es doivent &ecirc;tre aussi courtes que possible
                    pour une meilleure mont&eacute;e en charge.Cependant, il est souvent n&eacute;cessaire d'impl&eacute;menter
                    de longues <span class="emphasis"><em>transactions applicatives</em></span>, une simple unit&eacute; de travail du point de vue de
                    l'utilisateur. Une transaction applicative
                    peut s'&eacute;taler sur plusieurs cycles de requ&ecirc;tes/r&eacute;ponses du client.
                    Il est commun d'utiliser des objets d&eacute;tach&eacute;s pour impl&eacute;menter des transactions applicatives.
                    Une alternative, extr&ecirc;mement appropri&eacute;e dans une architecture &agrave; 2 couches, est de
                    maintenir un seul contact de persistance ouvert (session) pour toute la dur&eacute;e de vie
                    de la transaction applicative et simplement se d&eacute;connecter de la connexion JDBC &agrave; la fin de chaque requ&ecirc;te,
                    et se reconnecter au d&eacute;but de la requ&ecirc;te suivante. Ne partagez jamais une seule
                    session avec plus d'une transaction applicative, ou vous travaillerez avec des
                    donn&eacute;es p&eacute;rim&eacute;es.
                </p></dd><dt><span class="term">Consid&eacute;rez que les exceptions ne sont pas rattrapables.</span></dt><dd><p>
                    Il s'agit plus d'une pratique obligatoire que d'une "meilleure pratique". Quand une exception
                    intervient, il faut faire un rollback de la <tt class="literal">Transaction</tt> et
                    fermer la <tt class="literal">Session</tt>.
                    Sinon, Hibernate ne peut garantir l'int&eacute;grit&eacute; des &eacute;tats persistants en m&eacute;moire. En particulier,
                    n'utilisez pas <tt class="literal">Session.load()</tt> pour d&eacute;terminer si une instance avec un identifiant
                    donn&eacute; existe en base de donn&eacute;es, utilisez <tt class="literal">Session.get()</tt> ou un requ&ecirc;te.
                </p></dd><dt><span class="term">Pr&eacute;f&eacute;rez le chargement tardif des associations.</span></dt><dd><p>
                    Utilisez le chargement complet avec mod&eacute;ration.
                    Utilisez les proxies et les collections charg&eacute;es tardivement
                    pour la plupart des associations vers des classes qui ne sont pas susceptibles
                    d'&ecirc;tre compl&egrave;tement retenues dans le cache de second niveau.
                    Pour les assocations de classes en cache, o&ugrave; il y a une extr&ecirc;mement
                    forte probabilit&eacute; que l'&eacute;l&eacute;ment soit en cache, d&eacute;sactivez explicitement le chargement
                    par jointures ouvertes en utilisant <tt class="literal">outer-join="false"</tt>.
                    Lorsqu'un chargement par jointure ouverte est appropri&eacute; pour un cas d'utilisation
                    particulier, utilisez une requ&ecirc;te avec un <tt class="literal">left join fetch</tt>.
                </p></dd><dt><span class="term">
                Utilisez le pattern <span class="emphasis"><em>d'une ouverture de session dans une vue</em></span>,
                ou une <span class="emphasis"><em>phase d'assemblage</em></span> disciplin&eacute;e pour &eacute;viter des probl&egrave;mes
                avec des donn&eacute;es non rapatri&eacute;es.
            </span></dt><dd><p>
                    Hibernate lib&egrave;re les d&eacute;veloppeurs de l'&eacute;criture fastidieuse des <span class="emphasis"><em>objets de transfert
                    de donn&eacute;es (NdT : Data Transfer Objects)</em></span> (DTO). Dans une architecture EJB traditionnelle,
                    les DTOs ont deux buts : premi&egrave;rement, ils contournent le probl&egrave;me des "entity bean" qui ne sont pas
                    s&eacute;rialisables ; deuxi&egrave;mement, ils d&eacute;finissent implicitement une phase d'assemblage o&ugrave; toutes les
                    donn&eacute;es utilis&eacute;es par la vue sont rapatri&eacute;es et organis&eacute;es dans les DTOs avant de retourner sous le
                    contr&ocirc;le de la couche de pr&eacute;sentation. Hibernate &eacute;limine le premier but. Pourtant, vous aurez encore
                    besoin d'une phase d'assemblage (pensez vos m&eacute;thodes m&eacute;tier comme ayant un contrat strict avec la
                    couche de pr&eacute;sentation &agrave; propos de quelles donn&eacute;es sont disponibles dans les objets d&eacute;tach&eacute;s)
                    &agrave; moins que vous soyez pr&eacute;par&eacute;s &agrave; garder le contexte de
                    persistance (la session) ouvert &agrave; travers tout le processus de rendu de la vue.
                </p></dd><dt><span class="term">Pensez &agrave; abstraite votre logique m&eacute;tier d'Hibernate.</span></dt><dd><p>
                    Cachez le m&eacute;canisme d'acc&egrave;s aux donn&eacute;es (Hibernate) derri&egrave;re une interface. Combinez les patterns
                    <span class="emphasis"><em>DAO</em></span> et <span class="emphasis"><em>Thread Local Session</em></span>. Vous pouvez m&ecirc;me avoir quelques
                    classes persist&eacute;es par du JDBC pur, associ&eacute;es &agrave; Hibernate via un <tt class="literal">UserType</tt> (ce conseil est
                    valable pour des applications de taille respectables ; il n'est pas valable pour une application
                    avec cinq tables).
                </p></dd><dt><span class="term">N'utilisez pas d'associations de mapping exotiques.</span></dt><dd><p>
                    De bons cas d'utilisation pour de vraies associations plusieurs-vers-plusieurs
                    sont rares. La plupart du temps vous avez besoin d'informations additionnelles
                    stock&eacute;es dans la table d'association.
                    Dans ce cas, il est pr&eacute;f&eacute;rable d'utiliser deux associations un-vers-plusieurs vers une classe
                    de liaisons interm&eacute;diaire. En fait, nous pensons que la plupart des associations sont
                    de type un-vers-plusieurs ou plusieurs-vers-un, vous devez &ecirc;tre tr&egrave;s attentifs lorsque
                    vous utilisez autre chose et vous demander si c'est vraiment n&eacute;cessaire.
                </p></dd><dt><span class="term">Pr&eacute;f&eacute;rez les associations bidirectionnelles.</span></dt><dd><p>
                    Les associations unidirectionnelles sont plus difficiles &agrave; questionner.
                    Dans une grande application, la plupart des associations devraient &ecirc;tre navigables dans les deux directions dans les requ&ecirc;tes.
                </p></dd></dl></div></div></div></body></html>